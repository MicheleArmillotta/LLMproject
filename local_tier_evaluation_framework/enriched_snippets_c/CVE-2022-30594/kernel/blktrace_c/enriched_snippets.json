[
  {
    "function_name": "blk_fill_rwbs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1886-1925",
    "snippet": "void blk_fill_rwbs(char *rwbs, unsigned int op)\n{\n\tint i = 0;\n\n\tif (op & REQ_PREFLUSH)\n\t\trwbs[i++] = 'F';\n\n\tswitch (op & REQ_OP_MASK) {\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_WRITE_SAME:\n\t\trwbs[i++] = 'W';\n\t\tbreak;\n\tcase REQ_OP_DISCARD:\n\t\trwbs[i++] = 'D';\n\t\tbreak;\n\tcase REQ_OP_SECURE_ERASE:\n\t\trwbs[i++] = 'D';\n\t\trwbs[i++] = 'E';\n\t\tbreak;\n\tcase REQ_OP_FLUSH:\n\t\trwbs[i++] = 'F';\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\trwbs[i++] = 'R';\n\t\tbreak;\n\tdefault:\n\t\trwbs[i++] = 'N';\n\t}\n\n\tif (op & REQ_FUA)\n\t\trwbs[i++] = 'F';\n\tif (op & REQ_RAHEAD)\n\t\trwbs[i++] = 'A';\n\tif (op & REQ_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (op & REQ_META)\n\t\trwbs[i++] = 'M';\n\n\trwbs[i] = '\\0';\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nvoid blk_fill_rwbs(char *rwbs, unsigned int op)\n{\n\tint i = 0;\n\n\tif (op & REQ_PREFLUSH)\n\t\trwbs[i++] = 'F';\n\n\tswitch (op & REQ_OP_MASK) {\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_WRITE_SAME:\n\t\trwbs[i++] = 'W';\n\t\tbreak;\n\tcase REQ_OP_DISCARD:\n\t\trwbs[i++] = 'D';\n\t\tbreak;\n\tcase REQ_OP_SECURE_ERASE:\n\t\trwbs[i++] = 'D';\n\t\trwbs[i++] = 'E';\n\t\tbreak;\n\tcase REQ_OP_FLUSH:\n\t\trwbs[i++] = 'F';\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\trwbs[i++] = 'R';\n\t\tbreak;\n\tdefault:\n\t\trwbs[i++] = 'N';\n\t}\n\n\tif (op & REQ_FUA)\n\t\trwbs[i++] = 'F';\n\tif (op & REQ_RAHEAD)\n\t\trwbs[i++] = 'A';\n\tif (op & REQ_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (op & REQ_META)\n\t\trwbs[i++] = 'M';\n\n\trwbs[i] = '\\0';\n}"
  },
  {
    "function_name": "blk_trace_remove_sysfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1867-1870",
    "snippet": "void blk_trace_remove_sysfs(struct device *dev)\n{\n\tsysfs_remove_group(&dev->kobj, &blk_trace_attr_group);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_remove_group",
          "args": [
            "&dev->kobj",
            "&blk_trace_attr_group"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nvoid blk_trace_remove_sysfs(struct device *dev)\n{\n\tsysfs_remove_group(&dev->kobj, &blk_trace_attr_group);\n}"
  },
  {
    "function_name": "blk_trace_init_sysfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1862-1865",
    "snippet": "int blk_trace_init_sysfs(struct device *dev)\n{\n\treturn sysfs_create_group(&dev->kobj, &blk_trace_attr_group);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "&dev->kobj",
            "&blk_trace_attr_group"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nint blk_trace_init_sysfs(struct device *dev)\n{\n\treturn sysfs_create_group(&dev->kobj, &blk_trace_attr_group);\n}"
  },
  {
    "function_name": "sysfs_blk_trace_attr_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1796-1860",
    "snippet": "static ssize_t sysfs_blk_trace_attr_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct block_device *bdev = dev_to_bdev(dev);\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tstruct blk_trace *bt;\n\tu64 value;\n\tssize_t ret = -EINVAL;\n\n\tif (count == 0)\n\t\tgoto out;\n\n\tif (attr == &dev_attr_act_mask) {\n\t\tif (kstrtoull(buf, 0, &value)) {\n\t\t\t/* Assume it is a list of trace category names */\n\t\t\tret = blk_trace_str2mask(buf);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tvalue = ret;\n\t\t}\n\t} else {\n\t\tif (kstrtoull(buf, 0, &value))\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&q->debugfs_mutex);\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (attr == &dev_attr_enable) {\n\t\tif (!!value == !!bt) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t\tif (value)\n\t\t\tret = blk_trace_setup_queue(q, bdev);\n\t\telse\n\t\t\tret = blk_trace_remove_queue(q);\n\t\tgoto out_unlock_bdev;\n\t}\n\n\tret = 0;\n\tif (bt == NULL) {\n\t\tret = blk_trace_setup_queue(q, bdev);\n\t\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\tlockdep_is_held(&q->debugfs_mutex));\n\t}\n\n\tif (ret == 0) {\n\t\tif (attr == &dev_attr_act_mask)\n\t\t\tbt->act_mask = value;\n\t\telse if (attr == &dev_attr_pid)\n\t\t\tbt->pid = value;\n\t\telse if (attr == &dev_attr_start_lba)\n\t\t\tbt->start_lba = value;\n\t\telse if (attr == &dev_attr_end_lba)\n\t\t\tbt->end_lba = value;\n\t}\n\nout_unlock_bdev:\n\tmutex_unlock(&q->debugfs_mutex);\nout:\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "q->blk_trace",
            "lockdep_is_held(&q->debugfs_mutex)"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_setup_queue",
          "args": [
            "q",
            "bdev"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_setup_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1626-1652",
          "snippet": "static int blk_trace_setup_queue(struct request_queue *q,\n\t\t\t\t struct block_device *bdev)\n{\n\tstruct blk_trace *bt = NULL;\n\tint ret = -ENOMEM;\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto free_bt;\n\n\tbt->dev = bdev->bd_dev;\n\tbt->act_mask = (u16)-1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\trcu_assign_pointer(q->blk_trace, bt);\n\tget_probe_ref();\n\treturn 0;\n\nfree_bt:\n\tblk_trace_free(bt);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_setup_queue(struct request_queue *q,\n\t\t\t\t struct block_device *bdev)\n{\n\tstruct blk_trace *bt = NULL;\n\tint ret = -ENOMEM;\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto free_bt;\n\n\tbt->dev = bdev->bd_dev;\n\tbt->act_mask = (u16)-1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\trcu_assign_pointer(q->blk_trace, bt);\n\tget_probe_ref();\n\treturn 0;\n\nfree_bt:\n\tblk_trace_free(bt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_remove_queue",
          "args": [
            "q"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_remove_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1600-1621",
          "snippet": "static int blk_trace_remove_queue(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state == Blktrace_running) {\n\t\tbt->trace_state = Blktrace_stopped;\n\t\traw_spin_lock_irq(&running_trace_lock);\n\t\tlist_del_init(&bt->running_list);\n\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\trelay_flush(bt->rchan);\n\t}\n\n\tput_probe_ref();\n\tsynchronize_rcu();\n\tblk_trace_free(bt);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_remove_queue(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state == Blktrace_running) {\n\t\tbt->trace_state = Blktrace_stopped;\n\t\traw_spin_lock_irq(&running_trace_lock);\n\t\tlist_del_init(&bt->running_list);\n\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\trelay_flush(bt->rchan);\n\t}\n\n\tput_probe_ref();\n\tsynchronize_rcu();\n\tblk_trace_free(bt);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "q->blk_trace",
            "lockdep_is_held(&q->debugfs_mutex)"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "buf",
            "0",
            "&value"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_trace_str2mask",
          "args": [
            "buf"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_str2mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1711-1744",
          "snippet": "static int blk_trace_str2mask(const char *str)\n{\n\tint i;\n\tint mask = 0;\n\tchar *buf, *s, *token;\n\n\tbuf = kstrdup(str, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\ts = strstrip(buf);\n\n\twhile (1) {\n\t\ttoken = strsep(&s, \",\");\n\t\tif (token == NULL)\n\t\t\tbreak;\n\n\t\tif (*token == '\\0')\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\t\tif (strcasecmp(token, mask_maps[i].str) == 0) {\n\t\t\t\tmask |= mask_maps[i].mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(mask_maps)) {\n\t\t\tmask = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(buf);\n\n\treturn mask;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_str2mask(const char *str)\n{\n\tint i;\n\tint mask = 0;\n\tchar *buf, *s, *token;\n\n\tbuf = kstrdup(str, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\ts = strstrip(buf);\n\n\twhile (1) {\n\t\ttoken = strsep(&s, \",\");\n\t\tif (token == NULL)\n\t\t\tbreak;\n\n\t\tif (*token == '\\0')\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\t\tif (strcasecmp(token, mask_maps[i].str) == 0) {\n\t\t\t\tmask |= mask_maps[i].mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(mask_maps)) {\n\t\t\tmask = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(buf);\n\n\treturn mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "buf",
            "0",
            "&value"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_bdev",
          "args": [
            "dev"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sysfs_blk_trace_attr_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct block_device *bdev = dev_to_bdev(dev);\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tstruct blk_trace *bt;\n\tu64 value;\n\tssize_t ret = -EINVAL;\n\n\tif (count == 0)\n\t\tgoto out;\n\n\tif (attr == &dev_attr_act_mask) {\n\t\tif (kstrtoull(buf, 0, &value)) {\n\t\t\t/* Assume it is a list of trace category names */\n\t\t\tret = blk_trace_str2mask(buf);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tvalue = ret;\n\t\t}\n\t} else {\n\t\tif (kstrtoull(buf, 0, &value))\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&q->debugfs_mutex);\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (attr == &dev_attr_enable) {\n\t\tif (!!value == !!bt) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t\tif (value)\n\t\t\tret = blk_trace_setup_queue(q, bdev);\n\t\telse\n\t\t\tret = blk_trace_remove_queue(q);\n\t\tgoto out_unlock_bdev;\n\t}\n\n\tret = 0;\n\tif (bt == NULL) {\n\t\tret = blk_trace_setup_queue(q, bdev);\n\t\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\tlockdep_is_held(&q->debugfs_mutex));\n\t}\n\n\tif (ret == 0) {\n\t\tif (attr == &dev_attr_act_mask)\n\t\t\tbt->act_mask = value;\n\t\telse if (attr == &dev_attr_pid)\n\t\t\tbt->pid = value;\n\t\telse if (attr == &dev_attr_start_lba)\n\t\t\tbt->start_lba = value;\n\t\telse if (attr == &dev_attr_end_lba)\n\t\t\tbt->end_lba = value;\n\t}\n\nout_unlock_bdev:\n\tmutex_unlock(&q->debugfs_mutex);\nout:\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "sysfs_blk_trace_attr_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1762-1794",
    "snippet": "static ssize_t sysfs_blk_trace_attr_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct block_device *bdev = dev_to_bdev(dev);\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tstruct blk_trace *bt;\n\tssize_t ret = -ENXIO;\n\n\tmutex_lock(&q->debugfs_mutex);\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (attr == &dev_attr_enable) {\n\t\tret = sprintf(buf, \"%u\\n\", !!bt);\n\t\tgoto out_unlock_bdev;\n\t}\n\n\tif (bt == NULL)\n\t\tret = sprintf(buf, \"disabled\\n\");\n\telse if (attr == &dev_attr_act_mask)\n\t\tret = blk_trace_mask2str(buf, bt->act_mask);\n\telse if (attr == &dev_attr_pid)\n\t\tret = sprintf(buf, \"%u\\n\", bt->pid);\n\telse if (attr == &dev_attr_start_lba)\n\t\tret = sprintf(buf, \"%llu\\n\", bt->start_lba);\n\telse if (attr == &dev_attr_end_lba)\n\t\tret = sprintf(buf, \"%llu\\n\", bt->end_lba);\n\nout_unlock_bdev:\n\tmutex_unlock(&q->debugfs_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%llu\\n\"",
            "bt->end_lba"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%llu\\n\"",
            "bt->start_lba"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "bt->pid"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_trace_mask2str",
          "args": [
            "buf",
            "bt->act_mask"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_mask2str",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1746-1760",
          "snippet": "static ssize_t blk_trace_mask2str(char *buf, int mask)\n{\n\tint i;\n\tchar *p = buf;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\tif (mask & mask_maps[i].mask) {\n\t\t\tp += sprintf(p, \"%s%s\",\n\t\t\t\t    (p == buf) ? \"\" : \",\", mask_maps[i].str);\n\t\t}\n\t}\n\t*p++ = '\\n';\n\n\treturn p - buf;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t blk_trace_mask2str(char *buf, int mask)\n{\n\tint i;\n\tchar *p = buf;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\tif (mask & mask_maps[i].mask) {\n\t\t\tp += sprintf(p, \"%s%s\",\n\t\t\t\t    (p == buf) ? \"\" : \",\", mask_maps[i].str);\n\t\t}\n\t}\n\t*p++ = '\\n';\n\n\treturn p - buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"disabled\\n\""
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "!!bt"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "q->blk_trace",
            "lockdep_is_held(&q->debugfs_mutex)"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_bdev",
          "args": [
            "dev"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sysfs_blk_trace_attr_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct block_device *bdev = dev_to_bdev(dev);\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tstruct blk_trace *bt;\n\tssize_t ret = -ENXIO;\n\n\tmutex_lock(&q->debugfs_mutex);\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (attr == &dev_attr_enable) {\n\t\tret = sprintf(buf, \"%u\\n\", !!bt);\n\t\tgoto out_unlock_bdev;\n\t}\n\n\tif (bt == NULL)\n\t\tret = sprintf(buf, \"disabled\\n\");\n\telse if (attr == &dev_attr_act_mask)\n\t\tret = blk_trace_mask2str(buf, bt->act_mask);\n\telse if (attr == &dev_attr_pid)\n\t\tret = sprintf(buf, \"%u\\n\", bt->pid);\n\telse if (attr == &dev_attr_start_lba)\n\t\tret = sprintf(buf, \"%llu\\n\", bt->start_lba);\n\telse if (attr == &dev_attr_end_lba)\n\t\tret = sprintf(buf, \"%llu\\n\", bt->end_lba);\n\nout_unlock_bdev:\n\tmutex_unlock(&q->debugfs_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "blk_trace_mask2str",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1746-1760",
    "snippet": "static ssize_t blk_trace_mask2str(char *buf, int mask)\n{\n\tint i;\n\tchar *p = buf;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\tif (mask & mask_maps[i].mask) {\n\t\t\tp += sprintf(p, \"%s%s\",\n\t\t\t\t    (p == buf) ? \"\" : \",\", mask_maps[i].str);\n\t\t}\n\t}\n\t*p++ = '\\n';\n\n\treturn p - buf;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "p",
            "\"%s%s\"",
            "(p == buf) ? \"\" : \",\"",
            "mask_maps[i].str"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mask_maps"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t blk_trace_mask2str(char *buf, int mask)\n{\n\tint i;\n\tchar *p = buf;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\tif (mask & mask_maps[i].mask) {\n\t\t\tp += sprintf(p, \"%s%s\",\n\t\t\t\t    (p == buf) ? \"\" : \",\", mask_maps[i].str);\n\t\t}\n\t}\n\t*p++ = '\\n';\n\n\treturn p - buf;\n}"
  },
  {
    "function_name": "blk_trace_str2mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1711-1744",
    "snippet": "static int blk_trace_str2mask(const char *str)\n{\n\tint i;\n\tint mask = 0;\n\tchar *buf, *s, *token;\n\n\tbuf = kstrdup(str, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\ts = strstrip(buf);\n\n\twhile (1) {\n\t\ttoken = strsep(&s, \",\");\n\t\tif (token == NULL)\n\t\t\tbreak;\n\n\t\tif (*token == '\\0')\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\t\tif (strcasecmp(token, mask_maps[i].str) == 0) {\n\t\t\t\tmask |= mask_maps[i].mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(mask_maps)) {\n\t\t\tmask = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(buf);\n\n\treturn mask;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mask_maps"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "token",
            "mask_maps[i].str"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mask_maps"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&s",
            "\",\""
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_str2mask(const char *str)\n{\n\tint i;\n\tint mask = 0;\n\tchar *buf, *s, *token;\n\n\tbuf = kstrdup(str, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\ts = strstrip(buf);\n\n\twhile (1) {\n\t\ttoken = strsep(&s, \",\");\n\t\tif (token == NULL)\n\t\t\tbreak;\n\n\t\tif (*token == '\\0')\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\t\tif (strcasecmp(token, mask_maps[i].str) == 0) {\n\t\t\t\tmask |= mask_maps[i].mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(mask_maps)) {\n\t\t\tmask = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(buf);\n\n\treturn mask;\n}"
  },
  {
    "function_name": "blk_trace_setup_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1626-1652",
    "snippet": "static int blk_trace_setup_queue(struct request_queue *q,\n\t\t\t\t struct block_device *bdev)\n{\n\tstruct blk_trace *bt = NULL;\n\tint ret = -ENOMEM;\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto free_bt;\n\n\tbt->dev = bdev->bd_dev;\n\tbt->act_mask = (u16)-1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\trcu_assign_pointer(q->blk_trace, bt);\n\tget_probe_ref();\n\treturn 0;\n\nfree_bt:\n\tblk_trace_free(bt);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_trace_free",
          "args": [
            "bt"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "313-320",
          "snippet": "static void blk_trace_free(struct blk_trace *bt)\n{\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_free(struct blk_trace *bt)\n{\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_probe_ref",
          "args": [],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "get_probe_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "322-328",
          "snippet": "static void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "q->blk_trace",
            "bt"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_trace_setup_lba",
          "args": [
            "bt",
            "bdev"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_setup_lba",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "457-467",
          "snippet": "static void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tif (bdev) {\n\t\tbt->start_lba = bdev->bd_start_sect;\n\t\tbt->end_lba = bdev->bd_start_sect + bdev_nr_sectors(bdev);\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tif (bdev) {\n\t\tbt->start_lba = bdev->bd_start_sect;\n\t\tbt->end_lba = bdev->bd_start_sect + bdev_nr_sectors(bdev);\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_percpu",
          "args": [
            "BLK_TN_MAX_MSG",
            "__alignof__(char)"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bt)",
            "GFP_KERNEL"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_setup_queue(struct request_queue *q,\n\t\t\t\t struct block_device *bdev)\n{\n\tstruct blk_trace *bt = NULL;\n\tint ret = -ENOMEM;\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto free_bt;\n\n\tbt->dev = bdev->bd_dev;\n\tbt->act_mask = (u16)-1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\trcu_assign_pointer(q->blk_trace, bt);\n\tget_probe_ref();\n\treturn 0;\n\nfree_bt:\n\tblk_trace_free(bt);\n\treturn ret;\n}"
  },
  {
    "function_name": "blk_trace_remove_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1600-1621",
    "snippet": "static int blk_trace_remove_queue(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state == Blktrace_running) {\n\t\tbt->trace_state = Blktrace_stopped;\n\t\traw_spin_lock_irq(&running_trace_lock);\n\t\tlist_del_init(&bt->running_list);\n\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\trelay_flush(bt->rchan);\n\t}\n\n\tput_probe_ref();\n\tsynchronize_rcu();\n\tblk_trace_free(bt);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_trace_free",
          "args": [
            "bt"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "313-320",
          "snippet": "static void blk_trace_free(struct blk_trace *bt)\n{\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_free(struct blk_trace *bt)\n{\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_probe_ref",
          "args": [],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "put_probe_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "330-336",
          "snippet": "static void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_flush",
          "args": [
            "bt->rchan"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "relay_flush",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "788-806",
          "snippet": "void relay_flush(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0))) {\n\t\trelay_switch_subbuf(buf, 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_switch_subbuf(buf, 0);\n\tmutex_unlock(&relay_channels_mutex);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(relay_channels_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\n\nvoid relay_flush(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0))) {\n\t\trelay_switch_subbuf(buf, 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_switch_subbuf(buf, 0);\n\tmutex_unlock(&relay_channels_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&running_trace_lock"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bt->running_list"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&running_trace_lock"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_replace_pointer",
          "args": [
            "q->blk_trace",
            "NULL",
            "lockdep_is_held(&q->debugfs_mutex)"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_remove_queue(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state == Blktrace_running) {\n\t\tbt->trace_state = Blktrace_stopped;\n\t\traw_spin_lock_irq(&running_trace_lock);\n\t\tlist_del_init(&bt->running_list);\n\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\trelay_flush(bt->rchan);\n\t}\n\n\tput_probe_ref();\n\tsynchronize_rcu();\n\tblk_trace_free(bt);\n\treturn 0;\n}"
  },
  {
    "function_name": "init_blk_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1582-1596",
    "snippet": "static int __init init_blk_tracer(void)\n{\n\tif (!register_trace_event(&trace_blk_event)) {\n\t\tpr_warn(\"Warning: could not register block events\\n\");\n\t\treturn 1;\n\t}\n\n\tif (register_tracer(&blk_tracer) != 0) {\n\t\tpr_warn(\"Warning: could not register the block tracer\\n\");\n\t\tunregister_trace_event(&trace_blk_event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_event",
          "args": [
            "&trace_blk_event"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "826-833",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: could not register the block tracer\\n\""
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&blk_tracer"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2037-2120",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: could not register block events\\n\""
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __init init_blk_tracer(void)\n{\n\tif (!register_trace_event(&trace_blk_event)) {\n\t\tpr_warn(\"Warning: could not register block events\\n\");\n\t\treturn 1;\n\t}\n\n\tif (register_tracer(&blk_tracer) != 0) {\n\t\tpr_warn(\"Warning: could not register the block tracer\\n\");\n\t\tunregister_trace_event(&trace_blk_event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_tracer_set_flag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1547-1558",
    "snippet": "static int\nblk_tracer_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\t/* don't output context-info for blk_classic output */\n\tif (bit == TRACE_BLK_OPT_CLASSIC) {\n\t\tif (set)\n\t\t\ttr->trace_flags &= ~TRACE_ITER_CONTEXT_INFO;\n\t\telse\n\t\t\ttr->trace_flags |= TRACE_ITER_CONTEXT_INFO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CLASSIC\t0x1"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CLASSIC\t0x1\n\nstatic int\nblk_tracer_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\t/* don't output context-info for blk_classic output */\n\tif (bit == TRACE_BLK_OPT_CLASSIC) {\n\t\tif (set)\n\t\t\ttr->trace_flags &= ~TRACE_ITER_CONTEXT_INFO;\n\t\telse\n\t\t\ttr->trace_flags |= TRACE_ITER_CONTEXT_INFO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_tracer_print_line",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1539-1545",
    "snippet": "static enum print_line_t blk_tracer_print_line(struct trace_iterator *iter)\n{\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CLASSIC))\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\treturn print_one_line(iter, true);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CLASSIC\t0x1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_one_line",
          "args": [
            "iter",
            "true"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "print_one_line",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1476-1507",
          "snippet": "static enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CLASSIC\t0x1\n\nstatic enum print_line_t blk_tracer_print_line(struct trace_iterator *iter)\n{\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CLASSIC))\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\treturn print_one_line(iter, true);\n}"
  },
  {
    "function_name": "blk_trace_event_print_binary",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1530-1537",
    "snippet": "static enum print_line_t\nblk_trace_event_print_binary(struct trace_iterator *iter, int flags,\n\t\t\t     struct trace_event *event)\n{\n\tblk_trace_synthesize_old_trace(iter);\n\n\treturn trace_handle_return(&iter->seq);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "&iter->seq"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_synthesize_old_trace",
          "args": [
            "iter"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_synthesize_old_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1515-1528",
          "snippet": "static void blk_trace_synthesize_old_trace(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct blk_io_trace *t = (struct blk_io_trace *)iter->ent;\n\tconst int offset = offsetof(struct blk_io_trace, sector);\n\tstruct blk_io_trace old = {\n\t\t.magic\t  = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION,\n\t\t.time     = iter->ts,\n\t};\n\n\ttrace_seq_putmem(s, &old, offset);\n\ttrace_seq_putmem(s, &t->sector,\n\t\t\t sizeof(old) - offset + t->pdu_len);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_synthesize_old_trace(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct blk_io_trace *t = (struct blk_io_trace *)iter->ent;\n\tconst int offset = offsetof(struct blk_io_trace, sector);\n\tstruct blk_io_trace old = {\n\t\t.magic\t  = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION,\n\t\t.time     = iter->ts,\n\t};\n\n\ttrace_seq_putmem(s, &old, offset);\n\ttrace_seq_putmem(s, &t->sector,\n\t\t\t sizeof(old) - offset + t->pdu_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t\nblk_trace_event_print_binary(struct trace_iterator *iter, int flags,\n\t\t\t     struct trace_event *event)\n{\n\tblk_trace_synthesize_old_trace(iter);\n\n\treturn trace_handle_return(&iter->seq);\n}"
  },
  {
    "function_name": "blk_trace_synthesize_old_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1515-1528",
    "snippet": "static void blk_trace_synthesize_old_trace(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct blk_io_trace *t = (struct blk_io_trace *)iter->ent;\n\tconst int offset = offsetof(struct blk_io_trace, sector);\n\tstruct blk_io_trace old = {\n\t\t.magic\t  = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION,\n\t\t.time     = iter->ts,\n\t};\n\n\ttrace_seq_putmem(s, &old, offset);\n\ttrace_seq_putmem(s, &t->sector,\n\t\t\t sizeof(old) - offset + t->pdu_len);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putmem",
          "args": [
            "s",
            "&t->sector",
            "sizeof(old) - offset + t->pdu_len"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putmem_hex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "285-309",
          "snippet": "void trace_seq_putmem_hex(struct trace_seq *s, const void *mem,\n\t\t\t unsigned int len)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\t/* Each byte is represented by two chars */\n\tif (len * 2 > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\t/* The added spaces can still cause an overflow */\n\tseq_buf_putmem_hex(&s->seq, mem, len);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putmem_hex(struct trace_seq *s, const void *mem,\n\t\t\t unsigned int len)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\t/* Each byte is represented by two chars */\n\tif (len * 2 > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\t/* The added spaces can still cause an overflow */\n\tseq_buf_putmem_hex(&s->seq, mem, len);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_synthesize_old_trace(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct blk_io_trace *t = (struct blk_io_trace *)iter->ent;\n\tconst int offset = offsetof(struct blk_io_trace, sector);\n\tstruct blk_io_trace old = {\n\t\t.magic\t  = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION,\n\t\t.time     = iter->ts,\n\t};\n\n\ttrace_seq_putmem(s, &old, offset);\n\ttrace_seq_putmem(s, &t->sector,\n\t\t\t sizeof(old) - offset + t->pdu_len);\n}"
  },
  {
    "function_name": "blk_trace_event_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1509-1513",
    "snippet": "static enum print_line_t blk_trace_event_print(struct trace_iterator *iter,\n\t\t\t\t\t       int flags, struct trace_event *event)\n{\n\treturn print_one_line(iter, false);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_one_line",
          "args": [
            "iter",
            "false"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "print_one_line",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1476-1507",
          "snippet": "static enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t blk_trace_event_print(struct trace_iterator *iter,\n\t\t\t\t\t       int flags, struct trace_event *event)\n{\n\treturn print_one_line(iter, false);\n}"
  },
  {
    "function_name": "print_one_line",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1476-1507",
    "snippet": "static enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "what2act[what].print",
          "args": [
            "s",
            "iter->ent",
            "has_cg"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_action",
          "args": [
            "iter",
            "what2act[what].act[long_act]",
            "has_cg"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "blk_log_action",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1255-1295",
          "snippet": "static void blk_log_action(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\tif (has_cg) {\n\t\tu64 id = t_cgid(iter->ent);\n\n\t\tif (blk_tracer_flags.val & TRACE_BLK_OPT_CGNAME) {\n\t\t\tchar blkcg_name_buf[NAME_MAX + 1] = \"<...>\";\n\n\t\t\tcgroup_path_from_kernfs_id(id, blkcg_name_buf,\n\t\t\t\tsizeof(blkcg_name_buf));\n\t\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %s %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t blkcg_name_buf, act, rwbs);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The cgid portion used to be \"INO,GEN\".  Userland\n\t\t\t * builds a FILEID_INO32_GEN fid out of them and\n\t\t\t * opens the cgroup using open_by_handle_at(2).\n\t\t\t * While 32bit ino setups are still the same, 64bit\n\t\t\t * ones now use the 64bit ino as the whole ID and\n\t\t\t * no longer use generation.\n\t\t\t *\n\t\t\t * Regardless of the content, always output\n\t\t\t * \"LOW32,HIGH32\" so that FILEID_INO32_GEN fid can\n\t\t\t * be mapped back to @id on both 64 and 32bit ino\n\t\t\t * setups.  See __kernfs_fh_to_dentry().\n\t\t\t */\n\t\t\ttrace_seq_printf(&iter->seq,\n\t\t\t\t \"%3d,%-3d %llx,%-llx %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t id & U32_MAX, id >> 32, act, rwbs);\n\t\t}\n\t} else\n\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device), act, rwbs);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TRACE_BLK_OPT_CGNAME\t0x4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGNAME\t0x4\n\nstatic void blk_log_action(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\tif (has_cg) {\n\t\tu64 id = t_cgid(iter->ent);\n\n\t\tif (blk_tracer_flags.val & TRACE_BLK_OPT_CGNAME) {\n\t\t\tchar blkcg_name_buf[NAME_MAX + 1] = \"<...>\";\n\n\t\t\tcgroup_path_from_kernfs_id(id, blkcg_name_buf,\n\t\t\t\tsizeof(blkcg_name_buf));\n\t\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %s %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t blkcg_name_buf, act, rwbs);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The cgid portion used to be \"INO,GEN\".  Userland\n\t\t\t * builds a FILEID_INO32_GEN fid out of them and\n\t\t\t * opens the cgroup using open_by_handle_at(2).\n\t\t\t * While 32bit ino setups are still the same, 64bit\n\t\t\t * ones now use the 64bit ino as the whole ID and\n\t\t\t * no longer use generation.\n\t\t\t *\n\t\t\t * Regardless of the content, always output\n\t\t\t * \"LOW32,HIGH32\" so that FILEID_INO32_GEN fid can\n\t\t\t * be mapped back to @id on both 64 and 32bit ino\n\t\t\t * setups.  See __kernfs_fh_to_dentry().\n\t\t\t */\n\t\t\ttrace_seq_printf(&iter->seq,\n\t\t\t\t \"%3d,%-3d %llx,%-llx %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t id & U32_MAX, id >> 32, act, rwbs);\n\t\t}\n\t} else\n\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device), act, rwbs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"Unknown action %x\\n\"",
            "what"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "what == 0 || what >= ARRAY_SIZE(what2act)"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "what2act"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_log_msg",
          "args": [
            "s",
            "iter->ent",
            "has_cg"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "blk_log_msg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1411-1418",
          "snippet": "static void blk_log_msg(struct trace_seq *s, const struct trace_entry *ent,\n\t\t\tbool has_cg)\n{\n\n\ttrace_seq_putmem(s, pdu_start(ent, has_cg),\n\t\tpdu_real_len(ent, has_cg));\n\ttrace_seq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_msg(struct trace_seq *s, const struct trace_entry *ent,\n\t\t\tbool has_cg)\n{\n\n\ttrace_seq_putmem(s, pdu_start(ent, has_cg),\n\t\tpdu_real_len(ent, has_cg));\n\ttrace_seq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "iter->ent"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1183-1187",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "blk_tracer_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1449-1452",
    "snippet": "static void blk_tracer_reset(struct trace_array *tr)\n{\n\tblk_tracer_stop(tr);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_tracer_stop",
          "args": [
            "tr"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "blk_tracer_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1444-1447",
          "snippet": "static void blk_tracer_stop(struct trace_array *tr)\n{\n\tblk_tracer_enabled = false;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_tracer_stop(struct trace_array *tr)\n{\n\tblk_tracer_enabled = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_tracer_reset(struct trace_array *tr)\n{\n\tblk_tracer_stop(tr);\n}"
  },
  {
    "function_name": "blk_tracer_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1444-1447",
    "snippet": "static void blk_tracer_stop(struct trace_array *tr)\n{\n\tblk_tracer_enabled = false;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_tracer_stop(struct trace_array *tr)\n{\n\tblk_tracer_enabled = false;\n}"
  },
  {
    "function_name": "blk_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1437-1442",
    "snippet": "static int blk_tracer_init(struct trace_array *tr)\n{\n\tblk_tr = tr;\n\tblk_tracer_start(tr);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_tracer_start",
          "args": [
            "tr"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "blk_tracer_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1432-1435",
          "snippet": "static void blk_tracer_start(struct trace_array *tr)\n{\n\tblk_tracer_enabled = true;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_tracer_start(struct trace_array *tr)\n{\n\tblk_tracer_enabled = true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_tracer_init(struct trace_array *tr)\n{\n\tblk_tr = tr;\n\tblk_tracer_start(tr);\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_tracer_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1432-1435",
    "snippet": "static void blk_tracer_start(struct trace_array *tr)\n{\n\tblk_tracer_enabled = true;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_tracer_start(struct trace_array *tr)\n{\n\tblk_tracer_enabled = true;\n}"
  },
  {
    "function_name": "blk_tracer_print_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1424-1430",
    "snippet": "static void blk_tracer_print_header(struct seq_file *m)\n{\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CLASSIC))\n\t\treturn;\n\tseq_puts(m, \"# DEV   CPU TIMESTAMP     PID ACT FLG\\n\"\n\t\t    \"#  |     |     |           |   |   |\\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CLASSIC\t0x1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"# DEV   CPU TIMESTAMP     PID ACT FLG\\n\"\n\t\t    \"#  |     |     |           |   |   |\\n\""
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CLASSIC\t0x1\n\nstatic void blk_tracer_print_header(struct seq_file *m)\n{\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CLASSIC))\n\t\treturn;\n\tseq_puts(m, \"# DEV   CPU TIMESTAMP     PID ACT FLG\\n\"\n\t\t    \"#  |     |     |           |   |   |\\n\");\n}"
  },
  {
    "function_name": "blk_log_msg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1411-1418",
    "snippet": "static void blk_log_msg(struct trace_seq *s, const struct trace_entry *ent,\n\t\t\tbool has_cg)\n{\n\n\ttrace_seq_putmem(s, pdu_start(ent, has_cg),\n\t\tpdu_real_len(ent, has_cg));\n\ttrace_seq_putc(s, '\\n');\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putmem",
          "args": [
            "s",
            "pdu_start(ent, has_cg)",
            "pdu_real_len(ent, has_cg)"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putmem_hex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "285-309",
          "snippet": "void trace_seq_putmem_hex(struct trace_seq *s, const void *mem,\n\t\t\t unsigned int len)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\t/* Each byte is represented by two chars */\n\tif (len * 2 > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\t/* The added spaces can still cause an overflow */\n\tseq_buf_putmem_hex(&s->seq, mem, len);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putmem_hex(struct trace_seq *s, const void *mem,\n\t\t\t unsigned int len)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\t/* Each byte is represented by two chars */\n\tif (len * 2 > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\t/* The added spaces can still cause an overflow */\n\tseq_buf_putmem_hex(&s->seq, mem, len);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdu_real_len",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_real_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1199-1202",
          "snippet": "static inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len - (has_cg ? sizeof(u64) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len - (has_cg ? sizeof(u64) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdu_start",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1189-1192",
          "snippet": "static inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) + (has_cg ? sizeof(u64) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) + (has_cg ? sizeof(u64) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_msg(struct trace_seq *s, const struct trace_entry *ent,\n\t\t\tbool has_cg)\n{\n\n\ttrace_seq_putmem(s, pdu_start(ent, has_cg),\n\t\tpdu_real_len(ent, has_cg));\n\ttrace_seq_putc(s, '\\n');\n}"
  },
  {
    "function_name": "blk_log_split",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1401-1409",
    "snippet": "static void blk_log_split(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"%llu / %llu [%s]\\n\", t_sector(ent),\n\t\t\t get_pdu_int(ent, has_cg), cmd);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%llu / %llu [%s]\\n\"",
            "t_sector(ent)",
            "get_pdu_int(ent, has_cg)",
            "cmd"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pdu_int",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "get_pdu_int",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1229-1233",
          "snippet": "static __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __be64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __be64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_sector",
          "args": [
            "ent"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "t_sector",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1219-1222",
          "snippet": "static inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "ent->pid",
            "cmd"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2443-2452",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_split(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"%llu / %llu [%s]\\n\", t_sector(ent),\n\t\t\t get_pdu_int(ent, has_cg), cmd);\n}"
  },
  {
    "function_name": "blk_log_unplug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1392-1399",
    "snippet": "static void blk_log_unplug(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"[%s] %llu\\n\", cmd, get_pdu_int(ent, has_cg));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"[%s] %llu\\n\"",
            "cmd",
            "get_pdu_int(ent, has_cg)"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pdu_int",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "get_pdu_int",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1229-1233",
          "snippet": "static __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __be64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __be64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "ent->pid",
            "cmd"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2443-2452",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_unplug(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"[%s] %llu\\n\", cmd, get_pdu_int(ent, has_cg));\n}"
  },
  {
    "function_name": "blk_log_plug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1383-1390",
    "snippet": "static void blk_log_plug(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"[%s]\\n\"",
            "cmd"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "ent->pid",
            "cmd"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2443-2452",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_plug(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n}"
  },
  {
    "function_name": "blk_log_remap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1372-1381",
    "snippet": "static void blk_log_remap(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tconst struct blk_io_trace_remap *__r = pdu_start(ent, has_cg);\n\n\ttrace_seq_printf(s, \"%llu + %u <- (%d,%d) %llu\\n\",\n\t\t\t t_sector(ent), t_sec(ent),\n\t\t\t MAJOR(be32_to_cpu(__r->device_from)),\n\t\t\t MINOR(be32_to_cpu(__r->device_from)),\n\t\t\t be64_to_cpu(__r->sector_from));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%llu + %u <- (%d,%d) %llu\\n\"",
            "t_sector(ent)",
            "t_sec(ent)",
            "MAJOR(be32_to_cpu(__r->device_from))",
            "MINOR(be32_to_cpu(__r->device_from))",
            "be64_to_cpu(__r->sector_from)"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "__r->sector_from"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "be32_to_cpu(__r->device_from)"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "__r->device_from"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "be32_to_cpu(__r->device_from)"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "__r->device_from"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_sec",
          "args": [
            "ent"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "t_sector",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1219-1222",
          "snippet": "static inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdu_start",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1189-1192",
          "snippet": "static inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) + (has_cg ? sizeof(u64) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) + (has_cg ? sizeof(u64) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_remap(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tconst struct blk_io_trace_remap *__r = pdu_start(ent, has_cg);\n\n\ttrace_seq_printf(s, \"%llu + %u <- (%d,%d) %llu\\n\",\n\t\t\t t_sector(ent), t_sec(ent),\n\t\t\t MAJOR(be32_to_cpu(__r->device_from)),\n\t\t\t MINOR(be32_to_cpu(__r->device_from)),\n\t\t\t be64_to_cpu(__r->sector_from));\n}"
  },
  {
    "function_name": "blk_log_with_error",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1355-1370",
    "snippet": "static void blk_log_with_error(struct trace_seq *s,\n\t\t\t      const struct trace_entry *ent, bool has_cg)\n{\n\tif (t_action(ent) & BLK_TC_ACT(BLK_TC_PC)) {\n\t\tblk_log_dump_pdu(s, ent, has_cg);\n\t\ttrace_seq_printf(s, \"[%d]\\n\", t_error(ent));\n\t} else {\n\t\tif (t_sec(ent))\n\t\t\ttrace_seq_printf(s, \"%llu + %u [%d]\\n\",\n\t\t\t\t\t t_sector(ent),\n\t\t\t\t\t t_sec(ent), t_error(ent));\n\t\telse\n\t\t\ttrace_seq_printf(s, \"%llu [%d]\\n\",\n\t\t\t\t\t t_sector(ent), t_error(ent));\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%llu [%d]\\n\"",
            "t_sector(ent)",
            "t_error(ent)"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_error",
          "args": [
            "ent"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "t_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1224-1227",
          "snippet": "static inline __u16 t_error(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->error;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline __u16 t_error(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_sector",
          "args": [
            "ent"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "t_sector",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1219-1222",
          "snippet": "static inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_log_dump_pdu",
          "args": [
            "s",
            "ent",
            "has_cg"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "blk_log_dump_pdu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1297-1334",
          "snippet": "static void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeros and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeros and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_PC"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_action",
          "args": [
            "ent"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "t_action",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1204-1207",
          "snippet": "static inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_with_error(struct trace_seq *s,\n\t\t\t      const struct trace_entry *ent, bool has_cg)\n{\n\tif (t_action(ent) & BLK_TC_ACT(BLK_TC_PC)) {\n\t\tblk_log_dump_pdu(s, ent, has_cg);\n\t\ttrace_seq_printf(s, \"[%d]\\n\", t_error(ent));\n\t} else {\n\t\tif (t_sec(ent))\n\t\t\ttrace_seq_printf(s, \"%llu + %u [%d]\\n\",\n\t\t\t\t\t t_sector(ent),\n\t\t\t\t\t t_sec(ent), t_error(ent));\n\t\telse\n\t\t\ttrace_seq_printf(s, \"%llu [%d]\\n\",\n\t\t\t\t\t t_sector(ent), t_error(ent));\n\t}\n}"
  },
  {
    "function_name": "blk_log_generic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1336-1353",
    "snippet": "static void blk_log_generic(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\tif (t_action(ent) & BLK_TC_ACT(BLK_TC_PC)) {\n\t\ttrace_seq_printf(s, \"%u \", t_bytes(ent));\n\t\tblk_log_dump_pdu(s, ent, has_cg);\n\t\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n\t} else {\n\t\tif (t_sec(ent))\n\t\t\ttrace_seq_printf(s, \"%llu + %u [%s]\\n\",\n\t\t\t\t\t\tt_sector(ent), t_sec(ent), cmd);\n\t\telse\n\t\t\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"[%s]\\n\"",
            "cmd"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_sec",
          "args": [
            "ent"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "t_sector",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1219-1222",
          "snippet": "static inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_log_dump_pdu",
          "args": [
            "s",
            "ent",
            "has_cg"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "blk_log_dump_pdu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1297-1334",
          "snippet": "static void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeros and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeros and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_bytes",
          "args": [
            "ent"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "t_bytes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1209-1212",
          "snippet": "static inline u32 t_bytes(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_bytes(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_PC"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_action",
          "args": [
            "ent"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "t_action",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1204-1207",
          "snippet": "static inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "ent->pid",
            "cmd"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2443-2452",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_generic(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\tif (t_action(ent) & BLK_TC_ACT(BLK_TC_PC)) {\n\t\ttrace_seq_printf(s, \"%u \", t_bytes(ent));\n\t\tblk_log_dump_pdu(s, ent, has_cg);\n\t\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n\t} else {\n\t\tif (t_sec(ent))\n\t\t\ttrace_seq_printf(s, \"%llu + %u [%s]\\n\",\n\t\t\t\t\t\tt_sector(ent), t_sec(ent), cmd);\n\t\telse\n\t\t\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n\t}\n}"
  },
  {
    "function_name": "blk_log_dump_pdu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1297-1334",
    "snippet": "static void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeros and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\") \""
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s%02x\"",
            "i == 0 ? \"\" : \" \"",
            "pdu_buf[i]"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'('"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdu_real_len",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_real_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1199-1202",
          "snippet": "static inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len - (has_cg ? sizeof(u64) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len - (has_cg ? sizeof(u64) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdu_start",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1189-1192",
          "snippet": "static inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) + (has_cg ? sizeof(u64) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) + (has_cg ? sizeof(u64) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeros and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}"
  },
  {
    "function_name": "blk_log_action",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1255-1295",
    "snippet": "static void blk_log_action(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\tif (has_cg) {\n\t\tu64 id = t_cgid(iter->ent);\n\n\t\tif (blk_tracer_flags.val & TRACE_BLK_OPT_CGNAME) {\n\t\t\tchar blkcg_name_buf[NAME_MAX + 1] = \"<...>\";\n\n\t\t\tcgroup_path_from_kernfs_id(id, blkcg_name_buf,\n\t\t\t\tsizeof(blkcg_name_buf));\n\t\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %s %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t blkcg_name_buf, act, rwbs);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The cgid portion used to be \"INO,GEN\".  Userland\n\t\t\t * builds a FILEID_INO32_GEN fid out of them and\n\t\t\t * opens the cgroup using open_by_handle_at(2).\n\t\t\t * While 32bit ino setups are still the same, 64bit\n\t\t\t * ones now use the 64bit ino as the whole ID and\n\t\t\t * no longer use generation.\n\t\t\t *\n\t\t\t * Regardless of the content, always output\n\t\t\t * \"LOW32,HIGH32\" so that FILEID_INO32_GEN fid can\n\t\t\t * be mapped back to @id on both 64 and 32bit ino\n\t\t\t * setups.  See __kernfs_fh_to_dentry().\n\t\t\t */\n\t\t\ttrace_seq_printf(&iter->seq,\n\t\t\t\t \"%3d,%-3d %llx,%-llx %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t id & U32_MAX, id >> 32, act, rwbs);\n\t\t}\n\t} else\n\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device), act, rwbs);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CGNAME\t0x4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "&iter->seq",
            "\"%3d,%-3d %2s %3s \"",
            "MAJOR(t->device)",
            "MINOR(t->device)",
            "act",
            "rwbs"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "t->device"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "t->device"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "t->device"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "t->device"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "t->device"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "t->device"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_path_from_kernfs_id",
          "args": [
            "id",
            "blkcg_name_buf",
            "sizeof(blkcg_name_buf)"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_path_from_kernfs_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "5948-5957",
          "snippet": "void cgroup_path_from_kernfs_id(u64 id, char *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = kernfs_find_and_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\treturn;\n\tkernfs_path(kn, buf, buflen);\n\tkernfs_put(kn);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\n\nvoid cgroup_path_from_kernfs_id(u64 id, char *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = kernfs_find_and_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\treturn;\n\tkernfs_path(kn, buf, buflen);\n\tkernfs_put(kn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_cgid",
          "args": [
            "iter->ent"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "t_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1194-1197",
          "snippet": "static inline u64 t_cgid(const struct trace_entry *ent)\n{\n\treturn *(u64 *)(te_blk_io_trace(ent) + 1);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u64 t_cgid(const struct trace_entry *ent)\n{\n\treturn *(u64 *)(te_blk_io_trace(ent) + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_rwbs",
          "args": [
            "rwbs",
            "t"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "blk_fill_rwbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1886-1925",
          "snippet": "void blk_fill_rwbs(char *rwbs, unsigned int op)\n{\n\tint i = 0;\n\n\tif (op & REQ_PREFLUSH)\n\t\trwbs[i++] = 'F';\n\n\tswitch (op & REQ_OP_MASK) {\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_WRITE_SAME:\n\t\trwbs[i++] = 'W';\n\t\tbreak;\n\tcase REQ_OP_DISCARD:\n\t\trwbs[i++] = 'D';\n\t\tbreak;\n\tcase REQ_OP_SECURE_ERASE:\n\t\trwbs[i++] = 'D';\n\t\trwbs[i++] = 'E';\n\t\tbreak;\n\tcase REQ_OP_FLUSH:\n\t\trwbs[i++] = 'F';\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\trwbs[i++] = 'R';\n\t\tbreak;\n\tdefault:\n\t\trwbs[i++] = 'N';\n\t}\n\n\tif (op & REQ_FUA)\n\t\trwbs[i++] = 'F';\n\tif (op & REQ_RAHEAD)\n\t\trwbs[i++] = 'A';\n\tif (op & REQ_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (op & REQ_META)\n\t\trwbs[i++] = 'M';\n\n\trwbs[i] = '\\0';\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nvoid blk_fill_rwbs(char *rwbs, unsigned int op)\n{\n\tint i = 0;\n\n\tif (op & REQ_PREFLUSH)\n\t\trwbs[i++] = 'F';\n\n\tswitch (op & REQ_OP_MASK) {\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_WRITE_SAME:\n\t\trwbs[i++] = 'W';\n\t\tbreak;\n\tcase REQ_OP_DISCARD:\n\t\trwbs[i++] = 'D';\n\t\tbreak;\n\tcase REQ_OP_SECURE_ERASE:\n\t\trwbs[i++] = 'D';\n\t\trwbs[i++] = 'E';\n\t\tbreak;\n\tcase REQ_OP_FLUSH:\n\t\trwbs[i++] = 'F';\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\trwbs[i++] = 'R';\n\t\tbreak;\n\tdefault:\n\t\trwbs[i++] = 'N';\n\t}\n\n\tif (op & REQ_FUA)\n\t\trwbs[i++] = 'F';\n\tif (op & REQ_RAHEAD)\n\t\trwbs[i++] = 'A';\n\tif (op & REQ_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (op & REQ_META)\n\t\trwbs[i++] = 'M';\n\n\trwbs[i] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "iter->ent"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1183-1187",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGNAME\t0x4\n\nstatic void blk_log_action(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\tif (has_cg) {\n\t\tu64 id = t_cgid(iter->ent);\n\n\t\tif (blk_tracer_flags.val & TRACE_BLK_OPT_CGNAME) {\n\t\t\tchar blkcg_name_buf[NAME_MAX + 1] = \"<...>\";\n\n\t\t\tcgroup_path_from_kernfs_id(id, blkcg_name_buf,\n\t\t\t\tsizeof(blkcg_name_buf));\n\t\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %s %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t blkcg_name_buf, act, rwbs);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The cgid portion used to be \"INO,GEN\".  Userland\n\t\t\t * builds a FILEID_INO32_GEN fid out of them and\n\t\t\t * opens the cgroup using open_by_handle_at(2).\n\t\t\t * While 32bit ino setups are still the same, 64bit\n\t\t\t * ones now use the 64bit ino as the whole ID and\n\t\t\t * no longer use generation.\n\t\t\t *\n\t\t\t * Regardless of the content, always output\n\t\t\t * \"LOW32,HIGH32\" so that FILEID_INO32_GEN fid can\n\t\t\t * be mapped back to @id on both 64 and 32bit ino\n\t\t\t * setups.  See __kernfs_fh_to_dentry().\n\t\t\t */\n\t\t\ttrace_seq_printf(&iter->seq,\n\t\t\t\t \"%3d,%-3d %llx,%-llx %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t id & U32_MAX, id >> 32, act, rwbs);\n\t\t}\n\t} else\n\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device), act, rwbs);\n}"
  },
  {
    "function_name": "blk_log_action_classic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1238-1253",
    "snippet": "static void blk_log_action_classic(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tunsigned long long ts  = iter->ts;\n\tunsigned long nsec_rem = do_div(ts, NSEC_PER_SEC);\n\tunsigned secs\t       = (unsigned long)ts;\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\n\ttrace_seq_printf(&iter->seq,\n\t\t\t \"%3d,%-3d %2d %5d.%09lu %5u %2s %3s \",\n\t\t\t MAJOR(t->device), MINOR(t->device), iter->cpu,\n\t\t\t secs, nsec_rem, iter->ent->pid, act, rwbs);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "&iter->seq",
            "\"%3d,%-3d %2d %5d.%09lu %5u %2s %3s \"",
            "MAJOR(t->device)",
            "MINOR(t->device)",
            "iter->cpu",
            "secs",
            "nsec_rem",
            "iter->ent->pid",
            "act",
            "rwbs"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "t->device"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "t->device"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_rwbs",
          "args": [
            "rwbs",
            "t"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "blk_fill_rwbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1886-1925",
          "snippet": "void blk_fill_rwbs(char *rwbs, unsigned int op)\n{\n\tint i = 0;\n\n\tif (op & REQ_PREFLUSH)\n\t\trwbs[i++] = 'F';\n\n\tswitch (op & REQ_OP_MASK) {\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_WRITE_SAME:\n\t\trwbs[i++] = 'W';\n\t\tbreak;\n\tcase REQ_OP_DISCARD:\n\t\trwbs[i++] = 'D';\n\t\tbreak;\n\tcase REQ_OP_SECURE_ERASE:\n\t\trwbs[i++] = 'D';\n\t\trwbs[i++] = 'E';\n\t\tbreak;\n\tcase REQ_OP_FLUSH:\n\t\trwbs[i++] = 'F';\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\trwbs[i++] = 'R';\n\t\tbreak;\n\tdefault:\n\t\trwbs[i++] = 'N';\n\t}\n\n\tif (op & REQ_FUA)\n\t\trwbs[i++] = 'F';\n\tif (op & REQ_RAHEAD)\n\t\trwbs[i++] = 'A';\n\tif (op & REQ_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (op & REQ_META)\n\t\trwbs[i++] = 'M';\n\n\trwbs[i] = '\\0';\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nvoid blk_fill_rwbs(char *rwbs, unsigned int op)\n{\n\tint i = 0;\n\n\tif (op & REQ_PREFLUSH)\n\t\trwbs[i++] = 'F';\n\n\tswitch (op & REQ_OP_MASK) {\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_WRITE_SAME:\n\t\trwbs[i++] = 'W';\n\t\tbreak;\n\tcase REQ_OP_DISCARD:\n\t\trwbs[i++] = 'D';\n\t\tbreak;\n\tcase REQ_OP_SECURE_ERASE:\n\t\trwbs[i++] = 'D';\n\t\trwbs[i++] = 'E';\n\t\tbreak;\n\tcase REQ_OP_FLUSH:\n\t\trwbs[i++] = 'F';\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\trwbs[i++] = 'R';\n\t\tbreak;\n\tdefault:\n\t\trwbs[i++] = 'N';\n\t}\n\n\tif (op & REQ_FUA)\n\t\trwbs[i++] = 'F';\n\tif (op & REQ_RAHEAD)\n\t\trwbs[i++] = 'A';\n\tif (op & REQ_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (op & REQ_META)\n\t\trwbs[i++] = 'M';\n\n\trwbs[i] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "iter->ent"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1183-1187",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ts",
            "NSEC_PER_SEC"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_action_classic(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tunsigned long long ts  = iter->ts;\n\tunsigned long nsec_rem = do_div(ts, NSEC_PER_SEC);\n\tunsigned secs\t       = (unsigned long)ts;\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\n\ttrace_seq_printf(&iter->seq,\n\t\t\t \"%3d,%-3d %2d %5d.%09lu %5u %2s %3s \",\n\t\t\t MAJOR(t->device), MINOR(t->device), iter->cpu,\n\t\t\t secs, nsec_rem, iter->ent->pid, act, rwbs);\n}"
  },
  {
    "function_name": "get_pdu_int",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1229-1233",
    "snippet": "static __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __be64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*val"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdu_start",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1189-1192",
          "snippet": "static inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) + (has_cg ? sizeof(u64) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) + (has_cg ? sizeof(u64) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __be64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}"
  },
  {
    "function_name": "t_error",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1224-1227",
    "snippet": "static inline __u16 t_error(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->error;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1183-1187",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline __u16 t_error(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->error;\n}"
  },
  {
    "function_name": "t_sector",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1219-1222",
    "snippet": "static inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1183-1187",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}"
  },
  {
    "function_name": "t_sec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1214-1217",
    "snippet": "static inline u32 t_sec(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes >> 9;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1183-1187",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_sec(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes >> 9;\n}"
  },
  {
    "function_name": "t_bytes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1209-1212",
    "snippet": "static inline u32 t_bytes(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1183-1187",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_bytes(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes;\n}"
  },
  {
    "function_name": "t_action",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1204-1207",
    "snippet": "static inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1183-1187",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}"
  },
  {
    "function_name": "pdu_real_len",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1199-1202",
    "snippet": "static inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len - (has_cg ? sizeof(u64) : 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1183-1187",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len - (has_cg ? sizeof(u64) : 0);\n}"
  },
  {
    "function_name": "t_cgid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1194-1197",
    "snippet": "static inline u64 t_cgid(const struct trace_entry *ent)\n{\n\treturn *(u64 *)(te_blk_io_trace(ent) + 1);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1183-1187",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u64 t_cgid(const struct trace_entry *ent)\n{\n\treturn *(u64 *)(te_blk_io_trace(ent) + 1);\n}"
  },
  {
    "function_name": "pdu_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1189-1192",
    "snippet": "static inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) + (has_cg ? sizeof(u64) : 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1183-1187",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) + (has_cg ? sizeof(u64) : 0);\n}"
  },
  {
    "function_name": "te_blk_io_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1183-1187",
    "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
  },
  {
    "function_name": "fill_rwbs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1149-1181",
    "snippet": "static void fill_rwbs(char *rwbs, const struct blk_io_trace *t)\n{\n\tint i = 0;\n\tint tc = t->action >> BLK_TC_SHIFT;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\trwbs[i++] = 'N';\n\t\tgoto out;\n\t}\n\n\tif (tc & BLK_TC_FLUSH)\n\t\trwbs[i++] = 'F';\n\n\tif (tc & BLK_TC_DISCARD)\n\t\trwbs[i++] = 'D';\n\telse if (tc & BLK_TC_WRITE)\n\t\trwbs[i++] = 'W';\n\telse if (t->bytes)\n\t\trwbs[i++] = 'R';\n\telse\n\t\trwbs[i++] = 'N';\n\n\tif (tc & BLK_TC_FUA)\n\t\trwbs[i++] = 'F';\n\tif (tc & BLK_TC_AHEAD)\n\t\trwbs[i++] = 'A';\n\tif (tc & BLK_TC_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (tc & BLK_TC_META)\n\t\trwbs[i++] = 'M';\nout:\n\trwbs[i] = '\\0';\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void fill_rwbs(char *rwbs, const struct blk_io_trace *t)\n{\n\tint i = 0;\n\tint tc = t->action >> BLK_TC_SHIFT;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\trwbs[i++] = 'N';\n\t\tgoto out;\n\t}\n\n\tif (tc & BLK_TC_FLUSH)\n\t\trwbs[i++] = 'F';\n\n\tif (tc & BLK_TC_DISCARD)\n\t\trwbs[i++] = 'D';\n\telse if (tc & BLK_TC_WRITE)\n\t\trwbs[i++] = 'W';\n\telse if (t->bytes)\n\t\trwbs[i++] = 'R';\n\telse\n\t\trwbs[i++] = 'N';\n\n\tif (tc & BLK_TC_FUA)\n\t\trwbs[i++] = 'F';\n\tif (tc & BLK_TC_AHEAD)\n\t\trwbs[i++] = 'A';\n\tif (tc & BLK_TC_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (tc & BLK_TC_META)\n\t\trwbs[i++] = 'M';\nout:\n\trwbs[i] = '\\0';\n}"
  },
  {
    "function_name": "blk_unregister_tracepoints",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1123-1143",
    "snippet": "static void blk_unregister_tracepoints(void)\n{\n\tunregister_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tunregister_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tunregister_trace_block_split(blk_add_trace_split, NULL);\n\tunregister_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tunregister_trace_block_plug(blk_add_trace_plug, NULL);\n\tunregister_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tunregister_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tunregister_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tunregister_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tunregister_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tunregister_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tunregister_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tunregister_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tunregister_trace_block_rq_merge(blk_add_trace_rq_merge, NULL);\n\tunregister_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tunregister_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\n\ttracepoint_synchronize_unregister();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_rq_insert",
          "args": [
            "blk_add_trace_rq_insert",
            "NULL"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_rq_issue",
          "args": [
            "blk_add_trace_rq_issue",
            "NULL"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_rq_merge",
          "args": [
            "blk_add_trace_rq_merge",
            "NULL"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_rq_requeue",
          "args": [
            "blk_add_trace_rq_requeue",
            "NULL"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_rq_complete",
          "args": [
            "blk_add_trace_rq_complete",
            "NULL"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_bounce",
          "args": [
            "blk_add_trace_bio_bounce",
            "NULL"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_complete",
          "args": [
            "blk_add_trace_bio_complete",
            "NULL"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_backmerge",
          "args": [
            "blk_add_trace_bio_backmerge",
            "NULL"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_frontmerge",
          "args": [
            "blk_add_trace_bio_frontmerge",
            "NULL"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_queue",
          "args": [
            "blk_add_trace_bio_queue",
            "NULL"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_getrq",
          "args": [
            "blk_add_trace_getrq",
            "NULL"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_plug",
          "args": [
            "blk_add_trace_plug",
            "NULL"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_unplug",
          "args": [
            "blk_add_trace_unplug",
            "NULL"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_split",
          "args": [
            "blk_add_trace_split",
            "NULL"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_remap",
          "args": [
            "blk_add_trace_bio_remap",
            "NULL"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_rq_remap",
          "args": [
            "blk_add_trace_rq_remap",
            "NULL"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_unregister_tracepoints(void)\n{\n\tunregister_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tunregister_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tunregister_trace_block_split(blk_add_trace_split, NULL);\n\tunregister_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tunregister_trace_block_plug(blk_add_trace_plug, NULL);\n\tunregister_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tunregister_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tunregister_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tunregister_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tunregister_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tunregister_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tunregister_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tunregister_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tunregister_trace_block_rq_merge(blk_add_trace_rq_merge, NULL);\n\tunregister_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tunregister_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\n\ttracepoint_synchronize_unregister();\n}"
  },
  {
    "function_name": "blk_register_tracepoints",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1085-1121",
    "snippet": "static void blk_register_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_merge(blk_add_trace_rq_merge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_plug(blk_add_trace_plug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_split(blk_add_trace_split, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tWARN_ON(ret);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_rq_remap",
          "args": [
            "blk_add_trace_rq_remap",
            "NULL"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_remap",
          "args": [
            "blk_add_trace_bio_remap",
            "NULL"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_split",
          "args": [
            "blk_add_trace_split",
            "NULL"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_unplug",
          "args": [
            "blk_add_trace_unplug",
            "NULL"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_plug",
          "args": [
            "blk_add_trace_plug",
            "NULL"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_getrq",
          "args": [
            "blk_add_trace_getrq",
            "NULL"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_queue",
          "args": [
            "blk_add_trace_bio_queue",
            "NULL"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_frontmerge",
          "args": [
            "blk_add_trace_bio_frontmerge",
            "NULL"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_backmerge",
          "args": [
            "blk_add_trace_bio_backmerge",
            "NULL"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_complete",
          "args": [
            "blk_add_trace_bio_complete",
            "NULL"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_bounce",
          "args": [
            "blk_add_trace_bio_bounce",
            "NULL"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_rq_complete",
          "args": [
            "blk_add_trace_rq_complete",
            "NULL"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_rq_requeue",
          "args": [
            "blk_add_trace_rq_requeue",
            "NULL"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_rq_merge",
          "args": [
            "blk_add_trace_rq_merge",
            "NULL"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_rq_issue",
          "args": [
            "blk_add_trace_rq_issue",
            "NULL"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_rq_insert",
          "args": [
            "blk_add_trace_rq_insert",
            "NULL"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_register_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_merge(blk_add_trace_rq_merge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_plug(blk_add_trace_plug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_split(blk_add_trace_split, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tWARN_ON(ret);\n}"
  },
  {
    "function_name": "blk_add_driver_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1067-1082",
    "snippet": "void blk_add_driver_data(struct request *rq, void *data, size_t len)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), blk_rq_bytes(rq), 0, 0,\n\t\t\t\tBLK_TA_DRV_DATA, 0, len, data,\n\t\t\t\tblk_trace_request_get_cgid(rq));\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "blk_rq_trace_sector(rq)",
            "blk_rq_bytes(rq)",
            "0",
            "0",
            "BLK_TA_DRV_DATA",
            "0",
            "len",
            "data",
            "blk_trace_request_get_cgid(rq)"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "215-311",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "rq"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "794-801",
          "snippet": "static u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_rq_bytes",
          "args": [
            "rq"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_trace_sector",
          "args": [
            "rq"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bt"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "rq->q->blk_trace"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nvoid blk_add_driver_data(struct request *rq, void *data, size_t len)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), blk_rq_bytes(rq), 0, 0,\n\t\t\t\tBLK_TA_DRV_DATA, 0, len, data,\n\t\t\t\tblk_trace_request_get_cgid(rq));\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "blk_add_trace_rq_remap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "1034-1055",
    "snippet": "static void blk_add_trace_rq_remap(void *ignore, struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->q->disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(rq));\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "blk_rq_pos(rq)",
            "blk_rq_bytes(rq)",
            "rq_data_dir(rq)",
            "0",
            "BLK_TA_REMAP",
            "0",
            "sizeof(r)",
            "&r",
            "blk_trace_request_get_cgid(rq)"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "215-311",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "rq"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "794-801",
          "snippet": "static u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_data_dir",
          "args": [
            "rq"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_bytes",
          "args": [
            "rq"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_pos",
          "args": [
            "rq"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "disk_devt(rq->q->disk)"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_devt",
          "args": [
            "rq->q->disk"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dev"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bt"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "rq->q->blk_trace"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_remap(void *ignore, struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->q->disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(rq));\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "blk_add_trace_bio_remap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "997-1020",
    "snippet": "static void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "bio->bi_iter.bi_sector",
            "bio->bi_iter.bi_size",
            "bio_op(bio)",
            "bio->bi_opf",
            "BLK_TA_REMAP",
            "blk_status_to_errno(bio->bi_status)",
            "sizeof(r)",
            "&r",
            "blk_trace_bio_get_cgid(q, bio)"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "215-311",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_bio_get_cgid",
          "args": [
            "q",
            "bio"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_bio_get_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "788-791",
          "snippet": "static u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "bio->bi_status"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_op",
          "args": [
            "bio"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bio_dev(bio)"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_dev",
          "args": [
            "bio"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dev"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bt"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "q->blk_trace"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "blk_add_trace_split",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "968-986",
    "snippet": "static void blk_add_trace_split(void *ignore, struct bio *bio, unsigned int pdu)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (bt) {\n\t\t__be64 rpdu = cpu_to_be64(pdu);\n\n\t\t__blk_add_trace(bt, bio->bi_iter.bi_sector,\n\t\t\t\tbio->bi_iter.bi_size, bio_op(bio), bio->bi_opf,\n\t\t\t\tBLK_TA_SPLIT,\n\t\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\t\tsizeof(rpdu), &rpdu,\n\t\t\t\tblk_trace_bio_get_cgid(q, bio));\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "bio->bi_iter.bi_sector",
            "bio->bi_iter.bi_size",
            "bio_op(bio)",
            "bio->bi_opf",
            "BLK_TA_SPLIT",
            "blk_status_to_errno(bio->bi_status)",
            "sizeof(rpdu)",
            "&rpdu",
            "blk_trace_bio_get_cgid(q, bio)"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "215-311",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_bio_get_cgid",
          "args": [
            "q",
            "bio"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_bio_get_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "788-791",
          "snippet": "static u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "bio->bi_status"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_op",
          "args": [
            "bio"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "pdu"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "q->blk_trace"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_split(void *ignore, struct bio *bio, unsigned int pdu)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (bt) {\n\t\t__be64 rpdu = cpu_to_be64(pdu);\n\n\t\t__blk_add_trace(bt, bio->bi_iter.bi_sector,\n\t\t\t\tbio->bi_iter.bi_size, bio_op(bio), bio->bi_opf,\n\t\t\t\tBLK_TA_SPLIT,\n\t\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\t\tsizeof(rpdu), &rpdu,\n\t\t\t\tblk_trace_bio_get_cgid(q, bio));\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "blk_add_trace_unplug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "947-966",
    "snippet": "static void blk_add_trace_unplug(void *ignore, struct request_queue *q,\n\t\t\t\t    unsigned int depth, bool explicit)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (bt) {\n\t\t__be64 rpdu = cpu_to_be64(depth);\n\t\tu32 what;\n\n\t\tif (explicit)\n\t\t\twhat = BLK_TA_UNPLUG_IO;\n\t\telse\n\t\t\twhat = BLK_TA_UNPLUG_TIMER;\n\n\t\t__blk_add_trace(bt, 0, 0, 0, 0, what, 0, sizeof(rpdu), &rpdu, 0);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "0",
            "0",
            "0",
            "0",
            "what",
            "0",
            "sizeof(rpdu)",
            "&rpdu",
            "0"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "215-311",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "depth"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "q->blk_trace"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_unplug(void *ignore, struct request_queue *q,\n\t\t\t\t    unsigned int depth, bool explicit)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (bt) {\n\t\t__be64 rpdu = cpu_to_be64(depth);\n\t\tu32 what;\n\n\t\tif (explicit)\n\t\t\twhat = BLK_TA_UNPLUG_IO;\n\t\telse\n\t\t\twhat = BLK_TA_UNPLUG_TIMER;\n\n\t\t__blk_add_trace(bt, 0, 0, 0, 0, what, 0, sizeof(rpdu), &rpdu, 0);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "blk_add_trace_plug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "936-945",
    "snippet": "static void blk_add_trace_plug(void *ignore, struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (bt)\n\t\t__blk_add_trace(bt, 0, 0, 0, 0, BLK_TA_PLUG, 0, 0, NULL, 0);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "0",
            "0",
            "0",
            "0",
            "BLK_TA_PLUG",
            "0",
            "0",
            "NULL",
            "0"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "215-311",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "q->blk_trace"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_plug(void *ignore, struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (bt)\n\t\t__blk_add_trace(bt, 0, 0, 0, 0, BLK_TA_PLUG, 0, 0, NULL, 0);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "blk_add_trace_getrq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "931-934",
    "snippet": "static void blk_add_trace_getrq(void *ignore, struct bio *bio)\n{\n\tblk_add_trace_bio(bio->bi_bdev->bd_disk->queue, bio, BLK_TA_GETRQ, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "bio->bi_bdev->bd_disk->queue",
            "bio",
            "BLK_TA_GETRQ",
            "0"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "997-1020",
          "snippet": "static void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_getrq(void *ignore, struct bio *bio)\n{\n\tblk_add_trace_bio(bio->bi_bdev->bd_disk->queue, bio, BLK_TA_GETRQ, 0);\n}"
  },
  {
    "function_name": "blk_add_trace_bio_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "926-929",
    "snippet": "static void blk_add_trace_bio_queue(void *ignore, struct bio *bio)\n{\n\tblk_add_trace_bio(bio->bi_bdev->bd_disk->queue, bio, BLK_TA_QUEUE, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "bio->bi_bdev->bd_disk->queue",
            "bio",
            "BLK_TA_QUEUE",
            "0"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "997-1020",
          "snippet": "static void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_queue(void *ignore, struct bio *bio)\n{\n\tblk_add_trace_bio(bio->bi_bdev->bd_disk->queue, bio, BLK_TA_QUEUE, 0);\n}"
  },
  {
    "function_name": "blk_add_trace_bio_frontmerge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "920-924",
    "snippet": "static void blk_add_trace_bio_frontmerge(void *ignore, struct bio *bio)\n{\n\tblk_add_trace_bio(bio->bi_bdev->bd_disk->queue, bio, BLK_TA_FRONTMERGE,\n\t\t\t0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "bio->bi_bdev->bd_disk->queue",
            "bio",
            "BLK_TA_FRONTMERGE",
            "0"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "997-1020",
          "snippet": "static void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_frontmerge(void *ignore, struct bio *bio)\n{\n\tblk_add_trace_bio(bio->bi_bdev->bd_disk->queue, bio, BLK_TA_FRONTMERGE,\n\t\t\t0);\n}"
  },
  {
    "function_name": "blk_add_trace_bio_backmerge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "914-918",
    "snippet": "static void blk_add_trace_bio_backmerge(void *ignore, struct bio *bio)\n{\n\tblk_add_trace_bio(bio->bi_bdev->bd_disk->queue, bio, BLK_TA_BACKMERGE,\n\t\t\t0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "bio->bi_bdev->bd_disk->queue",
            "bio",
            "BLK_TA_BACKMERGE",
            "0"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "997-1020",
          "snippet": "static void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_backmerge(void *ignore, struct bio *bio)\n{\n\tblk_add_trace_bio(bio->bi_bdev->bd_disk->queue, bio, BLK_TA_BACKMERGE,\n\t\t\t0);\n}"
  },
  {
    "function_name": "blk_add_trace_bio_complete",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "907-912",
    "snippet": "static void blk_add_trace_bio_complete(void *ignore,\n\t\t\t\t       struct request_queue *q, struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_COMPLETE,\n\t\t\t  blk_status_to_errno(bio->bi_status));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "q",
            "bio",
            "BLK_TA_COMPLETE",
            "blk_status_to_errno(bio->bi_status)"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "997-1020",
          "snippet": "static void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "bio->bi_status"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_complete(void *ignore,\n\t\t\t\t       struct request_queue *q, struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_COMPLETE,\n\t\t\t  blk_status_to_errno(bio->bi_status));\n}"
  },
  {
    "function_name": "blk_add_trace_bio_bounce",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "902-905",
    "snippet": "static void blk_add_trace_bio_bounce(void *ignore, struct bio *bio)\n{\n\tblk_add_trace_bio(bio->bi_bdev->bd_disk->queue, bio, BLK_TA_BOUNCE, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "bio->bi_bdev->bd_disk->queue",
            "bio",
            "BLK_TA_BOUNCE",
            "0"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "997-1020",
          "snippet": "static void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_remap(void *ignore, struct bio *bio, dev_t dev,\n\t\t\t\t    sector_t from)\n{\n\tstruct request_queue *q = bio->bi_bdev->bd_disk->queue;\n\tstruct blk_trace *bt;\n\tstruct blk_io_trace_remap r;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP,\n\t\t\tblk_status_to_errno(bio->bi_status),\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_bounce(void *ignore, struct bio *bio)\n{\n\tblk_add_trace_bio(bio->bi_bdev->bd_disk->queue, bio, BLK_TA_BOUNCE, 0);\n}"
  },
  {
    "function_name": "blk_add_trace_bio",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "884-900",
    "snippet": "static void blk_add_trace_bio(struct request_queue *q, struct bio *bio,\n\t\t\t      u32 what, int error)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, what, error, 0, NULL,\n\t\t\tblk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "bio->bi_iter.bi_sector",
            "bio->bi_iter.bi_size",
            "bio_op(bio)",
            "bio->bi_opf",
            "what",
            "error",
            "0",
            "NULL",
            "blk_trace_bio_get_cgid(q, bio)"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "215-311",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_bio_get_cgid",
          "args": [
            "q",
            "bio"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_bio_get_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "788-791",
          "snippet": "static u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_op",
          "args": [
            "bio"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bt"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "q->blk_trace"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio(struct request_queue *q, struct bio *bio,\n\t\t\t      u32 what, int error)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, what, error, 0, NULL,\n\t\t\tblk_trace_bio_get_cgid(q, bio));\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "blk_add_trace_rq_complete",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "866-871",
    "snippet": "static void blk_add_trace_rq_complete(void *ignore, struct request *rq,\n\t\t\tblk_status_t error, unsigned int nr_bytes)\n{\n\tblk_add_trace_rq(rq, error, nr_bytes, BLK_TA_COMPLETE,\n\t\t\t blk_trace_request_get_cgid(rq));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_rq",
          "args": [
            "rq",
            "error",
            "nr_bytes",
            "BLK_TA_COMPLETE",
            "blk_trace_request_get_cgid(rq)"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "819-840",
          "snippet": "static void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "rq"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "794-801",
          "snippet": "static u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_complete(void *ignore, struct request *rq,\n\t\t\tblk_status_t error, unsigned int nr_bytes)\n{\n\tblk_add_trace_rq(rq, error, nr_bytes, BLK_TA_COMPLETE,\n\t\t\t blk_trace_request_get_cgid(rq));\n}"
  },
  {
    "function_name": "blk_add_trace_rq_requeue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "860-864",
    "snippet": "static void blk_add_trace_rq_requeue(void *ignore, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_REQUEUE,\n\t\t\t blk_trace_request_get_cgid(rq));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_rq",
          "args": [
            "rq",
            "0",
            "blk_rq_bytes(rq)",
            "BLK_TA_REQUEUE",
            "blk_trace_request_get_cgid(rq)"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "819-840",
          "snippet": "static void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "rq"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "794-801",
          "snippet": "static u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_rq_bytes",
          "args": [
            "rq"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_requeue(void *ignore, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_REQUEUE,\n\t\t\t blk_trace_request_get_cgid(rq));\n}"
  },
  {
    "function_name": "blk_add_trace_rq_merge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "854-858",
    "snippet": "static void blk_add_trace_rq_merge(void *ignore, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_BACKMERGE,\n\t\t\t blk_trace_request_get_cgid(rq));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_rq",
          "args": [
            "rq",
            "0",
            "blk_rq_bytes(rq)",
            "BLK_TA_BACKMERGE",
            "blk_trace_request_get_cgid(rq)"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "819-840",
          "snippet": "static void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "rq"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "794-801",
          "snippet": "static u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_rq_bytes",
          "args": [
            "rq"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_merge(void *ignore, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_BACKMERGE,\n\t\t\t blk_trace_request_get_cgid(rq));\n}"
  },
  {
    "function_name": "blk_add_trace_rq_issue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "848-852",
    "snippet": "static void blk_add_trace_rq_issue(void *ignore, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_ISSUE,\n\t\t\t blk_trace_request_get_cgid(rq));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_rq",
          "args": [
            "rq",
            "0",
            "blk_rq_bytes(rq)",
            "BLK_TA_ISSUE",
            "blk_trace_request_get_cgid(rq)"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "819-840",
          "snippet": "static void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "rq"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "794-801",
          "snippet": "static u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_rq_bytes",
          "args": [
            "rq"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_issue(void *ignore, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_ISSUE,\n\t\t\t blk_trace_request_get_cgid(rq));\n}"
  },
  {
    "function_name": "blk_add_trace_rq_insert",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "842-846",
    "snippet": "static void blk_add_trace_rq_insert(void *ignore, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_INSERT,\n\t\t\t blk_trace_request_get_cgid(rq));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_rq",
          "args": [
            "rq",
            "0",
            "blk_rq_bytes(rq)",
            "BLK_TA_INSERT",
            "blk_trace_request_get_cgid(rq)"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "819-840",
          "snippet": "static void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "rq"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "794-801",
          "snippet": "static u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_rq_bytes",
          "args": [
            "rq"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_insert(void *ignore, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_INSERT,\n\t\t\t blk_trace_request_get_cgid(rq));\n}"
  },
  {
    "function_name": "blk_add_trace_rq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "819-840",
    "snippet": "static void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "blk_rq_trace_sector(rq)",
            "nr_bytes",
            "req_op(rq)",
            "rq->cmd_flags",
            "what",
            "blk_status_to_errno(error)",
            "0",
            "NULL",
            "cgid"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "215-311",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "error"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req_op",
          "args": [
            "rq"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_trace_sector",
          "args": [
            "rq"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_FS"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_PC"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_is_passthrough",
          "args": [
            "rq"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bt"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "rq->q->blk_trace"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq(struct request *rq, blk_status_t error,\n\t\t\t     unsigned int nr_bytes, u32 what, u64 cgid)\n{\n\tstruct blk_trace *bt;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(rq->q->blk_trace);\n\tif (likely(!bt)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, blk_status_to_errno(error), 0,\n\t\t\tNULL, cgid);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "blk_trace_request_get_cgid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "794-801",
    "snippet": "static u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_trace_bio_get_cgid",
          "args": [
            "rq->q",
            "rq->bio"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_bio_get_cgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "788-791",
          "snippet": "static u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64\nblk_trace_request_get_cgid(struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn 0;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(rq->q, rq->bio);\n}"
  },
  {
    "function_name": "blk_trace_bio_get_cgid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "788-791",
    "snippet": "static u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_trace_bio_get_cgid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "774-786",
    "snippet": "static u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\tstruct blk_trace *bt;\n\n\t/* We don't use the 'bt' value here except as an optimization... */\n\tbt = rcu_dereference_protected(q->blk_trace, 1);\n\tif (!bt || !(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\treturn 0;\n\n\tif (!bio->bi_blkg)\n\t\treturn 0;\n\treturn cgroup_id(bio_blkcg(bio)->css.cgroup);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CGROUP\t0x2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_id",
          "args": [
            "bio_blkcg(bio)->css.cgroup"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_blkcg",
          "args": [
            "bio"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "q->blk_trace",
            "1"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGROUP\t0x2\n\nstatic u64 blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\tstruct blk_trace *bt;\n\n\t/* We don't use the 'bt' value here except as an optimization... */\n\tbt = rcu_dereference_protected(q->blk_trace, 1);\n\tif (!bt || !(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\treturn 0;\n\n\tif (!bio->bi_blkg)\n\t\treturn 0;\n\treturn cgroup_id(bio_blkcg(bio)->css.cgroup);\n}"
  },
  {
    "function_name": "blk_trace_shutdown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "761-771",
    "snippet": "void blk_trace_shutdown(struct request_queue *q)\n{\n\tmutex_lock(&q->debugfs_mutex);\n\tif (rcu_dereference_protected(q->blk_trace,\n\t\t\t\t      lockdep_is_held(&q->debugfs_mutex))) {\n\t\t__blk_trace_startstop(q, 0);\n\t\t__blk_trace_remove(q);\n\t}\n\n\tmutex_unlock(&q->debugfs_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_remove",
          "args": [
            "q"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "345-358",
          "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_startstop",
          "args": [
            "q",
            "0"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_startstop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "648-688",
          "snippet": "static int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt;\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt;\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "q->blk_trace",
            "lockdep_is_held(&q->debugfs_mutex)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nvoid blk_trace_shutdown(struct request_queue *q)\n{\n\tmutex_lock(&q->debugfs_mutex);\n\tif (rcu_dereference_protected(q->blk_trace,\n\t\t\t\t      lockdep_is_held(&q->debugfs_mutex))) {\n\t\t__blk_trace_startstop(q, 0);\n\t\t__blk_trace_remove(q);\n\t}\n\n\tmutex_unlock(&q->debugfs_mutex);\n}"
  },
  {
    "function_name": "blk_trace_ioctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "715-754",
    "snippet": "int blk_trace_ioctl(struct block_device *bdev, unsigned cmd, char __user *arg)\n{\n\tstruct request_queue *q;\n\tint ret, start = 0;\n\tchar b[BDEVNAME_SIZE];\n\n\tq = bdev_get_queue(bdev);\n\tif (!q)\n\t\treturn -ENXIO;\n\n\tmutex_lock(&q->debugfs_mutex);\n\n\tswitch (cmd) {\n\tcase BLKTRACESETUP:\n\t\tbdevname(bdev, b);\n\t\tret = __blk_trace_setup(q, b, bdev->bd_dev, bdev, arg);\n\t\tbreak;\n#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)\n\tcase BLKTRACESETUP32:\n\t\tbdevname(bdev, b);\n\t\tret = compat_blk_trace_setup(q, b, bdev->bd_dev, bdev, arg);\n\t\tbreak;\n#endif\n\tcase BLKTRACESTART:\n\t\tstart = 1;\n\t\tfallthrough;\n\tcase BLKTRACESTOP:\n\t\tret = __blk_trace_startstop(q, start);\n\t\tbreak;\n\tcase BLKTRACETEARDOWN:\n\t\tret = __blk_trace_remove(q);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&q->debugfs_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_remove",
          "args": [
            "q"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "345-358",
          "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_startstop",
          "args": [
            "q",
            "start"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_startstop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "648-688",
          "snippet": "static int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt;\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt;\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_blk_trace_setup",
          "args": [
            "q",
            "b",
            "bdev->bd_dev",
            "bdev",
            "arg"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "compat_blk_trace_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "615-645",
          "snippet": "static int compat_blk_trace_setup(struct request_queue *q, char *name,\n\t\t\t\t  dev_t dev, struct block_device *bdev,\n\t\t\t\t  char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tstruct compat_blk_user_trace_setup cbuts;\n\tint ret;\n\n\tif (copy_from_user(&cbuts, arg, sizeof(cbuts)))\n\t\treturn -EFAULT;\n\n\tbuts = (struct blk_user_trace_setup) {\n\t\t.act_mask = cbuts.act_mask,\n\t\t.buf_size = cbuts.buf_size,\n\t\t.buf_nr = cbuts.buf_nr,\n\t\t.start_lba = cbuts.start_lba,\n\t\t.end_lba = cbuts.end_lba,\n\t\t.pid = cbuts.pid,\n\t};\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts.name, ARRAY_SIZE(buts.name))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int compat_blk_trace_setup(struct request_queue *q, char *name,\n\t\t\t\t  dev_t dev, struct block_device *bdev,\n\t\t\t\t  char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tstruct compat_blk_user_trace_setup cbuts;\n\tint ret;\n\n\tif (copy_from_user(&cbuts, arg, sizeof(cbuts)))\n\t\treturn -EFAULT;\n\n\tbuts = (struct blk_user_trace_setup) {\n\t\t.act_mask = cbuts.act_mask,\n\t\t.buf_size = cbuts.buf_size,\n\t\t.buf_nr = cbuts.buf_nr,\n\t\t.start_lba = cbuts.start_lba,\n\t\t.end_lba = cbuts.end_lba,\n\t\t.pid = cbuts.pid,\n\t};\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts.name, ARRAY_SIZE(buts.name))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bdev",
            "b"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__blk_trace_setup",
          "args": [
            "q",
            "b",
            "bdev->bd_dev",
            "bdev",
            "arg"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "579-598",
          "snippet": "static int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bdev",
            "b"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nint blk_trace_ioctl(struct block_device *bdev, unsigned cmd, char __user *arg)\n{\n\tstruct request_queue *q;\n\tint ret, start = 0;\n\tchar b[BDEVNAME_SIZE];\n\n\tq = bdev_get_queue(bdev);\n\tif (!q)\n\t\treturn -ENXIO;\n\n\tmutex_lock(&q->debugfs_mutex);\n\n\tswitch (cmd) {\n\tcase BLKTRACESETUP:\n\t\tbdevname(bdev, b);\n\t\tret = __blk_trace_setup(q, b, bdev->bd_dev, bdev, arg);\n\t\tbreak;\n#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)\n\tcase BLKTRACESETUP32:\n\t\tbdevname(bdev, b);\n\t\tret = compat_blk_trace_setup(q, b, bdev->bd_dev, bdev, arg);\n\t\tbreak;\n#endif\n\tcase BLKTRACESTART:\n\t\tstart = 1;\n\t\tfallthrough;\n\tcase BLKTRACESTOP:\n\t\tret = __blk_trace_startstop(q, start);\n\t\tbreak;\n\tcase BLKTRACETEARDOWN:\n\t\tret = __blk_trace_remove(q);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&q->debugfs_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "blk_trace_startstop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "690-699",
    "snippet": "int blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\n\tmutex_lock(&q->debugfs_mutex);\n\tret = __blk_trace_startstop(q, start);\n\tmutex_unlock(&q->debugfs_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_startstop",
          "args": [
            "q",
            "start"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_startstop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "648-688",
          "snippet": "static int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt;\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt;\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nint blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\n\tmutex_lock(&q->debugfs_mutex);\n\tret = __blk_trace_startstop(q, start);\n\tmutex_unlock(&q->debugfs_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__blk_trace_startstop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "648-688",
    "snippet": "static int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt;\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_flush",
          "args": [
            "bt->rchan"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "relay_flush",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "788-806",
          "snippet": "void relay_flush(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0))) {\n\t\trelay_switch_subbuf(buf, 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_switch_subbuf(buf, 0);\n\tmutex_unlock(&relay_channels_mutex);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(relay_channels_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\n\nvoid relay_flush(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0))) {\n\t\trelay_switch_subbuf(buf, 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_switch_subbuf(buf, 0);\n\tmutex_unlock(&relay_channels_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&running_trace_lock"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bt->running_list"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&running_trace_lock"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_note_time",
          "args": [
            "bt"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "trace_note_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "132-146",
          "snippet": "static void trace_note_time(struct blk_trace *bt)\n{\n\tstruct timespec64 now;\n\tunsigned long flags;\n\tu32 words[2];\n\n\t/* need to check user space to see if this breaks in y2038 or y2106 */\n\tktime_get_real_ts64(&now);\n\twords[0] = (u32)now.tv_sec;\n\twords[1] = now.tv_nsec;\n\n\tlocal_irq_save(flags);\n\ttrace_note(bt, 0, BLK_TN_TIMESTAMP, words, sizeof(words), 0);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void trace_note_time(struct blk_trace *bt)\n{\n\tstruct timespec64 now;\n\tunsigned long flags;\n\tu32 words[2];\n\n\t/* need to check user space to see if this breaks in y2038 or y2106 */\n\tktime_get_real_ts64(&now);\n\twords[0] = (u32)now.tv_sec;\n\twords[1] = now.tv_nsec;\n\n\tlocal_irq_save(flags);\n\ttrace_note(bt, 0, BLK_TN_TIMESTAMP, words, sizeof(words), 0);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&bt->running_list",
            "&running_trace_list"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "q->blk_trace",
            "lockdep_is_held(&q->debugfs_mutex)"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt;\n\n\tbt = rcu_dereference_protected(q->blk_trace,\n\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\traw_spin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\traw_spin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "compat_blk_trace_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "615-645",
    "snippet": "static int compat_blk_trace_setup(struct request_queue *q, char *name,\n\t\t\t\t  dev_t dev, struct block_device *bdev,\n\t\t\t\t  char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tstruct compat_blk_user_trace_setup cbuts;\n\tint ret;\n\n\tif (copy_from_user(&cbuts, arg, sizeof(cbuts)))\n\t\treturn -EFAULT;\n\n\tbuts = (struct blk_user_trace_setup) {\n\t\t.act_mask = cbuts.act_mask,\n\t\t.buf_size = cbuts.buf_size,\n\t\t.buf_nr = cbuts.buf_nr,\n\t\t.start_lba = cbuts.start_lba,\n\t\t.end_lba = cbuts.end_lba,\n\t\t.pid = cbuts.pid,\n\t};\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts.name, ARRAY_SIZE(buts.name))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_trace_remove",
          "args": [
            "q"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "345-358",
          "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&buts.name",
            "ARRAY_SIZE(buts.name)"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buts.name"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_blk_trace_setup",
          "args": [
            "q",
            "name",
            "dev",
            "bdev",
            "&buts"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "do_blk_trace_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "472-577",
          "snippet": "static int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tlockdep_assert_held(&q->debugfs_mutex);\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\t/*\n\t * bdev can be NULL, as with scsi-generic, this is a helpful as\n\t * we can be.\n\t */\n\tif (rcu_dereference_protected(q->blk_trace,\n\t\t\t\t      lockdep_is_held(&q->debugfs_mutex))) {\n\t\tpr_warn(\"Concurrent blktraces are not allowed on %s\\n\",\n\t\t\tbuts->name);\n\t\treturn -EBUSY;\n\t}\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\t/*\n\t * When tracing the whole disk reuse the existing debugfs directory\n\t * created by the block layer on init. For partitions block devices,\n\t * and scsi-generic block devices we create a temporary new debugfs\n\t * directory that will be removed once the trace ends.\n\t */\n\tif (bdev && !bdev_is_partition(bdev))\n\t\tdir = q->debugfs_dir;\n\telse\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\n\t/*\n\t * As blktrace relies on debugfs for its interface the debugfs directory\n\t * is required, contrary to the usual mantra of not checking for debugfs\n\t * files or directories.\n\t */\n\tif (IS_ERR_OR_NULL(dir)) {\n\t\tpr_warn(\"debugfs_dir not present for %s so skipping\\n\",\n\t\t\tbuts->name);\n\t\tret = -ENOENT;\n\t\tgoto err;\n\t}\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tdebugfs_create_file(\"dropped\", 0444, dir, bt, &blk_dropped_fops);\n\tdebugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\trcu_assign_pointer(q->blk_trace, bt);\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tlockdep_assert_held(&q->debugfs_mutex);\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\t/*\n\t * bdev can be NULL, as with scsi-generic, this is a helpful as\n\t * we can be.\n\t */\n\tif (rcu_dereference_protected(q->blk_trace,\n\t\t\t\t      lockdep_is_held(&q->debugfs_mutex))) {\n\t\tpr_warn(\"Concurrent blktraces are not allowed on %s\\n\",\n\t\t\tbuts->name);\n\t\treturn -EBUSY;\n\t}\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\t/*\n\t * When tracing the whole disk reuse the existing debugfs directory\n\t * created by the block layer on init. For partitions block devices,\n\t * and scsi-generic block devices we create a temporary new debugfs\n\t * directory that will be removed once the trace ends.\n\t */\n\tif (bdev && !bdev_is_partition(bdev))\n\t\tdir = q->debugfs_dir;\n\telse\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\n\t/*\n\t * As blktrace relies on debugfs for its interface the debugfs directory\n\t * is required, contrary to the usual mantra of not checking for debugfs\n\t * files or directories.\n\t */\n\tif (IS_ERR_OR_NULL(dir)) {\n\t\tpr_warn(\"debugfs_dir not present for %s so skipping\\n\",\n\t\t\tbuts->name);\n\t\tret = -ENOENT;\n\t\tgoto err;\n\t}\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tdebugfs_create_file(\"dropped\", 0444, dir, bt, &blk_dropped_fops);\n\tdebugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\trcu_assign_pointer(q->blk_trace, bt);\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cbuts",
            "arg",
            "sizeof(cbuts)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int compat_blk_trace_setup(struct request_queue *q, char *name,\n\t\t\t\t  dev_t dev, struct block_device *bdev,\n\t\t\t\t  char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tstruct compat_blk_user_trace_setup cbuts;\n\tint ret;\n\n\tif (copy_from_user(&cbuts, arg, sizeof(cbuts)))\n\t\treturn -EFAULT;\n\n\tbuts = (struct blk_user_trace_setup) {\n\t\t.act_mask = cbuts.act_mask,\n\t\t.buf_size = cbuts.buf_size,\n\t\t.buf_nr = cbuts.buf_nr,\n\t\t.start_lba = cbuts.start_lba,\n\t\t.end_lba = cbuts.end_lba,\n\t\t.pid = cbuts.pid,\n\t};\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts.name, ARRAY_SIZE(buts.name))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_trace_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "600-611",
    "snippet": "int blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t    struct block_device *bdev,\n\t\t    char __user *arg)\n{\n\tint ret;\n\n\tmutex_lock(&q->debugfs_mutex);\n\tret = __blk_trace_setup(q, name, dev, bdev, arg);\n\tmutex_unlock(&q->debugfs_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_setup",
          "args": [
            "q",
            "name",
            "dev",
            "bdev",
            "arg"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "579-598",
          "snippet": "static int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nint blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t    struct block_device *bdev,\n\t\t    char __user *arg)\n{\n\tint ret;\n\n\tmutex_lock(&q->debugfs_mutex);\n\tret = __blk_trace_setup(q, name, dev, bdev, arg);\n\tmutex_unlock(&q->debugfs_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__blk_trace_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "579-598",
    "snippet": "static int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_trace_remove",
          "args": [
            "q"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "345-358",
          "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&buts",
            "sizeof(buts)"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_blk_trace_setup",
          "args": [
            "q",
            "name",
            "dev",
            "bdev",
            "&buts"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "do_blk_trace_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "472-577",
          "snippet": "static int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tlockdep_assert_held(&q->debugfs_mutex);\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\t/*\n\t * bdev can be NULL, as with scsi-generic, this is a helpful as\n\t * we can be.\n\t */\n\tif (rcu_dereference_protected(q->blk_trace,\n\t\t\t\t      lockdep_is_held(&q->debugfs_mutex))) {\n\t\tpr_warn(\"Concurrent blktraces are not allowed on %s\\n\",\n\t\t\tbuts->name);\n\t\treturn -EBUSY;\n\t}\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\t/*\n\t * When tracing the whole disk reuse the existing debugfs directory\n\t * created by the block layer on init. For partitions block devices,\n\t * and scsi-generic block devices we create a temporary new debugfs\n\t * directory that will be removed once the trace ends.\n\t */\n\tif (bdev && !bdev_is_partition(bdev))\n\t\tdir = q->debugfs_dir;\n\telse\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\n\t/*\n\t * As blktrace relies on debugfs for its interface the debugfs directory\n\t * is required, contrary to the usual mantra of not checking for debugfs\n\t * files or directories.\n\t */\n\tif (IS_ERR_OR_NULL(dir)) {\n\t\tpr_warn(\"debugfs_dir not present for %s so skipping\\n\",\n\t\t\tbuts->name);\n\t\tret = -ENOENT;\n\t\tgoto err;\n\t}\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tdebugfs_create_file(\"dropped\", 0444, dir, bt, &blk_dropped_fops);\n\tdebugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\trcu_assign_pointer(q->blk_trace, bt);\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tlockdep_assert_held(&q->debugfs_mutex);\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\t/*\n\t * bdev can be NULL, as with scsi-generic, this is a helpful as\n\t * we can be.\n\t */\n\tif (rcu_dereference_protected(q->blk_trace,\n\t\t\t\t      lockdep_is_held(&q->debugfs_mutex))) {\n\t\tpr_warn(\"Concurrent blktraces are not allowed on %s\\n\",\n\t\t\tbuts->name);\n\t\treturn -EBUSY;\n\t}\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\t/*\n\t * When tracing the whole disk reuse the existing debugfs directory\n\t * created by the block layer on init. For partitions block devices,\n\t * and scsi-generic block devices we create a temporary new debugfs\n\t * directory that will be removed once the trace ends.\n\t */\n\tif (bdev && !bdev_is_partition(bdev))\n\t\tdir = q->debugfs_dir;\n\telse\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\n\t/*\n\t * As blktrace relies on debugfs for its interface the debugfs directory\n\t * is required, contrary to the usual mantra of not checking for debugfs\n\t * files or directories.\n\t */\n\tif (IS_ERR_OR_NULL(dir)) {\n\t\tpr_warn(\"debugfs_dir not present for %s so skipping\\n\",\n\t\t\tbuts->name);\n\t\tret = -ENOENT;\n\t\tgoto err;\n\t}\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tdebugfs_create_file(\"dropped\", 0444, dir, bt, &blk_dropped_fops);\n\tdebugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\trcu_assign_pointer(q->blk_trace, bt);\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&buts",
            "arg",
            "sizeof(buts)"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_blk_trace_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "472-577",
    "snippet": "static int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tlockdep_assert_held(&q->debugfs_mutex);\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\t/*\n\t * bdev can be NULL, as with scsi-generic, this is a helpful as\n\t * we can be.\n\t */\n\tif (rcu_dereference_protected(q->blk_trace,\n\t\t\t\t      lockdep_is_held(&q->debugfs_mutex))) {\n\t\tpr_warn(\"Concurrent blktraces are not allowed on %s\\n\",\n\t\t\tbuts->name);\n\t\treturn -EBUSY;\n\t}\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\t/*\n\t * When tracing the whole disk reuse the existing debugfs directory\n\t * created by the block layer on init. For partitions block devices,\n\t * and scsi-generic block devices we create a temporary new debugfs\n\t * directory that will be removed once the trace ends.\n\t */\n\tif (bdev && !bdev_is_partition(bdev))\n\t\tdir = q->debugfs_dir;\n\telse\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\n\t/*\n\t * As blktrace relies on debugfs for its interface the debugfs directory\n\t * is required, contrary to the usual mantra of not checking for debugfs\n\t * files or directories.\n\t */\n\tif (IS_ERR_OR_NULL(dir)) {\n\t\tpr_warn(\"debugfs_dir not present for %s so skipping\\n\",\n\t\t\tbuts->name);\n\t\tret = -ENOENT;\n\t\tgoto err;\n\t}\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tdebugfs_create_file(\"dropped\", 0444, dir, bt, &blk_dropped_fops);\n\tdebugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\trcu_assign_pointer(q->blk_trace, bt);\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_trace_free",
          "args": [
            "bt"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "313-320",
          "snippet": "static void blk_trace_free(struct blk_trace *bt)\n{\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_free(struct blk_trace *bt)\n{\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_probe_ref",
          "args": [],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "get_probe_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "322-328",
          "snippet": "static void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "q->blk_trace",
            "bt"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_trace_setup_lba",
          "args": [
            "bt",
            "bdev"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_setup_lba",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "457-467",
          "snippet": "static void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tif (bdev) {\n\t\tbt->start_lba = bdev->bd_start_sect;\n\t\tbt->end_lba = bdev->bd_start_sect + bdev_nr_sectors(bdev);\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tif (bdev) {\n\t\tbt->start_lba = bdev->bd_start_sect;\n\t\tbt->end_lba = bdev->bd_start_sect + bdev_nr_sectors(bdev);\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_open",
          "args": [
            "\"trace\"",
            "dir",
            "buts->buf_size",
            "buts->buf_nr",
            "&blk_relay_callbacks",
            "bt"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "relay_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "477-539",
          "snippet": "struct rchan *relay_open(const char *base_filename,\n\t\t\t struct dentry *parent,\n\t\t\t size_t subbuf_size,\n\t\t\t size_t n_subbufs,\n\t\t\t const struct rchan_callbacks *cb,\n\t\t\t void *private_data)\n{\n\tunsigned int i;\n\tstruct rchan *chan;\n\tstruct rchan_buf *buf;\n\n\tif (!(subbuf_size && n_subbufs))\n\t\treturn NULL;\n\tif (subbuf_size > UINT_MAX / n_subbufs)\n\t\treturn NULL;\n\tif (!cb || !cb->create_buf_file || !cb->remove_buf_file)\n\t\treturn NULL;\n\n\tchan = kzalloc(sizeof(struct rchan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn NULL;\n\n\tchan->buf = alloc_percpu(struct rchan_buf *);\n\tif (!chan->buf) {\n\t\tkfree(chan);\n\t\treturn NULL;\n\t}\n\n\tchan->version = RELAYFS_CHANNEL_VERSION;\n\tchan->n_subbufs = n_subbufs;\n\tchan->subbuf_size = subbuf_size;\n\tchan->alloc_size = PAGE_ALIGN(subbuf_size * n_subbufs);\n\tchan->parent = parent;\n\tchan->private_data = private_data;\n\tif (base_filename) {\n\t\tchan->has_base_filename = 1;\n\t\tstrlcpy(chan->base_filename, base_filename, NAME_MAX);\n\t}\n\tchan->cb = cb;\n\tkref_init(&chan->kref);\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_online_cpu(i) {\n\t\tbuf = relay_open_buf(chan, i);\n\t\tif (!buf)\n\t\t\tgoto free_bufs;\n\t\t*per_cpu_ptr(chan->buf, i) = buf;\n\t}\n\tlist_add(&chan->list, &relay_channels);\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn chan;\n\nfree_bufs:\n\tfor_each_possible_cpu(i) {\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_close_buf(buf);\n\t}\n\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(relay_channels_mutex);",
            "static LIST_HEAD(relay_channels);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\nstatic LIST_HEAD(relay_channels);\n\nstruct rchan *relay_open(const char *base_filename,\n\t\t\t struct dentry *parent,\n\t\t\t size_t subbuf_size,\n\t\t\t size_t n_subbufs,\n\t\t\t const struct rchan_callbacks *cb,\n\t\t\t void *private_data)\n{\n\tunsigned int i;\n\tstruct rchan *chan;\n\tstruct rchan_buf *buf;\n\n\tif (!(subbuf_size && n_subbufs))\n\t\treturn NULL;\n\tif (subbuf_size > UINT_MAX / n_subbufs)\n\t\treturn NULL;\n\tif (!cb || !cb->create_buf_file || !cb->remove_buf_file)\n\t\treturn NULL;\n\n\tchan = kzalloc(sizeof(struct rchan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn NULL;\n\n\tchan->buf = alloc_percpu(struct rchan_buf *);\n\tif (!chan->buf) {\n\t\tkfree(chan);\n\t\treturn NULL;\n\t}\n\n\tchan->version = RELAYFS_CHANNEL_VERSION;\n\tchan->n_subbufs = n_subbufs;\n\tchan->subbuf_size = subbuf_size;\n\tchan->alloc_size = PAGE_ALIGN(subbuf_size * n_subbufs);\n\tchan->parent = parent;\n\tchan->private_data = private_data;\n\tif (base_filename) {\n\t\tchan->has_base_filename = 1;\n\t\tstrlcpy(chan->base_filename, base_filename, NAME_MAX);\n\t}\n\tchan->cb = cb;\n\tkref_init(&chan->kref);\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_online_cpu(i) {\n\t\tbuf = relay_open_buf(chan, i);\n\t\tif (!buf)\n\t\t\tgoto free_bufs;\n\t\t*per_cpu_ptr(chan->buf, i) = buf;\n\t}\n\tlist_add(&chan->list, &relay_channels);\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn chan;\n\nfree_bufs:\n\tfor_each_possible_cpu(i) {\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_close_buf(buf);\n\t}\n\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"msg\"",
            "0222",
            "dir",
            "bt",
            "&blk_msg_fops"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"dropped\"",
            "0444",
            "dir",
            "bt",
            "&blk_dropped_fops"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bt->running_list"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bt->dropped",
            "0"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"debugfs_dir not present for %s so skipping\\n\"",
            "buts->name"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "dir"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "buts->name",
            "blk_debugfs_root"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_is_partition",
          "args": [
            "bdev"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_percpu",
          "args": [
            "BLK_TN_MAX_MSG",
            "__alignof__(char)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "unsignedlong"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bt)",
            "GFP_KERNEL"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Concurrent blktraces are not allowed on %s\\n\"",
            "buts->name"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "q->blk_trace",
            "lockdep_is_held(&q->debugfs_mutex)"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strreplace",
          "args": [
            "buts->name",
            "'/'",
            "'_'"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buts->name",
            "name",
            "BLKTRACE_BDEV_SIZE"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tlockdep_assert_held(&q->debugfs_mutex);\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\t/*\n\t * bdev can be NULL, as with scsi-generic, this is a helpful as\n\t * we can be.\n\t */\n\tif (rcu_dereference_protected(q->blk_trace,\n\t\t\t\t      lockdep_is_held(&q->debugfs_mutex))) {\n\t\tpr_warn(\"Concurrent blktraces are not allowed on %s\\n\",\n\t\t\tbuts->name);\n\t\treturn -EBUSY;\n\t}\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\t/*\n\t * When tracing the whole disk reuse the existing debugfs directory\n\t * created by the block layer on init. For partitions block devices,\n\t * and scsi-generic block devices we create a temporary new debugfs\n\t * directory that will be removed once the trace ends.\n\t */\n\tif (bdev && !bdev_is_partition(bdev))\n\t\tdir = q->debugfs_dir;\n\telse\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\n\t/*\n\t * As blktrace relies on debugfs for its interface the debugfs directory\n\t * is required, contrary to the usual mantra of not checking for debugfs\n\t * files or directories.\n\t */\n\tif (IS_ERR_OR_NULL(dir)) {\n\t\tpr_warn(\"debugfs_dir not present for %s so skipping\\n\",\n\t\t\tbuts->name);\n\t\tret = -ENOENT;\n\t\tgoto err;\n\t}\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tdebugfs_create_file(\"dropped\", 0444, dir, bt, &blk_dropped_fops);\n\tdebugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\trcu_assign_pointer(q->blk_trace, bt);\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}"
  },
  {
    "function_name": "blk_trace_setup_lba",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "457-467",
    "snippet": "static void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tif (bdev) {\n\t\tbt->start_lba = bdev->bd_start_sect;\n\t\tbt->end_lba = bdev->bd_start_sect + bdev_nr_sectors(bdev);\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_nr_sectors",
          "args": [
            "bdev"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tif (bdev) {\n\t\tbt->start_lba = bdev->bd_start_sect;\n\t\tbt->end_lba = bdev->bd_start_sect + bdev_nr_sectors(bdev);\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}"
  },
  {
    "function_name": "blk_create_buf_file_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "441-449",
    "snippet": "static struct dentry *blk_create_buf_file_callback(const char *filename,\n\t\t\t\t\t\t   struct dentry *parent,\n\t\t\t\t\t\t   umode_t mode,\n\t\t\t\t\t\t   struct rchan_buf *buf,\n\t\t\t\t\t\t   int *is_global)\n{\n\treturn debugfs_create_file(filename, mode, parent, buf,\n\t\t\t\t\t&relay_file_operations);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "filename",
            "mode",
            "parent",
            "buf",
            "&relay_file_operations"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *blk_create_buf_file_callback(const char *filename,\n\t\t\t\t\t\t   struct dentry *parent,\n\t\t\t\t\t\t   umode_t mode,\n\t\t\t\t\t\t   struct rchan_buf *buf,\n\t\t\t\t\t\t   int *is_global)\n{\n\treturn debugfs_create_file(filename, mode, parent, buf,\n\t\t\t\t\t&relay_file_operations);\n}"
  },
  {
    "function_name": "blk_remove_buf_file_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "434-439",
    "snippet": "static int blk_remove_buf_file_callback(struct dentry *dentry)\n{\n\tdebugfs_remove(dentry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "dentry"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "164-170",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_remove_buf_file_callback(struct dentry *dentry)\n{\n\tdebugfs_remove(dentry);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_subbuf_start_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "421-432",
    "snippet": "static int blk_subbuf_start_callback(struct rchan_buf *buf, void *subbuf,\n\t\t\t\t     void *prev_subbuf, size_t prev_padding)\n{\n\tstruct blk_trace *bt;\n\n\tif (!relay_buf_full(buf))\n\t\treturn 1;\n\n\tbt = buf->chan->private_data;\n\tatomic_inc(&bt->dropped);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bt->dropped"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_buf_full",
          "args": [
            "buf"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "relay_buf_full",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "244-248",
          "snippet": "int relay_buf_full(struct rchan_buf *buf)\n{\n\tsize_t ready = buf->subbufs_produced - buf->subbufs_consumed;\n\treturn (ready >= buf->chan->n_subbufs) ? 1 : 0;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nint relay_buf_full(struct rchan_buf *buf)\n{\n\tsize_t ready = buf->subbufs_produced - buf->subbufs_consumed;\n\treturn (ready >= buf->chan->n_subbufs) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_subbuf_start_callback(struct rchan_buf *buf, void *subbuf,\n\t\t\t\t     void *prev_subbuf, size_t prev_padding)\n{\n\tstruct blk_trace *bt;\n\n\tif (!relay_buf_full(buf))\n\t\treturn 1;\n\n\tbt = buf->chan->private_data;\n\tatomic_inc(&bt->dropped);\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_msg_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "390-408",
    "snippet": "static ssize_t blk_msg_write(struct file *filp, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *msg;\n\tstruct blk_trace *bt;\n\n\tif (count >= BLK_TN_MAX_MSG)\n\t\treturn -EINVAL;\n\n\tmsg = memdup_user_nul(buffer, count);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tbt = filp->private_data;\n\t__trace_note_message(bt, NULL, \"%s\", msg);\n\tkfree(msg);\n\n\treturn count;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msg"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_note_message",
          "args": [
            "bt",
            "NULL",
            "\"%s\"",
            "msg"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_note_message",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "148-182",
          "snippet": "void __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n,\n\t\t   blkcg ? cgroup_id(blkcg->css.cgroup) : 1);\n#else\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n, 0);\n#endif\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TRACE_BLK_OPT_CGROUP\t0x2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGROUP\t0x2\n\nvoid __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n,\n\t\t   blkcg ? cgroup_id(blkcg->css.cgroup) : 1);\n#else\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n, 0);\n#endif\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "msg"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "msg"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buffer",
            "count"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t blk_msg_write(struct file *filp, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *msg;\n\tstruct blk_trace *bt;\n\n\tif (count >= BLK_TN_MAX_MSG)\n\t\treturn -EINVAL;\n\n\tmsg = memdup_user_nul(buffer, count);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tbt = filp->private_data;\n\t__trace_note_message(bt, NULL, \"%s\", msg);\n\tkfree(msg);\n\n\treturn count;\n}"
  },
  {
    "function_name": "blk_dropped_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "372-381",
    "snippet": "static ssize_t blk_dropped_read(struct file *filp, char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct blk_trace *bt = filp->private_data;\n\tchar buf[16];\n\n\tsnprintf(buf, sizeof(buf), \"%u\\n\", atomic_read(&bt->dropped));\n\n\treturn simple_read_from_buffer(buffer, count, ppos, buf, strlen(buf));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buffer",
            "count",
            "ppos",
            "buf",
            "strlen(buf)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%u\\n\"",
            "atomic_read(&bt->dropped)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bt->dropped"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t blk_dropped_read(struct file *filp, char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct blk_trace *bt = filp->private_data;\n\tchar buf[16];\n\n\tsnprintf(buf, sizeof(buf), \"%u\\n\", atomic_read(&bt->dropped));\n\n\treturn simple_read_from_buffer(buffer, count, ppos, buf, strlen(buf));\n}"
  },
  {
    "function_name": "blk_trace_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "360-369",
    "snippet": "int blk_trace_remove(struct request_queue *q)\n{\n\tint ret;\n\n\tmutex_lock(&q->debugfs_mutex);\n\tret = __blk_trace_remove(q);\n\tmutex_unlock(&q->debugfs_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_remove",
          "args": [
            "q"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "345-358",
          "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nint blk_trace_remove(struct request_queue *q)\n{\n\tint ret;\n\n\tmutex_lock(&q->debugfs_mutex);\n\tret = __blk_trace_remove(q);\n\tmutex_unlock(&q->debugfs_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__blk_trace_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "345-358",
    "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_trace_cleanup",
          "args": [
            "bt"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "338-343",
          "snippet": "static void blk_trace_cleanup(struct blk_trace *bt)\n{\n\tsynchronize_rcu();\n\tblk_trace_free(bt);\n\tput_probe_ref();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_cleanup(struct blk_trace *bt)\n{\n\tsynchronize_rcu();\n\tblk_trace_free(bt);\n\tput_probe_ref();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_replace_pointer",
          "args": [
            "q->blk_trace",
            "NULL",
            "lockdep_is_held(&q->debugfs_mutex)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&q->debugfs_mutex"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = rcu_replace_pointer(q->blk_trace, NULL,\n\t\t\t\t lockdep_is_held(&q->debugfs_mutex));\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_trace_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "338-343",
    "snippet": "static void blk_trace_cleanup(struct blk_trace *bt)\n{\n\tsynchronize_rcu();\n\tblk_trace_free(bt);\n\tput_probe_ref();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_probe_ref",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "put_probe_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "330-336",
          "snippet": "static void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_free",
          "args": [
            "bt"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "313-320",
          "snippet": "static void blk_trace_free(struct blk_trace *bt)\n{\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_free(struct blk_trace *bt)\n{\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_cleanup(struct blk_trace *bt)\n{\n\tsynchronize_rcu();\n\tblk_trace_free(bt);\n\tput_probe_ref();\n}"
  },
  {
    "function_name": "put_probe_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "330-336",
    "snippet": "static void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&blk_probe_mutex"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_unregister_tracepoints",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "blk_unregister_tracepoints",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1123-1143",
          "snippet": "static void blk_unregister_tracepoints(void)\n{\n\tunregister_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tunregister_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tunregister_trace_block_split(blk_add_trace_split, NULL);\n\tunregister_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tunregister_trace_block_plug(blk_add_trace_plug, NULL);\n\tunregister_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tunregister_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tunregister_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tunregister_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tunregister_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tunregister_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tunregister_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tunregister_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tunregister_trace_block_rq_merge(blk_add_trace_rq_merge, NULL);\n\tunregister_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tunregister_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\n\ttracepoint_synchronize_unregister();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_unregister_tracepoints(void)\n{\n\tunregister_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tunregister_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tunregister_trace_block_split(blk_add_trace_split, NULL);\n\tunregister_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tunregister_trace_block_plug(blk_add_trace_plug, NULL);\n\tunregister_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tunregister_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tunregister_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tunregister_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tunregister_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tunregister_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tunregister_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tunregister_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tunregister_trace_block_rq_merge(blk_add_trace_rq_merge, NULL);\n\tunregister_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tunregister_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\n\ttracepoint_synchronize_unregister();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&blk_probe_mutex"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
  },
  {
    "function_name": "get_probe_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "322-328",
    "snippet": "static void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&blk_probe_mutex"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_register_tracepoints",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "blk_register_tracepoints",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "1085-1121",
          "snippet": "static void blk_register_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_merge(blk_add_trace_rq_merge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_plug(blk_add_trace_plug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_split(blk_add_trace_split, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tWARN_ON(ret);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_register_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_merge(blk_add_trace_rq_merge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_plug(blk_add_trace_plug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_split(blk_add_trace_split, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tWARN_ON(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&blk_probe_mutex"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
  },
  {
    "function_name": "blk_trace_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "313-320",
    "snippet": "static void blk_trace_free(struct blk_trace *bt)\n{\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bt"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "bt->msg_data"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "bt->dir"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "164-170",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_close",
          "args": [
            "bt->rchan"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "relay_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "755-779",
          "snippet": "void relay_close(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tmutex_lock(&relay_channels_mutex);\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0)))\n\t\trelay_close_buf(buf);\n\telse\n\t\tfor_each_possible_cpu(i)\n\t\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\t\trelay_close_buf(buf);\n\n\tif (chan->last_toobig)\n\t\tprintk(KERN_WARNING \"relay: one or more items not logged \"\n\t\t       \"[item size (%zd) > sub-buffer size (%zd)]\\n\",\n\t\t       chan->last_toobig, chan->subbuf_size);\n\n\tlist_del(&chan->list);\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(relay_channels_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\n\nvoid relay_close(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tmutex_lock(&relay_channels_mutex);\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0)))\n\t\trelay_close_buf(buf);\n\telse\n\t\tfor_each_possible_cpu(i)\n\t\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\t\trelay_close_buf(buf);\n\n\tif (chan->last_toobig)\n\t\tprintk(KERN_WARNING \"relay: one or more items not logged \"\n\t\t       \"[item size (%zd) > sub-buffer size (%zd)]\\n\",\n\t\t       chan->last_toobig, chan->subbuf_size);\n\n\tlist_del(&chan->list);\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_free(struct blk_trace *bt)\n{\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}"
  },
  {
    "function_name": "__blk_add_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "215-311",
    "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "blk_tr",
            "buffer",
            "event",
            "trace_ctx"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1322-1328",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)t + sizeof(*t) + cgid_len",
            "pdu_data",
            "pdu_len"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_get()"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "bt->sequence",
            "cpu"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_reserve",
          "args": [
            "bt->rchan",
            "sizeof(*t) + pdu_len + cgid_len"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_note_tsk",
          "args": [
            "tsk"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "trace_note_tsk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "118-130",
          "snippet": "static void trace_note_tsk(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\tstruct blk_trace *bt;\n\n\ttsk->btrace_seq = blktrace_seq;\n\traw_spin_lock_irqsave(&running_trace_lock, flags);\n\tlist_for_each_entry(bt, &running_trace_list, running_list) {\n\t\ttrace_note(bt, tsk->pid, BLK_TN_PROCESS, tsk->comm,\n\t\t\t   sizeof(tsk->comm), 0);\n\t}\n\traw_spin_unlock_irqrestore(&running_trace_lock, flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void trace_note_tsk(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\tstruct blk_trace *bt;\n\n\ttsk->btrace_seq = blktrace_seq;\n\traw_spin_lock_irqsave(&running_trace_lock, flags);\n\tlist_for_each_entry(bt, &running_trace_list, running_list) {\n\t\ttrace_note(bt, tsk->pid, BLK_TN_PROCESS, tsk->comm,\n\t\t\t   sizeof(tsk->comm), 0);\n\t}\n\traw_spin_unlock_irqrestore(&running_trace_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk->btrace_seq != blktrace_seq"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_BLK",
            "sizeof(*t) + pdu_len + cgid_len",
            "trace_ctx"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "0"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_record_cmdline",
          "args": [
            "current"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_record_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2562-2565",
          "snippet": "void tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "act_log_check",
          "args": [
            "bt",
            "what",
            "sector",
            "pid"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "act_log_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "185-196",
          "snippet": "static int act_log_check(struct blk_trace *bt, u32 what, sector_t sector,\n\t\t\t pid_t pid)\n{\n\tif (((bt->act_mask << BLK_TC_SHIFT) & what) == 0)\n\t\treturn 1;\n\tif (sector && (sector < bt->start_lba || sector > bt->end_lba))\n\t\treturn 1;\n\tif (bt->pid && pid != bt->pid)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int act_log_check(struct blk_trace *bt, u32 what, sector_t sector,\n\t\t\t pid_t pid)\n{\n\tif (((bt->act_mask << BLK_TC_SHIFT) & what) == 0)\n\t\treturn 1;\n\tif (sector && (sector < bt->start_lba || sector > bt->end_lba))\n\t\treturn 1;\n\tif (bt->pid && pid != bt->pid)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_FLUSH"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_DISCARD"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MASK_TC_BIT",
          "args": [
            "op_flags",
            "FUA"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MASK_TC_BIT",
          "args": [
            "op_flags",
            "PREFLUSH"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MASK_TC_BIT",
          "args": [
            "op_flags",
            "META"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MASK_TC_BIT",
          "args": [
            "op_flags",
            "RAHEAD"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MASK_TC_BIT",
          "args": [
            "op_flags",
            "SYNC"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_write",
          "args": [
            "op"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bt->trace_state != Blktrace_running && !blk_tracer"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, u64 cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tunsigned int trace_ctx = 0;\n\tpid_t pid;\n\tint cpu;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "act_log_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "185-196",
    "snippet": "static int act_log_check(struct blk_trace *bt, u32 what, sector_t sector,\n\t\t\t pid_t pid)\n{\n\tif (((bt->act_mask << BLK_TC_SHIFT) & what) == 0)\n\t\treturn 1;\n\tif (sector && (sector < bt->start_lba || sector > bt->end_lba))\n\t\treturn 1;\n\tif (bt->pid && pid != bt->pid)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int act_log_check(struct blk_trace *bt, u32 what, sector_t sector,\n\t\t\t pid_t pid)\n{\n\tif (((bt->act_mask << BLK_TC_SHIFT) & what) == 0)\n\t\treturn 1;\n\tif (sector && (sector < bt->start_lba || sector > bt->end_lba))\n\t\treturn 1;\n\tif (bt->pid && pid != bt->pid)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__trace_note_message",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "148-182",
    "snippet": "void __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n,\n\t\t   blkcg ? cgroup_id(blkcg->css.cgroup) : 1);\n#else\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n, 0);\n#endif\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CGROUP\t0x2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_note",
          "args": [
            "bt",
            "current->pid",
            "BLK_TN_MESSAGE",
            "buf",
            "n",
            "0"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_note_message",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "148-182",
          "snippet": "void __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n,\n\t\t   blkcg ? cgroup_id(blkcg->css.cgroup) : 1);\n#else\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n, 0);\n#endif\n\tlocal_irq_restore(flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_id",
          "args": [
            "blkcg->css.cgroup"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vscnprintf",
          "args": [
            "buf",
            "BLK_TN_MAX_MSG",
            "fmt",
            "args"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "bt->msg_data"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGROUP\t0x2\n\nvoid __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n,\n\t\t   blkcg ? cgroup_id(blkcg->css.cgroup) : 1);\n#else\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n, 0);\n#endif\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "trace_note_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "132-146",
    "snippet": "static void trace_note_time(struct blk_trace *bt)\n{\n\tstruct timespec64 now;\n\tunsigned long flags;\n\tu32 words[2];\n\n\t/* need to check user space to see if this breaks in y2038 or y2106 */\n\tktime_get_real_ts64(&now);\n\twords[0] = (u32)now.tv_sec;\n\twords[1] = now.tv_nsec;\n\n\tlocal_irq_save(flags);\n\ttrace_note(bt, 0, BLK_TN_TIMESTAMP, words, sizeof(words), 0);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_note",
          "args": [
            "bt",
            "0",
            "BLK_TN_TIMESTAMP",
            "words",
            "sizeof(words)",
            "0"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_note_message",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "148-182",
          "snippet": "void __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n,\n\t\t   blkcg ? cgroup_id(blkcg->css.cgroup) : 1);\n#else\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n, 0);\n#endif\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TRACE_BLK_OPT_CGROUP\t0x2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGROUP\t0x2\n\nvoid __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n,\n\t\t   blkcg ? cgroup_id(blkcg->css.cgroup) : 1);\n#else\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n, 0);\n#endif\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_ts64",
          "args": [
            "&now"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "796-814",
          "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void trace_note_time(struct blk_trace *bt)\n{\n\tstruct timespec64 now;\n\tunsigned long flags;\n\tu32 words[2];\n\n\t/* need to check user space to see if this breaks in y2038 or y2106 */\n\tktime_get_real_ts64(&now);\n\twords[0] = (u32)now.tv_sec;\n\twords[1] = now.tv_nsec;\n\n\tlocal_irq_save(flags);\n\ttrace_note(bt, 0, BLK_TN_TIMESTAMP, words, sizeof(words), 0);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "trace_note_tsk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "118-130",
    "snippet": "static void trace_note_tsk(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\tstruct blk_trace *bt;\n\n\ttsk->btrace_seq = blktrace_seq;\n\traw_spin_lock_irqsave(&running_trace_lock, flags);\n\tlist_for_each_entry(bt, &running_trace_list, running_list) {\n\t\ttrace_note(bt, tsk->pid, BLK_TN_PROCESS, tsk->comm,\n\t\t\t   sizeof(tsk->comm), 0);\n\t}\n\traw_spin_unlock_irqrestore(&running_trace_lock, flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&running_trace_lock",
            "flags"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_note",
          "args": [
            "bt",
            "tsk->pid",
            "BLK_TN_PROCESS",
            "tsk->comm",
            "sizeof(tsk->comm)",
            "0"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_note_message",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
          "lines": "148-182",
          "snippet": "void __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n,\n\t\t   blkcg ? cgroup_id(blkcg->css.cgroup) : 1);\n#else\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n, 0);\n#endif\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TRACE_BLK_OPT_CGROUP\t0x2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGROUP\t0x2\n\nvoid __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n,\n\t\t   blkcg ? cgroup_id(blkcg->css.cgroup) : 1);\n#else\n\ttrace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n, 0);\n#endif\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bt",
            "&running_trace_list",
            "running_list"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&running_trace_lock",
            "flags"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void trace_note_tsk(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\tstruct blk_trace *bt;\n\n\ttsk->btrace_seq = blktrace_seq;\n\traw_spin_lock_irqsave(&running_trace_lock, flags);\n\tlist_for_each_entry(bt, &running_trace_list, running_list) {\n\t\ttrace_note(bt, tsk->pid, BLK_TN_PROCESS, tsk->comm,\n\t\t\t   sizeof(tsk->comm), 0);\n\t}\n\traw_spin_unlock_irqrestore(&running_trace_lock, flags);\n}"
  },
  {
    "function_name": "trace_note",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/blktrace.c",
    "lines": "69-112",
    "snippet": "static void trace_note(struct blk_trace *bt, pid_t pid, int action,\n\t\t       const void *data, size_t len, u64 cgid)\n{\n\tstruct blk_io_trace *t;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tunsigned int trace_ctx = 0;\n\tint cpu = smp_processor_id();\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (blk_tracer) {\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (!bt->rchan)\n\t\treturn;\n\n\tt = relay_reserve(bt->rchan, sizeof(*t) + len + cgid_len);\n\tif (t) {\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\tt->device = bt->dev;\n\t\tt->action = action | (cgid ? __BLK_TN_CGROUP : 0);\n\t\tt->pid = pid;\n\t\tt->cpu = cpu;\n\t\tt->pdu_len = len + cgid_len;\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tmemcpy((void *) t + sizeof(*t) + cgid_len, data, len);\n\n\t\tif (blk_tracer)\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "blk_tr",
            "buffer",
            "event",
            "trace_ctx"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1322-1328",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *) t + sizeof(*t) + cgid_len",
            "data",
            "len"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_get()"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_reserve",
          "args": [
            "bt->rchan",
            "sizeof(*t) + len + cgid_len"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_BLK",
            "sizeof(*t) + len + cgid_len",
            "trace_ctx"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "0"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void trace_note(struct blk_trace *bt, pid_t pid, int action,\n\t\t       const void *data, size_t len, u64 cgid)\n{\n\tstruct blk_io_trace *t;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct trace_buffer *buffer = NULL;\n\tunsigned int trace_ctx = 0;\n\tint cpu = smp_processor_id();\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(cgid) : 0;\n\n\tif (blk_tracer) {\n\t\tbuffer = blk_tr->array_buffer.buffer;\n\t\ttrace_ctx = tracing_gen_ctx_flags(0);\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + len + cgid_len,\n\t\t\t\t\t\t  trace_ctx);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (!bt->rchan)\n\t\treturn;\n\n\tt = relay_reserve(bt->rchan, sizeof(*t) + len + cgid_len);\n\tif (t) {\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\tt->device = bt->dev;\n\t\tt->action = action | (cgid ? __BLK_TN_CGROUP : 0);\n\t\tt->pid = pid;\n\t\tt->cpu = cpu;\n\t\tt->pdu_len = len + cgid_len;\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), &cgid, cgid_len);\n\t\tmemcpy((void *) t + sizeof(*t) + cgid_len, data, len);\n\n\t\tif (blk_tracer)\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, trace_ctx);\n\t}\n}"
  }
]