[
  {
    "function_name": "cgroup_freeze",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
    "lines": "260-323",
    "snippet": "void cgroup_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *dsct;\n\tbool applied = false;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Nothing changed? Just exit.\n\t */\n\tif (cgrp->freezer.freeze == freeze)\n\t\treturn;\n\n\tcgrp->freezer.freeze = freeze;\n\n\t/*\n\t * Propagate changes downwards the cgroup tree.\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tdsct = css->cgroup;\n\n\t\tif (cgroup_is_dead(dsct))\n\t\t\tcontinue;\n\n\t\tif (freeze) {\n\t\t\tdsct->freezer.e_freeze++;\n\t\t\t/*\n\t\t\t * Already frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 1)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tdsct->freezer.e_freeze--;\n\t\t\t/*\n\t\t\t * Still frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 0)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(dsct->freezer.e_freeze < 0);\n\t\t}\n\n\t\t/*\n\t\t * Do change actual state: freeze or unfreeze.\n\t\t */\n\t\tcgroup_do_freeze(dsct, freeze);\n\t\tapplied = true;\n\t}\n\n\t/*\n\t * Even if the actual state hasn't changed, let's notify a user.\n\t * The state can be enforced by an ancestor cgroup: the cgroup\n\t * can already be in the desired state or it can be locked in the\n\t * opposite state, so that the transition will never happen.\n\t * In both cases it's better to notify a user, that there is\n\t * nothing to wait for.\n\t */\n\tif (!applied) {\n\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp,\n\t\t\t\t  test_bit(CGRP_FROZEN, &cgrp->flags));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\t}\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&cgrp->events_file"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "notify_frozen",
            "cgrp",
            "test_bit(CGRP_FROZEN, &cgrp->flags)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_do_freeze",
          "args": [
            "dsct",
            "freeze"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_do_freeze",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "177-216",
          "snippet": "static void cgroup_do_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tif (freeze)\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\telse\n\t\tclear_bit(CGRP_FREEZE, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (freeze)\n\t\tTRACE_CGROUP_PATH(freeze, cgrp);\n\telse\n\t\tTRACE_CGROUP_PATH(unfreeze, cgrp);\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/*\n\t\t * Ignore kernel threads here. Freezing cgroups containing\n\t\t * kthreads isn't supported.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tcgroup_freeze_task(task, freeze);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * Cgroup state should be revisited here to cover empty leaf cgroups\n\t * and cgroups which descendants are already in the desired state.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tif (cgrp->nr_descendants == cgrp->freezer.nr_frozen_descendants)\n\t\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_do_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tif (freeze)\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\telse\n\t\tclear_bit(CGRP_FREEZE, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (freeze)\n\t\tTRACE_CGROUP_PATH(freeze, cgrp);\n\telse\n\t\tTRACE_CGROUP_PATH(unfreeze, cgrp);\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/*\n\t\t * Ignore kernel threads here. Freezing cgroups containing\n\t\t * kthreads isn't supported.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tcgroup_freeze_task(task, freeze);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * Cgroup state should be revisited here to cover empty leaf cgroups\n\t * and cgroups which descendants are already in the desired state.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tif (cgrp->nr_descendants == cgrp->freezer.nr_frozen_descendants)\n\t\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dsct->freezer.e_freeze < 0"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_dead",
          "args": [
            "dsct"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_dead",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "187-190",
          "snippet": "static inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "&cgrp->self"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *dsct;\n\tbool applied = false;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Nothing changed? Just exit.\n\t */\n\tif (cgrp->freezer.freeze == freeze)\n\t\treturn;\n\n\tcgrp->freezer.freeze = freeze;\n\n\t/*\n\t * Propagate changes downwards the cgroup tree.\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tdsct = css->cgroup;\n\n\t\tif (cgroup_is_dead(dsct))\n\t\t\tcontinue;\n\n\t\tif (freeze) {\n\t\t\tdsct->freezer.e_freeze++;\n\t\t\t/*\n\t\t\t * Already frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 1)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tdsct->freezer.e_freeze--;\n\t\t\t/*\n\t\t\t * Still frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 0)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(dsct->freezer.e_freeze < 0);\n\t\t}\n\n\t\t/*\n\t\t * Do change actual state: freeze or unfreeze.\n\t\t */\n\t\tcgroup_do_freeze(dsct, freeze);\n\t\tapplied = true;\n\t}\n\n\t/*\n\t * Even if the actual state hasn't changed, let's notify a user.\n\t * The state can be enforced by an ancestor cgroup: the cgroup\n\t * can already be in the desired state or it can be locked in the\n\t * opposite state, so that the transition will never happen.\n\t * In both cases it's better to notify a user, that there is\n\t * nothing to wait for.\n\t */\n\tif (!applied) {\n\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp,\n\t\t\t\t  test_bit(CGRP_FROZEN, &cgrp->flags));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\t}\n}"
  },
  {
    "function_name": "cgroup_freezer_migrate_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
    "lines": "222-258",
    "snippet": "void cgroup_freezer_migrate_task(struct task_struct *task,\n\t\t\t\t struct cgroup *src, struct cgroup *dst)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * Kernel threads are not supposed to be frozen at all.\n\t */\n\tif (task->flags & PF_KTHREAD)\n\t\treturn;\n\n\t/*\n\t * It's not necessary to do changes if both of the src and dst cgroups\n\t * are not freezing and task is not frozen.\n\t */\n\tif (!test_bit(CGRP_FREEZE, &src->flags) &&\n\t    !test_bit(CGRP_FREEZE, &dst->flags) &&\n\t    !task->frozen)\n\t\treturn;\n\n\t/*\n\t * Adjust counters of freezing and frozen tasks.\n\t * Note, that if the task is frozen, but the destination cgroup is not\n\t * frozen, we bump both counters to keep them balanced.\n\t */\n\tif (task->frozen) {\n\t\tcgroup_inc_frozen_cnt(dst);\n\t\tcgroup_dec_frozen_cnt(src);\n\t}\n\tcgroup_update_frozen(dst);\n\tcgroup_update_frozen(src);\n\n\t/*\n\t * Force the task to the desired state.\n\t */\n\tcgroup_freeze_task(task, test_bit(CGRP_FREEZE, &dst->flags));\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_freeze_task",
          "args": [
            "task",
            "test_bit(CGRP_FREEZE, &dst->flags)"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_freeze_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "155-172",
          "snippet": "static void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FREEZE",
            "&dst->flags"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_update_frozen",
          "args": [
            "src"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "52-84",
          "snippet": "void cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_dec_frozen_cnt",
          "args": [
            "src"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_dec_frozen_cnt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "97-101",
          "snippet": "static void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_inc_frozen_cnt",
          "args": [
            "dst"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_inc_frozen_cnt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "89-92",
          "snippet": "static void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_freezer_migrate_task(struct task_struct *task,\n\t\t\t\t struct cgroup *src, struct cgroup *dst)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * Kernel threads are not supposed to be frozen at all.\n\t */\n\tif (task->flags & PF_KTHREAD)\n\t\treturn;\n\n\t/*\n\t * It's not necessary to do changes if both of the src and dst cgroups\n\t * are not freezing and task is not frozen.\n\t */\n\tif (!test_bit(CGRP_FREEZE, &src->flags) &&\n\t    !test_bit(CGRP_FREEZE, &dst->flags) &&\n\t    !task->frozen)\n\t\treturn;\n\n\t/*\n\t * Adjust counters of freezing and frozen tasks.\n\t * Note, that if the task is frozen, but the destination cgroup is not\n\t * frozen, we bump both counters to keep them balanced.\n\t */\n\tif (task->frozen) {\n\t\tcgroup_inc_frozen_cnt(dst);\n\t\tcgroup_dec_frozen_cnt(src);\n\t}\n\tcgroup_update_frozen(dst);\n\tcgroup_update_frozen(src);\n\n\t/*\n\t * Force the task to the desired state.\n\t */\n\tcgroup_freeze_task(task, test_bit(CGRP_FREEZE, &dst->flags));\n}"
  },
  {
    "function_name": "cgroup_do_freeze",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
    "lines": "177-216",
    "snippet": "static void cgroup_do_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tif (freeze)\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\telse\n\t\tclear_bit(CGRP_FREEZE, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (freeze)\n\t\tTRACE_CGROUP_PATH(freeze, cgrp);\n\telse\n\t\tTRACE_CGROUP_PATH(unfreeze, cgrp);\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/*\n\t\t * Ignore kernel threads here. Freezing cgroups containing\n\t\t * kthreads isn't supported.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tcgroup_freeze_task(task, freeze);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * Cgroup state should be revisited here to cover empty leaf cgroups\n\t * and cgroups which descendants are already in the desired state.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tif (cgrp->nr_descendants == cgrp->freezer.nr_frozen_descendants)\n\t\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_update_frozen",
          "args": [
            "cgrp"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "52-84",
          "snippet": "void cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&it"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_freeze_task",
          "args": [
            "task",
            "freeze"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_freeze_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "155-172",
          "snippet": "static void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&it"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4730-4753",
          "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&cgrp->self",
            "0",
            "&it"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4700-4720",
          "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "unfreeze",
            "cgrp"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "freeze",
            "cgrp"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CGRP_FREEZE",
            "&cgrp->flags"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_FREEZE",
            "&cgrp->flags"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_do_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tif (freeze)\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\telse\n\t\tclear_bit(CGRP_FREEZE, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (freeze)\n\t\tTRACE_CGROUP_PATH(freeze, cgrp);\n\telse\n\t\tTRACE_CGROUP_PATH(unfreeze, cgrp);\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/*\n\t\t * Ignore kernel threads here. Freezing cgroups containing\n\t\t * kthreads isn't supported.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tcgroup_freeze_task(task, freeze);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * Cgroup state should be revisited here to cover empty leaf cgroups\n\t * and cgroups which descendants are already in the desired state.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tif (cgrp->nr_descendants == cgrp->freezer.nr_frozen_descendants)\n\t\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}"
  },
  {
    "function_name": "cgroup_freeze_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
    "lines": "155-172",
    "snippet": "static void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "task"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "task",
            "false"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "763-775",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1384-1414",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}"
  },
  {
    "function_name": "cgroup_leave_frozen",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
    "lines": "131-149",
    "snippet": "void cgroup_leave_frozen(bool always_leave)\n{\n\tstruct cgroup *cgrp;\n\n\tspin_lock_irq(&css_set_lock);\n\tcgrp = task_dfl_cgroup(current);\n\tif (always_leave || !test_bit(CGRP_FREEZE, &cgrp->flags)) {\n\t\tcgroup_dec_frozen_cnt(cgrp);\n\t\tcgroup_update_frozen(cgrp);\n\t\tWARN_ON_ONCE(!current->frozen);\n\t\tcurrent->frozen = false;\n\t} else if (!(current->jobctl & JOBCTL_TRAP_FREEZE)) {\n\t\tspin_lock(&current->sighand->siglock);\n\t\tcurrent->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\tspin_unlock(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_SIGPENDING"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!current->frozen"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_update_frozen",
          "args": [
            "cgrp"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "52-84",
          "snippet": "void cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_dec_frozen_cnt",
          "args": [
            "cgrp"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_dec_frozen_cnt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "97-101",
          "snippet": "static void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FREEZE",
            "&cgrp->flags"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_dfl_cgroup",
          "args": [
            "current"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_leave_frozen(bool always_leave)\n{\n\tstruct cgroup *cgrp;\n\n\tspin_lock_irq(&css_set_lock);\n\tcgrp = task_dfl_cgroup(current);\n\tif (always_leave || !test_bit(CGRP_FREEZE, &cgrp->flags)) {\n\t\tcgroup_dec_frozen_cnt(cgrp);\n\t\tcgroup_update_frozen(cgrp);\n\t\tWARN_ON_ONCE(!current->frozen);\n\t\tcurrent->frozen = false;\n\t} else if (!(current->jobctl & JOBCTL_TRAP_FREEZE)) {\n\t\tspin_lock(&current->sighand->siglock);\n\t\tcurrent->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\tspin_unlock(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n}"
  },
  {
    "function_name": "cgroup_enter_frozen",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
    "lines": "107-120",
    "snippet": "void cgroup_enter_frozen(void)\n{\n\tstruct cgroup *cgrp;\n\n\tif (current->frozen)\n\t\treturn;\n\n\tspin_lock_irq(&css_set_lock);\n\tcurrent->frozen = true;\n\tcgrp = task_dfl_cgroup(current);\n\tcgroup_inc_frozen_cnt(cgrp);\n\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_update_frozen",
          "args": [
            "cgrp"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "52-84",
          "snippet": "void cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_inc_frozen_cnt",
          "args": [
            "cgrp"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_inc_frozen_cnt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "89-92",
          "snippet": "static void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_dfl_cgroup",
          "args": [
            "current"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_enter_frozen(void)\n{\n\tstruct cgroup *cgrp;\n\n\tif (current->frozen)\n\t\treturn;\n\n\tspin_lock_irq(&css_set_lock);\n\tcurrent->frozen = true;\n\tcgrp = task_dfl_cgroup(current);\n\tcgroup_inc_frozen_cnt(cgrp);\n\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}"
  },
  {
    "function_name": "cgroup_dec_frozen_cnt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
    "lines": "97-101",
    "snippet": "static void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cgrp->freezer.nr_frozen_tasks < 0"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}"
  },
  {
    "function_name": "cgroup_inc_frozen_cnt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
    "lines": "89-92",
    "snippet": "static void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}"
  },
  {
    "function_name": "cgroup_update_frozen",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
    "lines": "52-84",
    "snippet": "void cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_propagate_frozen",
          "args": [
            "cgrp",
            "frozen"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_propagate_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "14-46",
          "snippet": "static void cgroup_propagate_frozen(struct cgroup *cgrp, bool frozen)\n{\n\tint desc = 1;\n\n\t/*\n\t * If the new state is frozen, some freezing ancestor cgroups may change\n\t * their state too, depending on if all their descendants are frozen.\n\t *\n\t * Otherwise, all ancestor cgroups are forced into the non-frozen state.\n\t */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (frozen) {\n\t\t\tcgrp->freezer.nr_frozen_descendants += desc;\n\t\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags) &&\n\t\t\t    test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\t\t    cgrp->freezer.nr_frozen_descendants ==\n\t\t\t    cgrp->nr_descendants) {\n\t\t\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 1);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t} else {\n\t\t\tcgrp->freezer.nr_frozen_descendants -= desc;\n\t\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags)) {\n\t\t\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 0);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_propagate_frozen(struct cgroup *cgrp, bool frozen)\n{\n\tint desc = 1;\n\n\t/*\n\t * If the new state is frozen, some freezing ancestor cgroups may change\n\t * their state too, depending on if all their descendants are frozen.\n\t *\n\t * Otherwise, all ancestor cgroups are forced into the non-frozen state.\n\t */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (frozen) {\n\t\t\tcgrp->freezer.nr_frozen_descendants += desc;\n\t\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags) &&\n\t\t\t    test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\t\t    cgrp->freezer.nr_frozen_descendants ==\n\t\t\t    cgrp->nr_descendants) {\n\t\t\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 1);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t} else {\n\t\t\tcgrp->freezer.nr_frozen_descendants -= desc;\n\t\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags)) {\n\t\t\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 0);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "notify_frozen",
            "cgrp",
            "frozen"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&cgrp->events_file"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cgroup_task_count",
          "args": [
            "cgrp"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_task_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "624-635",
          "snippet": "int __cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count = 0;\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tcount += link->cset->nr_tasks;\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint __cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count = 0;\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tcount += link->cset->nr_tasks;\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}"
  },
  {
    "function_name": "cgroup_propagate_frozen",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
    "lines": "14-46",
    "snippet": "static void cgroup_propagate_frozen(struct cgroup *cgrp, bool frozen)\n{\n\tint desc = 1;\n\n\t/*\n\t * If the new state is frozen, some freezing ancestor cgroups may change\n\t * their state too, depending on if all their descendants are frozen.\n\t *\n\t * Otherwise, all ancestor cgroups are forced into the non-frozen state.\n\t */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (frozen) {\n\t\t\tcgrp->freezer.nr_frozen_descendants += desc;\n\t\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags) &&\n\t\t\t    test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\t\t    cgrp->freezer.nr_frozen_descendants ==\n\t\t\t    cgrp->nr_descendants) {\n\t\t\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 1);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t} else {\n\t\t\tcgrp->freezer.nr_frozen_descendants -= desc;\n\t\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags)) {\n\t\t\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 0);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "notify_frozen",
            "cgrp",
            "0"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&cgrp->events_file"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "notify_frozen",
            "cgrp",
            "1"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&cgrp->events_file"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_propagate_frozen(struct cgroup *cgrp, bool frozen)\n{\n\tint desc = 1;\n\n\t/*\n\t * If the new state is frozen, some freezing ancestor cgroups may change\n\t * their state too, depending on if all their descendants are frozen.\n\t *\n\t * Otherwise, all ancestor cgroups are forced into the non-frozen state.\n\t */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (frozen) {\n\t\t\tcgrp->freezer.nr_frozen_descendants += desc;\n\t\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags) &&\n\t\t\t    test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\t\t    cgrp->freezer.nr_frozen_descendants ==\n\t\t\t    cgrp->nr_descendants) {\n\t\t\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 1);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t} else {\n\t\t\tcgrp->freezer.nr_frozen_descendants -= desc;\n\t\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags)) {\n\t\t\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 0);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t}\n\t}\n}"
  }
]