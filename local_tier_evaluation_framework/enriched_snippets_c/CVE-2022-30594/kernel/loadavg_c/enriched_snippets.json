[
  {
    "function_name": "calc_global_load_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "386-398",
    "snippet": "void calc_global_load_tick(struct rq *this_rq)\n{\n\tlong delta;\n\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\tdelta  = calc_load_fold_active(this_rq, 0);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tthis_rq->calc_load_update += LOAD_FREQ;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t calc_load_tasks;",
      "unsigned long calc_load_update;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "delta",
            "&calc_load_tasks"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load_fold_active",
          "args": [
            "this_rq",
            "0"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_fold_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "79-92",
          "snippet": "long calc_load_fold_active(struct rq *this_rq, long adjust)\n{\n\tlong nr_active, delta = 0;\n\n\tnr_active = this_rq->nr_running - adjust;\n\tnr_active += (int)this_rq->nr_uninterruptible;\n\n\tif (nr_active != this_rq->calc_load_active) {\n\t\tdelta = nr_active - this_rq->calc_load_active;\n\t\tthis_rq->calc_load_active = nr_active;\n\t}\n\n\treturn delta;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nlong calc_load_fold_active(struct rq *this_rq, long adjust)\n{\n\tlong nr_active, delta = 0;\n\n\tnr_active = this_rq->nr_running - adjust;\n\tnr_active += (int)this_rq->nr_uninterruptible;\n\n\tif (nr_active != this_rq->calc_load_active) {\n\t\tdelta = nr_active - this_rq->calc_load_active;\n\t\tthis_rq->calc_load_active = nr_active;\n\t}\n\n\treturn delta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "this_rq->calc_load_update"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\natomic_long_t calc_load_tasks;\nunsigned long calc_load_update;\n\nvoid calc_global_load_tick(struct rq *this_rq)\n{\n\tlong delta;\n\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\tdelta  = calc_load_fold_active(this_rq, 0);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tthis_rq->calc_load_update += LOAD_FREQ;\n}"
  },
  {
    "function_name": "calc_global_load",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "350-380",
    "snippet": "void calc_global_load(void)\n{\n\tunsigned long sample_window;\n\tlong active, delta;\n\n\tsample_window = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, sample_window + 10))\n\t\treturn;\n\n\t/*\n\t * Fold the 'old' NO_HZ-delta to include all NO_HZ CPUs.\n\t */\n\tdelta = calc_load_nohz_read();\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tactive = atomic_long_read(&calc_load_tasks);\n\tactive = active > 0 ? active * FIXED_1 : 0;\n\n\tavenrun[0] = calc_load(avenrun[0], EXP_1, active);\n\tavenrun[1] = calc_load(avenrun[1], EXP_5, active);\n\tavenrun[2] = calc_load(avenrun[2], EXP_15, active);\n\n\tWRITE_ONCE(calc_load_update, sample_window + LOAD_FREQ);\n\n\t/*\n\t * In case we went to NO_HZ for multiple LOAD_FREQ intervals\n\t * catch up in bulk.\n\t */\n\tcalc_global_nohz();\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t calc_load_tasks;",
      "unsigned long calc_load_update;",
      "unsigned long avenrun[3];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_global_nohz",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "calc_global_nohz",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "340-340",
          "snippet": "static inline void calc_global_nohz(void) { }",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void calc_global_nohz(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "calc_load_update",
            "sample_window + LOAD_FREQ"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load",
          "args": [
            "avenrun[2]",
            "EXP_15",
            "active"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load",
          "args": [
            "avenrun[1]",
            "EXP_5",
            "active"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load",
          "args": [
            "avenrun[0]",
            "EXP_1",
            "active"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&calc_load_tasks"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "delta",
            "&calc_load_tasks"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load_nohz_read",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_nohz_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "339-339",
          "snippet": "static inline long calc_load_nohz_read(void) { return 0; }",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline long calc_load_nohz_read(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "sample_window + 10"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "calc_load_update"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\natomic_long_t calc_load_tasks;\nunsigned long calc_load_update;\nunsigned long avenrun[3];\n\nvoid calc_global_load(void)\n{\n\tunsigned long sample_window;\n\tlong active, delta;\n\n\tsample_window = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, sample_window + 10))\n\t\treturn;\n\n\t/*\n\t * Fold the 'old' NO_HZ-delta to include all NO_HZ CPUs.\n\t */\n\tdelta = calc_load_nohz_read();\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tactive = atomic_long_read(&calc_load_tasks);\n\tactive = active > 0 ? active * FIXED_1 : 0;\n\n\tavenrun[0] = calc_load(avenrun[0], EXP_1, active);\n\tavenrun[1] = calc_load(avenrun[1], EXP_5, active);\n\tavenrun[2] = calc_load(avenrun[2], EXP_15, active);\n\n\tWRITE_ONCE(calc_load_update, sample_window + LOAD_FREQ);\n\n\t/*\n\t * In case we went to NO_HZ for multiple LOAD_FREQ intervals\n\t * catch up in bulk.\n\t */\n\tcalc_global_nohz();\n}"
  },
  {
    "function_name": "calc_global_nohz",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "340-340",
    "snippet": "static inline void calc_global_nohz(void) { }",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void calc_global_nohz(void) { }"
  },
  {
    "function_name": "calc_load_nohz_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "339-339",
    "snippet": "static inline long calc_load_nohz_read(void) { return 0; }",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline long calc_load_nohz_read(void) { return 0; }"
  },
  {
    "function_name": "calc_global_nohz",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "304-336",
    "snippet": "static void calc_global_nohz(void)\n{\n\tunsigned long sample_window;\n\tlong delta, active, n;\n\n\tsample_window = READ_ONCE(calc_load_update);\n\tif (!time_before(jiffies, sample_window + 10)) {\n\t\t/*\n\t\t * Catch-up, fold however many we are behind still\n\t\t */\n\t\tdelta = jiffies - sample_window - 10;\n\t\tn = 1 + (delta / LOAD_FREQ);\n\n\t\tactive = atomic_long_read(&calc_load_tasks);\n\t\tactive = active > 0 ? active * FIXED_1 : 0;\n\n\t\tavenrun[0] = calc_load_n(avenrun[0], EXP_1, active, n);\n\t\tavenrun[1] = calc_load_n(avenrun[1], EXP_5, active, n);\n\t\tavenrun[2] = calc_load_n(avenrun[2], EXP_15, active, n);\n\n\t\tWRITE_ONCE(calc_load_update, sample_window + n * LOAD_FREQ);\n\t}\n\n\t/*\n\t * Flip the NO_HZ index...\n\t *\n\t * Make sure we first write the new time then flip the index, so that\n\t * calc_load_write_idx() will see the new time when it reads the new\n\t * index, this avoids a double flip messing things up.\n\t */\n\tsmp_wmb();\n\tcalc_load_idx++;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t calc_load_tasks;",
      "unsigned long calc_load_update;",
      "unsigned long avenrun[3];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "calc_load_update",
            "sample_window + n * LOAD_FREQ"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load_n",
          "args": [
            "avenrun[2]",
            "EXP_15",
            "active",
            "n"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_n",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "156-161",
          "snippet": "unsigned long\ncalc_load_n(unsigned long load, unsigned long exp,\n\t    unsigned long active, unsigned int n)\n{\n\treturn calc_load(load, fixed_power_int(exp, FSHIFT, n), active);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nunsigned long\ncalc_load_n(unsigned long load, unsigned long exp,\n\t    unsigned long active, unsigned int n)\n{\n\treturn calc_load(load, fixed_power_int(exp, FSHIFT, n), active);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&calc_load_tasks"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "sample_window + 10"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "calc_load_update"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\natomic_long_t calc_load_tasks;\nunsigned long calc_load_update;\nunsigned long avenrun[3];\n\nstatic void calc_global_nohz(void)\n{\n\tunsigned long sample_window;\n\tlong delta, active, n;\n\n\tsample_window = READ_ONCE(calc_load_update);\n\tif (!time_before(jiffies, sample_window + 10)) {\n\t\t/*\n\t\t * Catch-up, fold however many we are behind still\n\t\t */\n\t\tdelta = jiffies - sample_window - 10;\n\t\tn = 1 + (delta / LOAD_FREQ);\n\n\t\tactive = atomic_long_read(&calc_load_tasks);\n\t\tactive = active > 0 ? active * FIXED_1 : 0;\n\n\t\tavenrun[0] = calc_load_n(avenrun[0], EXP_1, active, n);\n\t\tavenrun[1] = calc_load_n(avenrun[1], EXP_5, active, n);\n\t\tavenrun[2] = calc_load_n(avenrun[2], EXP_15, active, n);\n\n\t\tWRITE_ONCE(calc_load_update, sample_window + n * LOAD_FREQ);\n\t}\n\n\t/*\n\t * Flip the NO_HZ index...\n\t *\n\t * Make sure we first write the new time then flip the index, so that\n\t * calc_load_write_idx() will see the new time when it reads the new\n\t * index, this avoids a double flip messing things up.\n\t */\n\tsmp_wmb();\n\tcalc_load_idx++;\n}"
  },
  {
    "function_name": "calc_load_nohz_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "284-293",
    "snippet": "static long calc_load_nohz_read(void)\n{\n\tint idx = calc_load_read_idx();\n\tlong delta = 0;\n\n\tif (atomic_long_read(&calc_load_nohz[idx]))\n\t\tdelta = atomic_long_xchg(&calc_load_nohz[idx], 0);\n\n\treturn delta;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_xchg",
          "args": [
            "&calc_load_nohz[idx]",
            "0"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&calc_load_nohz[idx]"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load_read_idx",
          "args": [],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_read_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "229-232",
          "snippet": "static inline int calc_load_read_idx(void)\n{\n\treturn calc_load_idx & 1;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline int calc_load_read_idx(void)\n{\n\treturn calc_load_idx & 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic long calc_load_nohz_read(void)\n{\n\tint idx = calc_load_read_idx();\n\tlong delta = 0;\n\n\tif (atomic_long_read(&calc_load_nohz[idx]))\n\t\tdelta = atomic_long_xchg(&calc_load_nohz[idx], 0);\n\n\treturn delta;\n}"
  },
  {
    "function_name": "calc_load_nohz_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "264-282",
    "snippet": "void calc_load_nohz_stop(void)\n{\n\tstruct rq *this_rq = this_rq();\n\n\t/*\n\t * If we're still before the pending sample window, we're done.\n\t */\n\tthis_rq->calc_load_update = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\t/*\n\t * We woke inside or after the sample window, this means we're already\n\t * accounted through the nohz accounting, so skip the entire deal and\n\t * sync up for the next window.\n\t */\n\tif (time_before(jiffies, this_rq->calc_load_update + 10))\n\t\tthis_rq->calc_load_update += LOAD_FREQ;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long calc_load_update;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "this_rq->calc_load_update + 10"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "this_rq->calc_load_update"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "calc_load_update"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nunsigned long calc_load_update;\n\nvoid calc_load_nohz_stop(void)\n{\n\tstruct rq *this_rq = this_rq();\n\n\t/*\n\t * If we're still before the pending sample window, we're done.\n\t */\n\tthis_rq->calc_load_update = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\t/*\n\t * We woke inside or after the sample window, this means we're already\n\t * accounted through the nohz accounting, so skip the entire deal and\n\t * sync up for the next window.\n\t */\n\tif (time_before(jiffies, this_rq->calc_load_update + 10))\n\t\tthis_rq->calc_load_update += LOAD_FREQ;\n}"
  },
  {
    "function_name": "calc_load_nohz_remote",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "259-262",
    "snippet": "void calc_load_nohz_remote(struct rq *rq)\n{\n\tcalc_load_nohz_fold(rq);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_load_nohz_fold",
          "args": [
            "rq"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_nohz_fold",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "234-244",
          "snippet": "static void calc_load_nohz_fold(struct rq *rq)\n{\n\tlong delta;\n\n\tdelta = calc_load_fold_active(rq, 0);\n\tif (delta) {\n\t\tint idx = calc_load_write_idx();\n\n\t\tatomic_long_add(delta, &calc_load_nohz[idx]);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void calc_load_nohz_fold(struct rq *rq)\n{\n\tlong delta;\n\n\tdelta = calc_load_fold_active(rq, 0);\n\tif (delta) {\n\t\tint idx = calc_load_write_idx();\n\n\t\tatomic_long_add(delta, &calc_load_nohz[idx]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid calc_load_nohz_remote(struct rq *rq)\n{\n\tcalc_load_nohz_fold(rq);\n}"
  },
  {
    "function_name": "calc_load_nohz_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "246-253",
    "snippet": "void calc_load_nohz_start(void)\n{\n\t/*\n\t * We're going into NO_HZ mode, if there's any pending delta, fold it\n\t * into the pending NO_HZ delta.\n\t */\n\tcalc_load_nohz_fold(this_rq());\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_load_nohz_fold",
          "args": [
            "this_rq()"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_nohz_fold",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "234-244",
          "snippet": "static void calc_load_nohz_fold(struct rq *rq)\n{\n\tlong delta;\n\n\tdelta = calc_load_fold_active(rq, 0);\n\tif (delta) {\n\t\tint idx = calc_load_write_idx();\n\n\t\tatomic_long_add(delta, &calc_load_nohz[idx]);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void calc_load_nohz_fold(struct rq *rq)\n{\n\tlong delta;\n\n\tdelta = calc_load_fold_active(rq, 0);\n\tif (delta) {\n\t\tint idx = calc_load_write_idx();\n\n\t\tatomic_long_add(delta, &calc_load_nohz[idx]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid calc_load_nohz_start(void)\n{\n\t/*\n\t * We're going into NO_HZ mode, if there's any pending delta, fold it\n\t * into the pending NO_HZ delta.\n\t */\n\tcalc_load_nohz_fold(this_rq());\n}"
  },
  {
    "function_name": "calc_load_nohz_fold",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "234-244",
    "snippet": "static void calc_load_nohz_fold(struct rq *rq)\n{\n\tlong delta;\n\n\tdelta = calc_load_fold_active(rq, 0);\n\tif (delta) {\n\t\tint idx = calc_load_write_idx();\n\n\t\tatomic_long_add(delta, &calc_load_nohz[idx]);\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "delta",
            "&calc_load_nohz[idx]"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load_write_idx",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_write_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "209-227",
          "snippet": "static inline int calc_load_write_idx(void)\n{\n\tint idx = calc_load_idx;\n\n\t/*\n\t * See calc_global_nohz(), if we observe the new index, we also\n\t * need to observe the new update time.\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the folding window started, make sure we start writing in the\n\t * next NO_HZ-delta.\n\t */\n\tif (!time_before(jiffies, READ_ONCE(calc_load_update)))\n\t\tidx++;\n\n\treturn idx & 1;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long calc_load_update;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nunsigned long calc_load_update;\n\nstatic inline int calc_load_write_idx(void)\n{\n\tint idx = calc_load_idx;\n\n\t/*\n\t * See calc_global_nohz(), if we observe the new index, we also\n\t * need to observe the new update time.\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the folding window started, make sure we start writing in the\n\t * next NO_HZ-delta.\n\t */\n\tif (!time_before(jiffies, READ_ONCE(calc_load_update)))\n\t\tidx++;\n\n\treturn idx & 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_load_fold_active",
          "args": [
            "rq",
            "0"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_fold_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "79-92",
          "snippet": "long calc_load_fold_active(struct rq *this_rq, long adjust)\n{\n\tlong nr_active, delta = 0;\n\n\tnr_active = this_rq->nr_running - adjust;\n\tnr_active += (int)this_rq->nr_uninterruptible;\n\n\tif (nr_active != this_rq->calc_load_active) {\n\t\tdelta = nr_active - this_rq->calc_load_active;\n\t\tthis_rq->calc_load_active = nr_active;\n\t}\n\n\treturn delta;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nlong calc_load_fold_active(struct rq *this_rq, long adjust)\n{\n\tlong nr_active, delta = 0;\n\n\tnr_active = this_rq->nr_running - adjust;\n\tnr_active += (int)this_rq->nr_uninterruptible;\n\n\tif (nr_active != this_rq->calc_load_active) {\n\t\tdelta = nr_active - this_rq->calc_load_active;\n\t\tthis_rq->calc_load_active = nr_active;\n\t}\n\n\treturn delta;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void calc_load_nohz_fold(struct rq *rq)\n{\n\tlong delta;\n\n\tdelta = calc_load_fold_active(rq, 0);\n\tif (delta) {\n\t\tint idx = calc_load_write_idx();\n\n\t\tatomic_long_add(delta, &calc_load_nohz[idx]);\n\t}\n}"
  },
  {
    "function_name": "calc_load_read_idx",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "229-232",
    "snippet": "static inline int calc_load_read_idx(void)\n{\n\treturn calc_load_idx & 1;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline int calc_load_read_idx(void)\n{\n\treturn calc_load_idx & 1;\n}"
  },
  {
    "function_name": "calc_load_write_idx",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "209-227",
    "snippet": "static inline int calc_load_write_idx(void)\n{\n\tint idx = calc_load_idx;\n\n\t/*\n\t * See calc_global_nohz(), if we observe the new index, we also\n\t * need to observe the new update time.\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the folding window started, make sure we start writing in the\n\t * next NO_HZ-delta.\n\t */\n\tif (!time_before(jiffies, READ_ONCE(calc_load_update)))\n\t\tidx++;\n\n\treturn idx & 1;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long calc_load_update;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "READ_ONCE(calc_load_update)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "calc_load_update"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nunsigned long calc_load_update;\n\nstatic inline int calc_load_write_idx(void)\n{\n\tint idx = calc_load_idx;\n\n\t/*\n\t * See calc_global_nohz(), if we observe the new index, we also\n\t * need to observe the new update time.\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the folding window started, make sure we start writing in the\n\t * next NO_HZ-delta.\n\t */\n\tif (!time_before(jiffies, READ_ONCE(calc_load_update)))\n\t\tidx++;\n\n\treturn idx & 1;\n}"
  },
  {
    "function_name": "calc_load_n",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "156-161",
    "snippet": "unsigned long\ncalc_load_n(unsigned long load, unsigned long exp,\n\t    unsigned long active, unsigned int n)\n{\n\treturn calc_load(load, fixed_power_int(exp, FSHIFT, n), active);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_load",
          "args": [
            "load",
            "fixed_power_int(exp, FSHIFT, n)",
            "active"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixed_power_int",
          "args": [
            "exp",
            "FSHIFT",
            "n"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_power_int",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "109-131",
          "snippet": "static unsigned long\nfixed_power_int(unsigned long x, unsigned int frac_bits, unsigned int n)\n{\n\tunsigned long result = 1UL << frac_bits;\n\n\tif (n) {\n\t\tfor (;;) {\n\t\t\tif (n & 1) {\n\t\t\t\tresult *= x;\n\t\t\t\tresult += 1UL << (frac_bits - 1);\n\t\t\t\tresult >>= frac_bits;\n\t\t\t}\n\t\t\tn >>= 1;\n\t\t\tif (!n)\n\t\t\t\tbreak;\n\t\t\tx *= x;\n\t\t\tx += 1UL << (frac_bits - 1);\n\t\t\tx >>= frac_bits;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic unsigned long\nfixed_power_int(unsigned long x, unsigned int frac_bits, unsigned int n)\n{\n\tunsigned long result = 1UL << frac_bits;\n\n\tif (n) {\n\t\tfor (;;) {\n\t\t\tif (n & 1) {\n\t\t\t\tresult *= x;\n\t\t\t\tresult += 1UL << (frac_bits - 1);\n\t\t\t\tresult >>= frac_bits;\n\t\t\t}\n\t\t\tn >>= 1;\n\t\t\tif (!n)\n\t\t\t\tbreak;\n\t\t\tx *= x;\n\t\t\tx += 1UL << (frac_bits - 1);\n\t\t\tx >>= frac_bits;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nunsigned long\ncalc_load_n(unsigned long load, unsigned long exp,\n\t    unsigned long active, unsigned int n)\n{\n\treturn calc_load(load, fixed_power_int(exp, FSHIFT, n), active);\n}"
  },
  {
    "function_name": "fixed_power_int",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "109-131",
    "snippet": "static unsigned long\nfixed_power_int(unsigned long x, unsigned int frac_bits, unsigned int n)\n{\n\tunsigned long result = 1UL << frac_bits;\n\n\tif (n) {\n\t\tfor (;;) {\n\t\t\tif (n & 1) {\n\t\t\t\tresult *= x;\n\t\t\t\tresult += 1UL << (frac_bits - 1);\n\t\t\t\tresult >>= frac_bits;\n\t\t\t}\n\t\t\tn >>= 1;\n\t\t\tif (!n)\n\t\t\t\tbreak;\n\t\t\tx *= x;\n\t\t\tx += 1UL << (frac_bits - 1);\n\t\t\tx >>= frac_bits;\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic unsigned long\nfixed_power_int(unsigned long x, unsigned int frac_bits, unsigned int n)\n{\n\tunsigned long result = 1UL << frac_bits;\n\n\tif (n) {\n\t\tfor (;;) {\n\t\t\tif (n & 1) {\n\t\t\t\tresult *= x;\n\t\t\t\tresult += 1UL << (frac_bits - 1);\n\t\t\t\tresult >>= frac_bits;\n\t\t\t}\n\t\t\tn >>= 1;\n\t\t\tif (!n)\n\t\t\t\tbreak;\n\t\t\tx *= x;\n\t\t\tx += 1UL << (frac_bits - 1);\n\t\t\tx >>= frac_bits;\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "calc_load_fold_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "79-92",
    "snippet": "long calc_load_fold_active(struct rq *this_rq, long adjust)\n{\n\tlong nr_active, delta = 0;\n\n\tnr_active = this_rq->nr_running - adjust;\n\tnr_active += (int)this_rq->nr_uninterruptible;\n\n\tif (nr_active != this_rq->calc_load_active) {\n\t\tdelta = nr_active - this_rq->calc_load_active;\n\t\tthis_rq->calc_load_active = nr_active;\n\t}\n\n\treturn delta;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nlong calc_load_fold_active(struct rq *this_rq, long adjust)\n{\n\tlong nr_active, delta = 0;\n\n\tnr_active = this_rq->nr_running - adjust;\n\tnr_active += (int)this_rq->nr_uninterruptible;\n\n\tif (nr_active != this_rq->calc_load_active) {\n\t\tdelta = nr_active - this_rq->calc_load_active;\n\t\tthis_rq->calc_load_active = nr_active;\n\t}\n\n\treturn delta;\n}"
  },
  {
    "function_name": "get_avenrun",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
    "lines": "72-77",
    "snippet": "void get_avenrun(unsigned long *loads, unsigned long offset, int shift)\n{\n\tloads[0] = (avenrun[0] + offset) << shift;\n\tloads[1] = (avenrun[1] + offset) << shift;\n\tloads[2] = (avenrun[2] + offset) << shift;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long avenrun[3];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nunsigned long avenrun[3];\n\nvoid get_avenrun(unsigned long *loads, unsigned long offset, int shift)\n{\n\tloads[0] = (avenrun[0] + offset) << shift;\n\tloads[1] = (avenrun[1] + offset) << shift;\n\tloads[2] = (avenrun[2] + offset) << shift;\n}"
  }
]