[
  {
    "function_name": "ftrace_test_event_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2313-2371",
    "snippet": "static __init int ftrace_test_event_filter(void)\n{\n\tint i;\n\n\tprintk(KERN_INFO \"Testing ftrace filter: \");\n\n\tfor (i = 0; i < DATA_CNT; i++) {\n\t\tstruct event_filter *filter = NULL;\n\t\tstruct test_filter_data_t *d = &test_filter_data[i];\n\t\tint err;\n\n\t\terr = create_filter(NULL, &event_ftrace_test_filter,\n\t\t\t\t    d->filter, false, &filter);\n\t\tif (err) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to get filter for '%s', err %d\\n\",\n\t\t\t       d->filter, err);\n\t\t\t__free_filter(filter);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Needed to dereference filter->prog */\n\t\tmutex_lock(&event_mutex);\n\t\t/*\n\t\t * The preemption disabling is not really needed for self\n\t\t * tests, but the rcu dereference will complain without it.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (*d->not_visited)\n\t\t\tupdate_pred_fn(filter, d->not_visited);\n\n\t\ttest_pred_visited = 0;\n\t\terr = filter_match_preds(filter, &d->rec);\n\t\tpreempt_enable();\n\n\t\tmutex_unlock(&event_mutex);\n\n\t\t__free_filter(filter);\n\n\t\tif (test_pred_visited) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",\n\t\t\t       d->filter);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err != d->match) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to match filter '%s', expected %d\\n\",\n\t\t\t       d->filter, d->match);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DATA_CNT)\n\t\tprintk(KERN_CONT \"OK\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define DATA_CNT ARRAY_SIZE(test_filter_data)"
    ],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"OK\\n\""
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"Failed to match filter '%s', expected %d\\n\"",
            "d->filter",
            "d->match"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "230-242",
          "snippet": "int __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\"",
            "d->filter"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1124-1132",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_match_preds",
          "args": [
            "filter",
            "&d->rec"
          ],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "filter_match_preds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "990-1011",
          "snippet": "int filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nint filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pred_fn",
          "args": [
            "filter",
            "d->not_visited"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "update_pred_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "2289-2311",
          "snippet": "static void update_pred_fn(struct event_filter *filter, char *fields)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tstruct ftrace_event_field *field = pred->field;\n\n\t\tWARN_ON_ONCE(!pred->fn);\n\n\t\tif (!field) {\n\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strchr(fields, *field->name))\n\t\t\tcontinue;\n\n\t\tpred->fn = test_pred_visited_fn;\n\t}\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void update_pred_fn(struct event_filter *filter, char *fields)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tstruct ftrace_event_field *field = pred->field;\n\n\t\tWARN_ON_ONCE(!pred->fn);\n\n\t\tif (!field) {\n\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strchr(fields, *field->name))\n\t\t\tcontinue;\n\n\t\tpred->fn = test_pred_visited_fn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_filter",
          "args": [
            "NULL",
            "&event_ftrace_test_filter",
            "d->filter",
            "false",
            "&filter"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1833-1855",
          "snippet": "static int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define DATA_CNT ARRAY_SIZE(test_filter_data)\n\nstatic __percpu struct;\n\nstatic __init int ftrace_test_event_filter(void)\n{\n\tint i;\n\n\tprintk(KERN_INFO \"Testing ftrace filter: \");\n\n\tfor (i = 0; i < DATA_CNT; i++) {\n\t\tstruct event_filter *filter = NULL;\n\t\tstruct test_filter_data_t *d = &test_filter_data[i];\n\t\tint err;\n\n\t\terr = create_filter(NULL, &event_ftrace_test_filter,\n\t\t\t\t    d->filter, false, &filter);\n\t\tif (err) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to get filter for '%s', err %d\\n\",\n\t\t\t       d->filter, err);\n\t\t\t__free_filter(filter);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Needed to dereference filter->prog */\n\t\tmutex_lock(&event_mutex);\n\t\t/*\n\t\t * The preemption disabling is not really needed for self\n\t\t * tests, but the rcu dereference will complain without it.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (*d->not_visited)\n\t\t\tupdate_pred_fn(filter, d->not_visited);\n\n\t\ttest_pred_visited = 0;\n\t\terr = filter_match_preds(filter, &d->rec);\n\t\tpreempt_enable();\n\n\t\tmutex_unlock(&event_mutex);\n\n\t\t__free_filter(filter);\n\n\t\tif (test_pred_visited) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",\n\t\t\t       d->filter);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err != d->match) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to match filter '%s', expected %d\\n\",\n\t\t\t       d->filter, d->match);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DATA_CNT)\n\t\tprintk(KERN_CONT \"OK\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "update_pred_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2289-2311",
    "snippet": "static void update_pred_fn(struct event_filter *filter, char *fields)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tstruct ftrace_event_field *field = pred->field;\n\n\t\tWARN_ON_ONCE(!pred->fn);\n\n\t\tif (!field) {\n\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strchr(fields, *field->name))\n\t\t\tcontinue;\n\n\t\tpred->fn = test_pred_visited_fn;\n\t}\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fields",
            "*field->name"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"all leafs should have field defined %d\"",
            "i"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pred->fn"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "filter->prog",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&event_mutex"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void update_pred_fn(struct event_filter *filter, char *fields)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tstruct ftrace_event_field *field = pred->field;\n\n\t\tWARN_ON_ONCE(!pred->fn);\n\n\t\tif (!field) {\n\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strchr(fields, *field->name))\n\t\t\tcontinue;\n\n\t\tpred->fn = test_pred_visited_fn;\n\t}\n}"
  },
  {
    "function_name": "test_pred_visited_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2280-2287",
    "snippet": "static int test_pred_visited_fn(struct filter_pred *pred, void *event)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\ttest_pred_visited = 1;\n\tprintk(KERN_INFO \"\\npred visited %s\\n\", field->name);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"\\npred visited %s\\n\"",
            "field->name"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int test_pred_visited_fn(struct filter_pred *pred, void *event)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\ttest_pred_visited = 1;\n\tprintk(KERN_INFO \"\\npred visited %s\\n\", field->name);\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_profile_set_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2156-2192",
    "snippet": "int ftrace_profile_set_filter(struct perf_event *event, int event_id,\n\t\t\t      char *filter_str)\n{\n\tint err;\n\tstruct event_filter *filter = NULL;\n\tstruct trace_event_call *call;\n\n\tmutex_lock(&event_mutex);\n\n\tcall = event->tp_event;\n\n\terr = -EINVAL;\n\tif (!call)\n\t\tgoto out_unlock;\n\n\terr = -EEXIST;\n\tif (event->filter)\n\t\tgoto out_unlock;\n\n\terr = create_filter(NULL, call, filter_str, false, &filter);\n\tif (err)\n\t\tgoto free_filter;\n\n\tif (ftrace_event_is_function(call))\n\t\terr = ftrace_function_set_filter(event, filter);\n\telse\n\t\tevent->filter = filter;\n\nfree_filter:\n\tif (err || ftrace_event_is_function(call))\n\t\t__free_filter(filter);\n\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1124-1132",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_is_function",
          "args": [
            "call"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_is_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_export.c",
          "lines": "186-189",
          "snippet": "bool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_output.h\"",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stringify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_output.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stringify.h>\n\nbool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_function_set_filter",
          "args": [
            "event",
            "filter"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_function_set_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "2149-2153",
          "snippet": "static int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_filter",
          "args": [
            "NULL",
            "call",
            "filter_str",
            "false",
            "&filter"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1833-1855",
          "snippet": "static int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nint ftrace_profile_set_filter(struct perf_event *event, int event_id,\n\t\t\t      char *filter_str)\n{\n\tint err;\n\tstruct event_filter *filter = NULL;\n\tstruct trace_event_call *call;\n\n\tmutex_lock(&event_mutex);\n\n\tcall = event->tp_event;\n\n\terr = -EINVAL;\n\tif (!call)\n\t\tgoto out_unlock;\n\n\terr = -EEXIST;\n\tif (event->filter)\n\t\tgoto out_unlock;\n\n\terr = create_filter(NULL, call, filter_str, false, &filter);\n\tif (err)\n\t\tgoto free_filter;\n\n\tif (ftrace_event_is_function(call))\n\t\terr = ftrace_function_set_filter(event, filter);\n\telse\n\t\tevent->filter = filter;\n\nfree_filter:\n\tif (err || ftrace_event_is_function(call))\n\t\t__free_filter(filter);\n\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ftrace_function_set_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2149-2153",
    "snippet": "static int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "ftrace_function_set_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2125-2147",
    "snippet": "static int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tstruct function_filter_data data = {\n\t\t.first_filter  = 1,\n\t\t.first_notrace = 1,\n\t\t.ops           = &event->ftrace_ops,\n\t};\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\n\t\tif (!is_or(prog, i))\n\t\t\treturn -EINVAL;\n\n\t\tif (ftrace_function_set_filter_pred(pred, &data) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * ops[] = { OPS };",
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_function_set_filter_pred",
          "args": [
            "pred",
            "&data"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_function_set_filter_pred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "2091-2105",
          "snippet": "static int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\n\t/* Checking the node is valid for function trace. */\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\n\t/* Checking the node is valid for function trace. */\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_or",
          "args": [
            "prog",
            "i"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "is_or",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "2107-2123",
          "snippet": "static bool is_or(struct prog_entry *prog, int i)\n{\n\tint target;\n\n\t/*\n\t * Only \"||\" is allowed for function events, thus,\n\t * all true branches should jump to true, and any\n\t * false branch should jump to false.\n\t */\n\ttarget = prog[i].target + 1;\n\t/* True and false have NULL preds (all prog entries should jump to one */\n\tif (prog[target].pred)\n\t\treturn false;\n\n\t/* prog[target].target is 1 for TRUE, 0 for FALSE */\n\treturn prog[i].when_to_branch == prog[target].target;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic bool is_or(struct prog_entry *prog, int i)\n{\n\tint target;\n\n\t/*\n\t * Only \"||\" is allowed for function events, thus,\n\t * all true branches should jump to true, and any\n\t * false branch should jump to false.\n\t */\n\ttarget = prog[i].target + 1;\n\t/* True and false have NULL preds (all prog entries should jump to one */\n\tif (prog[target].pred)\n\t\treturn false;\n\n\t/* prog[target].target is 1 for TRUE, 0 for FALSE */\n\treturn prog[i].when_to_branch == prog[target].target;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "filter->prog",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&event_mutex"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char * ops[] = { OPS };\nstatic __percpu struct;\n\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tstruct function_filter_data data = {\n\t\t.first_filter  = 1,\n\t\t.first_notrace = 1,\n\t\t.ops           = &event->ftrace_ops,\n\t};\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\n\t\tif (!is_or(prog, i))\n\t\t\treturn -EINVAL;\n\n\t\tif (ftrace_function_set_filter_pred(pred, &data) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "is_or",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2107-2123",
    "snippet": "static bool is_or(struct prog_entry *prog, int i)\n{\n\tint target;\n\n\t/*\n\t * Only \"||\" is allowed for function events, thus,\n\t * all true branches should jump to true, and any\n\t * false branch should jump to false.\n\t */\n\ttarget = prog[i].target + 1;\n\t/* True and false have NULL preds (all prog entries should jump to one */\n\tif (prog[target].pred)\n\t\treturn false;\n\n\t/* prog[target].target is 1 for TRUE, 0 for FALSE */\n\treturn prog[i].when_to_branch == prog[target].target;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic bool is_or(struct prog_entry *prog, int i)\n{\n\tint target;\n\n\t/*\n\t * Only \"||\" is allowed for function events, thus,\n\t * all true branches should jump to true, and any\n\t * false branch should jump to false.\n\t */\n\ttarget = prog[i].target + 1;\n\t/* True and false have NULL preds (all prog entries should jump to one */\n\tif (prog[target].pred)\n\t\treturn false;\n\n\t/* prog[target].target is 1 for TRUE, 0 for FALSE */\n\treturn prog[i].when_to_branch == prog[target].target;\n}"
  },
  {
    "function_name": "ftrace_function_set_filter_pred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2091-2105",
    "snippet": "static int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\n\t/* Checking the node is valid for function trace. */\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_function_set_filter",
          "args": [
            "pred->op == OP_EQ",
            "pred->regex.pattern",
            "pred->regex.len",
            "data"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_function_set_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "2041-2071",
          "snippet": "static int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\n\t/*\n\t * The 'ip' field could have multiple filters set, separated\n\t * either by space or comma. We first cut the filter and apply\n\t * all pieces separately.\n\t */\n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\n\targv_free(re);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * ops[] = { OPS };",
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char * ops[] = { OPS };\nstatic __percpu struct;\n\nstatic int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\n\t/*\n\t * The 'ip' field could have multiple filters set, separated\n\t * either by space or comma. We first cut the filter and apply\n\t * all pieces separately.\n\t */\n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\n\targv_free(re);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_function_check_pred",
          "args": [
            "pred"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_function_check_pred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "2073-2089",
          "snippet": "static int ftrace_function_check_pred(struct filter_pred *pred)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\t/*\n\t * Check the predicate for function trace, verify:\n\t *  - only '==' and '!=' is used\n\t *  - the 'ip' field is used\n\t */\n\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))\n\t\treturn -EINVAL;\n\n\tif (strcmp(field->name, \"ip\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int ftrace_function_check_pred(struct filter_pred *pred)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\t/*\n\t * Check the predicate for function trace, verify:\n\t *  - only '==' and '!=' is used\n\t *  - the 'ip' field is used\n\t */\n\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))\n\t\treturn -EINVAL;\n\n\tif (strcmp(field->name, \"ip\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\n\t/* Checking the node is valid for function trace. */\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}"
  },
  {
    "function_name": "ftrace_function_check_pred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2073-2089",
    "snippet": "static int ftrace_function_check_pred(struct filter_pred *pred)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\t/*\n\t * Check the predicate for function trace, verify:\n\t *  - only '==' and '!=' is used\n\t *  - the 'ip' field is used\n\t */\n\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))\n\t\treturn -EINVAL;\n\n\tif (strcmp(field->name, \"ip\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->name",
            "\"ip\""
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int ftrace_function_check_pred(struct filter_pred *pred)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\t/*\n\t * Check the predicate for function trace, verify:\n\t *  - only '==' and '!=' is used\n\t *  - the 'ip' field is used\n\t */\n\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))\n\t\treturn -EINVAL;\n\n\tif (strcmp(field->name, \"ip\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ftrace_function_set_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2041-2071",
    "snippet": "static int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\n\t/*\n\t * The 'ip' field could have multiple filters set, separated\n\t * either by space or comma. We first cut the filter and apply\n\t * all pieces separately.\n\t */\n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\n\targv_free(re);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * ops[] = { OPS };",
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "re"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_function_set_regexp",
          "args": [
            "data->ops",
            "filter",
            "*reset",
            "re[i]",
            "strlen(re[i])"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_function_set_regexp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "2028-2039",
          "snippet": "static int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * ops[] = { OPS };",
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char * ops[] = { OPS };\nstatic __percpu struct;\n\nstatic int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "re[i]"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_function_filter_re",
          "args": [
            "buf",
            "len",
            "&re_cnt"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_function_filter_re",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "2008-2026",
          "snippet": "static char **\nftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic char **\nftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char * ops[] = { OPS };\nstatic __percpu struct;\n\nstatic int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\n\t/*\n\t * The 'ip' field could have multiple filters set, separated\n\t * either by space or comma. We first cut the filter and apply\n\t * all pieces separately.\n\t */\n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\n\targv_free(re);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_function_set_regexp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2028-2039",
    "snippet": "static int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * ops[] = { OPS };",
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_notrace",
          "args": [
            "ops",
            "re",
            "len",
            "reset"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_notrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5694-5699",
          "snippet": "int ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter",
          "args": [
            "ops",
            "re",
            "len",
            "reset"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5675-5680",
          "snippet": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char * ops[] = { OPS };\nstatic __percpu struct;\n\nstatic int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_function_filter_re",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "2008-2026",
    "snippet": "static char **\nftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "str"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_split",
          "args": [
            "GFP_KERNEL",
            "str",
            "count"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strreplace",
          "args": [
            "str",
            "','",
            "' '"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "buf",
            "len",
            "GFP_KERNEL"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic char **\nftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}"
  },
  {
    "function_name": "ftrace_profile_free_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1993-1999",
    "snippet": "void ftrace_profile_free_filter(struct perf_event *event)\n{\n\tstruct event_filter *filter = event->filter;\n\n\tevent->filter = NULL;\n\t__free_filter(filter);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1124-1132",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nvoid ftrace_profile_free_filter(struct perf_event *event)\n{\n\tstruct event_filter *filter = event->filter;\n\n\tevent->filter = NULL;\n\t__free_filter(filter);\n}"
  },
  {
    "function_name": "apply_subsystem_event_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1948-1989",
    "snippet": "int apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t/* Make sure the system still has events */\n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t/* Ensure all filters are no longer used */\n\t\ttracepoint_synchronize_unregister();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, filter_string, &filter);\n\tif (filter) {\n\t\t/*\n\t\t * No event actually uses the system filter\n\t\t * we can free it without synchronize_rcu().\n\t\t */\n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "system->filter"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1124-1132",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_system_filter",
          "args": [
            "dir",
            "filter_string",
            "&filter"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "create_system_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1874-1894",
          "snippet": "static int create_system_filter(struct trace_subsystem_dir *dir,\n\t\t\t\tchar *filter_str, struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\terr = create_filter_start(filter_str, true, &pe, filterp);\n\tif (!err) {\n\t\terr = process_system_preds(dir, dir->tr, pe, filter_str);\n\t\tif (!err) {\n\t\t\t/* System filters just show a default message */\n\t\t\tkfree((*filterp)->filter_string);\n\t\t\t(*filterp)->filter_string = NULL;\n\t\t} else {\n\t\t\tappend_filter_err(dir->tr, pe, *filterp);\n\t\t}\n\t}\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int create_system_filter(struct trace_subsystem_dir *dir,\n\t\t\t\tchar *filter_str, struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\terr = create_filter_start(filter_str, true, &pe, filterp);\n\tif (!err) {\n\t\terr = process_system_preds(dir, dir->tr, pe, filter_str);\n\t\tif (!err) {\n\t\t\t/* System filters just show a default message */\n\t\t\tkfree((*filterp)->filter_string);\n\t\t\t(*filterp)->filter_string = NULL;\n\t\t} else {\n\t\t\tappend_filter_err(dir->tr, pe, *filterp);\n\t\t}\n\t}\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_free_subsystem_filters",
          "args": [
            "dir",
            "tr"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "filter_free_subsystem_filters",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1163-1173",
          "snippet": "static void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n\t\t\t\t\t  struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__free_subsystem_filter(file);\n\t}\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n\t\t\t\t\t  struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__free_subsystem_filter(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_filter_string",
          "args": [
            "system->filter"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "remove_filter_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1014-1021",
          "snippet": "static void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_free_subsystem_preds",
          "args": [
            "dir",
            "tr"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "filter_free_subsystem_preds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1145-1155",
          "snippet": "static void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__remove_filter(file);\n\t}\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__remove_filter(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strstrip(filter_string)",
            "\"0\""
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "filter_string"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nint apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t/* Make sure the system still has events */\n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t/* Ensure all filters are no longer used */\n\t\ttracepoint_synchronize_unregister();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, filter_string, &filter);\n\tif (filter) {\n\t\t/*\n\t\t * No event actually uses the system filter\n\t\t * we can free it without synchronize_rcu().\n\t\t */\n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "apply_event_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1897-1946",
    "snippet": "int apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(file->tr, call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "tmp"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1124-1132",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_set_filter",
          "args": [
            "file",
            "filter"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "event_set_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1674-1678",
          "snippet": "static inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_disable",
          "args": [
            "file"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "filter_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1114-1122",
          "snippet": "static void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_set_filtered_flag",
          "args": [
            "file"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "event_set_filtered_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1664-1672",
          "snippet": "static inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_filter",
          "args": [
            "file"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1134-1137",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_filter",
          "args": [
            "file->tr",
            "call",
            "filter_string",
            "true",
            "&filter"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1833-1855",
          "snippet": "static int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_clear_filter",
          "args": [
            "file"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "event_clear_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1680-1683",
          "snippet": "static inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strstrip(filter_string)",
            "\"0\""
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "filter_string"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nint apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(file->tr, call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "create_system_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1874-1894",
    "snippet": "static int create_system_filter(struct trace_subsystem_dir *dir,\n\t\t\t\tchar *filter_str, struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\terr = create_filter_start(filter_str, true, &pe, filterp);\n\tif (!err) {\n\t\terr = process_system_preds(dir, dir->tr, pe, filter_str);\n\t\tif (!err) {\n\t\t\t/* System filters just show a default message */\n\t\t\tkfree((*filterp)->filter_string);\n\t\t\t(*filterp)->filter_string = NULL;\n\t\t} else {\n\t\t\tappend_filter_err(dir->tr, pe, *filterp);\n\t\t}\n\t}\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_filter_finish",
          "args": [
            "pe"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1810-1813",
          "snippet": "static void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_filter_err",
          "args": [
            "dir->tr",
            "pe",
            "*filterp"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "append_filter_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1023-1068",
          "snippet": "static void append_filter_err(struct trace_array *tr,\n\t\t\t      struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tpe->lasterr, pe->lasterr_pos);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tFILT_ERR_ERRNO, 0);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic __percpu struct;\n\nstatic void append_filter_err(struct trace_array *tr,\n\t\t\t      struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tpe->lasterr, pe->lasterr_pos);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tFILT_ERR_ERRNO, 0);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(*filterp)->filter_string"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_system_preds",
          "args": [
            "dir",
            "dir->tr",
            "pe",
            "filter_str"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "process_system_preds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1690-1775",
          "snippet": "static int process_system_preds(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tstruct filter_parse_error *pe,\n\t\t\t\tchar *filter_string)\n{\n\tstruct trace_event_file *file;\n\tstruct filter_list *filter_item;\n\tstruct event_filter *filter = NULL;\n\tstruct filter_list *tmp;\n\tLIST_HEAD(filter_list);\n\tbool fail = true;\n\tint err;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\n\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (!filter)\n\t\t\tgoto fail_mem;\n\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\tgoto fail_mem;\n\n\t\terr = process_preds(file->event_call, filter_string, filter, pe);\n\t\tif (err) {\n\t\t\tfilter_disable(file);\n\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\t\t\tappend_filter_err(tr, pe, filter);\n\t\t} else\n\t\t\tevent_set_filtered_flag(file);\n\n\n\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\n\t\tif (!filter_item)\n\t\t\tgoto fail_mem;\n\n\t\tlist_add_tail(&filter_item->list, &filter_list);\n\t\t/*\n\t\t * Regardless of if this returned an error, we still\n\t\t * replace the filter for the call.\n\t\t */\n\t\tfilter_item->filter = event_filter(file);\n\t\tevent_set_filter(file, filter);\n\t\tfilter = NULL;\n\n\t\tfail = false;\n\t}\n\n\tif (fail)\n\t\tgoto fail;\n\n\t/*\n\t * The calls can still be using the old filters.\n\t * Do a synchronize_rcu() and to ensure all calls are\n\t * done with them before we free them.\n\t */\n\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn 0;\n fail:\n\t/* No call succeeded */\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\treturn -EINVAL;\n fail_mem:\n\t__free_filter(filter);\n\t/* If any call succeeded, we still need to sync */\n\tif (!fail)\n\t\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int process_system_preds(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tstruct filter_parse_error *pe,\n\t\t\t\tchar *filter_string)\n{\n\tstruct trace_event_file *file;\n\tstruct filter_list *filter_item;\n\tstruct event_filter *filter = NULL;\n\tstruct filter_list *tmp;\n\tLIST_HEAD(filter_list);\n\tbool fail = true;\n\tint err;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\n\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (!filter)\n\t\t\tgoto fail_mem;\n\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\tgoto fail_mem;\n\n\t\terr = process_preds(file->event_call, filter_string, filter, pe);\n\t\tif (err) {\n\t\t\tfilter_disable(file);\n\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\t\t\tappend_filter_err(tr, pe, filter);\n\t\t} else\n\t\t\tevent_set_filtered_flag(file);\n\n\n\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\n\t\tif (!filter_item)\n\t\t\tgoto fail_mem;\n\n\t\tlist_add_tail(&filter_item->list, &filter_list);\n\t\t/*\n\t\t * Regardless of if this returned an error, we still\n\t\t * replace the filter for the call.\n\t\t */\n\t\tfilter_item->filter = event_filter(file);\n\t\tevent_set_filter(file, filter);\n\t\tfilter = NULL;\n\n\t\tfail = false;\n\t}\n\n\tif (fail)\n\t\tgoto fail;\n\n\t/*\n\t * The calls can still be using the old filters.\n\t * Do a synchronize_rcu() and to ensure all calls are\n\t * done with them before we free them.\n\t */\n\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn 0;\n fail:\n\t/* No call succeeded */\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\treturn -EINVAL;\n fail_mem:\n\t__free_filter(filter);\n\t/* If any call succeeded, we still need to sync */\n\tif (!fail)\n\t\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_filter_start",
          "args": [
            "filter_str",
            "true",
            "&pe",
            "filterp"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1777-1808",
          "snippet": "static int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int create_system_filter(struct trace_subsystem_dir *dir,\n\t\t\t\tchar *filter_str, struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\terr = create_filter_start(filter_str, true, &pe, filterp);\n\tif (!err) {\n\t\terr = process_system_preds(dir, dir->tr, pe, filter_str);\n\t\tif (!err) {\n\t\t\t/* System filters just show a default message */\n\t\t\tkfree((*filterp)->filter_string);\n\t\t\t(*filterp)->filter_string = NULL;\n\t\t} else {\n\t\t\tappend_filter_err(dir->tr, pe, *filterp);\n\t\t}\n\t}\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}"
  },
  {
    "function_name": "create_event_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1857-1863",
    "snippet": "int create_event_filter(struct trace_array *tr,\n\t\t\tstruct trace_event_call *call,\n\t\t\tchar *filter_str, bool set_str,\n\t\t\tstruct event_filter **filterp)\n{\n\treturn create_filter(tr, call, filter_str, set_str, filterp);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_filter",
          "args": [
            "tr",
            "call",
            "filter_str",
            "set_str",
            "filterp"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1833-1855",
          "snippet": "static int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nint create_event_filter(struct trace_array *tr,\n\t\t\tstruct trace_event_call *call,\n\t\t\tchar *filter_str, bool set_str,\n\t\t\tstruct event_filter **filterp)\n{\n\treturn create_filter(tr, call, filter_str, set_str, filterp);\n}"
  },
  {
    "function_name": "create_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1833-1855",
    "snippet": "static int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_filter_finish",
          "args": [
            "pe"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1810-1813",
          "snippet": "static void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_filter_err",
          "args": [
            "tr",
            "pe",
            "*filterp"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "append_filter_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1023-1068",
          "snippet": "static void append_filter_err(struct trace_array *tr,\n\t\t\t      struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tpe->lasterr, pe->lasterr_pos);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tFILT_ERR_ERRNO, 0);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic __percpu struct;\n\nstatic void append_filter_err(struct trace_array *tr,\n\t\t\t      struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tpe->lasterr, pe->lasterr_pos);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tFILT_ERR_ERRNO, 0);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_preds",
          "args": [
            "call",
            "filter_string",
            "*filterp",
            "pe"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "process_preds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1626-1662",
          "snippet": "static int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_filter_start",
          "args": [
            "filter_string",
            "set_str",
            "&pe",
            "filterp"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1777-1808",
          "snippet": "static int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*filterp"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}"
  },
  {
    "function_name": "create_filter_finish",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1810-1813",
    "snippet": "static void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pe"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}"
  },
  {
    "function_name": "create_filter_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1777-1808",
    "snippet": "static int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1124-1132",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pe"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pe)",
            "GFP_KERNEL"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "filter_string",
            "GFP_KERNEL"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*filter)",
            "GFP_KERNEL"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "*pse || *filterp"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "process_system_preds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1690-1775",
    "snippet": "static int process_system_preds(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tstruct filter_parse_error *pe,\n\t\t\t\tchar *filter_string)\n{\n\tstruct trace_event_file *file;\n\tstruct filter_list *filter_item;\n\tstruct event_filter *filter = NULL;\n\tstruct filter_list *tmp;\n\tLIST_HEAD(filter_list);\n\tbool fail = true;\n\tint err;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\n\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (!filter)\n\t\t\tgoto fail_mem;\n\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\tgoto fail_mem;\n\n\t\terr = process_preds(file->event_call, filter_string, filter, pe);\n\t\tif (err) {\n\t\t\tfilter_disable(file);\n\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\t\t\tappend_filter_err(tr, pe, filter);\n\t\t} else\n\t\t\tevent_set_filtered_flag(file);\n\n\n\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\n\t\tif (!filter_item)\n\t\t\tgoto fail_mem;\n\n\t\tlist_add_tail(&filter_item->list, &filter_list);\n\t\t/*\n\t\t * Regardless of if this returned an error, we still\n\t\t * replace the filter for the call.\n\t\t */\n\t\tfilter_item->filter = event_filter(file);\n\t\tevent_set_filter(file, filter);\n\t\tfilter = NULL;\n\n\t\tfail = false;\n\t}\n\n\tif (fail)\n\t\tgoto fail;\n\n\t/*\n\t * The calls can still be using the old filters.\n\t * Do a synchronize_rcu() and to ensure all calls are\n\t * done with them before we free them.\n\t */\n\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn 0;\n fail:\n\t/* No call succeeded */\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\treturn -EINVAL;\n fail_mem:\n\t__free_filter(filter);\n\t/* If any call succeeded, we still need to sync */\n\tif (!fail)\n\t\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filter_item"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&filter_item->list"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter_item->filter"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1124-1132",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "filter_item",
            "tmp",
            "&filter_list",
            "list"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_error",
          "args": [
            "pe",
            "FILT_ERR_BAD_SUBSYS_FILTER",
            "0"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "parse_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "134-138",
          "snippet": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "filter_item",
            "tmp",
            "&filter_list",
            "list"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "filter_item",
            "tmp",
            "&filter_list",
            "list"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_set_filter",
          "args": [
            "file",
            "filter"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "event_set_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1674-1678",
          "snippet": "static inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_filter",
          "args": [
            "file"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1134-1137",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&filter_item->list",
            "&filter_list"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*filter_item)",
            "GFP_KERNEL"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_set_filtered_flag",
          "args": [
            "file"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "event_set_filtered_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1664-1672",
          "snippet": "static inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_filter_err",
          "args": [
            "tr",
            "pe",
            "filter"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "append_filter_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1023-1068",
          "snippet": "static void append_filter_err(struct trace_array *tr,\n\t\t\t      struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tpe->lasterr, pe->lasterr_pos);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tFILT_ERR_ERRNO, 0);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic __percpu struct;\n\nstatic void append_filter_err(struct trace_array *tr,\n\t\t\t      struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tpe->lasterr, pe->lasterr_pos);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tFILT_ERR_ERRNO, 0);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_disable",
          "args": [
            "file"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "filter_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1114-1122",
          "snippet": "static void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_preds",
          "args": [
            "file->event_call",
            "filter_string",
            "filter",
            "pe"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "process_preds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1626-1662",
          "snippet": "static int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "filter_string",
            "GFP_KERNEL"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*filter)",
            "GFP_KERNEL"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "filter_list"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int process_system_preds(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tstruct filter_parse_error *pe,\n\t\t\t\tchar *filter_string)\n{\n\tstruct trace_event_file *file;\n\tstruct filter_list *filter_item;\n\tstruct event_filter *filter = NULL;\n\tstruct filter_list *tmp;\n\tLIST_HEAD(filter_list);\n\tbool fail = true;\n\tint err;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\n\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (!filter)\n\t\t\tgoto fail_mem;\n\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\tgoto fail_mem;\n\n\t\terr = process_preds(file->event_call, filter_string, filter, pe);\n\t\tif (err) {\n\t\t\tfilter_disable(file);\n\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\t\t\tappend_filter_err(tr, pe, filter);\n\t\t} else\n\t\t\tevent_set_filtered_flag(file);\n\n\n\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\n\t\tif (!filter_item)\n\t\t\tgoto fail_mem;\n\n\t\tlist_add_tail(&filter_item->list, &filter_list);\n\t\t/*\n\t\t * Regardless of if this returned an error, we still\n\t\t * replace the filter for the call.\n\t\t */\n\t\tfilter_item->filter = event_filter(file);\n\t\tevent_set_filter(file, filter);\n\t\tfilter = NULL;\n\n\t\tfail = false;\n\t}\n\n\tif (fail)\n\t\tgoto fail;\n\n\t/*\n\t * The calls can still be using the old filters.\n\t * Do a synchronize_rcu() and to ensure all calls are\n\t * done with them before we free them.\n\t */\n\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn 0;\n fail:\n\t/* No call succeeded */\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\treturn -EINVAL;\n fail_mem:\n\t__free_filter(filter);\n\t/* If any call succeeded, we still need to sync */\n\tif (!fail)\n\t\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "event_clear_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1680-1683",
    "snippet": "static inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "file->filter",
            "NULL"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}"
  },
  {
    "function_name": "event_set_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1674-1678",
    "snippet": "static inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "file->filter",
            "filter"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}"
  },
  {
    "function_name": "event_set_filtered_flag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1664-1672",
    "snippet": "static inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffered_event_enable",
          "args": [],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffered_event_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2644-2677",
          "snippet": "void trace_buffered_event_enable(void)\n{\n\tstruct ring_buffer_event *event;\n\tstruct page *page;\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (trace_buffered_event_ref++)\n\t\treturn;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\t\tif (!page)\n\t\t\tgoto failed;\n\n\t\tevent = page_address(page);\n\t\tmemset(event, 0, sizeof(*event));\n\n\t\tper_cpu(trace_buffered_event, cpu) = event;\n\n\t\tpreempt_disable();\n\t\tif (cpu == smp_processor_id() &&\n\t\t    __this_cpu_read(trace_buffered_event) !=\n\t\t    per_cpu(trace_buffered_event, cpu))\n\t\t\tWARN_ON_ONCE(1);\n\t\tpreempt_enable();\n\t}\n\n\treturn;\n failed:\n\ttrace_buffered_event_disable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static int trace_buffered_event_ref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic int trace_buffered_event_ref;\n\nvoid trace_buffered_event_enable(void)\n{\n\tstruct ring_buffer_event *event;\n\tstruct page *page;\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (trace_buffered_event_ref++)\n\t\treturn;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\t\tif (!page)\n\t\t\tgoto failed;\n\n\t\tevent = page_address(page);\n\t\tmemset(event, 0, sizeof(*event));\n\n\t\tper_cpu(trace_buffered_event, cpu) = event;\n\n\t\tpreempt_disable();\n\t\tif (cpu == smp_processor_id() &&\n\t\t    __this_cpu_read(trace_buffered_event) !=\n\t\t    per_cpu(trace_buffered_event, cpu))\n\t\t\tWARN_ON_ONCE(1);\n\t\tpreempt_enable();\n\t}\n\n\treturn;\n failed:\n\ttrace_buffered_event_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}"
  },
  {
    "function_name": "process_preds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1626-1662",
    "snippet": "static int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "filter->prog",
            "prog"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "predicate_parse",
          "args": [
            "filter_string",
            "nr_parens",
            "nr_preds",
            "parse_pred",
            "call",
            "pe"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "predicate_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "410-591",
          "snippet": "static struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kcalloc(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\t/* accepting only \"&&\" or \"||\" */\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tkfree(op_stack);\n\tkfree(inverts);\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(inverts);\n\tif (prog_stack) {\n\t\tfor (i = 0; prog_stack[i].pred; i++)\n\t\t\tkfree(prog_stack[i].pred);\n\t\tkfree(prog_stack);\n\t}\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kcalloc(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\t/* accepting only \"&&\" or \"||\" */\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tkfree(op_stack);\n\tkfree(inverts);\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(inverts);\n\tif (prog_stack) {\n\t\tfor (i = 0; prog_stack[i].pred; i++)\n\t\t\tkfree(prog_stack[i].pred);\n\t\tkfree(prog_stack);\n\t}\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_error",
          "args": [
            "pe",
            "FILT_ERR_TOO_MANY_CLOSE",
            "index"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "parse_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "134-138",
          "snippet": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_stack",
          "args": [
            "filter_string",
            "&nr_parens",
            "&nr_preds",
            "&index"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "calc_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1529-1624",
          "snippet": "static int calc_stack(const char *str, int *parens, int *preds, int *err)\n{\n\tbool is_pred = false;\n\tint nr_preds = 0;\n\tint open = 1; /* Count the expression as \"(E)\" */\n\tint last_quote = 0;\n\tint max_open = 1;\n\tint quote = 0;\n\tint i;\n\n\t*err = 0;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tif (isspace(str[i]))\n\t\t\tcontinue;\n\t\tif (quote) {\n\t\t\tif (str[i] == quote)\n\t\t\t       quote = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[i]) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tquote = str[i];\n\t\t\tlast_quote = i;\n\t\t\tbreak;\n\t\tcase '|':\n\t\tcase '&':\n\t\t\tif (str[i+1] != str[i])\n\t\t\t\tbreak;\n\t\t\tis_pred = false;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tis_pred = false;\n\t\t\topen++;\n\t\t\tif (open > max_open)\n\t\t\t\tmax_open = open;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tis_pred = false;\n\t\t\tif (open == 1) {\n\t\t\t\t*err = i;\n\t\t\t\treturn TOO_MANY_CLOSE;\n\t\t\t}\n\t\t\topen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_pred) {\n\t\t\tnr_preds++;\n\t\t\tis_pred = true;\n\t\t}\n\t}\n\n\tif (quote) {\n\t\t*err = last_quote;\n\t\treturn MISSING_QUOTE;\n\t}\n\n\tif (open != 1) {\n\t\tint level = open;\n\n\t\t/* find the bad open */\n\t\tfor (i--; i; i--) {\n\t\t\tif (quote) {\n\t\t\t\tif (str[i] == quote)\n\t\t\t\t\tquote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\tif (level == open) {\n\t\t\t\t\t*err = i;\n\t\t\t\t\treturn TOO_MANY_OPEN;\n\t\t\t\t}\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tquote = str[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* First character is the '(' with missing ')' */\n\t\t*err = 0;\n\t\treturn TOO_MANY_OPEN;\n\t}\n\n\t/* Set the size of the required stacks */\n\t*parens = max_open;\n\t*preds = nr_preds;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic int calc_stack(const char *str, int *parens, int *preds, int *err)\n{\n\tbool is_pred = false;\n\tint nr_preds = 0;\n\tint open = 1; /* Count the expression as \"(E)\" */\n\tint last_quote = 0;\n\tint max_open = 1;\n\tint quote = 0;\n\tint i;\n\n\t*err = 0;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tif (isspace(str[i]))\n\t\t\tcontinue;\n\t\tif (quote) {\n\t\t\tif (str[i] == quote)\n\t\t\t       quote = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[i]) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tquote = str[i];\n\t\t\tlast_quote = i;\n\t\t\tbreak;\n\t\tcase '|':\n\t\tcase '&':\n\t\t\tif (str[i+1] != str[i])\n\t\t\t\tbreak;\n\t\t\tis_pred = false;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tis_pred = false;\n\t\t\topen++;\n\t\t\tif (open > max_open)\n\t\t\t\tmax_open = open;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tis_pred = false;\n\t\t\tif (open == 1) {\n\t\t\t\t*err = i;\n\t\t\t\treturn TOO_MANY_CLOSE;\n\t\t\t}\n\t\t\topen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_pred) {\n\t\t\tnr_preds++;\n\t\t\tis_pred = true;\n\t\t}\n\t}\n\n\tif (quote) {\n\t\t*err = last_quote;\n\t\treturn MISSING_QUOTE;\n\t}\n\n\tif (open != 1) {\n\t\tint level = open;\n\n\t\t/* find the bad open */\n\t\tfor (i--; i; i--) {\n\t\t\tif (quote) {\n\t\t\t\tif (str[i] == quote)\n\t\t\t\t\tquote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\tif (level == open) {\n\t\t\t\t\t*err = i;\n\t\t\t\t\treturn TOO_MANY_OPEN;\n\t\t\t\t}\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tquote = str[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* First character is the '(' with missing ')' */\n\t\t*err = 0;\n\t\treturn TOO_MANY_OPEN;\n\t}\n\n\t/* Set the size of the required stacks */\n\t*parens = max_open;\n\t*preds = nr_preds;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}"
  },
  {
    "function_name": "calc_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1529-1624",
    "snippet": "static int calc_stack(const char *str, int *parens, int *preds, int *err)\n{\n\tbool is_pred = false;\n\tint nr_preds = 0;\n\tint open = 1; /* Count the expression as \"(E)\" */\n\tint last_quote = 0;\n\tint max_open = 1;\n\tint quote = 0;\n\tint i;\n\n\t*err = 0;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tif (isspace(str[i]))\n\t\t\tcontinue;\n\t\tif (quote) {\n\t\t\tif (str[i] == quote)\n\t\t\t       quote = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[i]) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tquote = str[i];\n\t\t\tlast_quote = i;\n\t\t\tbreak;\n\t\tcase '|':\n\t\tcase '&':\n\t\t\tif (str[i+1] != str[i])\n\t\t\t\tbreak;\n\t\t\tis_pred = false;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tis_pred = false;\n\t\t\topen++;\n\t\t\tif (open > max_open)\n\t\t\t\tmax_open = open;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tis_pred = false;\n\t\t\tif (open == 1) {\n\t\t\t\t*err = i;\n\t\t\t\treturn TOO_MANY_CLOSE;\n\t\t\t}\n\t\t\topen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_pred) {\n\t\t\tnr_preds++;\n\t\t\tis_pred = true;\n\t\t}\n\t}\n\n\tif (quote) {\n\t\t*err = last_quote;\n\t\treturn MISSING_QUOTE;\n\t}\n\n\tif (open != 1) {\n\t\tint level = open;\n\n\t\t/* find the bad open */\n\t\tfor (i--; i; i--) {\n\t\t\tif (quote) {\n\t\t\t\tif (str[i] == quote)\n\t\t\t\t\tquote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\tif (level == open) {\n\t\t\t\t\t*err = i;\n\t\t\t\t\treturn TOO_MANY_OPEN;\n\t\t\t\t}\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tquote = str[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* First character is the '(' with missing ')' */\n\t\t*err = 0;\n\t\treturn TOO_MANY_OPEN;\n\t}\n\n\t/* Set the size of the required stacks */\n\t*parens = max_open;\n\t*preds = nr_preds;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "str[i]"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic int calc_stack(const char *str, int *parens, int *preds, int *err)\n{\n\tbool is_pred = false;\n\tint nr_preds = 0;\n\tint open = 1; /* Count the expression as \"(E)\" */\n\tint last_quote = 0;\n\tint max_open = 1;\n\tint quote = 0;\n\tint i;\n\n\t*err = 0;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tif (isspace(str[i]))\n\t\t\tcontinue;\n\t\tif (quote) {\n\t\t\tif (str[i] == quote)\n\t\t\t       quote = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[i]) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tquote = str[i];\n\t\t\tlast_quote = i;\n\t\t\tbreak;\n\t\tcase '|':\n\t\tcase '&':\n\t\t\tif (str[i+1] != str[i])\n\t\t\t\tbreak;\n\t\t\tis_pred = false;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tis_pred = false;\n\t\t\topen++;\n\t\t\tif (open > max_open)\n\t\t\t\tmax_open = open;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tis_pred = false;\n\t\t\tif (open == 1) {\n\t\t\t\t*err = i;\n\t\t\t\treturn TOO_MANY_CLOSE;\n\t\t\t}\n\t\t\topen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_pred) {\n\t\t\tnr_preds++;\n\t\t\tis_pred = true;\n\t\t}\n\t}\n\n\tif (quote) {\n\t\t*err = last_quote;\n\t\treturn MISSING_QUOTE;\n\t}\n\n\tif (open != 1) {\n\t\tint level = open;\n\n\t\t/* find the bad open */\n\t\tfor (i--; i; i--) {\n\t\t\tif (quote) {\n\t\t\t\tif (str[i] == quote)\n\t\t\t\t\tquote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\tif (level == open) {\n\t\t\t\t\t*err = i;\n\t\t\t\t\treturn TOO_MANY_OPEN;\n\t\t\t\t}\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tquote = str[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* First character is the '(' with missing ')' */\n\t\t*err = 0;\n\t\treturn TOO_MANY_OPEN;\n\t}\n\n\t/* Set the size of the required stacks */\n\t*parens = max_open;\n\t*preds = nr_preds;\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_pred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1249-1511",
    "snippet": "static int parse_pred(const char *str, void *data,\n\t\t      int pos, struct filter_parse_error *pe,\n\t\t      struct filter_pred **pred_ptr)\n{\n\tstruct trace_event_call *call = data;\n\tstruct ftrace_event_field *field;\n\tstruct filter_pred *pred = NULL;\n\tchar num_buf[24];\t/* Big enough to hold an address */\n\tchar *field_name;\n\tbool ustring = false;\n\tchar q;\n\tu64 val;\n\tint len;\n\tint ret;\n\tint op;\n\tint s;\n\tint i = 0;\n\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\n\tlen = i - s;\n\n\tif (!len)\n\t\treturn -1;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\n\t/* Make sure that the field exists */\n\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field) {\n\t\tparse_error(pe, FILT_ERR_FIELD_NOT_FOUND, pos + i);\n\t\treturn -EINVAL;\n\t}\n\n\t/* See if the field is a user space string */\n\tif ((len = str_has_prefix(str + i, \".ustring\"))) {\n\t\tustring = true;\n\t\ti += len;\n\t}\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\t/* Make sure this op is supported */\n\tfor (op = 0; ops[op]; op++) {\n\t\t/* This is why '<=' must come before '<' in ops[] */\n\t\tif (strncmp(str + i, ops[op], strlen(ops[op])) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ops[op]) {\n\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\tgoto err_free;\n\t}\n\n\ti += strlen(ops[op]);\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\ts = i;\n\n\tpred = kzalloc(sizeof(*pred), GFP_KERNEL);\n\tif (!pred)\n\t\treturn -ENOMEM;\n\n\tpred->field = field;\n\tpred->offset = field->offset;\n\tpred->op = op;\n\n\tif (ftrace_event_is_function(call)) {\n\t\t/*\n\t\t * Perf does things different with function events.\n\t\t * It only allows an \"ip\" field, and expects a string.\n\t\t * But the string does not need to be surrounded by quotes.\n\t\t * If it is a string, the assigned function as a nop,\n\t\t * (perf doesn't use it) and grab everything.\n\t\t */\n\t\tif (strcmp(field->name, \"ip\") != 0) {\n\t\t\tparse_error(pe, FILT_ERR_IP_FIELD_ONLY, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\t\tpred->fn = filter_pred_none;\n\n\t\t/*\n\t\t * Quotes are not required, but if they exist then we need\n\t\t * to read them till we hit a matching one.\n\t\t */\n\t\tif (str[i] == '\\'' || str[i] == '\"')\n\t\t\tq = str[i];\n\t\telse\n\t\t\tq = 0;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (q && str[i] == q)\n\t\t\t\tbreak;\n\t\t\tif (!q && (str[i] == ')' || str[i] == '&' ||\n\t\t\t\t   str[i] == '|'))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Skip quotes */\n\t\tif (q)\n\t\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t/* This is either a string, or an integer */\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the op is OK for strings */\n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\t\tpred->not = 1;\n\t\t\tfallthrough;\n\t\tcase OP_GLOB:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_DIGIT, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i]) {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t\tfilter_build_regex(pred);\n\n\t\tif (field->filter_type == FILTER_COMM) {\n\t\t\tpred->fn = filter_pred_comm;\n\n\t\t} else if (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\tpred->fn = filter_pred_string;\n\t\t\tpred->regex.field_len = field->size;\n\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\tpred->fn = filter_pred_strloc;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\tpred->fn = filter_pred_strrelloc;\n\t\telse {\n\n\t\t\tif (!ustring_per_cpu) {\n\t\t\t\t/* Once allocated, keep it around for good */\n\t\t\t\tustring_per_cpu = alloc_percpu(struct ustring_buffer);\n\t\t\t\tif (!ustring_per_cpu)\n\t\t\t\t\tgoto err_mem;\n\t\t\t}\n\n\t\t\tif (ustring)\n\t\t\t\tpred->fn = filter_pred_pchar_user;\n\t\t\telse\n\t\t\t\tpred->fn = filter_pred_pchar;\n\t\t}\n\t\t/* go past the last quote */\n\t\ti++;\n\n\t} else if (isdigit(str[i]) || str[i] == '-') {\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_STRING, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (op == OP_GLOB) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\n\t\tlen = i - s;\n\t\t/* 0xfeedfacedeadbeef is 18 chars max */\n\t\tif (len >= sizeof(num_buf)) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tstrncpy(num_buf, str + s, len);\n\t\tnum_buf[len] = 0;\n\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num_buf, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num_buf, 0, &val);\n\t\tif (ret) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_INTVAL, pos + s);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->val = val;\n\n\t\tif (field->filter_type == FILTER_CPU)\n\t\t\tpred->fn = filter_pred_cpu;\n\t\telse {\n\t\t\tpred->fn = select_comparison_fn(pred->op, field->size,\n\t\t\t\t\t\t\tfield->is_signed);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t}\n\n\t} else {\n\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\tgoto err_free;\n\t}\n\n\t*pred_ptr = pred;\n\treturn i;\n\nerr_free:\n\tkfree(pred);\n\treturn -EINVAL;\nerr_mem:\n\tkfree(pred);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * ops[] = { OPS };",
      "static __percpu struct",
      "ustring_buffer *ustring_per_cpu;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pred"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_error",
          "args": [
            "pe",
            "FILT_ERR_INVALID_VALUE",
            "pos + i"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "parse_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "134-138",
          "snippet": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_comparison_fn",
          "args": [
            "pred->op",
            "field->size",
            "field->is_signed"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "select_comparison_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1192-1246",
          "snippet": "static filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t    int field_size, int field_is_signed)\n{\n\tfilter_pred_fn_t fn = NULL;\n\tint pred_func_index = -1;\n\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn NULL;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn NULL;\n\t}\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s64[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u64[pred_func_index];\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s32[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u32[pred_func_index];\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s16[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u16[pred_func_index];\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s8[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u8[pred_func_index];\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define PRED_FUNC_MAX\t\t\t(OP_BAND - PRED_FUNC_START)",
            "#define PRED_FUNC_START\t\t\tOP_LE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define PRED_FUNC_MAX\t\t\t(OP_BAND - PRED_FUNC_START)\n#define PRED_FUNC_START\t\t\tOP_LE\n\nstatic filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t    int field_size, int field_is_signed)\n{\n\tfilter_pred_fn_t fn = NULL;\n\tint pred_func_index = -1;\n\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn NULL;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn NULL;\n\t}\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s64[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u64[pred_func_index];\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s32[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u32[pred_func_index];\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s16[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u16[pred_func_index];\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s8[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u8[pred_func_index];\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "num_buf",
            "0",
            "&val"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoll",
          "args": [
            "num_buf",
            "0",
            "&val"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "num_buf",
            "str + s",
            "len"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "str[i]"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_string_field",
          "args": [
            "field"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "is_string_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1470-1477",
          "snippet": "static inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "str[i]"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structustring_buffer"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_build_regex",
          "args": [
            "pred"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "filter_build_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "956-987",
          "snippet": "static void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->regex;\n\tchar *search;\n\tenum regex_type type = MATCH_FULL;\n\n\tif (pred->op == OP_GLOB) {\n\t\ttype = filter_parse_regex(r->pattern, r->len, &search, &pred->not);\n\t\tr->len = strlen(search);\n\t\tmemmove(r->pattern, search, r->len+1);\n\t}\n\n\tswitch (type) {\n\t/* MATCH_INDEX should not happen, but if it does, match full */\n\tcase MATCH_INDEX:\n\tcase MATCH_FULL:\n\t\tr->match = regex_match_full;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tr->match = regex_match_front;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tr->match = regex_match_middle;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tr->match = regex_match_end;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tr->match = regex_match_glob;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->regex;\n\tchar *search;\n\tenum regex_type type = MATCH_FULL;\n\n\tif (pred->op == OP_GLOB) {\n\t\ttype = filter_parse_regex(r->pattern, r->len, &search, &pred->not);\n\t\tr->len = strlen(search);\n\t\tmemmove(r->pattern, search, r->len+1);\n\t}\n\n\tswitch (type) {\n\t/* MATCH_INDEX should not happen, but if it does, match full */\n\tcase MATCH_INDEX:\n\tcase MATCH_FULL:\n\t\tr->match = regex_match_full;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tr->match = regex_match_front;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tr->match = regex_match_middle;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tr->match = regex_match_end;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tr->match = regex_match_glob;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pred->regex.pattern",
            "str + s",
            "len"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pred->regex.pattern",
            "str + s",
            "len"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->name",
            "\"ip\""
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_is_function",
          "args": [
            "call"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_is_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_export.c",
          "lines": "186-189",
          "snippet": "bool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_output.h\"",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stringify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_output.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stringify.h>\n\nbool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pred)",
            "GFP_KERNEL"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "str[i]"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ops[op]"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str + i",
            "ops[op]",
            "strlen(ops[op])"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "str[i]"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str + i",
            "\".ustring\""
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_find_event_field",
          "args": [
            "call",
            "field_name"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_event_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "89-105",
          "snippet": "struct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ftrace_generic_fields);",
            "static LIST_HEAD(ftrace_common_fields);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(ftrace_generic_fields);\nstatic LIST_HEAD(ftrace_common_fields);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup_nul",
          "args": [
            "str + s",
            "len",
            "GFP_KERNEL"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "str[i]"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "str[i]"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char * ops[] = { OPS };\nstatic __percpu struct;\nustring_buffer *ustring_per_cpu;\n\nstatic int parse_pred(const char *str, void *data,\n\t\t      int pos, struct filter_parse_error *pe,\n\t\t      struct filter_pred **pred_ptr)\n{\n\tstruct trace_event_call *call = data;\n\tstruct ftrace_event_field *field;\n\tstruct filter_pred *pred = NULL;\n\tchar num_buf[24];\t/* Big enough to hold an address */\n\tchar *field_name;\n\tbool ustring = false;\n\tchar q;\n\tu64 val;\n\tint len;\n\tint ret;\n\tint op;\n\tint s;\n\tint i = 0;\n\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\n\tlen = i - s;\n\n\tif (!len)\n\t\treturn -1;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\n\t/* Make sure that the field exists */\n\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field) {\n\t\tparse_error(pe, FILT_ERR_FIELD_NOT_FOUND, pos + i);\n\t\treturn -EINVAL;\n\t}\n\n\t/* See if the field is a user space string */\n\tif ((len = str_has_prefix(str + i, \".ustring\"))) {\n\t\tustring = true;\n\t\ti += len;\n\t}\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\t/* Make sure this op is supported */\n\tfor (op = 0; ops[op]; op++) {\n\t\t/* This is why '<=' must come before '<' in ops[] */\n\t\tif (strncmp(str + i, ops[op], strlen(ops[op])) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ops[op]) {\n\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\tgoto err_free;\n\t}\n\n\ti += strlen(ops[op]);\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\ts = i;\n\n\tpred = kzalloc(sizeof(*pred), GFP_KERNEL);\n\tif (!pred)\n\t\treturn -ENOMEM;\n\n\tpred->field = field;\n\tpred->offset = field->offset;\n\tpred->op = op;\n\n\tif (ftrace_event_is_function(call)) {\n\t\t/*\n\t\t * Perf does things different with function events.\n\t\t * It only allows an \"ip\" field, and expects a string.\n\t\t * But the string does not need to be surrounded by quotes.\n\t\t * If it is a string, the assigned function as a nop,\n\t\t * (perf doesn't use it) and grab everything.\n\t\t */\n\t\tif (strcmp(field->name, \"ip\") != 0) {\n\t\t\tparse_error(pe, FILT_ERR_IP_FIELD_ONLY, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\t\tpred->fn = filter_pred_none;\n\n\t\t/*\n\t\t * Quotes are not required, but if they exist then we need\n\t\t * to read them till we hit a matching one.\n\t\t */\n\t\tif (str[i] == '\\'' || str[i] == '\"')\n\t\t\tq = str[i];\n\t\telse\n\t\t\tq = 0;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (q && str[i] == q)\n\t\t\t\tbreak;\n\t\t\tif (!q && (str[i] == ')' || str[i] == '&' ||\n\t\t\t\t   str[i] == '|'))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Skip quotes */\n\t\tif (q)\n\t\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t/* This is either a string, or an integer */\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the op is OK for strings */\n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\t\tpred->not = 1;\n\t\t\tfallthrough;\n\t\tcase OP_GLOB:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_DIGIT, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i]) {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t\tfilter_build_regex(pred);\n\n\t\tif (field->filter_type == FILTER_COMM) {\n\t\t\tpred->fn = filter_pred_comm;\n\n\t\t} else if (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\tpred->fn = filter_pred_string;\n\t\t\tpred->regex.field_len = field->size;\n\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\tpred->fn = filter_pred_strloc;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\tpred->fn = filter_pred_strrelloc;\n\t\telse {\n\n\t\t\tif (!ustring_per_cpu) {\n\t\t\t\t/* Once allocated, keep it around for good */\n\t\t\t\tustring_per_cpu = alloc_percpu(struct ustring_buffer);\n\t\t\t\tif (!ustring_per_cpu)\n\t\t\t\t\tgoto err_mem;\n\t\t\t}\n\n\t\t\tif (ustring)\n\t\t\t\tpred->fn = filter_pred_pchar_user;\n\t\t\telse\n\t\t\t\tpred->fn = filter_pred_pchar;\n\t\t}\n\t\t/* go past the last quote */\n\t\ti++;\n\n\t} else if (isdigit(str[i]) || str[i] == '-') {\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_STRING, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (op == OP_GLOB) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\n\t\tlen = i - s;\n\t\t/* 0xfeedfacedeadbeef is 18 chars max */\n\t\tif (len >= sizeof(num_buf)) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tstrncpy(num_buf, str + s, len);\n\t\tnum_buf[len] = 0;\n\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num_buf, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num_buf, 0, &val);\n\t\tif (ret) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_INTVAL, pos + s);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->val = val;\n\n\t\tif (field->filter_type == FILTER_CPU)\n\t\t\tpred->fn = filter_pred_cpu;\n\t\telse {\n\t\t\tpred->fn = select_comparison_fn(pred->op, field->size,\n\t\t\t\t\t\t\tfield->is_signed);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t}\n\n\t} else {\n\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\tgoto err_free;\n\t}\n\n\t*pred_ptr = pred;\n\treturn i;\n\nerr_free:\n\tkfree(pred);\n\treturn -EINVAL;\nerr_mem:\n\tkfree(pred);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "select_comparison_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1192-1246",
    "snippet": "static filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t    int field_size, int field_is_signed)\n{\n\tfilter_pred_fn_t fn = NULL;\n\tint pred_func_index = -1;\n\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn NULL;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn NULL;\n\t}\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s64[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u64[pred_func_index];\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s32[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u32[pred_func_index];\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s16[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u16[pred_func_index];\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s8[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u8[pred_func_index];\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define PRED_FUNC_MAX\t\t\t(OP_BAND - PRED_FUNC_START)",
      "#define PRED_FUNC_START\t\t\tOP_LE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pred_func_index > PRED_FUNC_MAX"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "op < PRED_FUNC_START"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define PRED_FUNC_MAX\t\t\t(OP_BAND - PRED_FUNC_START)\n#define PRED_FUNC_START\t\t\tOP_LE\n\nstatic filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t    int field_size, int field_is_signed)\n{\n\tfilter_pred_fn_t fn = NULL;\n\tint pred_func_index = -1;\n\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn NULL;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn NULL;\n\t}\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s64[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u64[pred_func_index];\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s32[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u32[pred_func_index];\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s16[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u16[pred_func_index];\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s8[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u8[pred_func_index];\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
  },
  {
    "function_name": "filter_assign_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1175-1190",
    "snippet": "int filter_assign_type(const char *type)\n{\n\tif (strstr(type, \"__data_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_DYN_STRING;\n\n\tif (strstr(type, \"__rel_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_RDYN_STRING;\n\n\tif (strchr(type, '[') && strstr(type, \"char\"))\n\t\treturn FILTER_STATIC_STRING;\n\n\tif (strcmp(type, \"char *\") == 0 || strcmp(type, \"const char *\") == 0)\n\t\treturn FILTER_PTR_STRING;\n\n\treturn FILTER_OTHER;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"const char *\""
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"char\""
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "type",
            "'['"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"char\""
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"__rel_loc\""
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"char\""
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"__data_loc\""
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nint filter_assign_type(const char *type)\n{\n\tif (strstr(type, \"__data_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_DYN_STRING;\n\n\tif (strstr(type, \"__rel_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_RDYN_STRING;\n\n\tif (strchr(type, '[') && strstr(type, \"char\"))\n\t\treturn FILTER_STATIC_STRING;\n\n\tif (strcmp(type, \"char *\") == 0 || strcmp(type, \"const char *\") == 0)\n\t\treturn FILTER_PTR_STRING;\n\n\treturn FILTER_OTHER;\n}"
  },
  {
    "function_name": "filter_free_subsystem_filters",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1163-1173",
    "snippet": "static void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n\t\t\t\t\t  struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__free_subsystem_filter(file);\n\t}\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_subsystem_filter",
          "args": [
            "file"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "__free_subsystem_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1157-1161",
          "snippet": "static inline void __free_subsystem_filter(struct trace_event_file *file)\n{\n\t__free_filter(file->filter);\n\tfile->filter = NULL;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void __free_subsystem_filter(struct trace_event_file *file)\n{\n\t__free_filter(file->filter);\n\tfile->filter = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n\t\t\t\t\t  struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__free_subsystem_filter(file);\n\t}\n}"
  },
  {
    "function_name": "__free_subsystem_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1157-1161",
    "snippet": "static inline void __free_subsystem_filter(struct trace_event_file *file)\n{\n\t__free_filter(file->filter);\n\tfile->filter = NULL;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "file->filter"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1124-1132",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void __free_subsystem_filter(struct trace_event_file *file)\n{\n\t__free_filter(file->filter);\n\tfile->filter = NULL;\n}"
  },
  {
    "function_name": "filter_free_subsystem_preds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1145-1155",
    "snippet": "static void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__remove_filter(file);\n\t}\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__remove_filter",
          "args": [
            "file"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1139-1143",
          "snippet": "static inline void __remove_filter(struct trace_event_file *file)\n{\n\tfilter_disable(file);\n\tremove_filter_string(file->filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void __remove_filter(struct trace_event_file *file)\n{\n\tfilter_disable(file);\n\tremove_filter_string(file->filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__remove_filter(file);\n\t}\n}"
  },
  {
    "function_name": "__remove_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1139-1143",
    "snippet": "static inline void __remove_filter(struct trace_event_file *file)\n{\n\tfilter_disable(file);\n\tremove_filter_string(file->filter);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_filter_string",
          "args": [
            "file->filter"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "remove_filter_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1014-1021",
          "snippet": "static void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_disable",
          "args": [
            "file"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "filter_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1114-1122",
          "snippet": "static void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline void __remove_filter(struct trace_event_file *file)\n{\n\tfilter_disable(file);\n\tremove_filter_string(file->filter);\n}"
  },
  {
    "function_name": "free_event_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1134-1137",
    "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1124-1132",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
  },
  {
    "function_name": "__free_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1124-1132",
    "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filter"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_prog",
          "args": [
            "filter"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "free_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1100-1112",
          "snippet": "static void free_prog(struct event_filter *filter)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\tprog = rcu_access_pointer(filter->prog);\n\tif (!prog)\n\t\treturn;\n\n\tfor (i = 0; prog[i].pred; i++)\n\t\tkfree(prog[i].pred);\n\tkfree(prog);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void free_prog(struct event_filter *filter)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\tprog = rcu_access_pointer(filter->prog);\n\tif (!prog)\n\t\treturn;\n\n\tfor (i = 0; prog[i].pred; i++)\n\t\tkfree(prog[i].pred);\n\tkfree(prog);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
  },
  {
    "function_name": "filter_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1114-1122",
    "snippet": "static void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffered_event_disable",
          "args": [],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffered_event_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2699-2735",
          "snippet": "void trace_buffered_event_disable(void)\n{\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (WARN_ON_ONCE(!trace_buffered_event_ref))\n\t\treturn;\n\n\tif (--trace_buffered_event_ref)\n\t\treturn;\n\n\tpreempt_disable();\n\t/* For each CPU, set the buffer as used. */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       disable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n\n\t/* Wait for all current users to finish */\n\tsynchronize_rcu();\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tfree_page((unsigned long)per_cpu(trace_buffered_event, cpu));\n\t\tper_cpu(trace_buffered_event, cpu) = NULL;\n\t}\n\t/*\n\t * Make sure trace_buffered_event is NULL before clearing\n\t * trace_buffered_event_cnt.\n\t */\n\tsmp_wmb();\n\n\tpreempt_disable();\n\t/* Do the work on each cpu */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       enable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_buffered_event_ref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int trace_buffered_event_ref;\n\nvoid trace_buffered_event_disable(void)\n{\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (WARN_ON_ONCE(!trace_buffered_event_ref))\n\t\treturn;\n\n\tif (--trace_buffered_event_ref)\n\t\treturn;\n\n\tpreempt_disable();\n\t/* For each CPU, set the buffer as used. */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       disable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n\n\t/* Wait for all current users to finish */\n\tsynchronize_rcu();\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tfree_page((unsigned long)per_cpu(trace_buffered_event, cpu));\n\t\tper_cpu(trace_buffered_event, cpu) = NULL;\n\t}\n\t/*\n\t * Make sure trace_buffered_event is NULL before clearing\n\t * trace_buffered_event_cnt.\n\t */\n\tsmp_wmb();\n\n\tpreempt_disable();\n\t/* Do the work on each cpu */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       enable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}"
  },
  {
    "function_name": "free_prog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1100-1112",
    "snippet": "static void free_prog(struct event_filter *filter)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\tprog = rcu_access_pointer(filter->prog);\n\tif (!prog)\n\t\treturn;\n\n\tfor (i = 0; prog[i].pred; i++)\n\t\tkfree(prog[i].pred);\n\tkfree(prog);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "prog"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "filter->prog"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void free_prog(struct event_filter *filter)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\tprog = rcu_access_pointer(filter->prog);\n\tif (!prog)\n\t\treturn;\n\n\tfor (i = 0; prog[i].pred; i++)\n\t\tkfree(prog[i].pred);\n\tkfree(prog);\n}"
  },
  {
    "function_name": "print_subsystem_event_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1086-1098",
    "snippet": "void print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t  struct trace_seq *s)\n{\n\tstruct event_filter *filter;\n\n\tmutex_lock(&event_mutex);\n\tfilter = system->filter;\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define DEFAULT_SYS_FILTER_MESSAGE\t\t\t\t\t\\\n\t\"### global filter ###\\n\"\t\t\t\t\t\\\n\t\"# Use this to set filters for multiple events.\\n\"\t\t\\\n\t\"# Only events with the given fields will be affected.\\n\"\t\\\n\t\"# If no events are modified, an error message will be displayed here\""
    ],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "DEFAULT_SYS_FILTER_MESSAGE \"\\n\""
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s\\n\"",
            "filter->filter_string"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define DEFAULT_SYS_FILTER_MESSAGE\t\t\t\t\t\\\n\t\"### global filter ###\\n\"\t\t\t\t\t\\\n\t\"# Use this to set filters for multiple events.\\n\"\t\t\\\n\t\"# Only events with the given fields will be affected.\\n\"\t\\\n\t\"# If no events are modified, an error message will be displayed here\"\n\nstatic __percpu struct;\n\nvoid print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t  struct trace_seq *s)\n{\n\tstruct event_filter *filter;\n\n\tmutex_lock(&event_mutex);\n\tfilter = system->filter;\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "print_event_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1076-1084",
    "snippet": "void print_event_filter(struct trace_event_file *file, struct trace_seq *s)\n{\n\tstruct event_filter *filter = event_filter(file);\n\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, \"none\\n\");\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"none\\n\""
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s\\n\"",
            "filter->filter_string"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_filter",
          "args": [
            "file"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1134-1137",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nvoid print_event_filter(struct trace_event_file *file, struct trace_seq *s)\n{\n\tstruct event_filter *filter = event_filter(file);\n\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, \"none\\n\");\n}"
  },
  {
    "function_name": "event_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1070-1073",
    "snippet": "static inline struct event_filter *event_filter(struct trace_event_file *file)\n{\n\treturn file->filter;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic inline struct event_filter *event_filter(struct trace_event_file *file)\n{\n\treturn file->filter;\n}"
  },
  {
    "function_name": "append_filter_err",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1023-1068",
    "snippet": "static void append_filter_err(struct trace_array *tr,\n\t\t\t      struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tpe->lasterr, pe->lasterr_pos);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tFILT_ERR_ERRNO, 0);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *err_text[] = { ERRORS };",
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup_nul",
          "args": [
            "s->buffer",
            "s->seq.len",
            "GFP_KERNEL"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "0"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_log_err",
          "args": [
            "tr",
            "\"event filter parse error\"",
            "filter->filter_string",
            "err_text",
            "FILT_ERR_ERRNO",
            "0"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "7807-7833",
          "snippet": "void tracing_log_err(struct trace_array *tr,\n\t\t     const char *loc, const char *cmd,\n\t\t     const char **errs, u8 type, u8 pos)\n{\n\tstruct tracing_log_err *err;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tmutex_lock(&tracing_err_log_lock);\n\terr = get_tracing_log_err(tr);\n\tif (PTR_ERR(err) == -ENOMEM) {\n\t\tmutex_unlock(&tracing_err_log_lock);\n\t\treturn;\n\t}\n\n\tsnprintf(err->loc, TRACING_LOG_LOC_MAX, \"%s: error: \", loc);\n\tsnprintf(err->cmd, MAX_FILTER_STR_VAL,\"\\n\" CMD_PREFIX \"%s\\n\", cmd);\n\n\terr->info.errs = errs;\n\terr->info.type = type;\n\terr->info.pos = pos;\n\terr->info.ts = local_clock();\n\n\tlist_add_tail(&err->list, &tr->err_log);\n\tmutex_unlock(&tracing_err_log_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define CMD_PREFIX \"  Command: \"",
            "#define TRACING_LOG_LOC_MAX\t128"
          ],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static DEFINE_MUTEX(tracing_err_log_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define CMD_PREFIX \"  Command: \"\n#define TRACING_LOG_LOC_MAX\t128\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic DEFINE_MUTEX(tracing_err_log_lock);\n\nvoid tracing_log_err(struct trace_array *tr,\n\t\t     const char *loc, const char *cmd,\n\t\t     const char **errs, u8 type, u8 pos)\n{\n\tstruct tracing_log_err *err;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tmutex_lock(&tracing_err_log_lock);\n\terr = get_tracing_log_err(tr);\n\tif (PTR_ERR(err) == -ENOMEM) {\n\t\tmutex_unlock(&tracing_err_log_lock);\n\t\treturn;\n\t}\n\n\tsnprintf(err->loc, TRACING_LOG_LOC_MAX, \"%s: error: \", loc);\n\tsnprintf(err->cmd, MAX_FILTER_STR_VAL,\"\\n\" CMD_PREFIX \"%s\\n\", cmd);\n\n\terr->info.errs = errs;\n\terr->info.type = type;\n\terr->info.pos = pos;\n\terr->info.ts = local_clock();\n\n\tlist_add_tail(&err->list, &tr->err_log);\n\tmutex_unlock(&tracing_err_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"\\nError: (%d)\\n\"",
            "pe->lasterr"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "filter->filter_string"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filter->filter_string"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "s"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "36-40",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*s)",
            "GFP_KERNEL"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!filter->filter_string"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic __percpu struct;\n\nstatic void append_filter_err(struct trace_array *tr,\n\t\t\t      struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tpe->lasterr, pe->lasterr_pos);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tFILT_ERR_ERRNO, 0);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}"
  },
  {
    "function_name": "remove_filter_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "1014-1021",
    "snippet": "static void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filter->filter_string"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}"
  },
  {
    "function_name": "filter_match_preds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "990-1011",
    "snippet": "int filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred->fn",
          "args": [
            "pred",
            "rec"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "filter->prog"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nint filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}"
  },
  {
    "function_name": "filter_build_regex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "956-987",
    "snippet": "static void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->regex;\n\tchar *search;\n\tenum regex_type type = MATCH_FULL;\n\n\tif (pred->op == OP_GLOB) {\n\t\ttype = filter_parse_regex(r->pattern, r->len, &search, &pred->not);\n\t\tr->len = strlen(search);\n\t\tmemmove(r->pattern, search, r->len+1);\n\t}\n\n\tswitch (type) {\n\t/* MATCH_INDEX should not happen, but if it does, match full */\n\tcase MATCH_INDEX:\n\tcase MATCH_FULL:\n\t\tr->match = regex_match_full;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tr->match = regex_match_front;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tr->match = regex_match_middle;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tr->match = regex_match_end;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tr->match = regex_match_glob;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "r->pattern",
            "search",
            "r->len+1"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "search"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_parse_regex",
          "args": [
            "r->pattern",
            "r->len",
            "&search",
            "&pred->not"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "filter_parse_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "915-954",
          "snippet": "enum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->regex;\n\tchar *search;\n\tenum regex_type type = MATCH_FULL;\n\n\tif (pred->op == OP_GLOB) {\n\t\ttype = filter_parse_regex(r->pattern, r->len, &search, &pred->not);\n\t\tr->len = strlen(search);\n\t\tmemmove(r->pattern, search, r->len+1);\n\t}\n\n\tswitch (type) {\n\t/* MATCH_INDEX should not happen, but if it does, match full */\n\tcase MATCH_INDEX:\n\tcase MATCH_FULL:\n\t\tr->match = regex_match_full;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tr->match = regex_match_front;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tr->match = regex_match_middle;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tr->match = regex_match_end;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tr->match = regex_match_glob;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "filter_parse_regex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "915-954",
    "snippet": "enum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"[?\\\\\"",
            "buff[i]"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "buff[0]"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}"
  },
  {
    "function_name": "regex_match_glob",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "891-896",
    "snippet": "static int regex_match_glob(char *str, struct regex *r, int len __maybe_unused)\n{\n\tif (glob_match(r->pattern, str))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "glob_match",
          "args": [
            "r->pattern",
            "str"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int regex_match_glob(char *str, struct regex *r, int len __maybe_unused)\n{\n\tif (glob_match(r->pattern, str))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "regex_match_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "881-889",
    "snippet": "static int regex_match_end(char *str, struct regex *r, int len)\n{\n\tint strlen = len - 1;\n\n\tif (strlen >= r->len &&\n\t    memcmp(str + strlen - r->len, r->pattern, r->len) == 0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "str + strlen - r->len",
            "r->pattern",
            "r->len"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int regex_match_end(char *str, struct regex *r, int len)\n{\n\tint strlen = len - 1;\n\n\tif (strlen >= r->len &&\n\t    memcmp(str + strlen - r->len, r->pattern, r->len) == 0)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "regex_match_middle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "873-879",
    "snippet": "static int regex_match_middle(char *str, struct regex *r, int len)\n{\n\tif (!len)\n\t\treturn strstr(str, r->pattern) != NULL;\n\n\treturn strnstr(str, r->pattern, len) != NULL;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "str",
            "r->pattern",
            "len"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "r->pattern"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int regex_match_middle(char *str, struct regex *r, int len)\n{\n\tif (!len)\n\t\treturn strstr(str, r->pattern) != NULL;\n\n\treturn strnstr(str, r->pattern, len) != NULL;\n}"
  },
  {
    "function_name": "regex_match_front",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "865-871",
    "snippet": "static int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "r->pattern",
            "r->len"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}"
  },
  {
    "function_name": "regex_match_full",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "856-863",
    "snippet": "static int regex_match_full(char *str, struct regex *r, int len)\n{\n\t/* len of zero means str is dynamic and ends with '\\0' */\n\tif (!len)\n\t\treturn strcmp(str, r->pattern) == 0;\n\n\treturn strncmp(str, r->pattern, len) == 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "r->pattern",
            "len"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "r->pattern"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int regex_match_full(char *str, struct regex *r, int len)\n{\n\t/* len of zero means str is dynamic and ends with '\\0' */\n\tif (!len)\n\t\treturn strcmp(str, r->pattern) == 0;\n\n\treturn strncmp(str, r->pattern, len) == 0;\n}"
  },
  {
    "function_name": "filter_pred_none",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "839-842",
    "snippet": "static int filter_pred_none(struct filter_pred *pred, void *event)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int filter_pred_none(struct filter_pred *pred, void *event)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "filter_pred_comm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "830-837",
    "snippet": "static int filter_pred_comm(struct filter_pred *pred, void *event)\n{\n\tint cmp;\n\n\tcmp = pred->regex.match(current->comm, &pred->regex,\n\t\t\t\tTASK_COMM_LEN);\n\treturn cmp ^ pred->not;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred->regex.match",
          "args": [
            "current->comm",
            "&pred->regex",
            "TASK_COMM_LEN"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int filter_pred_comm(struct filter_pred *pred, void *event)\n{\n\tint cmp;\n\n\tcmp = pred->regex.match(current->comm, &pred->regex,\n\t\t\t\tTASK_COMM_LEN);\n\treturn cmp ^ pred->not;\n}"
  },
  {
    "function_name": "filter_pred_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "804-827",
    "snippet": "static int filter_pred_cpu(struct filter_pred *pred, void *event)\n{\n\tint cpu, cmp;\n\n\tcpu = raw_smp_processor_id();\n\tcmp = pred->val;\n\n\tswitch (pred->op) {\n\tcase OP_EQ:\n\t\treturn cpu == cmp;\n\tcase OP_NE:\n\t\treturn cpu != cmp;\n\tcase OP_LT:\n\t\treturn cpu < cmp;\n\tcase OP_LE:\n\t\treturn cpu <= cmp;\n\tcase OP_GT:\n\t\treturn cpu > cmp;\n\tcase OP_GE:\n\t\treturn cpu >= cmp;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int filter_pred_cpu(struct filter_pred *pred, void *event)\n{\n\tint cpu, cmp;\n\n\tcpu = raw_smp_processor_id();\n\tcmp = pred->val;\n\n\tswitch (pred->op) {\n\tcase OP_EQ:\n\t\treturn cpu == cmp;\n\tcase OP_NE:\n\t\treturn cpu != cmp;\n\tcase OP_LT:\n\t\treturn cpu < cmp;\n\tcase OP_LE:\n\t\treturn cpu <= cmp;\n\tcase OP_GT:\n\t\treturn cpu > cmp;\n\tcase OP_GE:\n\t\treturn cpu >= cmp;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "filter_pred_strrelloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "787-801",
    "snippet": "static int filter_pred_strrelloc(struct filter_pred *pred, void *event)\n{\n\tu32 *item = (u32 *)(event + pred->offset);\n\tu32 str_item = *item;\n\tint str_loc = str_item & 0xffff;\n\tint str_len = str_item >> 16;\n\tchar *addr = (char *)(&item[1]) + str_loc;\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, str_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred->regex.match",
          "args": [
            "addr",
            "&pred->regex",
            "str_len"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int filter_pred_strrelloc(struct filter_pred *pred, void *event)\n{\n\tu32 *item = (u32 *)(event + pred->offset);\n\tu32 str_item = *item;\n\tint str_loc = str_item & 0xffff;\n\tint str_len = str_item >> 16;\n\tchar *addr = (char *)(&item[1]) + str_loc;\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, str_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}"
  },
  {
    "function_name": "filter_pred_strloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "765-778",
    "snippet": "static int filter_pred_strloc(struct filter_pred *pred, void *event)\n{\n\tu32 str_item = *(u32 *)(event + pred->offset);\n\tint str_loc = str_item & 0xffff;\n\tint str_len = str_item >> 16;\n\tchar *addr = (char *)(event + str_loc);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, str_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred->regex.match",
          "args": [
            "addr",
            "&pred->regex",
            "str_len"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int filter_pred_strloc(struct filter_pred *pred, void *event)\n{\n\tu32 str_item = *(u32 *)(event + pred->offset);\n\tint str_loc = str_item & 0xffff;\n\tint str_len = str_item >> 16;\n\tchar *addr = (char *)(event + str_loc);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, str_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}"
  },
  {
    "function_name": "filter_pred_pchar_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "743-753",
    "snippet": "static int filter_pred_pchar_user(struct filter_pred *pred, void *event)\n{\n\tchar **addr = (char **)(event + pred->offset);\n\tchar *str;\n\n\tstr = test_ustring(*addr);\n\tif (!str)\n\t\treturn 0;\n\n\treturn filter_pchar(pred, str);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "filter_pchar",
          "args": [
            "pred",
            "str"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "filter_pchar",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "717-728",
          "snippet": "static __always_inline int filter_pchar(struct filter_pred *pred, char *str)\n{\n\tint cmp, match;\n\tint len;\n\n\tlen = strlen(str) + 1;\t/* including tailing '\\0' */\n\tcmp = pred->regex.match(str, &pred->regex, len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic __always_inline int filter_pchar(struct filter_pred *pred, char *str)\n{\n\tint cmp, match;\n\tint len;\n\n\tlen = strlen(str) + 1;\t/* including tailing '\\0' */\n\tcmp = pred->regex.match(str, &pred->regex, len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_ustring",
          "args": [
            "*addr"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "test_ustring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "684-702",
          "snippet": "static __always_inline char *test_ustring(char *str)\n{\n\tstruct ustring_buffer *ubuf;\n\tchar __user *ustr;\n\tchar *kstr;\n\n\tif (!ustring_per_cpu)\n\t\treturn NULL;\n\n\tubuf = this_cpu_ptr(ustring_per_cpu);\n\tkstr = ubuf->buffer;\n\n\t/* user space address? */\n\tustr = (char __user *)str;\n\tif (!strncpy_from_user_nofault(kstr, ustr, USTRING_BUF_SIZE))\n\t\treturn NULL;\n\n\treturn kstr;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define USTRING_BUF_SIZE\t1024"
          ],
          "globals_used": [
            "static __percpu struct",
            "ustring_buffer *ustring_per_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define USTRING_BUF_SIZE\t1024\n\nstatic __percpu struct;\nustring_buffer *ustring_per_cpu;\n\nstatic __always_inline char *test_ustring(char *str)\n{\n\tstruct ustring_buffer *ubuf;\n\tchar __user *ustr;\n\tchar *kstr;\n\n\tif (!ustring_per_cpu)\n\t\treturn NULL;\n\n\tubuf = this_cpu_ptr(ustring_per_cpu);\n\tkstr = ubuf->buffer;\n\n\t/* user space address? */\n\tustr = (char __user *)str;\n\tif (!strncpy_from_user_nofault(kstr, ustr, USTRING_BUF_SIZE))\n\t\treturn NULL;\n\n\treturn kstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int filter_pred_pchar_user(struct filter_pred *pred, void *event)\n{\n\tchar **addr = (char **)(event + pred->offset);\n\tchar *str;\n\n\tstr = test_ustring(*addr);\n\tif (!str)\n\t\treturn 0;\n\n\treturn filter_pchar(pred, str);\n}"
  },
  {
    "function_name": "filter_pred_pchar",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "730-740",
    "snippet": "static int filter_pred_pchar(struct filter_pred *pred, void *event)\n{\n\tchar **addr = (char **)(event + pred->offset);\n\tchar *str;\n\n\tstr = test_string(*addr);\n\tif (!str)\n\t\treturn 0;\n\n\treturn filter_pchar(pred, str);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "filter_pchar",
          "args": [
            "pred",
            "str"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "filter_pchar",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "717-728",
          "snippet": "static __always_inline int filter_pchar(struct filter_pred *pred, char *str)\n{\n\tint cmp, match;\n\tint len;\n\n\tlen = strlen(str) + 1;\t/* including tailing '\\0' */\n\tcmp = pred->regex.match(str, &pred->regex, len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic __always_inline int filter_pchar(struct filter_pred *pred, char *str)\n{\n\tint cmp, match;\n\tint len;\n\n\tlen = strlen(str) + 1;\t/* including tailing '\\0' */\n\tcmp = pred->regex.match(str, &pred->regex, len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_string",
          "args": [
            "*addr"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "test_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "667-682",
          "snippet": "static __always_inline char *test_string(char *str)\n{\n\tstruct ustring_buffer *ubuf;\n\tchar *kstr;\n\n\tif (!ustring_per_cpu)\n\t\treturn NULL;\n\n\tubuf = this_cpu_ptr(ustring_per_cpu);\n\tkstr = ubuf->buffer;\n\n\t/* For safety, do not trust the string pointer */\n\tif (!strncpy_from_kernel_nofault(kstr, str, USTRING_BUF_SIZE))\n\t\treturn NULL;\n\treturn kstr;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define USTRING_BUF_SIZE\t1024"
          ],
          "globals_used": [
            "static __percpu struct",
            "ustring_buffer *ustring_per_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define USTRING_BUF_SIZE\t1024\n\nstatic __percpu struct;\nustring_buffer *ustring_per_cpu;\n\nstatic __always_inline char *test_string(char *str)\n{\n\tstruct ustring_buffer *ubuf;\n\tchar *kstr;\n\n\tif (!ustring_per_cpu)\n\t\treturn NULL;\n\n\tubuf = this_cpu_ptr(ustring_per_cpu);\n\tkstr = ubuf->buffer;\n\n\t/* For safety, do not trust the string pointer */\n\tif (!strncpy_from_kernel_nofault(kstr, str, USTRING_BUF_SIZE))\n\t\treturn NULL;\n\treturn kstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int filter_pred_pchar(struct filter_pred *pred, void *event)\n{\n\tchar **addr = (char **)(event + pred->offset);\n\tchar *str;\n\n\tstr = test_string(*addr);\n\tif (!str)\n\t\treturn 0;\n\n\treturn filter_pchar(pred, str);\n}"
  },
  {
    "function_name": "filter_pchar",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "717-728",
    "snippet": "static __always_inline int filter_pchar(struct filter_pred *pred, char *str)\n{\n\tint cmp, match;\n\tint len;\n\n\tlen = strlen(str) + 1;\t/* including tailing '\\0' */\n\tcmp = pred->regex.match(str, &pred->regex, len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred->regex.match",
          "args": [
            "str",
            "&pred->regex",
            "len"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic __always_inline int filter_pchar(struct filter_pred *pred, char *str)\n{\n\tint cmp, match;\n\tint len;\n\n\tlen = strlen(str) + 1;\t/* including tailing '\\0' */\n\tcmp = pred->regex.match(str, &pred->regex, len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}"
  },
  {
    "function_name": "filter_pred_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "705-715",
    "snippet": "static int filter_pred_string(struct filter_pred *pred, void *event)\n{\n\tchar *addr = (char *)(event + pred->offset);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, pred->regex.field_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred->regex.match",
          "args": [
            "addr",
            "&pred->regex",
            "pred->regex.field_len"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic int filter_pred_string(struct filter_pred *pred, void *event)\n{\n\tchar *addr = (char *)(event + pred->offset);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, pred->regex.field_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}"
  },
  {
    "function_name": "test_ustring",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "684-702",
    "snippet": "static __always_inline char *test_ustring(char *str)\n{\n\tstruct ustring_buffer *ubuf;\n\tchar __user *ustr;\n\tchar *kstr;\n\n\tif (!ustring_per_cpu)\n\t\treturn NULL;\n\n\tubuf = this_cpu_ptr(ustring_per_cpu);\n\tkstr = ubuf->buffer;\n\n\t/* user space address? */\n\tustr = (char __user *)str;\n\tif (!strncpy_from_user_nofault(kstr, ustr, USTRING_BUF_SIZE))\n\t\treturn NULL;\n\n\treturn kstr;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define USTRING_BUF_SIZE\t1024"
    ],
    "globals_used": [
      "static __percpu struct",
      "ustring_buffer *ustring_per_cpu;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy_from_user_nofault",
          "args": [
            "kstr",
            "ustr",
            "USTRING_BUF_SIZE"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "ustring_per_cpu"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define USTRING_BUF_SIZE\t1024\n\nstatic __percpu struct;\nustring_buffer *ustring_per_cpu;\n\nstatic __always_inline char *test_ustring(char *str)\n{\n\tstruct ustring_buffer *ubuf;\n\tchar __user *ustr;\n\tchar *kstr;\n\n\tif (!ustring_per_cpu)\n\t\treturn NULL;\n\n\tubuf = this_cpu_ptr(ustring_per_cpu);\n\tkstr = ubuf->buffer;\n\n\t/* user space address? */\n\tustr = (char __user *)str;\n\tif (!strncpy_from_user_nofault(kstr, ustr, USTRING_BUF_SIZE))\n\t\treturn NULL;\n\n\treturn kstr;\n}"
  },
  {
    "function_name": "test_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "667-682",
    "snippet": "static __always_inline char *test_string(char *str)\n{\n\tstruct ustring_buffer *ubuf;\n\tchar *kstr;\n\n\tif (!ustring_per_cpu)\n\t\treturn NULL;\n\n\tubuf = this_cpu_ptr(ustring_per_cpu);\n\tkstr = ubuf->buffer;\n\n\t/* For safety, do not trust the string pointer */\n\tif (!strncpy_from_kernel_nofault(kstr, str, USTRING_BUF_SIZE))\n\t\treturn NULL;\n\treturn kstr;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define USTRING_BUF_SIZE\t1024"
    ],
    "globals_used": [
      "static __percpu struct",
      "ustring_buffer *ustring_per_cpu;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy_from_kernel_nofault",
          "args": [
            "kstr",
            "str",
            "USTRING_BUF_SIZE"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "ustring_per_cpu"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define USTRING_BUF_SIZE\t1024\n\nstatic __percpu struct;\nustring_buffer *ustring_per_cpu;\n\nstatic __always_inline char *test_string(char *str)\n{\n\tstruct ustring_buffer *ubuf;\n\tchar *kstr;\n\n\tif (!ustring_per_cpu)\n\t\treturn NULL;\n\n\tubuf = this_cpu_ptr(ustring_per_cpu);\n\tkstr = ubuf->buffer;\n\n\t/* For safety, do not trust the string pointer */\n\tif (!strncpy_from_kernel_nofault(kstr, str, USTRING_BUF_SIZE))\n\t\treturn NULL;\n\treturn kstr;\n}"
  },
  {
    "function_name": "predicate_parse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "410-591",
    "snippet": "static struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kcalloc(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\t/* accepting only \"&&\" or \"||\" */\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tkfree(op_stack);\n\tkfree(inverts);\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(inverts);\n\tif (prog_stack) {\n\t\tfor (i = 0; prog_stack[i].pred; i++)\n\t\t\tkfree(prog_stack[i].pred);\n\t\tkfree(prog_stack);\n\t}\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "prog_stack"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "prog[i].target <= i"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_error",
          "args": [
            "pe",
            "FILT_ERR_NO_FILTER",
            "ptr - str"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "parse_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "134-138",
          "snippet": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_preds",
          "args": [
            "prog",
            "N - 1",
            "!invert"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "update_preds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "118-127",
          "snippet": "static void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*next"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_pred",
          "args": [
            "next",
            "data",
            "ptr - str",
            "pe",
            "&prog[N].pred"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "parse_pred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1249-1511",
          "snippet": "static int parse_pred(const char *str, void *data,\n\t\t      int pos, struct filter_parse_error *pe,\n\t\t      struct filter_pred **pred_ptr)\n{\n\tstruct trace_event_call *call = data;\n\tstruct ftrace_event_field *field;\n\tstruct filter_pred *pred = NULL;\n\tchar num_buf[24];\t/* Big enough to hold an address */\n\tchar *field_name;\n\tbool ustring = false;\n\tchar q;\n\tu64 val;\n\tint len;\n\tint ret;\n\tint op;\n\tint s;\n\tint i = 0;\n\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\n\tlen = i - s;\n\n\tif (!len)\n\t\treturn -1;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\n\t/* Make sure that the field exists */\n\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field) {\n\t\tparse_error(pe, FILT_ERR_FIELD_NOT_FOUND, pos + i);\n\t\treturn -EINVAL;\n\t}\n\n\t/* See if the field is a user space string */\n\tif ((len = str_has_prefix(str + i, \".ustring\"))) {\n\t\tustring = true;\n\t\ti += len;\n\t}\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\t/* Make sure this op is supported */\n\tfor (op = 0; ops[op]; op++) {\n\t\t/* This is why '<=' must come before '<' in ops[] */\n\t\tif (strncmp(str + i, ops[op], strlen(ops[op])) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ops[op]) {\n\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\tgoto err_free;\n\t}\n\n\ti += strlen(ops[op]);\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\ts = i;\n\n\tpred = kzalloc(sizeof(*pred), GFP_KERNEL);\n\tif (!pred)\n\t\treturn -ENOMEM;\n\n\tpred->field = field;\n\tpred->offset = field->offset;\n\tpred->op = op;\n\n\tif (ftrace_event_is_function(call)) {\n\t\t/*\n\t\t * Perf does things different with function events.\n\t\t * It only allows an \"ip\" field, and expects a string.\n\t\t * But the string does not need to be surrounded by quotes.\n\t\t * If it is a string, the assigned function as a nop,\n\t\t * (perf doesn't use it) and grab everything.\n\t\t */\n\t\tif (strcmp(field->name, \"ip\") != 0) {\n\t\t\tparse_error(pe, FILT_ERR_IP_FIELD_ONLY, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\t\tpred->fn = filter_pred_none;\n\n\t\t/*\n\t\t * Quotes are not required, but if they exist then we need\n\t\t * to read them till we hit a matching one.\n\t\t */\n\t\tif (str[i] == '\\'' || str[i] == '\"')\n\t\t\tq = str[i];\n\t\telse\n\t\t\tq = 0;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (q && str[i] == q)\n\t\t\t\tbreak;\n\t\t\tif (!q && (str[i] == ')' || str[i] == '&' ||\n\t\t\t\t   str[i] == '|'))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Skip quotes */\n\t\tif (q)\n\t\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t/* This is either a string, or an integer */\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the op is OK for strings */\n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\t\tpred->not = 1;\n\t\t\tfallthrough;\n\t\tcase OP_GLOB:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_DIGIT, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i]) {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t\tfilter_build_regex(pred);\n\n\t\tif (field->filter_type == FILTER_COMM) {\n\t\t\tpred->fn = filter_pred_comm;\n\n\t\t} else if (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\tpred->fn = filter_pred_string;\n\t\t\tpred->regex.field_len = field->size;\n\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\tpred->fn = filter_pred_strloc;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\tpred->fn = filter_pred_strrelloc;\n\t\telse {\n\n\t\t\tif (!ustring_per_cpu) {\n\t\t\t\t/* Once allocated, keep it around for good */\n\t\t\t\tustring_per_cpu = alloc_percpu(struct ustring_buffer);\n\t\t\t\tif (!ustring_per_cpu)\n\t\t\t\t\tgoto err_mem;\n\t\t\t}\n\n\t\t\tif (ustring)\n\t\t\t\tpred->fn = filter_pred_pchar_user;\n\t\t\telse\n\t\t\t\tpred->fn = filter_pred_pchar;\n\t\t}\n\t\t/* go past the last quote */\n\t\ti++;\n\n\t} else if (isdigit(str[i]) || str[i] == '-') {\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_STRING, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (op == OP_GLOB) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\n\t\tlen = i - s;\n\t\t/* 0xfeedfacedeadbeef is 18 chars max */\n\t\tif (len >= sizeof(num_buf)) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tstrncpy(num_buf, str + s, len);\n\t\tnum_buf[len] = 0;\n\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num_buf, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num_buf, 0, &val);\n\t\tif (ret) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_INTVAL, pos + s);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->val = val;\n\n\t\tif (field->filter_type == FILTER_CPU)\n\t\t\tpred->fn = filter_pred_cpu;\n\t\telse {\n\t\t\tpred->fn = select_comparison_fn(pred->op, field->size,\n\t\t\t\t\t\t\tfield->is_signed);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t}\n\n\t} else {\n\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\tgoto err_free;\n\t}\n\n\t*pred_ptr = pred;\n\treturn i;\n\nerr_free:\n\tkfree(pred);\n\treturn -EINVAL;\nerr_mem:\n\tkfree(pred);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * ops[] = { OPS };",
            "static __percpu struct",
            "ustring_buffer *ustring_per_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char * ops[] = { OPS };\nstatic __percpu struct;\nustring_buffer *ustring_per_cpu;\n\nstatic int parse_pred(const char *str, void *data,\n\t\t      int pos, struct filter_parse_error *pe,\n\t\t      struct filter_pred **pred_ptr)\n{\n\tstruct trace_event_call *call = data;\n\tstruct ftrace_event_field *field;\n\tstruct filter_pred *pred = NULL;\n\tchar num_buf[24];\t/* Big enough to hold an address */\n\tchar *field_name;\n\tbool ustring = false;\n\tchar q;\n\tu64 val;\n\tint len;\n\tint ret;\n\tint op;\n\tint s;\n\tint i = 0;\n\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\n\tlen = i - s;\n\n\tif (!len)\n\t\treturn -1;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\n\t/* Make sure that the field exists */\n\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field) {\n\t\tparse_error(pe, FILT_ERR_FIELD_NOT_FOUND, pos + i);\n\t\treturn -EINVAL;\n\t}\n\n\t/* See if the field is a user space string */\n\tif ((len = str_has_prefix(str + i, \".ustring\"))) {\n\t\tustring = true;\n\t\ti += len;\n\t}\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\t/* Make sure this op is supported */\n\tfor (op = 0; ops[op]; op++) {\n\t\t/* This is why '<=' must come before '<' in ops[] */\n\t\tif (strncmp(str + i, ops[op], strlen(ops[op])) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ops[op]) {\n\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\tgoto err_free;\n\t}\n\n\ti += strlen(ops[op]);\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\ts = i;\n\n\tpred = kzalloc(sizeof(*pred), GFP_KERNEL);\n\tif (!pred)\n\t\treturn -ENOMEM;\n\n\tpred->field = field;\n\tpred->offset = field->offset;\n\tpred->op = op;\n\n\tif (ftrace_event_is_function(call)) {\n\t\t/*\n\t\t * Perf does things different with function events.\n\t\t * It only allows an \"ip\" field, and expects a string.\n\t\t * But the string does not need to be surrounded by quotes.\n\t\t * If it is a string, the assigned function as a nop,\n\t\t * (perf doesn't use it) and grab everything.\n\t\t */\n\t\tif (strcmp(field->name, \"ip\") != 0) {\n\t\t\tparse_error(pe, FILT_ERR_IP_FIELD_ONLY, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\t\tpred->fn = filter_pred_none;\n\n\t\t/*\n\t\t * Quotes are not required, but if they exist then we need\n\t\t * to read them till we hit a matching one.\n\t\t */\n\t\tif (str[i] == '\\'' || str[i] == '\"')\n\t\t\tq = str[i];\n\t\telse\n\t\t\tq = 0;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (q && str[i] == q)\n\t\t\t\tbreak;\n\t\t\tif (!q && (str[i] == ')' || str[i] == '&' ||\n\t\t\t\t   str[i] == '|'))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Skip quotes */\n\t\tif (q)\n\t\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t/* This is either a string, or an integer */\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the op is OK for strings */\n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\t\tpred->not = 1;\n\t\t\tfallthrough;\n\t\tcase OP_GLOB:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_DIGIT, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i]) {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t\tfilter_build_regex(pred);\n\n\t\tif (field->filter_type == FILTER_COMM) {\n\t\t\tpred->fn = filter_pred_comm;\n\n\t\t} else if (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\tpred->fn = filter_pred_string;\n\t\t\tpred->regex.field_len = field->size;\n\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\tpred->fn = filter_pred_strloc;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\tpred->fn = filter_pred_strrelloc;\n\t\telse {\n\n\t\t\tif (!ustring_per_cpu) {\n\t\t\t\t/* Once allocated, keep it around for good */\n\t\t\t\tustring_per_cpu = alloc_percpu(struct ustring_buffer);\n\t\t\t\tif (!ustring_per_cpu)\n\t\t\t\t\tgoto err_mem;\n\t\t\t}\n\n\t\t\tif (ustring)\n\t\t\t\tpred->fn = filter_pred_pchar_user;\n\t\t\telse\n\t\t\t\tpred->fn = filter_pred_pchar;\n\t\t}\n\t\t/* go past the last quote */\n\t\ti++;\n\n\t} else if (isdigit(str[i]) || str[i] == '-') {\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_STRING, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (op == OP_GLOB) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\n\t\tlen = i - s;\n\t\t/* 0xfeedfacedeadbeef is 18 chars max */\n\t\tif (len >= sizeof(num_buf)) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tstrncpy(num_buf, str + s, len);\n\t\tnum_buf[len] = 0;\n\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num_buf, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num_buf, 0, &val);\n\t\tif (ret) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_INTVAL, pos + s);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->val = val;\n\n\t\tif (field->filter_type == FILTER_CPU)\n\t\t\tpred->fn = filter_pred_cpu;\n\t\telse {\n\t\t\tpred->fn = select_comparison_fn(pred->op, field->size,\n\t\t\t\t\t\t\tfield->is_signed);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t}\n\n\t} else {\n\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\tgoto err_free;\n\t}\n\n\t*pred_ptr = pred;\n\treturn i;\n\nerr_free:\n\tkfree(pred);\n\treturn -EINVAL;\nerr_mem:\n\tkfree(pred);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_not",
          "args": [
            "next"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "is_not",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "84-92",
          "snippet": "static bool is_not(const char *str)\n{\n\tswitch (str[1]) {\n\tcase '=':\n\tcase '~':\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic bool is_not(const char *str)\n{\n\tswitch (str[1]) {\n\tcase '=':\n\tcase '~':\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*next"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_preds",
            "sizeof(*inverts)",
            "GFP_KERNEL"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_preds",
            "sizeof(*prog_stack)",
            "GFP_KERNEL"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_parens",
            "sizeof(*op_stack)",
            "GFP_KERNEL"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kcalloc(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\t/* accepting only \"&&\" or \"||\" */\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tkfree(op_stack);\n\tkfree(inverts);\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(inverts);\n\tif (prog_stack) {\n\t\tfor (i = 0; prog_stack[i].pred; i++)\n\t\t\tkfree(prog_stack[i].pred);\n\t\tkfree(prog_stack);\n\t}\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "parse_error",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "134-138",
    "snippet": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}"
  },
  {
    "function_name": "update_preds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "118-127",
    "snippet": "static void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __percpu struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nstatic void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}"
  },
  {
    "function_name": "is_not",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
    "lines": "84-92",
    "snippet": "static bool is_not(const char *str)\n{\n\tswitch (str[1]) {\n\tcase '=':\n\tcase '~':\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic bool is_not(const char *str)\n{\n\tswitch (str[1]) {\n\tcase '=':\n\tcase '~':\n\t\treturn false;\n\t}\n\treturn true;\n}"
  }
]