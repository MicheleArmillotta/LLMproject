[
  {
    "function_name": "test_static_call_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "531-545",
    "snippet": "static int __init test_static_call_init(void)\n{\n      int i;\n\n      for (i = 0; i < ARRAY_SIZE(static_call_data); i++ ) {\n\t      struct static_call_data *scd = &static_call_data[i];\n\n              if (scd->func)\n                      static_call_update(sc_selftest, scd->func);\n\n              WARN_ON(static_call(sc_selftest)(scd->val) != scd->expect);\n      }\n\n      return 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "static_call(sc_selftest)(scd->val) != scd->expect"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_call",
          "args": [
            "scd->val"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_del_module",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "392-419",
          "snippet": "static void static_call_del_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = mod->static_call_sites +\n\t\t\t\t\tmod->num_static_call_sites;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod, **prev;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site < stop; site++) {\n\t\tkey = static_call_key(site);\n\t\tif (key == prev_key)\n\t\t\tcontinue;\n\n\t\tprev_key = key;\n\n\t\tfor (prev = &key->mods, site_mod = key->mods;\n\t\t     site_mod && site_mod->mod != mod;\n\t\t     prev = &site_mod->next, site_mod = site_mod->next)\n\t\t\t;\n\n\t\tif (!site_mod)\n\t\t\tcontinue;\n\n\t\t*prev = site_mod->next;\n\t\tkfree(site_mod);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic void static_call_del_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = mod->static_call_sites +\n\t\t\t\t\tmod->num_static_call_sites;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod, **prev;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site < stop; site++) {\n\t\tkey = static_call_key(site);\n\t\tif (key == prev_key)\n\t\t\tcontinue;\n\n\t\tprev_key = key;\n\n\t\tfor (prev = &key->mods, site_mod = key->mods;\n\t\t     site_mod && site_mod->mod != mod;\n\t\t     prev = &site_mod->next, site_mod = site_mod->next)\n\t\t\t;\n\n\t\tif (!site_mod)\n\t\t\tcontinue;\n\n\t\t*prev = site_mod->next;\n\t\tkfree(site_mod);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_update",
          "args": [
            "sc_selftest",
            "scd->func"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "static_call_data"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int __init test_static_call_init(void)\n{\n      int i;\n\n      for (i = 0; i < ARRAY_SIZE(static_call_data); i++ ) {\n\t      struct static_call_data *scd = &static_call_data[i];\n\n              if (scd->func)\n                      static_call_update(sc_selftest, scd->func);\n\n              WARN_ON(static_call(sc_selftest)(scd->val) != scd->expect);\n      }\n\n      return 0;\n}"
  },
  {
    "function_name": "func_b",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "514-517",
    "snippet": "static int func_b(int x)\n{\n\treturn x+2;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int func_b(int x)\n{\n\treturn x+2;\n}"
  },
  {
    "function_name": "func_a",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "509-512",
    "snippet": "static int func_a(int x)\n{\n\treturn x+1;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int func_a(int x)\n{\n\treturn x+1;\n}"
  },
  {
    "function_name": "__static_call_return0",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "502-505",
    "snippet": "long __static_call_return0(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nlong __static_call_return0(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "static_call_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "474-499",
    "snippet": "int __init static_call_init(void)\n{\n\tint ret;\n\n\tif (static_call_initialized)\n\t\treturn 0;\n\n\tcpus_read_lock();\n\tstatic_call_lock();\n\tret = __static_call_init(NULL, __start_static_call_sites,\n\t\t\t\t __stop_static_call_sites);\n\tstatic_call_unlock();\n\tcpus_read_unlock();\n\n\tif (ret) {\n\t\tpr_err(\"Failed to allocate memory for static_call!\\n\");\n\t\tBUG();\n\t}\n\n\tstatic_call_initialized = true;\n\n#ifdef CONFIG_MODULES\n\tregister_module_notifier(&static_call_module_nb);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct static_call_site __start_static_call_sites[],\n\t\t\t       __stop_static_call_sites[];",
      "static bool static_call_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&static_call_module_nb"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "307-310",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate memory for static_call!\\n\""
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_unlock",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "28-31",
          "snippet": "static void static_call_unlock(void)\n{\n\tmutex_unlock(&static_call_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(static_call_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(static_call_mutex);\n\nstatic void static_call_unlock(void)\n{\n\tmutex_unlock(&static_call_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__static_call_init",
          "args": [
            "NULL",
            "__start_static_call_sites",
            "__stop_static_call_sites"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "__static_call_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "209-280",
          "snippet": "static int __static_call_init(struct module *mod,\n\t\t\t      struct static_call_site *start,\n\t\t\t      struct static_call_site *stop)\n{\n\tstruct static_call_site *site;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod;\n\n\tif (start == stop)\n\t\treturn 0;\n\n\tstatic_call_sort_entries(start, stop);\n\n\tfor (site = start; site < stop; site++) {\n\t\tvoid *site_addr = static_call_addr(site);\n\n\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||\n\t\t    (!mod && init_section_contains(site_addr, 1)))\n\t\t\tstatic_call_set_init(site);\n\n\t\tkey = static_call_key(site);\n\t\tif (key != prev_key) {\n\t\t\tprev_key = key;\n\n\t\t\t/*\n\t\t\t * For vmlinux (!mod) avoid the allocation by storing\n\t\t\t * the sites pointer in the key itself. Also see\n\t\t\t * __static_call_update()'s @first.\n\t\t\t *\n\t\t\t * This allows architectures (eg. x86) to call\n\t\t\t * static_call_init() before memory allocation works.\n\t\t\t */\n\t\t\tif (!mod) {\n\t\t\t\tkey->sites = site;\n\t\t\t\tkey->type |= 1;\n\t\t\t\tgoto do_transform;\n\t\t\t}\n\n\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\tif (!site_mod)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/*\n\t\t\t * When the key has a direct sites pointer, extract\n\t\t\t * that into an explicit struct static_call_mod, so we\n\t\t\t * can have a list of modules.\n\t\t\t */\n\t\t\tif (static_call_key_sites(key)) {\n\t\t\t\tsite_mod->mod = NULL;\n\t\t\t\tsite_mod->next = NULL;\n\t\t\t\tsite_mod->sites = static_call_key_sites(key);\n\n\t\t\t\tkey->mods = site_mod;\n\n\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\t\tif (!site_mod)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tsite_mod->mod = mod;\n\t\t\tsite_mod->sites = site;\n\t\t\tsite_mod->next = static_call_key_next(key);\n\t\t\tkey->mods = site_mod;\n\t\t}\n\ndo_transform:\n\t\tarch_static_call_transform(site_addr, NULL, key->func,\n\t\t\t\tstatic_call_is_tail(site));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int __static_call_init(struct module *mod,\n\t\t\t      struct static_call_site *start,\n\t\t\t      struct static_call_site *stop)\n{\n\tstruct static_call_site *site;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod;\n\n\tif (start == stop)\n\t\treturn 0;\n\n\tstatic_call_sort_entries(start, stop);\n\n\tfor (site = start; site < stop; site++) {\n\t\tvoid *site_addr = static_call_addr(site);\n\n\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||\n\t\t    (!mod && init_section_contains(site_addr, 1)))\n\t\t\tstatic_call_set_init(site);\n\n\t\tkey = static_call_key(site);\n\t\tif (key != prev_key) {\n\t\t\tprev_key = key;\n\n\t\t\t/*\n\t\t\t * For vmlinux (!mod) avoid the allocation by storing\n\t\t\t * the sites pointer in the key itself. Also see\n\t\t\t * __static_call_update()'s @first.\n\t\t\t *\n\t\t\t * This allows architectures (eg. x86) to call\n\t\t\t * static_call_init() before memory allocation works.\n\t\t\t */\n\t\t\tif (!mod) {\n\t\t\t\tkey->sites = site;\n\t\t\t\tkey->type |= 1;\n\t\t\t\tgoto do_transform;\n\t\t\t}\n\n\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\tif (!site_mod)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/*\n\t\t\t * When the key has a direct sites pointer, extract\n\t\t\t * that into an explicit struct static_call_mod, so we\n\t\t\t * can have a list of modules.\n\t\t\t */\n\t\t\tif (static_call_key_sites(key)) {\n\t\t\t\tsite_mod->mod = NULL;\n\t\t\t\tsite_mod->next = NULL;\n\t\t\t\tsite_mod->sites = static_call_key_sites(key);\n\n\t\t\t\tkey->mods = site_mod;\n\n\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\t\tif (!site_mod)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tsite_mod->mod = mod;\n\t\t\tsite_mod->sites = site;\n\t\t\tsite_mod->next = static_call_key_next(key);\n\t\t\tkey->mods = site_mod;\n\t\t}\n\ndo_transform:\n\t\tarch_static_call_transform(site_addr, NULL, key->func,\n\t\t\t\tstatic_call_is_tail(site));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_lock",
          "args": [],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "23-26",
          "snippet": "static void static_call_lock(void)\n{\n\tmutex_lock(&static_call_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(static_call_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(static_call_mutex);\n\nstatic void static_call_lock(void)\n{\n\tmutex_lock(&static_call_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nextern struct static_call_site __start_static_call_sites[],\n\t\t\t       __stop_static_call_sites[];\nstatic bool static_call_initialized;\n\nint __init static_call_init(void)\n{\n\tint ret;\n\n\tif (static_call_initialized)\n\t\treturn 0;\n\n\tcpus_read_lock();\n\tstatic_call_lock();\n\tret = __static_call_init(NULL, __start_static_call_sites,\n\t\t\t\t __stop_static_call_sites);\n\tstatic_call_unlock();\n\tcpus_read_unlock();\n\n\tif (ret) {\n\t\tpr_err(\"Failed to allocate memory for static_call!\\n\");\n\t\tBUG();\n\t}\n\n\tstatic_call_initialized = true;\n\n#ifdef CONFIG_MODULES\n\tregister_module_notifier(&static_call_module_nb);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "static_call_text_reserved",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "462-472",
    "snippet": "int static_call_text_reserved(void *start, void *end)\n{\n\tbool init = system_state < SYSTEM_RUNNING;\n\tint ret = __static_call_text_reserved(__start_static_call_sites,\n\t\t\t__stop_static_call_sites, start, end, init);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn __static_call_mod_text_reserved(start, end);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct static_call_site __start_static_call_sites[],\n\t\t\t       __stop_static_call_sites[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__static_call_mod_text_reserved",
          "args": [
            "start",
            "end"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "__static_call_mod_text_reserved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "455-458",
          "snippet": "static inline int __static_call_mod_text_reserved(void *start, void *end)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline int __static_call_mod_text_reserved(void *start, void *end)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__static_call_text_reserved",
          "args": [
            "__start_static_call_sites",
            "__stop_static_call_sites",
            "start",
            "end",
            "init"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "__static_call_text_reserved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "293-308",
          "snippet": "static int __static_call_text_reserved(struct static_call_site *iter_start,\n\t\t\t\t       struct static_call_site *iter_stop,\n\t\t\t\t       void *start, void *end, bool init)\n{\n\tstruct static_call_site *iter = iter_start;\n\n\twhile (iter < iter_stop) {\n\t\tif (init || !static_call_is_init(iter)) {\n\t\t\tif (addr_conflict(iter, start, end))\n\t\t\t\treturn 1;\n\t\t}\n\t\titer++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int __static_call_text_reserved(struct static_call_site *iter_start,\n\t\t\t\t       struct static_call_site *iter_stop,\n\t\t\t\t       void *start, void *end, bool init)\n{\n\tstruct static_call_site *iter = iter_start;\n\n\twhile (iter < iter_stop) {\n\t\tif (init || !static_call_is_init(iter)) {\n\t\t\tif (addr_conflict(iter, start, end))\n\t\t\t\treturn 1;\n\t\t}\n\t\titer++;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nextern struct static_call_site __start_static_call_sites[],\n\t\t\t       __stop_static_call_sites[];\n\nint static_call_text_reserved(void *start, void *end)\n{\n\tbool init = system_state < SYSTEM_RUNNING;\n\tint ret = __static_call_text_reserved(__start_static_call_sites,\n\t\t\t__stop_static_call_sites, start, end, init);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn __static_call_mod_text_reserved(start, end);\n}"
  },
  {
    "function_name": "__static_call_mod_text_reserved",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "455-458",
    "snippet": "static inline int __static_call_mod_text_reserved(void *start, void *end)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline int __static_call_mod_text_reserved(void *start, void *end)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "static_call_module_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "421-447",
    "snippet": "static int static_call_module_notify(struct notifier_block *nb,\n\t\t\t\t     unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tstatic_call_lock();\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = static_call_add_module(mod);\n\t\tif (ret) {\n\t\t\tWARN(1, \"Failed to allocate memory for static calls\");\n\t\t\tstatic_call_del_module(mod);\n\t\t}\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tstatic_call_del_module(mod);\n\t\tbreak;\n\t}\n\n\tstatic_call_unlock();\n\tcpus_read_unlock();\n\n\treturn notifier_from_errno(ret);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_from_errno",
          "args": [
            "ret"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_unlock",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "28-31",
          "snippet": "static void static_call_unlock(void)\n{\n\tmutex_unlock(&static_call_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(static_call_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(static_call_mutex);\n\nstatic void static_call_unlock(void)\n{\n\tmutex_unlock(&static_call_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_del_module",
          "args": [
            "mod"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_del_module",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "392-419",
          "snippet": "static void static_call_del_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = mod->static_call_sites +\n\t\t\t\t\tmod->num_static_call_sites;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod, **prev;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site < stop; site++) {\n\t\tkey = static_call_key(site);\n\t\tif (key == prev_key)\n\t\t\tcontinue;\n\n\t\tprev_key = key;\n\n\t\tfor (prev = &key->mods, site_mod = key->mods;\n\t\t     site_mod && site_mod->mod != mod;\n\t\t     prev = &site_mod->next, site_mod = site_mod->next)\n\t\t\t;\n\n\t\tif (!site_mod)\n\t\t\tcontinue;\n\n\t\t*prev = site_mod->next;\n\t\tkfree(site_mod);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic void static_call_del_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = mod->static_call_sites +\n\t\t\t\t\tmod->num_static_call_sites;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod, **prev;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site < stop; site++) {\n\t\tkey = static_call_key(site);\n\t\tif (key == prev_key)\n\t\t\tcontinue;\n\n\t\tprev_key = key;\n\n\t\tfor (prev = &key->mods, site_mod = key->mods;\n\t\t     site_mod && site_mod->mod != mod;\n\t\t     prev = &site_mod->next, site_mod = site_mod->next)\n\t\t\t;\n\n\t\tif (!site_mod)\n\t\t\tcontinue;\n\n\t\t*prev = site_mod->next;\n\t\tkfree(site_mod);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Failed to allocate memory for static calls\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_call_add_module",
          "args": [
            "mod"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_add_module",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "353-390",
          "snippet": "static int static_call_add_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = start + mod->num_static_call_sites;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site != stop; site++) {\n\t\tunsigned long s_key = __static_call_key(site);\n\t\tunsigned long addr = s_key & ~STATIC_CALL_SITE_FLAGS;\n\t\tunsigned long key;\n\n\t\t/*\n\t\t * Is the key is exported, 'addr' points to the key, which\n\t\t * means modules are allowed to call static_call_update() on\n\t\t * it.\n\t\t *\n\t\t * Otherwise, the key isn't exported, and 'addr' points to the\n\t\t * trampoline so we need to lookup the key.\n\t\t *\n\t\t * We go through this dance to prevent crazy modules from\n\t\t * abusing sensitive static calls.\n\t\t */\n\t\tif (!kernel_text_address(addr))\n\t\t\tcontinue;\n\n\t\tkey = tramp_key_lookup(addr);\n\t\tif (!key) {\n\t\t\tpr_warn(\"Failed to fixup __raw_static_call() usage at: %ps\\n\",\n\t\t\t\tstatic_call_addr(site));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tkey |= s_key & STATIC_CALL_SITE_FLAGS;\n\t\tsite->key = key - (long)&site->key;\n\t}\n\n\treturn __static_call_init(mod, start, stop);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int static_call_add_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = start + mod->num_static_call_sites;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site != stop; site++) {\n\t\tunsigned long s_key = __static_call_key(site);\n\t\tunsigned long addr = s_key & ~STATIC_CALL_SITE_FLAGS;\n\t\tunsigned long key;\n\n\t\t/*\n\t\t * Is the key is exported, 'addr' points to the key, which\n\t\t * means modules are allowed to call static_call_update() on\n\t\t * it.\n\t\t *\n\t\t * Otherwise, the key isn't exported, and 'addr' points to the\n\t\t * trampoline so we need to lookup the key.\n\t\t *\n\t\t * We go through this dance to prevent crazy modules from\n\t\t * abusing sensitive static calls.\n\t\t */\n\t\tif (!kernel_text_address(addr))\n\t\t\tcontinue;\n\n\t\tkey = tramp_key_lookup(addr);\n\t\tif (!key) {\n\t\t\tpr_warn(\"Failed to fixup __raw_static_call() usage at: %ps\\n\",\n\t\t\t\tstatic_call_addr(site));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tkey |= s_key & STATIC_CALL_SITE_FLAGS;\n\t\tsite->key = key - (long)&site->key;\n\t}\n\n\treturn __static_call_init(mod, start, stop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_lock",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "23-26",
          "snippet": "static void static_call_lock(void)\n{\n\tmutex_lock(&static_call_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(static_call_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(static_call_mutex);\n\nstatic void static_call_lock(void)\n{\n\tmutex_lock(&static_call_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int static_call_module_notify(struct notifier_block *nb,\n\t\t\t\t     unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tstatic_call_lock();\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = static_call_add_module(mod);\n\t\tif (ret) {\n\t\t\tWARN(1, \"Failed to allocate memory for static calls\");\n\t\t\tstatic_call_del_module(mod);\n\t\t}\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tstatic_call_del_module(mod);\n\t\tbreak;\n\t}\n\n\tstatic_call_unlock();\n\tcpus_read_unlock();\n\n\treturn notifier_from_errno(ret);\n}"
  },
  {
    "function_name": "static_call_del_module",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "392-419",
    "snippet": "static void static_call_del_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = mod->static_call_sites +\n\t\t\t\t\tmod->num_static_call_sites;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod, **prev;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site < stop; site++) {\n\t\tkey = static_call_key(site);\n\t\tif (key == prev_key)\n\t\t\tcontinue;\n\n\t\tprev_key = key;\n\n\t\tfor (prev = &key->mods, site_mod = key->mods;\n\t\t     site_mod && site_mod->mod != mod;\n\t\t     prev = &site_mod->next, site_mod = site_mod->next)\n\t\t\t;\n\n\t\tif (!site_mod)\n\t\t\tcontinue;\n\n\t\t*prev = site_mod->next;\n\t\tkfree(site_mod);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "site_mod"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_key",
          "args": [
            "site"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_key_sites",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "115-121",
          "snippet": "static inline struct static_call_site *static_call_key_sites(struct static_call_key *key)\n{\n\tif (static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn (struct static_call_site *)(key->type & ~1);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline struct static_call_site *static_call_key_sites(struct static_call_key *key)\n{\n\tif (static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn (struct static_call_site *)(key->type & ~1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic void static_call_del_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = mod->static_call_sites +\n\t\t\t\t\tmod->num_static_call_sites;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod, **prev;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site < stop; site++) {\n\t\tkey = static_call_key(site);\n\t\tif (key == prev_key)\n\t\t\tcontinue;\n\n\t\tprev_key = key;\n\n\t\tfor (prev = &key->mods, site_mod = key->mods;\n\t\t     site_mod && site_mod->mod != mod;\n\t\t     prev = &site_mod->next, site_mod = site_mod->next)\n\t\t\t;\n\n\t\tif (!site_mod)\n\t\t\tcontinue;\n\n\t\t*prev = site_mod->next;\n\t\tkfree(site_mod);\n\t}\n}"
  },
  {
    "function_name": "static_call_add_module",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "353-390",
    "snippet": "static int static_call_add_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = start + mod->num_static_call_sites;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site != stop; site++) {\n\t\tunsigned long s_key = __static_call_key(site);\n\t\tunsigned long addr = s_key & ~STATIC_CALL_SITE_FLAGS;\n\t\tunsigned long key;\n\n\t\t/*\n\t\t * Is the key is exported, 'addr' points to the key, which\n\t\t * means modules are allowed to call static_call_update() on\n\t\t * it.\n\t\t *\n\t\t * Otherwise, the key isn't exported, and 'addr' points to the\n\t\t * trampoline so we need to lookup the key.\n\t\t *\n\t\t * We go through this dance to prevent crazy modules from\n\t\t * abusing sensitive static calls.\n\t\t */\n\t\tif (!kernel_text_address(addr))\n\t\t\tcontinue;\n\n\t\tkey = tramp_key_lookup(addr);\n\t\tif (!key) {\n\t\t\tpr_warn(\"Failed to fixup __raw_static_call() usage at: %ps\\n\",\n\t\t\t\tstatic_call_addr(site));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tkey |= s_key & STATIC_CALL_SITE_FLAGS;\n\t\tsite->key = key - (long)&site->key;\n\t}\n\n\treturn __static_call_init(mod, start, stop);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__static_call_init",
          "args": [
            "mod",
            "start",
            "stop"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "__static_call_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "209-280",
          "snippet": "static int __static_call_init(struct module *mod,\n\t\t\t      struct static_call_site *start,\n\t\t\t      struct static_call_site *stop)\n{\n\tstruct static_call_site *site;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod;\n\n\tif (start == stop)\n\t\treturn 0;\n\n\tstatic_call_sort_entries(start, stop);\n\n\tfor (site = start; site < stop; site++) {\n\t\tvoid *site_addr = static_call_addr(site);\n\n\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||\n\t\t    (!mod && init_section_contains(site_addr, 1)))\n\t\t\tstatic_call_set_init(site);\n\n\t\tkey = static_call_key(site);\n\t\tif (key != prev_key) {\n\t\t\tprev_key = key;\n\n\t\t\t/*\n\t\t\t * For vmlinux (!mod) avoid the allocation by storing\n\t\t\t * the sites pointer in the key itself. Also see\n\t\t\t * __static_call_update()'s @first.\n\t\t\t *\n\t\t\t * This allows architectures (eg. x86) to call\n\t\t\t * static_call_init() before memory allocation works.\n\t\t\t */\n\t\t\tif (!mod) {\n\t\t\t\tkey->sites = site;\n\t\t\t\tkey->type |= 1;\n\t\t\t\tgoto do_transform;\n\t\t\t}\n\n\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\tif (!site_mod)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/*\n\t\t\t * When the key has a direct sites pointer, extract\n\t\t\t * that into an explicit struct static_call_mod, so we\n\t\t\t * can have a list of modules.\n\t\t\t */\n\t\t\tif (static_call_key_sites(key)) {\n\t\t\t\tsite_mod->mod = NULL;\n\t\t\t\tsite_mod->next = NULL;\n\t\t\t\tsite_mod->sites = static_call_key_sites(key);\n\n\t\t\t\tkey->mods = site_mod;\n\n\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\t\tif (!site_mod)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tsite_mod->mod = mod;\n\t\t\tsite_mod->sites = site;\n\t\t\tsite_mod->next = static_call_key_next(key);\n\t\t\tkey->mods = site_mod;\n\t\t}\n\ndo_transform:\n\t\tarch_static_call_transform(site_addr, NULL, key->func,\n\t\t\t\tstatic_call_is_tail(site));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int __static_call_init(struct module *mod,\n\t\t\t      struct static_call_site *start,\n\t\t\t      struct static_call_site *stop)\n{\n\tstruct static_call_site *site;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod;\n\n\tif (start == stop)\n\t\treturn 0;\n\n\tstatic_call_sort_entries(start, stop);\n\n\tfor (site = start; site < stop; site++) {\n\t\tvoid *site_addr = static_call_addr(site);\n\n\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||\n\t\t    (!mod && init_section_contains(site_addr, 1)))\n\t\t\tstatic_call_set_init(site);\n\n\t\tkey = static_call_key(site);\n\t\tif (key != prev_key) {\n\t\t\tprev_key = key;\n\n\t\t\t/*\n\t\t\t * For vmlinux (!mod) avoid the allocation by storing\n\t\t\t * the sites pointer in the key itself. Also see\n\t\t\t * __static_call_update()'s @first.\n\t\t\t *\n\t\t\t * This allows architectures (eg. x86) to call\n\t\t\t * static_call_init() before memory allocation works.\n\t\t\t */\n\t\t\tif (!mod) {\n\t\t\t\tkey->sites = site;\n\t\t\t\tkey->type |= 1;\n\t\t\t\tgoto do_transform;\n\t\t\t}\n\n\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\tif (!site_mod)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/*\n\t\t\t * When the key has a direct sites pointer, extract\n\t\t\t * that into an explicit struct static_call_mod, so we\n\t\t\t * can have a list of modules.\n\t\t\t */\n\t\t\tif (static_call_key_sites(key)) {\n\t\t\t\tsite_mod->mod = NULL;\n\t\t\t\tsite_mod->next = NULL;\n\t\t\t\tsite_mod->sites = static_call_key_sites(key);\n\n\t\t\t\tkey->mods = site_mod;\n\n\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\t\tif (!site_mod)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tsite_mod->mod = mod;\n\t\t\tsite_mod->sites = site;\n\t\t\tsite_mod->next = static_call_key_next(key);\n\t\t\tkey->mods = site_mod;\n\t\t}\n\ndo_transform:\n\t\tarch_static_call_transform(site_addr, NULL, key->func,\n\t\t\t\tstatic_call_is_tail(site));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to fixup __raw_static_call() usage at: %ps\\n\"",
            "static_call_addr(site)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_call_addr",
          "args": [
            "site"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "33-36",
          "snippet": "static inline void *static_call_addr(struct static_call_site *site)\n{\n\treturn (void *)((long)site->addr + (long)&site->addr);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline void *static_call_addr(struct static_call_site *site)\n{\n\treturn (void *)((long)site->addr + (long)&site->addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tramp_key_lookup",
          "args": [
            "addr"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "tramp_key_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "336-351",
          "snippet": "static unsigned long tramp_key_lookup(unsigned long addr)\n{\n\tstruct static_call_tramp_key *start = __start_static_call_tramp_key;\n\tstruct static_call_tramp_key *stop = __stop_static_call_tramp_key;\n\tstruct static_call_tramp_key *tramp_key;\n\n\tfor (tramp_key = start; tramp_key != stop; tramp_key++) {\n\t\tunsigned long tramp;\n\n\t\ttramp = (long)tramp_key->tramp + (long)&tramp_key->tramp;\n\t\tif (tramp == addr)\n\t\t\treturn (long)tramp_key->key + (long)&tramp_key->key;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct static_call_tramp_key __start_static_call_tramp_key[],\n\t\t\t\t    __stop_static_call_tramp_key[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nextern struct static_call_tramp_key __start_static_call_tramp_key[],\n\t\t\t\t    __stop_static_call_tramp_key[];\n\nstatic unsigned long tramp_key_lookup(unsigned long addr)\n{\n\tstruct static_call_tramp_key *start = __start_static_call_tramp_key;\n\tstruct static_call_tramp_key *stop = __stop_static_call_tramp_key;\n\tstruct static_call_tramp_key *tramp_key;\n\n\tfor (tramp_key = start; tramp_key != stop; tramp_key++) {\n\t\tunsigned long tramp;\n\n\t\ttramp = (long)tramp_key->tramp + (long)&tramp_key->tramp;\n\t\tif (tramp == addr)\n\t\t\treturn (long)tramp_key->key + (long)&tramp_key->key;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_text_address",
          "args": [
            "addr"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_text_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/extable.c",
          "lines": "93-132",
          "snippet": "int kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots,\n\t * is_bpf_text_address() and is_bpf_image_address require\n\t * RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/sections.h>",
            "#include <linux/filter.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/extable.h>",
            "#include <linux/memory.h>",
            "#include <linux/ftrace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/sections.h>\n#include <linux/filter.h>\n#include <linux/kprobes.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/extable.h>\n#include <linux/memory.h>\n#include <linux/ftrace.h>\n\nint kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots,\n\t * is_bpf_text_address() and is_bpf_image_address require\n\t * RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__static_call_key",
          "args": [
            "site"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "__static_call_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "38-41",
          "snippet": "static inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int static_call_add_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = start + mod->num_static_call_sites;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site != stop; site++) {\n\t\tunsigned long s_key = __static_call_key(site);\n\t\tunsigned long addr = s_key & ~STATIC_CALL_SITE_FLAGS;\n\t\tunsigned long key;\n\n\t\t/*\n\t\t * Is the key is exported, 'addr' points to the key, which\n\t\t * means modules are allowed to call static_call_update() on\n\t\t * it.\n\t\t *\n\t\t * Otherwise, the key isn't exported, and 'addr' points to the\n\t\t * trampoline so we need to lookup the key.\n\t\t *\n\t\t * We go through this dance to prevent crazy modules from\n\t\t * abusing sensitive static calls.\n\t\t */\n\t\tif (!kernel_text_address(addr))\n\t\t\tcontinue;\n\n\t\tkey = tramp_key_lookup(addr);\n\t\tif (!key) {\n\t\t\tpr_warn(\"Failed to fixup __raw_static_call() usage at: %ps\\n\",\n\t\t\t\tstatic_call_addr(site));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tkey |= s_key & STATIC_CALL_SITE_FLAGS;\n\t\tsite->key = key - (long)&site->key;\n\t}\n\n\treturn __static_call_init(mod, start, stop);\n}"
  },
  {
    "function_name": "tramp_key_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "336-351",
    "snippet": "static unsigned long tramp_key_lookup(unsigned long addr)\n{\n\tstruct static_call_tramp_key *start = __start_static_call_tramp_key;\n\tstruct static_call_tramp_key *stop = __stop_static_call_tramp_key;\n\tstruct static_call_tramp_key *tramp_key;\n\n\tfor (tramp_key = start; tramp_key != stop; tramp_key++) {\n\t\tunsigned long tramp;\n\n\t\ttramp = (long)tramp_key->tramp + (long)&tramp_key->tramp;\n\t\tif (tramp == addr)\n\t\t\treturn (long)tramp_key->key + (long)&tramp_key->key;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct static_call_tramp_key __start_static_call_tramp_key[],\n\t\t\t\t    __stop_static_call_tramp_key[];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nextern struct static_call_tramp_key __start_static_call_tramp_key[],\n\t\t\t\t    __stop_static_call_tramp_key[];\n\nstatic unsigned long tramp_key_lookup(unsigned long addr)\n{\n\tstruct static_call_tramp_key *start = __start_static_call_tramp_key;\n\tstruct static_call_tramp_key *stop = __stop_static_call_tramp_key;\n\tstruct static_call_tramp_key *tramp_key;\n\n\tfor (tramp_key = start; tramp_key != stop; tramp_key++) {\n\t\tunsigned long tramp;\n\n\t\ttramp = (long)tramp_key->tramp + (long)&tramp_key->tramp;\n\t\tif (tramp == addr)\n\t\t\treturn (long)tramp_key->key + (long)&tramp_key->key;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__static_call_mod_text_reserved",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "312-334",
    "snippet": "static int __static_call_mod_text_reserved(void *start, void *end)\n{\n\tstruct module *mod;\n\tint ret;\n\n\tpreempt_disable();\n\tmod = __module_text_address((unsigned long)start);\n\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);\n\tif (!try_module_get(mod))\n\t\tmod = NULL;\n\tpreempt_enable();\n\n\tif (!mod)\n\t\treturn 0;\n\n\tret = __static_call_text_reserved(mod->static_call_sites,\n\t\t\tmod->static_call_sites + mod->num_static_call_sites,\n\t\t\tstart, end, mod->state == MODULE_STATE_COMING);\n\n\tmodule_put(mod);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "mod"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1087-1098",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__static_call_text_reserved",
          "args": [
            "mod->static_call_sites",
            "mod->static_call_sites + mod->num_static_call_sites",
            "start",
            "end",
            "mod->state == MODULE_STATE_COMING"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "__static_call_text_reserved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "293-308",
          "snippet": "static int __static_call_text_reserved(struct static_call_site *iter_start,\n\t\t\t\t       struct static_call_site *iter_stop,\n\t\t\t\t       void *start, void *end, bool init)\n{\n\tstruct static_call_site *iter = iter_start;\n\n\twhile (iter < iter_stop) {\n\t\tif (init || !static_call_is_init(iter)) {\n\t\t\tif (addr_conflict(iter, start, end))\n\t\t\t\treturn 1;\n\t\t}\n\t\titer++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int __static_call_text_reserved(struct static_call_site *iter_start,\n\t\t\t\t       struct static_call_site *iter_stop,\n\t\t\t\t       void *start, void *end, bool init)\n{\n\tstruct static_call_site *iter = iter_start;\n\n\twhile (iter < iter_stop) {\n\t\tif (init || !static_call_is_init(iter)) {\n\t\t\tif (addr_conflict(iter, start, end))\n\t\t\t\treturn 1;\n\t\t}\n\t\titer++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "mod"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "__module_text_address((unsigned long)end) != mod"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__module_text_address",
          "args": [
            "(unsigned long)end"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "__module_text_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4780-4790",
          "snippet": "struct module *__module_text_address(unsigned long addr)\n{\n\tstruct module *mod = __module_address(addr);\n\tif (mod) {\n\t\t/* Make sure it's within the text section. */\n\t\tif (!within(addr, mod->init_layout.base, mod->init_layout.text_size)\n\t\t    && !within(addr, mod->core_layout.base, mod->core_layout.text_size))\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nstruct module *__module_text_address(unsigned long addr)\n{\n\tstruct module *mod = __module_address(addr);\n\tif (mod) {\n\t\t/* Make sure it's within the text section. */\n\t\tif (!within(addr, mod->init_layout.base, mod->init_layout.text_size)\n\t\t    && !within(addr, mod->core_layout.base, mod->core_layout.text_size))\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int __static_call_mod_text_reserved(void *start, void *end)\n{\n\tstruct module *mod;\n\tint ret;\n\n\tpreempt_disable();\n\tmod = __module_text_address((unsigned long)start);\n\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);\n\tif (!try_module_get(mod))\n\t\tmod = NULL;\n\tpreempt_enable();\n\n\tif (!mod)\n\t\treturn 0;\n\n\tret = __static_call_text_reserved(mod->static_call_sites,\n\t\t\tmod->static_call_sites + mod->num_static_call_sites,\n\t\t\tstart, end, mod->state == MODULE_STATE_COMING);\n\n\tmodule_put(mod);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__static_call_text_reserved",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "293-308",
    "snippet": "static int __static_call_text_reserved(struct static_call_site *iter_start,\n\t\t\t\t       struct static_call_site *iter_stop,\n\t\t\t\t       void *start, void *end, bool init)\n{\n\tstruct static_call_site *iter = iter_start;\n\n\twhile (iter < iter_stop) {\n\t\tif (init || !static_call_is_init(iter)) {\n\t\t\tif (addr_conflict(iter, start, end))\n\t\t\t\treturn 1;\n\t\t}\n\t\titer++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addr_conflict",
          "args": [
            "iter",
            "start",
            "end"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "addr_conflict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "282-291",
          "snippet": "static int addr_conflict(struct static_call_site *site, void *start, void *end)\n{\n\tunsigned long addr = (unsigned long)static_call_addr(site);\n\n\tif (addr <= (unsigned long)end &&\n\t    addr + CALL_INSN_SIZE > (unsigned long)start)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int addr_conflict(struct static_call_site *site, void *start, void *end)\n{\n\tunsigned long addr = (unsigned long)static_call_addr(site);\n\n\tif (addr <= (unsigned long)end &&\n\t    addr + CALL_INSN_SIZE > (unsigned long)start)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_is_init",
          "args": [
            "iter"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_is_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "49-52",
          "snippet": "static inline bool static_call_is_init(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline bool static_call_is_init(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int __static_call_text_reserved(struct static_call_site *iter_start,\n\t\t\t\t       struct static_call_site *iter_stop,\n\t\t\t\t       void *start, void *end, bool init)\n{\n\tstruct static_call_site *iter = iter_start;\n\n\twhile (iter < iter_stop) {\n\t\tif (init || !static_call_is_init(iter)) {\n\t\t\tif (addr_conflict(iter, start, end))\n\t\t\t\treturn 1;\n\t\t}\n\t\titer++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "addr_conflict",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "282-291",
    "snippet": "static int addr_conflict(struct static_call_site *site, void *start, void *end)\n{\n\tunsigned long addr = (unsigned long)static_call_addr(site);\n\n\tif (addr <= (unsigned long)end &&\n\t    addr + CALL_INSN_SIZE > (unsigned long)start)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_call_addr",
          "args": [
            "site"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "33-36",
          "snippet": "static inline void *static_call_addr(struct static_call_site *site)\n{\n\treturn (void *)((long)site->addr + (long)&site->addr);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline void *static_call_addr(struct static_call_site *site)\n{\n\treturn (void *)((long)site->addr + (long)&site->addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int addr_conflict(struct static_call_site *site, void *start, void *end)\n{\n\tunsigned long addr = (unsigned long)static_call_addr(site);\n\n\tif (addr <= (unsigned long)end &&\n\t    addr + CALL_INSN_SIZE > (unsigned long)start)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__static_call_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "209-280",
    "snippet": "static int __static_call_init(struct module *mod,\n\t\t\t      struct static_call_site *start,\n\t\t\t      struct static_call_site *stop)\n{\n\tstruct static_call_site *site;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod;\n\n\tif (start == stop)\n\t\treturn 0;\n\n\tstatic_call_sort_entries(start, stop);\n\n\tfor (site = start; site < stop; site++) {\n\t\tvoid *site_addr = static_call_addr(site);\n\n\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||\n\t\t    (!mod && init_section_contains(site_addr, 1)))\n\t\t\tstatic_call_set_init(site);\n\n\t\tkey = static_call_key(site);\n\t\tif (key != prev_key) {\n\t\t\tprev_key = key;\n\n\t\t\t/*\n\t\t\t * For vmlinux (!mod) avoid the allocation by storing\n\t\t\t * the sites pointer in the key itself. Also see\n\t\t\t * __static_call_update()'s @first.\n\t\t\t *\n\t\t\t * This allows architectures (eg. x86) to call\n\t\t\t * static_call_init() before memory allocation works.\n\t\t\t */\n\t\t\tif (!mod) {\n\t\t\t\tkey->sites = site;\n\t\t\t\tkey->type |= 1;\n\t\t\t\tgoto do_transform;\n\t\t\t}\n\n\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\tif (!site_mod)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/*\n\t\t\t * When the key has a direct sites pointer, extract\n\t\t\t * that into an explicit struct static_call_mod, so we\n\t\t\t * can have a list of modules.\n\t\t\t */\n\t\t\tif (static_call_key_sites(key)) {\n\t\t\t\tsite_mod->mod = NULL;\n\t\t\t\tsite_mod->next = NULL;\n\t\t\t\tsite_mod->sites = static_call_key_sites(key);\n\n\t\t\t\tkey->mods = site_mod;\n\n\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\t\tif (!site_mod)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tsite_mod->mod = mod;\n\t\t\tsite_mod->sites = site;\n\t\t\tsite_mod->next = static_call_key_next(key);\n\t\t\tkey->mods = site_mod;\n\t\t}\n\ndo_transform:\n\t\tarch_static_call_transform(site_addr, NULL, key->func,\n\t\t\t\tstatic_call_is_tail(site));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_static_call_transform",
          "args": [
            "site_addr",
            "NULL",
            "key->func",
            "static_call_is_tail(site)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_call_is_tail",
          "args": [
            "site"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_is_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "54-57",
          "snippet": "static inline bool static_call_is_tail(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline bool static_call_is_tail(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_key_next",
          "args": [
            "key"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_key_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "107-113",
          "snippet": "static inline struct static_call_mod *static_call_key_next(struct static_call_key *key)\n{\n\tif (!static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn key->mods;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline struct static_call_mod *static_call_key_next(struct static_call_key *key)\n{\n\tif (!static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn key->mods;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*site_mod)",
            "GFP_KERNEL"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_call_key_sites",
          "args": [
            "key"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_key_sites",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "115-121",
          "snippet": "static inline struct static_call_site *static_call_key_sites(struct static_call_key *key)\n{\n\tif (static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn (struct static_call_site *)(key->type & ~1);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline struct static_call_site *static_call_key_sites(struct static_call_key *key)\n{\n\tif (static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn (struct static_call_site *)(key->type & ~1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*site_mod)",
            "GFP_KERNEL"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_call_set_init",
          "args": [
            "site"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_set_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "59-63",
          "snippet": "static inline void static_call_set_init(struct static_call_site *site)\n{\n\tsite->key = (__static_call_key(site) | STATIC_CALL_SITE_INIT) -\n\t\t    (long)&site->key;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline void static_call_set_init(struct static_call_site *site)\n{\n\tsite->key = (__static_call_key(site) | STATIC_CALL_SITE_INIT) -\n\t\t    (long)&site->key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_section_contains",
          "args": [
            "site_addr",
            "1"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "within_module_init",
          "args": [
            "(unsigned long)site_addr",
            "mod"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_call_addr",
          "args": [
            "site"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "33-36",
          "snippet": "static inline void *static_call_addr(struct static_call_site *site)\n{\n\treturn (void *)((long)site->addr + (long)&site->addr);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline void *static_call_addr(struct static_call_site *site)\n{\n\treturn (void *)((long)site->addr + (long)&site->addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_sort_entries",
          "args": [
            "start",
            "stop"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_sort_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "95-100",
          "snippet": "static inline void static_call_sort_entries(struct static_call_site *start,\n\t\t\t\t\t    struct static_call_site *stop)\n{\n\tsort(start, stop - start, sizeof(struct static_call_site),\n\t     static_call_site_cmp, static_call_site_swap);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline void static_call_sort_entries(struct static_call_site *start,\n\t\t\t\t\t    struct static_call_site *stop)\n{\n\tsort(start, stop - start, sizeof(struct static_call_site),\n\t     static_call_site_cmp, static_call_site_swap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int __static_call_init(struct module *mod,\n\t\t\t      struct static_call_site *start,\n\t\t\t      struct static_call_site *stop)\n{\n\tstruct static_call_site *site;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod;\n\n\tif (start == stop)\n\t\treturn 0;\n\n\tstatic_call_sort_entries(start, stop);\n\n\tfor (site = start; site < stop; site++) {\n\t\tvoid *site_addr = static_call_addr(site);\n\n\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||\n\t\t    (!mod && init_section_contains(site_addr, 1)))\n\t\t\tstatic_call_set_init(site);\n\n\t\tkey = static_call_key(site);\n\t\tif (key != prev_key) {\n\t\t\tprev_key = key;\n\n\t\t\t/*\n\t\t\t * For vmlinux (!mod) avoid the allocation by storing\n\t\t\t * the sites pointer in the key itself. Also see\n\t\t\t * __static_call_update()'s @first.\n\t\t\t *\n\t\t\t * This allows architectures (eg. x86) to call\n\t\t\t * static_call_init() before memory allocation works.\n\t\t\t */\n\t\t\tif (!mod) {\n\t\t\t\tkey->sites = site;\n\t\t\t\tkey->type |= 1;\n\t\t\t\tgoto do_transform;\n\t\t\t}\n\n\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\tif (!site_mod)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/*\n\t\t\t * When the key has a direct sites pointer, extract\n\t\t\t * that into an explicit struct static_call_mod, so we\n\t\t\t * can have a list of modules.\n\t\t\t */\n\t\t\tif (static_call_key_sites(key)) {\n\t\t\t\tsite_mod->mod = NULL;\n\t\t\t\tsite_mod->next = NULL;\n\t\t\t\tsite_mod->sites = static_call_key_sites(key);\n\n\t\t\t\tkey->mods = site_mod;\n\n\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\t\tif (!site_mod)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tsite_mod->mod = mod;\n\t\t\tsite_mod->sites = site;\n\t\t\tsite_mod->next = static_call_key_next(key);\n\t\t\tkey->mods = site_mod;\n\t\t}\n\ndo_transform:\n\t\tarch_static_call_transform(site_addr, NULL, key->func,\n\t\t\t\tstatic_call_is_tail(site));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__static_call_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "123-206",
    "snippet": "void __static_call_update(struct static_call_key *key, void *tramp, void *func)\n{\n\tstruct static_call_site *site, *stop;\n\tstruct static_call_mod *site_mod, first;\n\n\tcpus_read_lock();\n\tstatic_call_lock();\n\n\tif (key->func == func)\n\t\tgoto done;\n\n\tkey->func = func;\n\n\tarch_static_call_transform(NULL, tramp, func, false);\n\n\t/*\n\t * If uninitialized, we'll not update the callsites, but they still\n\t * point to the trampoline and we just patched that.\n\t */\n\tif (WARN_ON_ONCE(!static_call_initialized))\n\t\tgoto done;\n\n\tfirst = (struct static_call_mod){\n\t\t.next = static_call_key_next(key),\n\t\t.mod = NULL,\n\t\t.sites = static_call_key_sites(key),\n\t};\n\n\tfor (site_mod = &first; site_mod; site_mod = site_mod->next) {\n\t\tbool init = system_state < SYSTEM_RUNNING;\n\t\tstruct module *mod = site_mod->mod;\n\n\t\tif (!site_mod->sites) {\n\t\t\t/*\n\t\t\t * This can happen if the static call key is defined in\n\t\t\t * a module which doesn't use it.\n\t\t\t *\n\t\t\t * It also happens in the has_mods case, where the\n\t\t\t * 'first' entry has no sites associated with it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tstop = __stop_static_call_sites;\n\n\t\tif (mod) {\n#ifdef CONFIG_MODULES\n\t\t\tstop = mod->static_call_sites +\n\t\t\t       mod->num_static_call_sites;\n\t\t\tinit = mod->state == MODULE_STATE_COMING;\n#endif\n\t\t}\n\n\t\tfor (site = site_mod->sites;\n\t\t     site < stop && static_call_key(site) == key; site++) {\n\t\t\tvoid *site_addr = static_call_addr(site);\n\n\t\t\tif (!init && static_call_is_init(site))\n\t\t\t\tcontinue;\n\n\t\t\tif (!kernel_text_address((unsigned long)site_addr)) {\n\t\t\t\t/*\n\t\t\t\t * This skips patching built-in __exit, which\n\t\t\t\t * is part of init_section_contains() but is\n\t\t\t\t * not part of kernel_text_address().\n\t\t\t\t *\n\t\t\t\t * Skipping built-in __exit is fine since it\n\t\t\t\t * will never be executed.\n\t\t\t\t */\n\t\t\t\tWARN_ONCE(!static_call_is_init(site),\n\t\t\t\t\t  \"can't patch static call site at %pS\",\n\t\t\t\t\t  site_addr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tarch_static_call_transform(site_addr, NULL, func,\n\t\t\t\t\t\t   static_call_is_tail(site));\n\t\t}\n\t}\n\ndone:\n\tstatic_call_unlock();\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool static_call_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_unlock",
          "args": [],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "28-31",
          "snippet": "static void static_call_unlock(void)\n{\n\tmutex_unlock(&static_call_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(static_call_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(static_call_mutex);\n\nstatic void static_call_unlock(void)\n{\n\tmutex_unlock(&static_call_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_static_call_transform",
          "args": [
            "site_addr",
            "NULL",
            "func",
            "static_call_is_tail(site)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_call_is_tail",
          "args": [
            "site"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_is_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "54-57",
          "snippet": "static inline bool static_call_is_tail(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline bool static_call_is_tail(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!static_call_is_init(site)",
            "\"can't patch static call site at %pS\"",
            "site_addr"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_call_is_init",
          "args": [
            "site"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_is_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "49-52",
          "snippet": "static inline bool static_call_is_init(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline bool static_call_is_init(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_text_address",
          "args": [
            "(unsigned long)site_addr"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_text_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/extable.c",
          "lines": "93-132",
          "snippet": "int kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots,\n\t * is_bpf_text_address() and is_bpf_image_address require\n\t * RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/sections.h>",
            "#include <linux/filter.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/extable.h>",
            "#include <linux/memory.h>",
            "#include <linux/ftrace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/sections.h>\n#include <linux/filter.h>\n#include <linux/kprobes.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/extable.h>\n#include <linux/memory.h>\n#include <linux/ftrace.h>\n\nint kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots,\n\t * is_bpf_text_address() and is_bpf_image_address require\n\t * RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_addr",
          "args": [
            "site"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "33-36",
          "snippet": "static inline void *static_call_addr(struct static_call_site *site)\n{\n\treturn (void *)((long)site->addr + (long)&site->addr);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline void *static_call_addr(struct static_call_site *site)\n{\n\treturn (void *)((long)site->addr + (long)&site->addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_key",
          "args": [
            "site"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_key_sites",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "115-121",
          "snippet": "static inline struct static_call_site *static_call_key_sites(struct static_call_key *key)\n{\n\tif (static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn (struct static_call_site *)(key->type & ~1);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline struct static_call_site *static_call_key_sites(struct static_call_key *key)\n{\n\tif (static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn (struct static_call_site *)(key->type & ~1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call_key_next",
          "args": [
            "key"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_key_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "107-113",
          "snippet": "static inline struct static_call_mod *static_call_key_next(struct static_call_key *key)\n{\n\tif (!static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn key->mods;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline struct static_call_mod *static_call_key_next(struct static_call_key *key)\n{\n\tif (!static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn key->mods;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!static_call_initialized"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_static_call_transform",
          "args": [
            "NULL",
            "tramp",
            "func",
            "false"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_call_lock",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "23-26",
          "snippet": "static void static_call_lock(void)\n{\n\tmutex_lock(&static_call_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(static_call_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(static_call_mutex);\n\nstatic void static_call_lock(void)\n{\n\tmutex_lock(&static_call_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic bool static_call_initialized;\n\nvoid __static_call_update(struct static_call_key *key, void *tramp, void *func)\n{\n\tstruct static_call_site *site, *stop;\n\tstruct static_call_mod *site_mod, first;\n\n\tcpus_read_lock();\n\tstatic_call_lock();\n\n\tif (key->func == func)\n\t\tgoto done;\n\n\tkey->func = func;\n\n\tarch_static_call_transform(NULL, tramp, func, false);\n\n\t/*\n\t * If uninitialized, we'll not update the callsites, but they still\n\t * point to the trampoline and we just patched that.\n\t */\n\tif (WARN_ON_ONCE(!static_call_initialized))\n\t\tgoto done;\n\n\tfirst = (struct static_call_mod){\n\t\t.next = static_call_key_next(key),\n\t\t.mod = NULL,\n\t\t.sites = static_call_key_sites(key),\n\t};\n\n\tfor (site_mod = &first; site_mod; site_mod = site_mod->next) {\n\t\tbool init = system_state < SYSTEM_RUNNING;\n\t\tstruct module *mod = site_mod->mod;\n\n\t\tif (!site_mod->sites) {\n\t\t\t/*\n\t\t\t * This can happen if the static call key is defined in\n\t\t\t * a module which doesn't use it.\n\t\t\t *\n\t\t\t * It also happens in the has_mods case, where the\n\t\t\t * 'first' entry has no sites associated with it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tstop = __stop_static_call_sites;\n\n\t\tif (mod) {\n#ifdef CONFIG_MODULES\n\t\t\tstop = mod->static_call_sites +\n\t\t\t       mod->num_static_call_sites;\n\t\t\tinit = mod->state == MODULE_STATE_COMING;\n#endif\n\t\t}\n\n\t\tfor (site = site_mod->sites;\n\t\t     site < stop && static_call_key(site) == key; site++) {\n\t\t\tvoid *site_addr = static_call_addr(site);\n\n\t\t\tif (!init && static_call_is_init(site))\n\t\t\t\tcontinue;\n\n\t\t\tif (!kernel_text_address((unsigned long)site_addr)) {\n\t\t\t\t/*\n\t\t\t\t * This skips patching built-in __exit, which\n\t\t\t\t * is part of init_section_contains() but is\n\t\t\t\t * not part of kernel_text_address().\n\t\t\t\t *\n\t\t\t\t * Skipping built-in __exit is fine since it\n\t\t\t\t * will never be executed.\n\t\t\t\t */\n\t\t\t\tWARN_ONCE(!static_call_is_init(site),\n\t\t\t\t\t  \"can't patch static call site at %pS\",\n\t\t\t\t\t  site_addr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tarch_static_call_transform(site_addr, NULL, func,\n\t\t\t\t\t\t   static_call_is_tail(site));\n\t\t}\n\t}\n\ndone:\n\tstatic_call_unlock();\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "static_call_key_sites",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "115-121",
    "snippet": "static inline struct static_call_site *static_call_key_sites(struct static_call_key *key)\n{\n\tif (static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn (struct static_call_site *)(key->type & ~1);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_call_key_has_mods",
          "args": [
            "key"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_key_has_mods",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "102-105",
          "snippet": "static inline bool static_call_key_has_mods(struct static_call_key *key)\n{\n\treturn !(key->type & 1);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline bool static_call_key_has_mods(struct static_call_key *key)\n{\n\treturn !(key->type & 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline struct static_call_site *static_call_key_sites(struct static_call_key *key)\n{\n\tif (static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn (struct static_call_site *)(key->type & ~1);\n}"
  },
  {
    "function_name": "static_call_key_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "107-113",
    "snippet": "static inline struct static_call_mod *static_call_key_next(struct static_call_key *key)\n{\n\tif (!static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn key->mods;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_call_key_has_mods",
          "args": [
            "key"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_key_has_mods",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "102-105",
          "snippet": "static inline bool static_call_key_has_mods(struct static_call_key *key)\n{\n\treturn !(key->type & 1);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline bool static_call_key_has_mods(struct static_call_key *key)\n{\n\treturn !(key->type & 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline struct static_call_mod *static_call_key_next(struct static_call_key *key)\n{\n\tif (!static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn key->mods;\n}"
  },
  {
    "function_name": "static_call_key_has_mods",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "102-105",
    "snippet": "static inline bool static_call_key_has_mods(struct static_call_key *key)\n{\n\treturn !(key->type & 1);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline bool static_call_key_has_mods(struct static_call_key *key)\n{\n\treturn !(key->type & 1);\n}"
  },
  {
    "function_name": "static_call_sort_entries",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "95-100",
    "snippet": "static inline void static_call_sort_entries(struct static_call_site *start,\n\t\t\t\t\t    struct static_call_site *stop)\n{\n\tsort(start, stop - start, sizeof(struct static_call_site),\n\t     static_call_site_cmp, static_call_site_swap);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "start",
            "stop - start",
            "sizeof(struct static_call_site)",
            "static_call_site_cmp",
            "static_call_site_swap"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline void static_call_sort_entries(struct static_call_site *start,\n\t\t\t\t\t    struct static_call_site *stop)\n{\n\tsort(start, stop - start, sizeof(struct static_call_site),\n\t     static_call_site_cmp, static_call_site_swap);\n}"
  },
  {
    "function_name": "static_call_site_swap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "81-93",
    "snippet": "static void static_call_site_swap(void *_a, void *_b, int size)\n{\n\tlong delta = (unsigned long)_a - (unsigned long)_b;\n\tstruct static_call_site *a = _a;\n\tstruct static_call_site *b = _b;\n\tstruct static_call_site tmp = *a;\n\n\ta->addr = b->addr  - delta;\n\ta->key  = b->key   - delta;\n\n\tb->addr = tmp.addr + delta;\n\tb->key  = tmp.key  + delta;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic void static_call_site_swap(void *_a, void *_b, int size)\n{\n\tlong delta = (unsigned long)_a - (unsigned long)_b;\n\tstruct static_call_site *a = _a;\n\tstruct static_call_site *b = _b;\n\tstruct static_call_site tmp = *a;\n\n\ta->addr = b->addr  - delta;\n\ta->key  = b->key   - delta;\n\n\tb->addr = tmp.addr + delta;\n\tb->key  = tmp.key  + delta;\n}"
  },
  {
    "function_name": "static_call_site_cmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "65-79",
    "snippet": "static int static_call_site_cmp(const void *_a, const void *_b)\n{\n\tconst struct static_call_site *a = _a;\n\tconst struct static_call_site *b = _b;\n\tconst struct static_call_key *key_a = static_call_key(a);\n\tconst struct static_call_key *key_b = static_call_key(b);\n\n\tif (key_a < key_b)\n\t\treturn -1;\n\n\tif (key_a > key_b)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_call_key",
          "args": [
            "b"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_key_sites",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "115-121",
          "snippet": "static inline struct static_call_site *static_call_key_sites(struct static_call_key *key)\n{\n\tif (static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn (struct static_call_site *)(key->type & ~1);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline struct static_call_site *static_call_key_sites(struct static_call_key *key)\n{\n\tif (static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn (struct static_call_site *)(key->type & ~1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int static_call_site_cmp(const void *_a, const void *_b)\n{\n\tconst struct static_call_site *a = _a;\n\tconst struct static_call_site *b = _b;\n\tconst struct static_call_key *key_a = static_call_key(a);\n\tconst struct static_call_key *key_b = static_call_key(b);\n\n\tif (key_a < key_b)\n\t\treturn -1;\n\n\tif (key_a > key_b)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "static_call_set_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "59-63",
    "snippet": "static inline void static_call_set_init(struct static_call_site *site)\n{\n\tsite->key = (__static_call_key(site) | STATIC_CALL_SITE_INIT) -\n\t\t    (long)&site->key;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__static_call_key",
          "args": [
            "site"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "__static_call_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "38-41",
          "snippet": "static inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline void static_call_set_init(struct static_call_site *site)\n{\n\tsite->key = (__static_call_key(site) | STATIC_CALL_SITE_INIT) -\n\t\t    (long)&site->key;\n}"
  },
  {
    "function_name": "static_call_is_tail",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "54-57",
    "snippet": "static inline bool static_call_is_tail(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__static_call_key",
          "args": [
            "site"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "__static_call_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "38-41",
          "snippet": "static inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline bool static_call_is_tail(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;\n}"
  },
  {
    "function_name": "static_call_is_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "49-52",
    "snippet": "static inline bool static_call_is_init(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__static_call_key",
          "args": [
            "site"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "__static_call_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "38-41",
          "snippet": "static inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline bool static_call_is_init(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;\n}"
  },
  {
    "function_name": "static_call_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "43-46",
    "snippet": "static inline struct static_call_key *static_call_key(const struct static_call_site *site)\n{\n\treturn (void *)(__static_call_key(site) & ~STATIC_CALL_SITE_FLAGS);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__static_call_key",
          "args": [
            "site"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "__static_call_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "38-41",
          "snippet": "static inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline struct static_call_key *static_call_key(const struct static_call_site *site)\n{\n\treturn (void *)(__static_call_key(site) & ~STATIC_CALL_SITE_FLAGS);\n}"
  },
  {
    "function_name": "__static_call_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "38-41",
    "snippet": "static inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}"
  },
  {
    "function_name": "static_call_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "33-36",
    "snippet": "static inline void *static_call_addr(struct static_call_site *site)\n{\n\treturn (void *)((long)site->addr + (long)&site->addr);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic inline void *static_call_addr(struct static_call_site *site)\n{\n\treturn (void *)((long)site->addr + (long)&site->addr);\n}"
  },
  {
    "function_name": "static_call_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "28-31",
    "snippet": "static void static_call_unlock(void)\n{\n\tmutex_unlock(&static_call_mutex);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(static_call_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&static_call_mutex"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(static_call_mutex);\n\nstatic void static_call_unlock(void)\n{\n\tmutex_unlock(&static_call_mutex);\n}"
  },
  {
    "function_name": "static_call_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
    "lines": "23-26",
    "snippet": "static void static_call_lock(void)\n{\n\tmutex_lock(&static_call_mutex);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/processor.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/smp.h>",
      "#include <linux/bug.h>",
      "#include <linux/static_call.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(static_call_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&static_call_mutex"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(static_call_mutex);\n\nstatic void static_call_lock(void)\n{\n\tmutex_lock(&static_call_mutex);\n}"
  }
]