[
  {
    "function_name": "pm_autosleep_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/autosleep.c",
    "lines": "117-129",
    "snippet": "int __init pm_autosleep_init(void)\n{\n\tautosleep_ws = wakeup_source_register(NULL, \"autosleep\");\n\tif (!autosleep_ws)\n\t\treturn -ENOMEM;\n\n\tautosleep_wq = alloc_ordered_workqueue(\"autosleep\", 0);\n\tif (autosleep_wq)\n\t\treturn 0;\n\n\twakeup_source_unregister(autosleep_ws);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_wakeup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *autosleep_wq;",
      "static struct wakeup_source *autosleep_ws;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_source_unregister",
          "args": [
            "autosleep_ws"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_ordered_workqueue",
          "args": [
            "\"autosleep\"",
            "0"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_register",
          "args": [
            "NULL",
            "\"autosleep\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_wakeup.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n\nstatic struct workqueue_struct *autosleep_wq;\nstatic struct wakeup_source *autosleep_ws;\n\nint __init pm_autosleep_init(void)\n{\n\tautosleep_ws = wakeup_source_register(NULL, \"autosleep\");\n\tif (!autosleep_ws)\n\t\treturn -ENOMEM;\n\n\tautosleep_wq = alloc_ordered_workqueue(\"autosleep\", 0);\n\tif (autosleep_wq)\n\t\treturn 0;\n\n\twakeup_source_unregister(autosleep_ws);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "pm_autosleep_set_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/autosleep.c",
    "lines": "90-115",
    "snippet": "int pm_autosleep_set_state(suspend_state_t state)\n{\n\n#ifndef CONFIG_HIBERNATION\n\tif (state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n#endif\n\n\t__pm_stay_awake(autosleep_ws);\n\n\tmutex_lock(&autosleep_lock);\n\n\tautosleep_state = state;\n\n\t__pm_relax(autosleep_ws);\n\n\tif (state > PM_SUSPEND_ON) {\n\t\tpm_wakep_autosleep_enabled(true);\n\t\tqueue_up_suspend_work();\n\t} else {\n\t\tpm_wakep_autosleep_enabled(false);\n\t}\n\n\tmutex_unlock(&autosleep_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_wakeup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static suspend_state_t autosleep_state;",
      "static DEFINE_MUTEX(autosleep_lock);",
      "static struct wakeup_source *autosleep_ws;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&autosleep_lock"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_wakep_autosleep_enabled",
          "args": [
            "false"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_up_suspend_work",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "queue_up_suspend_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/autosleep.c",
          "lines": "69-73",
          "snippet": "void queue_up_suspend_work(void)\n{\n\tif (autosleep_state > PM_SUSPEND_ON)\n\t\tqueue_work(autosleep_wq, &suspend_work);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_wakeup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static suspend_state_t autosleep_state;",
            "static struct workqueue_struct *autosleep_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_wakeup.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n\nstatic suspend_state_t autosleep_state;\nstatic struct workqueue_struct *autosleep_wq;\n\nvoid queue_up_suspend_work(void)\n{\n\tif (autosleep_state > PM_SUSPEND_ON)\n\t\tqueue_work(autosleep_wq, &suspend_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_wakep_autosleep_enabled",
          "args": [
            "true"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_relax",
          "args": [
            "autosleep_ws"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&autosleep_lock"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pm_stay_awake",
          "args": [
            "autosleep_ws"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_wakeup.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n\nstatic suspend_state_t autosleep_state;\nstatic DEFINE_MUTEX(autosleep_lock);\nstatic struct wakeup_source *autosleep_ws;\n\nint pm_autosleep_set_state(suspend_state_t state)\n{\n\n#ifndef CONFIG_HIBERNATION\n\tif (state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n#endif\n\n\t__pm_stay_awake(autosleep_ws);\n\n\tmutex_lock(&autosleep_lock);\n\n\tautosleep_state = state;\n\n\t__pm_relax(autosleep_ws);\n\n\tif (state > PM_SUSPEND_ON) {\n\t\tpm_wakep_autosleep_enabled(true);\n\t\tqueue_up_suspend_work();\n\t} else {\n\t\tpm_wakep_autosleep_enabled(false);\n\t}\n\n\tmutex_unlock(&autosleep_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "pm_autosleep_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/autosleep.c",
    "lines": "85-88",
    "snippet": "void pm_autosleep_unlock(void)\n{\n\tmutex_unlock(&autosleep_lock);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_wakeup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(autosleep_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&autosleep_lock"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_wakeup.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(autosleep_lock);\n\nvoid pm_autosleep_unlock(void)\n{\n\tmutex_unlock(&autosleep_lock);\n}"
  },
  {
    "function_name": "pm_autosleep_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/autosleep.c",
    "lines": "80-83",
    "snippet": "int pm_autosleep_lock(void)\n{\n\treturn mutex_lock_interruptible(&autosleep_lock);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_wakeup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(autosleep_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&autosleep_lock"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "568-571",
          "snippet": "int __sched mutex_lock_interruptible(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched mutex_lock_interruptible(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_wakeup.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(autosleep_lock);\n\nint pm_autosleep_lock(void)\n{\n\treturn mutex_lock_interruptible(&autosleep_lock);\n}"
  },
  {
    "function_name": "pm_autosleep_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/autosleep.c",
    "lines": "75-78",
    "snippet": "suspend_state_t pm_autosleep_state(void)\n{\n\treturn autosleep_state;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_wakeup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static suspend_state_t autosleep_state;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_wakeup.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n\nstatic suspend_state_t autosleep_state;\n\nsuspend_state_t pm_autosleep_state(void)\n{\n\treturn autosleep_state;\n}"
  },
  {
    "function_name": "queue_up_suspend_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/autosleep.c",
    "lines": "69-73",
    "snippet": "void queue_up_suspend_work(void)\n{\n\tif (autosleep_state > PM_SUSPEND_ON)\n\t\tqueue_work(autosleep_wq, &suspend_work);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_wakeup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static suspend_state_t autosleep_state;",
      "static struct workqueue_struct *autosleep_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "autosleep_wq",
            "&suspend_work"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_wakeup.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n\nstatic suspend_state_t autosleep_state;\nstatic struct workqueue_struct *autosleep_wq;\n\nvoid queue_up_suspend_work(void)\n{\n\tif (autosleep_state > PM_SUSPEND_ON)\n\t\tqueue_work(autosleep_wq, &suspend_work);\n}"
  },
  {
    "function_name": "try_to_suspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/autosleep.c",
    "lines": "27-65",
    "snippet": "static void try_to_suspend(struct work_struct *work)\n{\n\tunsigned int initial_count, final_count;\n\n\tif (!pm_get_wakeup_count(&initial_count, true))\n\t\tgoto out;\n\n\tmutex_lock(&autosleep_lock);\n\n\tif (!pm_save_wakeup_count(initial_count) ||\n\t\tsystem_state != SYSTEM_RUNNING) {\n\t\tmutex_unlock(&autosleep_lock);\n\t\tgoto out;\n\t}\n\n\tif (autosleep_state == PM_SUSPEND_ON) {\n\t\tmutex_unlock(&autosleep_lock);\n\t\treturn;\n\t}\n\tif (autosleep_state >= PM_SUSPEND_MAX)\n\t\thibernate();\n\telse\n\t\tpm_suspend(autosleep_state);\n\n\tmutex_unlock(&autosleep_lock);\n\n\tif (!pm_get_wakeup_count(&final_count, false))\n\t\tgoto out;\n\n\t/*\n\t * If the wakeup occurred for an unknown reason, wait to prevent the\n\t * system from trying to suspend and waking up in a tight loop.\n\t */\n\tif (final_count == initial_count)\n\t\tschedule_timeout_uninterruptible(HZ / 2);\n\n out:\n\tqueue_up_suspend_work();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_wakeup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static suspend_state_t autosleep_state;",
      "static DEFINE_MUTEX(autosleep_lock);",
      "static DECLARE_WORK(suspend_work, try_to_suspend);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_up_suspend_work",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "queue_up_suspend_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/autosleep.c",
          "lines": "69-73",
          "snippet": "void queue_up_suspend_work(void)\n{\n\tif (autosleep_state > PM_SUSPEND_ON)\n\t\tqueue_work(autosleep_wq, &suspend_work);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_wakeup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static suspend_state_t autosleep_state;",
            "static struct workqueue_struct *autosleep_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_wakeup.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n\nstatic suspend_state_t autosleep_state;\nstatic struct workqueue_struct *autosleep_wq;\n\nvoid queue_up_suspend_work(void)\n{\n\tif (autosleep_state > PM_SUSPEND_ON)\n\t\tqueue_work(autosleep_wq, &suspend_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "HZ / 2"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_get_wakeup_count",
          "args": [
            "&final_count",
            "false"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&autosleep_lock"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_suspend",
          "args": [
            "autosleep_state"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "pm_suspend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/suspend.c",
          "lines": "605-622",
          "snippet": "int pm_suspend(suspend_state_t state)\n{\n\tint error;\n\n\tif (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n\n\tpr_info(\"suspend entry (%s)\\n\", mem_sleep_labels[state]);\n\terror = enter_state(state);\n\tif (error) {\n\t\tsuspend_stats.fail++;\n\t\tdpm_save_failed_errno(error);\n\t} else {\n\t\tsuspend_stats.success++;\n\t}\n\tpr_info(\"suspend exit\\n\");\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/moduleparam.h>",
            "#include <linux/compiler.h>",
            "#include <trace/events/power.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/swait.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/moduleparam.h>\n#include <linux/compiler.h>\n#include <trace/events/power.h>\n#include <linux/ftrace.h>\n#include <linux/swait.h>\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/gfp.h>\n#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n\nstatic const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};\n\nint pm_suspend(suspend_state_t state)\n{\n\tint error;\n\n\tif (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n\n\tpr_info(\"suspend entry (%s)\\n\", mem_sleep_labels[state]);\n\terror = enter_state(state);\n\tif (error) {\n\t\tsuspend_stats.fail++;\n\t\tdpm_save_failed_errno(error);\n\t} else {\n\t\tsuspend_stats.success++;\n\t}\n\tpr_info(\"suspend exit\\n\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "712-800",
          "snippet": "int hibernate(void)\n{\n\tbool snapshot_test = false;\n\tint error;\n\n\tif (!hibernation_available()) {\n\t\tpm_pr_dbg(\"Hibernation not available.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tlock_system_sleep();\n\t/* The snapshot device should not be opened while we're running */\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"hibernation entry\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\tif (error)\n\t\tgoto Restore;\n\n\tksys_sync_helper();\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Exit;\n\n\tlock_device_hotplug();\n\t/* Allocate memory management structures */\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Thaw;\n\n\terror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\n\tif (error || freezer_test_done)\n\t\tgoto Free_bitmaps;\n\n\tif (in_suspend) {\n\t\tunsigned int flags = 0;\n\n\t\tif (hibernation_mode == HIBERNATION_PLATFORM)\n\t\t\tflags |= SF_PLATFORM_MODE;\n\t\tif (nocompress)\n\t\t\tflags |= SF_NOCOMPRESS_MODE;\n\t\telse\n\t\t        flags |= SF_CRC32_MODE;\n\n\t\tpm_pr_dbg(\"Writing hibernation image.\\n\");\n\t\terror = swsusp_write(flags);\n\t\tswsusp_free();\n\t\tif (!error) {\n\t\t\tif (hibernation_mode == HIBERNATION_TEST_RESUME)\n\t\t\t\tsnapshot_test = true;\n\t\t\telse\n\t\t\t\tpower_down();\n\t\t}\n\t\tin_suspend = 0;\n\t\tpm_restore_gfp_mask();\n\t} else {\n\t\tpm_pr_dbg(\"Hibernation image restored successfully.\\n\");\n\t}\n\n Free_bitmaps:\n\tfree_basic_memory_bitmaps();\n Thaw:\n\tunlock_device_hotplug();\n\tif (snapshot_test) {\n\t\tpm_pr_dbg(\"Checking hibernation image\\n\");\n\t\terror = swsusp_check();\n\t\tif (!error)\n\t\t\terror = load_image_and_restore();\n\t}\n\tthaw_processes();\n\n\t/* Don't bother checking whether freezer_test_done is true */\n\tfreezer_test_done = false;\n Exit:\n\tpm_notifier_call_chain(PM_POST_HIBERNATION);\n Restore:\n\tpm_restore_console();\n\thibernate_release();\n Unlock:\n\tunlock_system_sleep();\n\tpr_info(\"hibernation exit\\n\");\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nocompress;",
            "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
            "bool freezer_test_done;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nocompress;\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nbool freezer_test_done;\n\nint hibernate(void)\n{\n\tbool snapshot_test = false;\n\tint error;\n\n\tif (!hibernation_available()) {\n\t\tpm_pr_dbg(\"Hibernation not available.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tlock_system_sleep();\n\t/* The snapshot device should not be opened while we're running */\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"hibernation entry\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\tif (error)\n\t\tgoto Restore;\n\n\tksys_sync_helper();\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Exit;\n\n\tlock_device_hotplug();\n\t/* Allocate memory management structures */\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Thaw;\n\n\terror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\n\tif (error || freezer_test_done)\n\t\tgoto Free_bitmaps;\n\n\tif (in_suspend) {\n\t\tunsigned int flags = 0;\n\n\t\tif (hibernation_mode == HIBERNATION_PLATFORM)\n\t\t\tflags |= SF_PLATFORM_MODE;\n\t\tif (nocompress)\n\t\t\tflags |= SF_NOCOMPRESS_MODE;\n\t\telse\n\t\t        flags |= SF_CRC32_MODE;\n\n\t\tpm_pr_dbg(\"Writing hibernation image.\\n\");\n\t\terror = swsusp_write(flags);\n\t\tswsusp_free();\n\t\tif (!error) {\n\t\t\tif (hibernation_mode == HIBERNATION_TEST_RESUME)\n\t\t\t\tsnapshot_test = true;\n\t\t\telse\n\t\t\t\tpower_down();\n\t\t}\n\t\tin_suspend = 0;\n\t\tpm_restore_gfp_mask();\n\t} else {\n\t\tpm_pr_dbg(\"Hibernation image restored successfully.\\n\");\n\t}\n\n Free_bitmaps:\n\tfree_basic_memory_bitmaps();\n Thaw:\n\tunlock_device_hotplug();\n\tif (snapshot_test) {\n\t\tpm_pr_dbg(\"Checking hibernation image\\n\");\n\t\terror = swsusp_check();\n\t\tif (!error)\n\t\t\terror = load_image_and_restore();\n\t}\n\tthaw_processes();\n\n\t/* Don't bother checking whether freezer_test_done is true */\n\tfreezer_test_done = false;\n Exit:\n\tpm_notifier_call_chain(PM_POST_HIBERNATION);\n Restore:\n\tpm_restore_console();\n\thibernate_release();\n Unlock:\n\tunlock_system_sleep();\n\tpr_info(\"hibernation exit\\n\");\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_save_wakeup_count",
          "args": [
            "initial_count"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&autosleep_lock"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_get_wakeup_count",
          "args": [
            "&initial_count",
            "true"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_wakeup.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n\nstatic suspend_state_t autosleep_state;\nstatic DEFINE_MUTEX(autosleep_lock);\nstatic DECLARE_WORK(suspend_work, try_to_suspend);\n\nstatic void try_to_suspend(struct work_struct *work)\n{\n\tunsigned int initial_count, final_count;\n\n\tif (!pm_get_wakeup_count(&initial_count, true))\n\t\tgoto out;\n\n\tmutex_lock(&autosleep_lock);\n\n\tif (!pm_save_wakeup_count(initial_count) ||\n\t\tsystem_state != SYSTEM_RUNNING) {\n\t\tmutex_unlock(&autosleep_lock);\n\t\tgoto out;\n\t}\n\n\tif (autosleep_state == PM_SUSPEND_ON) {\n\t\tmutex_unlock(&autosleep_lock);\n\t\treturn;\n\t}\n\tif (autosleep_state >= PM_SUSPEND_MAX)\n\t\thibernate();\n\telse\n\t\tpm_suspend(autosleep_state);\n\n\tmutex_unlock(&autosleep_lock);\n\n\tif (!pm_get_wakeup_count(&final_count, false))\n\t\tgoto out;\n\n\t/*\n\t * If the wakeup occurred for an unknown reason, wait to prevent the\n\t * system from trying to suspend and waking up in a tight loop.\n\t */\n\tif (final_count == initial_count)\n\t\tschedule_timeout_uninterruptible(HZ / 2);\n\n out:\n\tqueue_up_suspend_work();\n}"
  }
]