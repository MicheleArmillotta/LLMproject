[
  {
    "function_name": "arch_dynirq_lower_bound",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "996-999",
    "snippet": "unsigned int __weak arch_dynirq_lower_bound(unsigned int from)\n{\n\treturn from;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nunsigned int __weak arch_dynirq_lower_bound(unsigned int from)\n{\n\treturn from;\n}"
  },
  {
    "function_name": "arch_early_irq_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "991-994",
    "snippet": "__weak arch_early_irq_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\n__weak arch_early_irq_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_probe_nr_irqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "986-989",
    "snippet": "__weak arch_probe_nr_irqs(void)\n{\n\treturn NR_IRQS_LEGACY;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\n__weak arch_probe_nr_irqs(void)\n{\n\treturn NR_IRQS_LEGACY;\n}"
  },
  {
    "function_name": "early_irq_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "981-984",
    "snippet": "__weak early_irq_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\n__weak early_irq_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "spawn_ksoftirqd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "966-973",
    "snippet": "static __init int spawn_ksoftirqd(void)\n{\n\tcpuhp_setup_state_nocalls(CPUHP_SOFTIRQ_DEAD, \"softirq:dead\", NULL,\n\t\t\t\t  takeover_tasklets);\n\tBUG_ON(smpboot_register_percpu_thread(&softirq_threads));\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define takeover_tasklets\tNULL"
    ],
    "globals_used": [
      "static struct smp_hotplug_thread softirq_threads = {\n\t.store\t\t\t= &ksoftirqd,\n\t.thread_should_run\t= ksoftirqd_should_run,\n\t.thread_fn\t\t= run_ksoftirqd,\n\t.thread_comm\t\t= \"ksoftirqd/%u\",\n};",
      "int __init",
      "int __init",
      "int __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "smpboot_register_percpu_thread(&softirq_threads)"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smpboot_register_percpu_thread",
          "args": [
            "&softirq_threads"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "smpboot_register_percpu_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smpboot.c",
          "lines": "289-309",
          "snippet": "int smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(hotplug_threads);",
            "static DEFINE_MUTEX(smpboot_threads_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic LIST_HEAD(hotplug_threads);\nstatic DEFINE_MUTEX(smpboot_threads_lock);\n\nint smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_SOFTIRQ_DEAD",
            "\"softirq:dead\"",
            "NULL",
            "takeover_tasklets"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\n#define takeover_tasklets\tNULL\n\nstatic struct smp_hotplug_thread softirq_threads = {\n\t.store\t\t\t= &ksoftirqd,\n\t.thread_should_run\t= ksoftirqd_should_run,\n\t.thread_fn\t\t= run_ksoftirqd,\n\t.thread_comm\t\t= \"ksoftirqd/%u\",\n};\nint __init;\nint __init;\nint __init;\n\nstatic __init int spawn_ksoftirqd(void)\n{\n\tcpuhp_setup_state_nocalls(CPUHP_SOFTIRQ_DEAD, \"softirq:dead\", NULL,\n\t\t\t\t  takeover_tasklets);\n\tBUG_ON(smpboot_register_percpu_thread(&softirq_threads));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "takeover_tasklets",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "930-954",
    "snippet": "static int takeover_tasklets(unsigned int cpu)\n{\n\t/* CPU is dead, so no lock needed. */\n\tlocal_irq_disable();\n\n\t/* Find end, append list for that CPU. */\n\tif (&per_cpu(tasklet_vec, cpu).head != per_cpu(tasklet_vec, cpu).tail) {\n\t\t*__this_cpu_read(tasklet_vec.tail) = per_cpu(tasklet_vec, cpu).head;\n\t\t__this_cpu_write(tasklet_vec.tail, per_cpu(tasklet_vec, cpu).tail);\n\t\tper_cpu(tasklet_vec, cpu).head = NULL;\n\t\tper_cpu(tasklet_vec, cpu).tail = &per_cpu(tasklet_vec, cpu).head;\n\t}\n\traise_softirq_irqoff(TASKLET_SOFTIRQ);\n\n\tif (&per_cpu(tasklet_hi_vec, cpu).head != per_cpu(tasklet_hi_vec, cpu).tail) {\n\t\t*__this_cpu_read(tasklet_hi_vec.tail) = per_cpu(tasklet_hi_vec, cpu).head;\n\t\t__this_cpu_write(tasklet_hi_vec.tail, per_cpu(tasklet_hi_vec, cpu).tail);\n\t\tper_cpu(tasklet_hi_vec, cpu).head = NULL;\n\t\tper_cpu(tasklet_hi_vec, cpu).tail = &per_cpu(tasklet_hi_vec, cpu).head;\n\t}\n\traise_softirq_irqoff(HI_SOFTIRQ);\n\n\tlocal_irq_enable();\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define takeover_tasklets\tNULL"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);",
      "static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raise_softirq_irqoff",
          "args": [
            "HI_SOFTIRQ"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "696-701",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tasklet_hi_vec",
            "cpu"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "tasklet_hi_vec.tail",
            "per_cpu(tasklet_hi_vec, cpu).tail"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "tasklet_hi_vec.tail"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "tasklet_vec.tail",
            "per_cpu(tasklet_vec, cpu).tail"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "tasklet_vec.tail"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\n#define takeover_tasklets\tNULL\n\nstatic DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);\nstatic DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);\n\nstatic int takeover_tasklets(unsigned int cpu)\n{\n\t/* CPU is dead, so no lock needed. */\n\tlocal_irq_disable();\n\n\t/* Find end, append list for that CPU. */\n\tif (&per_cpu(tasklet_vec, cpu).head != per_cpu(tasklet_vec, cpu).tail) {\n\t\t*__this_cpu_read(tasklet_vec.tail) = per_cpu(tasklet_vec, cpu).head;\n\t\t__this_cpu_write(tasklet_vec.tail, per_cpu(tasklet_vec, cpu).tail);\n\t\tper_cpu(tasklet_vec, cpu).head = NULL;\n\t\tper_cpu(tasklet_vec, cpu).tail = &per_cpu(tasklet_vec, cpu).head;\n\t}\n\traise_softirq_irqoff(TASKLET_SOFTIRQ);\n\n\tif (&per_cpu(tasklet_hi_vec, cpu).head != per_cpu(tasklet_hi_vec, cpu).tail) {\n\t\t*__this_cpu_read(tasklet_hi_vec.tail) = per_cpu(tasklet_hi_vec, cpu).head;\n\t\t__this_cpu_write(tasklet_hi_vec.tail, per_cpu(tasklet_hi_vec, cpu).tail);\n\t\tper_cpu(tasklet_hi_vec, cpu).head = NULL;\n\t\tper_cpu(tasklet_hi_vec, cpu).tail = &per_cpu(tasklet_hi_vec, cpu).head;\n\t}\n\traise_softirq_irqoff(HI_SOFTIRQ);\n\n\tlocal_irq_enable();\n\treturn 0;\n}"
  },
  {
    "function_name": "run_ksoftirqd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "913-927",
    "snippet": "static void run_ksoftirqd(unsigned int cpu)\n{\n\tksoftirqd_run_begin();\n\tif (local_softirq_pending()) {\n\t\t/*\n\t\t * We can safely run softirq on inline stack, as we are not deep\n\t\t * in the task stack here.\n\t\t */\n\t\t__do_softirq();\n\t\tksoftirqd_run_end();\n\t\tcond_resched();\n\t\treturn;\n\t}\n\tksoftirqd_run_end();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ksoftirqd_run_end",
          "args": [],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "ksoftirqd_run_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "410-413",
          "snippet": "static inline void ksoftirqd_run_end(void)\n{\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void ksoftirqd_run_end(void)\n{\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_softirq",
          "args": [],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksoftirqd_run_begin",
          "args": [],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "ksoftirqd_run_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "405-408",
          "snippet": "static inline void ksoftirqd_run_begin(void)\n{\n\tlocal_irq_disable();\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void ksoftirqd_run_begin(void)\n{\n\tlocal_irq_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void run_ksoftirqd(unsigned int cpu)\n{\n\tksoftirqd_run_begin();\n\tif (local_softirq_pending()) {\n\t\t/*\n\t\t * We can safely run softirq on inline stack, as we are not deep\n\t\t * in the task stack here.\n\t\t */\n\t\t__do_softirq();\n\t\tksoftirqd_run_end();\n\t\tcond_resched();\n\t\treturn;\n\t}\n\tksoftirqd_run_end();\n}"
  },
  {
    "function_name": "ksoftirqd_should_run",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "908-911",
    "snippet": "static int ksoftirqd_should_run(unsigned int cpu)\n{\n\treturn local_softirq_pending();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic int ksoftirqd_should_run(unsigned int cpu)\n{\n\treturn local_softirq_pending();\n}"
  },
  {
    "function_name": "softirq_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "893-906",
    "snippet": "void __init softirq_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tper_cpu(tasklet_vec, cpu).tail =\n\t\t\t&per_cpu(tasklet_vec, cpu).head;\n\t\tper_cpu(tasklet_hi_vec, cpu).tail =\n\t\t\t&per_cpu(tasklet_hi_vec, cpu).head;\n\t}\n\n\topen_softirq(TASKLET_SOFTIRQ, tasklet_action);\n\topen_softirq(HI_SOFTIRQ, tasklet_hi_action);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);",
      "static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);",
      "int __init",
      "int __init",
      "int __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "open_softirq",
          "args": [
            "HI_SOFTIRQ",
            "tasklet_hi_action"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "open_softirq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "703-706",
          "snippet": "void open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct softirq_action softirq_vec[NR_SOFTIRQS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic struct softirq_action softirq_vec[NR_SOFTIRQS];\n\nvoid open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tasklet_hi_vec",
            "cpu"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);\nstatic DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);\nint __init;\nint __init;\nint __init;\n\nvoid __init softirq_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tper_cpu(tasklet_vec, cpu).tail =\n\t\t\t&per_cpu(tasklet_vec, cpu).head;\n\t\tper_cpu(tasklet_hi_vec, cpu).tail =\n\t\t\t&per_cpu(tasklet_hi_vec, cpu).head;\n\t}\n\n\topen_softirq(TASKLET_SOFTIRQ, tasklet_action);\n\topen_softirq(HI_SOFTIRQ, tasklet_hi_action);\n}"
  },
  {
    "function_name": "tasklet_unlock_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "886-889",
    "snippet": "void tasklet_unlock_wait(struct tasklet_struct *t)\n{\n\twait_var_event(&t->state, !test_bit(TASKLET_STATE_RUN, &t->state));\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_var_event",
          "args": [
            "&t->state",
            "!test_bit(TASKLET_STATE_RUN, &t->state)"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TASKLET_STATE_RUN",
            "&t->state"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid tasklet_unlock_wait(struct tasklet_struct *t)\n{\n\twait_var_event(&t->state, !test_bit(TASKLET_STATE_RUN, &t->state));\n}"
  },
  {
    "function_name": "tasklet_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "877-883",
    "snippet": "void tasklet_unlock(struct tasklet_struct *t)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(TASKLET_STATE_RUN, &t->state);\n\tsmp_mb__after_atomic();\n\twake_up_var(&t->state);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_var",
          "args": [
            "&t->state"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait_bit.c",
          "lines": "191-194",
          "snippet": "void wake_up_var(void *var)\n{\n\t__wake_up_bit(__var_waitqueue(var), var, -1);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid wake_up_var(void *var)\n{\n\t__wake_up_bit(__var_waitqueue(var), var, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "TASKLET_STATE_RUN",
            "&t->state"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid tasklet_unlock(struct tasklet_struct *t)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(TASKLET_STATE_RUN, &t->state);\n\tsmp_mb__after_atomic();\n\twake_up_var(&t->state);\n}"
  },
  {
    "function_name": "tasklet_kill",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "863-873",
    "snippet": "void tasklet_kill(struct tasklet_struct *t)\n{\n\tif (in_interrupt())\n\t\tpr_notice(\"Attempt to kill tasklet from interrupt\\n\");\n\n\twhile (test_and_set_bit(TASKLET_STATE_SCHED, &t->state))\n\t\twait_var_event(&t->state, !test_bit(TASKLET_STATE_SCHED, &t->state));\n\n\ttasklet_unlock_wait(t);\n\ttasklet_clear_sched(t);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasklet_clear_sched",
          "args": [
            "t"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "tasklet_clear_sched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "749-761",
          "snippet": "static bool tasklet_clear_sched(struct tasklet_struct *t)\n{\n\tif (test_and_clear_bit(TASKLET_STATE_SCHED, &t->state)) {\n\t\twake_up_var(&t->state);\n\t\treturn true;\n\t}\n\n\tWARN_ONCE(1, \"tasklet SCHED state not set: %s %pS\\n\",\n\t\t  t->use_callback ? \"callback\" : \"func\",\n\t\t  t->use_callback ? (void *)t->callback : (void *)t->func);\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic bool tasklet_clear_sched(struct tasklet_struct *t)\n{\n\tif (test_and_clear_bit(TASKLET_STATE_SCHED, &t->state)) {\n\t\twake_up_var(&t->state);\n\t\treturn true;\n\t}\n\n\tWARN_ONCE(1, \"tasklet SCHED state not set: %s %pS\\n\",\n\t\t  t->use_callback ? \"callback\" : \"func\",\n\t\t  t->use_callback ? (void *)t->callback : (void *)t->func);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tasklet_unlock_wait",
          "args": [
            "t"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "tasklet_unlock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "886-889",
          "snippet": "void tasklet_unlock_wait(struct tasklet_struct *t)\n{\n\twait_var_event(&t->state, !test_bit(TASKLET_STATE_RUN, &t->state));\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid tasklet_unlock_wait(struct tasklet_struct *t)\n{\n\twait_var_event(&t->state, !test_bit(TASKLET_STATE_RUN, &t->state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_var_event",
          "args": [
            "&t->state",
            "!test_bit(TASKLET_STATE_SCHED, &t->state)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TASKLET_STATE_SCHED",
            "&t->state"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "TASKLET_STATE_SCHED",
            "&t->state"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Attempt to kill tasklet from interrupt\\n\""
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid tasklet_kill(struct tasklet_struct *t)\n{\n\tif (in_interrupt())\n\t\tpr_notice(\"Attempt to kill tasklet from interrupt\\n\");\n\n\twhile (test_and_set_bit(TASKLET_STATE_SCHED, &t->state))\n\t\twait_var_event(&t->state, !test_bit(TASKLET_STATE_SCHED, &t->state));\n\n\ttasklet_unlock_wait(t);\n\ttasklet_clear_sched(t);\n}"
  },
  {
    "function_name": "tasklet_unlock_spin_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "842-859",
    "snippet": "void tasklet_unlock_spin_wait(struct tasklet_struct *t)\n{\n\twhile (test_bit(TASKLET_STATE_RUN, &(t)->state)) {\n\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\t\t/*\n\t\t\t * Prevent a live lock when current preempted soft\n\t\t\t * interrupt processing or prevents ksoftirqd from\n\t\t\t * running. If the tasklet runs on a different CPU\n\t\t\t * then this has no effect other than doing the BH\n\t\t\t * disable/enable dance for nothing.\n\t\t\t */\n\t\t\tlocal_bh_disable();\n\t\t\tlocal_bh_enable();\n\t\t} else {\n\t\t\tcpu_relax();\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "353-357",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TASKLET_STATE_RUN",
            "&(t)->state"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid tasklet_unlock_spin_wait(struct tasklet_struct *t)\n{\n\twhile (test_bit(TASKLET_STATE_RUN, &(t)->state)) {\n\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\t\t/*\n\t\t\t * Prevent a live lock when current preempted soft\n\t\t\t * interrupt processing or prevents ksoftirqd from\n\t\t\t * running. If the tasklet runs on a different CPU\n\t\t\t * then this has no effect other than doing the BH\n\t\t\t * disable/enable dance for nothing.\n\t\t\t */\n\t\t\tlocal_bh_disable();\n\t\t\tlocal_bh_enable();\n\t\t} else {\n\t\t\tcpu_relax();\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "tasklet_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "825-834",
    "snippet": "void tasklet_init(struct tasklet_struct *t,\n\t\t  void (*func)(unsigned long), unsigned long data)\n{\n\tt->next = NULL;\n\tt->state = 0;\n\tatomic_set(&t->count, 0);\n\tt->func = func;\n\tt->use_callback = false;\n\tt->data = data;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&t->count",
            "0"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid tasklet_init(struct tasklet_struct *t,\n\t\t  void (*func)(unsigned long), unsigned long data)\n{\n\tt->next = NULL;\n\tt->state = 0;\n\tatomic_set(&t->count, 0);\n\tt->func = func;\n\tt->use_callback = false;\n\tt->data = data;\n}"
  },
  {
    "function_name": "tasklet_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "813-822",
    "snippet": "void tasklet_setup(struct tasklet_struct *t,\n\t\t   void (*callback)(struct tasklet_struct *))\n{\n\tt->next = NULL;\n\tt->state = 0;\n\tatomic_set(&t->count, 0);\n\tt->callback = callback;\n\tt->use_callback = true;\n\tt->data = 0;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&t->count",
            "0"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid tasklet_setup(struct tasklet_struct *t,\n\t\t   void (*callback)(struct tasklet_struct *))\n{\n\tt->next = NULL;\n\tt->state = 0;\n\tatomic_set(&t->count, 0);\n\tt->callback = callback;\n\tt->use_callback = true;\n\tt->data = 0;\n}"
  },
  {
    "function_name": "tasklet_hi_action",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "808-811",
    "snippet": "static __latent_entropy void tasklet_hi_action(struct softirq_action *a)\n{\n\ttasklet_action_common(a, this_cpu_ptr(&tasklet_hi_vec), HI_SOFTIRQ);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasklet_action_common",
          "args": [
            "a",
            "this_cpu_ptr(&tasklet_hi_vec)",
            "HI_SOFTIRQ"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "tasklet_action_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "763-801",
          "snippet": "static void tasklet_action_common(struct softirq_action *a,\n\t\t\t\t  struct tasklet_head *tl_head,\n\t\t\t\t  unsigned int softirq_nr)\n{\n\tstruct tasklet_struct *list;\n\n\tlocal_irq_disable();\n\tlist = tl_head->head;\n\ttl_head->head = NULL;\n\ttl_head->tail = &tl_head->head;\n\tlocal_irq_enable();\n\n\twhile (list) {\n\t\tstruct tasklet_struct *t = list;\n\n\t\tlist = list->next;\n\n\t\tif (tasklet_trylock(t)) {\n\t\t\tif (!atomic_read(&t->count)) {\n\t\t\t\tif (tasklet_clear_sched(t)) {\n\t\t\t\t\tif (t->use_callback)\n\t\t\t\t\t\tt->callback(t);\n\t\t\t\t\telse\n\t\t\t\t\t\tt->func(t->data);\n\t\t\t\t}\n\t\t\t\ttasklet_unlock(t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttasklet_unlock(t);\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tt->next = NULL;\n\t\t*tl_head->tail = t;\n\t\ttl_head->tail = &t->next;\n\t\t__raise_softirq_irqoff(softirq_nr);\n\t\tlocal_irq_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void tasklet_action_common(struct softirq_action *a,\n\t\t\t\t  struct tasklet_head *tl_head,\n\t\t\t\t  unsigned int softirq_nr)\n{\n\tstruct tasklet_struct *list;\n\n\tlocal_irq_disable();\n\tlist = tl_head->head;\n\ttl_head->head = NULL;\n\ttl_head->tail = &tl_head->head;\n\tlocal_irq_enable();\n\n\twhile (list) {\n\t\tstruct tasklet_struct *t = list;\n\n\t\tlist = list->next;\n\n\t\tif (tasklet_trylock(t)) {\n\t\t\tif (!atomic_read(&t->count)) {\n\t\t\t\tif (tasklet_clear_sched(t)) {\n\t\t\t\t\tif (t->use_callback)\n\t\t\t\t\t\tt->callback(t);\n\t\t\t\t\telse\n\t\t\t\t\t\tt->func(t->data);\n\t\t\t\t}\n\t\t\t\ttasklet_unlock(t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttasklet_unlock(t);\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tt->next = NULL;\n\t\t*tl_head->tail = t;\n\t\ttl_head->tail = &t->next;\n\t\t__raise_softirq_irqoff(softirq_nr);\n\t\tlocal_irq_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tasklet_hi_vec"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);\n\nstatic __latent_entropy void tasklet_hi_action(struct softirq_action *a)\n{\n\ttasklet_action_common(a, this_cpu_ptr(&tasklet_hi_vec), HI_SOFTIRQ);\n}"
  },
  {
    "function_name": "tasklet_action",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "803-806",
    "snippet": "static __latent_entropy void tasklet_action(struct softirq_action *a)\n{\n\ttasklet_action_common(a, this_cpu_ptr(&tasklet_vec), TASKLET_SOFTIRQ);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasklet_action_common",
          "args": [
            "a",
            "this_cpu_ptr(&tasklet_vec)",
            "TASKLET_SOFTIRQ"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "tasklet_action_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "763-801",
          "snippet": "static void tasklet_action_common(struct softirq_action *a,\n\t\t\t\t  struct tasklet_head *tl_head,\n\t\t\t\t  unsigned int softirq_nr)\n{\n\tstruct tasklet_struct *list;\n\n\tlocal_irq_disable();\n\tlist = tl_head->head;\n\ttl_head->head = NULL;\n\ttl_head->tail = &tl_head->head;\n\tlocal_irq_enable();\n\n\twhile (list) {\n\t\tstruct tasklet_struct *t = list;\n\n\t\tlist = list->next;\n\n\t\tif (tasklet_trylock(t)) {\n\t\t\tif (!atomic_read(&t->count)) {\n\t\t\t\tif (tasklet_clear_sched(t)) {\n\t\t\t\t\tif (t->use_callback)\n\t\t\t\t\t\tt->callback(t);\n\t\t\t\t\telse\n\t\t\t\t\t\tt->func(t->data);\n\t\t\t\t}\n\t\t\t\ttasklet_unlock(t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttasklet_unlock(t);\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tt->next = NULL;\n\t\t*tl_head->tail = t;\n\t\ttl_head->tail = &t->next;\n\t\t__raise_softirq_irqoff(softirq_nr);\n\t\tlocal_irq_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void tasklet_action_common(struct softirq_action *a,\n\t\t\t\t  struct tasklet_head *tl_head,\n\t\t\t\t  unsigned int softirq_nr)\n{\n\tstruct tasklet_struct *list;\n\n\tlocal_irq_disable();\n\tlist = tl_head->head;\n\ttl_head->head = NULL;\n\ttl_head->tail = &tl_head->head;\n\tlocal_irq_enable();\n\n\twhile (list) {\n\t\tstruct tasklet_struct *t = list;\n\n\t\tlist = list->next;\n\n\t\tif (tasklet_trylock(t)) {\n\t\t\tif (!atomic_read(&t->count)) {\n\t\t\t\tif (tasklet_clear_sched(t)) {\n\t\t\t\t\tif (t->use_callback)\n\t\t\t\t\t\tt->callback(t);\n\t\t\t\t\telse\n\t\t\t\t\t\tt->func(t->data);\n\t\t\t\t}\n\t\t\t\ttasklet_unlock(t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttasklet_unlock(t);\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tt->next = NULL;\n\t\t*tl_head->tail = t;\n\t\ttl_head->tail = &t->next;\n\t\t__raise_softirq_irqoff(softirq_nr);\n\t\tlocal_irq_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tasklet_vec"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);\n\nstatic __latent_entropy void tasklet_action(struct softirq_action *a)\n{\n\ttasklet_action_common(a, this_cpu_ptr(&tasklet_vec), TASKLET_SOFTIRQ);\n}"
  },
  {
    "function_name": "tasklet_action_common",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "763-801",
    "snippet": "static void tasklet_action_common(struct softirq_action *a,\n\t\t\t\t  struct tasklet_head *tl_head,\n\t\t\t\t  unsigned int softirq_nr)\n{\n\tstruct tasklet_struct *list;\n\n\tlocal_irq_disable();\n\tlist = tl_head->head;\n\ttl_head->head = NULL;\n\ttl_head->tail = &tl_head->head;\n\tlocal_irq_enable();\n\n\twhile (list) {\n\t\tstruct tasklet_struct *t = list;\n\n\t\tlist = list->next;\n\n\t\tif (tasklet_trylock(t)) {\n\t\t\tif (!atomic_read(&t->count)) {\n\t\t\t\tif (tasklet_clear_sched(t)) {\n\t\t\t\t\tif (t->use_callback)\n\t\t\t\t\t\tt->callback(t);\n\t\t\t\t\telse\n\t\t\t\t\t\tt->func(t->data);\n\t\t\t\t}\n\t\t\t\ttasklet_unlock(t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttasklet_unlock(t);\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tt->next = NULL;\n\t\t*tl_head->tail = t;\n\t\ttl_head->tail = &t->next;\n\t\t__raise_softirq_irqoff(softirq_nr);\n\t\tlocal_irq_enable();\n\t}\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__raise_softirq_irqoff",
          "args": [
            "softirq_nr"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "696-701",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasklet_unlock",
          "args": [
            "t"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "tasklet_unlock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "886-889",
          "snippet": "void tasklet_unlock_wait(struct tasklet_struct *t)\n{\n\twait_var_event(&t->state, !test_bit(TASKLET_STATE_RUN, &t->state));\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid tasklet_unlock_wait(struct tasklet_struct *t)\n{\n\twait_var_event(&t->state, !test_bit(TASKLET_STATE_RUN, &t->state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->func",
          "args": [
            "t->data"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->callback",
          "args": [
            "t"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasklet_clear_sched",
          "args": [
            "t"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "tasklet_clear_sched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "749-761",
          "snippet": "static bool tasklet_clear_sched(struct tasklet_struct *t)\n{\n\tif (test_and_clear_bit(TASKLET_STATE_SCHED, &t->state)) {\n\t\twake_up_var(&t->state);\n\t\treturn true;\n\t}\n\n\tWARN_ONCE(1, \"tasklet SCHED state not set: %s %pS\\n\",\n\t\t  t->use_callback ? \"callback\" : \"func\",\n\t\t  t->use_callback ? (void *)t->callback : (void *)t->func);\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic bool tasklet_clear_sched(struct tasklet_struct *t)\n{\n\tif (test_and_clear_bit(TASKLET_STATE_SCHED, &t->state)) {\n\t\twake_up_var(&t->state);\n\t\treturn true;\n\t}\n\n\tWARN_ONCE(1, \"tasklet SCHED state not set: %s %pS\\n\",\n\t\t  t->use_callback ? \"callback\" : \"func\",\n\t\t  t->use_callback ? (void *)t->callback : (void *)t->func);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&t->count"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasklet_trylock",
          "args": [
            "t"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void tasklet_action_common(struct softirq_action *a,\n\t\t\t\t  struct tasklet_head *tl_head,\n\t\t\t\t  unsigned int softirq_nr)\n{\n\tstruct tasklet_struct *list;\n\n\tlocal_irq_disable();\n\tlist = tl_head->head;\n\ttl_head->head = NULL;\n\ttl_head->tail = &tl_head->head;\n\tlocal_irq_enable();\n\n\twhile (list) {\n\t\tstruct tasklet_struct *t = list;\n\n\t\tlist = list->next;\n\n\t\tif (tasklet_trylock(t)) {\n\t\t\tif (!atomic_read(&t->count)) {\n\t\t\t\tif (tasklet_clear_sched(t)) {\n\t\t\t\t\tif (t->use_callback)\n\t\t\t\t\t\tt->callback(t);\n\t\t\t\t\telse\n\t\t\t\t\t\tt->func(t->data);\n\t\t\t\t}\n\t\t\t\ttasklet_unlock(t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttasklet_unlock(t);\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tt->next = NULL;\n\t\t*tl_head->tail = t;\n\t\ttl_head->tail = &t->next;\n\t\t__raise_softirq_irqoff(softirq_nr);\n\t\tlocal_irq_enable();\n\t}\n}"
  },
  {
    "function_name": "tasklet_clear_sched",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "749-761",
    "snippet": "static bool tasklet_clear_sched(struct tasklet_struct *t)\n{\n\tif (test_and_clear_bit(TASKLET_STATE_SCHED, &t->state)) {\n\t\twake_up_var(&t->state);\n\t\treturn true;\n\t}\n\n\tWARN_ONCE(1, \"tasklet SCHED state not set: %s %pS\\n\",\n\t\t  t->use_callback ? \"callback\" : \"func\",\n\t\t  t->use_callback ? (void *)t->callback : (void *)t->func);\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"tasklet SCHED state not set: %s %pS\\n\"",
            "t->use_callback ? \"callback\" : \"func\"",
            "t->use_callback ? (void *)t->callback : (void *)t->func"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_var",
          "args": [
            "&t->state"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait_bit.c",
          "lines": "191-194",
          "snippet": "void wake_up_var(void *var)\n{\n\t__wake_up_bit(__var_waitqueue(var), var, -1);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid wake_up_var(void *var)\n{\n\t__wake_up_bit(__var_waitqueue(var), var, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "TASKLET_STATE_SCHED",
            "&t->state"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic bool tasklet_clear_sched(struct tasklet_struct *t)\n{\n\tif (test_and_clear_bit(TASKLET_STATE_SCHED, &t->state)) {\n\t\twake_up_var(&t->state);\n\t\treturn true;\n\t}\n\n\tWARN_ONCE(1, \"tasklet SCHED state not set: %s %pS\\n\",\n\t\t  t->use_callback ? \"callback\" : \"func\",\n\t\t  t->use_callback ? (void *)t->callback : (void *)t->func);\n\n\treturn false;\n}"
  },
  {
    "function_name": "__tasklet_hi_schedule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "742-746",
    "snippet": "void __tasklet_hi_schedule(struct tasklet_struct *t)\n{\n\t__tasklet_schedule_common(t, &tasklet_hi_vec,\n\t\t\t\t  HI_SOFTIRQ);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tasklet_schedule_common",
          "args": [
            "t",
            "&tasklet_hi_vec",
            "HI_SOFTIRQ"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "__tasklet_schedule_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "719-733",
          "snippet": "static void __tasklet_schedule_common(struct tasklet_struct *t,\n\t\t\t\t      struct tasklet_head __percpu *headp,\n\t\t\t\t      unsigned int softirq_nr)\n{\n\tstruct tasklet_head *head;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\thead = this_cpu_ptr(headp);\n\tt->next = NULL;\n\t*head->tail = t;\n\thead->tail = &(t->next);\n\traise_softirq_irqoff(softirq_nr);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void __tasklet_schedule_common(struct tasklet_struct *t,\n\t\t\t\t      struct tasklet_head __percpu *headp,\n\t\t\t\t      unsigned int softirq_nr)\n{\n\tstruct tasklet_head *head;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\thead = this_cpu_ptr(headp);\n\tt->next = NULL;\n\t*head->tail = t;\n\thead->tail = &(t->next);\n\traise_softirq_irqoff(softirq_nr);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);\n\nvoid __tasklet_hi_schedule(struct tasklet_struct *t)\n{\n\t__tasklet_schedule_common(t, &tasklet_hi_vec,\n\t\t\t\t  HI_SOFTIRQ);\n}"
  },
  {
    "function_name": "__tasklet_schedule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "735-739",
    "snippet": "void __tasklet_schedule(struct tasklet_struct *t)\n{\n\t__tasklet_schedule_common(t, &tasklet_vec,\n\t\t\t\t  TASKLET_SOFTIRQ);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tasklet_schedule_common",
          "args": [
            "t",
            "&tasklet_vec",
            "TASKLET_SOFTIRQ"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "__tasklet_schedule_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "719-733",
          "snippet": "static void __tasklet_schedule_common(struct tasklet_struct *t,\n\t\t\t\t      struct tasklet_head __percpu *headp,\n\t\t\t\t      unsigned int softirq_nr)\n{\n\tstruct tasklet_head *head;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\thead = this_cpu_ptr(headp);\n\tt->next = NULL;\n\t*head->tail = t;\n\thead->tail = &(t->next);\n\traise_softirq_irqoff(softirq_nr);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void __tasklet_schedule_common(struct tasklet_struct *t,\n\t\t\t\t      struct tasklet_head __percpu *headp,\n\t\t\t\t      unsigned int softirq_nr)\n{\n\tstruct tasklet_head *head;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\thead = this_cpu_ptr(headp);\n\tt->next = NULL;\n\t*head->tail = t;\n\thead->tail = &(t->next);\n\traise_softirq_irqoff(softirq_nr);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);\n\nvoid __tasklet_schedule(struct tasklet_struct *t)\n{\n\t__tasklet_schedule_common(t, &tasklet_vec,\n\t\t\t\t  TASKLET_SOFTIRQ);\n}"
  },
  {
    "function_name": "__tasklet_schedule_common",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "719-733",
    "snippet": "static void __tasklet_schedule_common(struct tasklet_struct *t,\n\t\t\t\t      struct tasklet_head __percpu *headp,\n\t\t\t\t      unsigned int softirq_nr)\n{\n\tstruct tasklet_head *head;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\thead = this_cpu_ptr(headp);\n\tt->next = NULL;\n\t*head->tail = t;\n\thead->tail = &(t->next);\n\traise_softirq_irqoff(softirq_nr);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raise_softirq_irqoff",
          "args": [
            "softirq_nr"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "696-701",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "headp"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void __tasklet_schedule_common(struct tasklet_struct *t,\n\t\t\t\t      struct tasklet_head __percpu *headp,\n\t\t\t\t      unsigned int softirq_nr)\n{\n\tstruct tasklet_head *head;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\thead = this_cpu_ptr(headp);\n\tt->next = NULL;\n\t*head->tail = t;\n\thead->tail = &(t->next);\n\traise_softirq_irqoff(softirq_nr);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "open_softirq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "703-706",
    "snippet": "void open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct softirq_action softirq_vec[NR_SOFTIRQS]"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic struct softirq_action softirq_vec[NR_SOFTIRQS];\n\nvoid open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}"
  },
  {
    "function_name": "__raise_softirq_irqoff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "696-701",
    "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "or_softirq_pending",
          "args": [
            "1UL << nr"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_softirq_raise",
          "args": [
            "nr"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
  },
  {
    "function_name": "raise_softirq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "687-694",
    "snippet": "void raise_softirq(unsigned int nr)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\traise_softirq_irqoff(nr);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raise_softirq_irqoff",
          "args": [
            "nr"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "696-701",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid raise_softirq(unsigned int nr)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\traise_softirq_irqoff(nr);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "raise_softirq_irqoff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "670-685",
    "snippet": "inline void raise_softirq_irqoff(unsigned int nr)\n{\n\t__raise_softirq_irqoff(nr);\n\n\t/*\n\t * If we're in an interrupt or softirq, we're done\n\t * (this also catches softirq-disabled code). We will\n\t * actually run the softirq once we return from\n\t * the irq or softirq.\n\t *\n\t * Otherwise we wake up ksoftirqd to make sure we\n\t * schedule the softirq soon.\n\t */\n\tif (!in_interrupt() && should_wake_ksoftirqd())\n\t\twakeup_softirqd();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_softirqd",
          "args": [],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_softirqd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "74-81",
          "snippet": "static void wakeup_softirqd(void)\n{\n\t/* Interrupts are disabled: no need to stop preemption */\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (tsk)\n\t\twake_up_process(tsk);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void wakeup_softirqd(void)\n{\n\t/* Interrupts are disabled: no need to stop preemption */\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (tsk)\n\t\twake_up_process(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_wake_ksoftirqd",
          "args": [],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "should_wake_ksoftirqd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "415-418",
          "snippet": "static inline bool should_wake_ksoftirqd(void)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline bool should_wake_ksoftirqd(void)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__raise_softirq_irqoff",
          "args": [
            "nr"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "696-701",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\ninline void raise_softirq_irqoff(unsigned int nr)\n{\n\t__raise_softirq_irqoff(nr);\n\n\t/*\n\t * If we're in an interrupt or softirq, we're done\n\t * (this also catches softirq-disabled code). We will\n\t * actually run the softirq once we return from\n\t * the irq or softirq.\n\t *\n\t * Otherwise we wake up ksoftirqd to make sure we\n\t * schedule the softirq soon.\n\t */\n\tif (!in_interrupt() && should_wake_ksoftirqd())\n\t\twakeup_softirqd();\n}"
  },
  {
    "function_name": "irq_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "659-665",
    "snippet": "void irq_exit(void)\n{\n\t__irq_exit_rcu();\n\trcu_irq_exit();\n\t /* must be last! */\n\tlockdep_hardirq_exit();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirq_exit",
          "args": [],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_irq_exit",
          "args": [],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_irq_exit_irqson",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "831-838",
          "snippet": "void rcu_irq_exit_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_exit();\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_irq_exit_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_exit();\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_exit_rcu",
          "args": [],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_exit_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "627-640",
          "snippet": "static inline void __irq_exit_rcu(void)\n{\n#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED\n\tlocal_irq_disable();\n#else\n\tlockdep_assert_irqs_disabled();\n#endif\n\taccount_hardirq_exit(current);\n\tpreempt_count_sub(HARDIRQ_OFFSET);\n\tif (!in_interrupt() && local_softirq_pending())\n\t\tinvoke_softirq();\n\n\ttick_irq_exit();\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void __irq_exit_rcu(void)\n{\n#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED\n\tlocal_irq_disable();\n#else\n\tlockdep_assert_irqs_disabled();\n#endif\n\taccount_hardirq_exit(current);\n\tpreempt_count_sub(HARDIRQ_OFFSET);\n\tif (!in_interrupt() && local_softirq_pending())\n\t\tinvoke_softirq();\n\n\ttick_irq_exit();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid irq_exit(void)\n{\n\t__irq_exit_rcu();\n\trcu_irq_exit();\n\t /* must be last! */\n\tlockdep_hardirq_exit();\n}"
  },
  {
    "function_name": "irq_exit_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "647-652",
    "snippet": "void irq_exit_rcu(void)\n{\n\t__irq_exit_rcu();\n\t /* must be last! */\n\tlockdep_hardirq_exit();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirq_exit",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_exit_rcu",
          "args": [],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_exit_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "627-640",
          "snippet": "static inline void __irq_exit_rcu(void)\n{\n#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED\n\tlocal_irq_disable();\n#else\n\tlockdep_assert_irqs_disabled();\n#endif\n\taccount_hardirq_exit(current);\n\tpreempt_count_sub(HARDIRQ_OFFSET);\n\tif (!in_interrupt() && local_softirq_pending())\n\t\tinvoke_softirq();\n\n\ttick_irq_exit();\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void __irq_exit_rcu(void)\n{\n#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED\n\tlocal_irq_disable();\n#else\n\tlockdep_assert_irqs_disabled();\n#endif\n\taccount_hardirq_exit(current);\n\tpreempt_count_sub(HARDIRQ_OFFSET);\n\tif (!in_interrupt() && local_softirq_pending())\n\t\tinvoke_softirq();\n\n\ttick_irq_exit();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid irq_exit_rcu(void)\n{\n\t__irq_exit_rcu();\n\t /* must be last! */\n\tlockdep_hardirq_exit();\n}"
  },
  {
    "function_name": "__irq_exit_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "627-640",
    "snippet": "static inline void __irq_exit_rcu(void)\n{\n#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED\n\tlocal_irq_disable();\n#else\n\tlockdep_assert_irqs_disabled();\n#endif\n\taccount_hardirq_exit(current);\n\tpreempt_count_sub(HARDIRQ_OFFSET);\n\tif (!in_interrupt() && local_softirq_pending())\n\t\tinvoke_softirq();\n\n\ttick_irq_exit();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_irq_exit",
          "args": [],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "tick_irq_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "614-625",
          "snippet": "static inline void tick_irq_exit(void)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tint cpu = smp_processor_id();\n\n\t/* Make sure that timer wheel updates are propagated */\n\tif ((idle_cpu(cpu) && !need_resched()) || tick_nohz_full_cpu(cpu)) {\n\t\tif (!in_irq())\n\t\t\ttick_nohz_irq_exit();\n\t}\n#endif\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void tick_irq_exit(void)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tint cpu = smp_processor_id();\n\n\t/* Make sure that timer wheel updates are propagated */\n\tif ((idle_cpu(cpu) && !need_resched()) || tick_nohz_full_cpu(cpu)) {\n\t\tif (!in_irq())\n\t\t\ttick_nohz_irq_exit();\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "invoke_softirq",
          "args": [],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_softirq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "420-444",
          "snippet": "static inline void invoke_softirq(void)\n{\n\tif (ksoftirqd_running(local_softirq_pending()))\n\t\treturn;\n\n\tif (!force_irqthreads() || !__this_cpu_read(ksoftirqd)) {\n#ifdef CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK\n\t\t/*\n\t\t * We can safely execute softirq on the current stack if\n\t\t * it is the irq stack, because it should be near empty\n\t\t * at this stage.\n\t\t */\n\t\t__do_softirq();\n#else\n\t\t/*\n\t\t * Otherwise, irq_exit() is called on the task stack that can\n\t\t * be potentially deep already. So call softirq in its own stack\n\t\t * to prevent from any overrun.\n\t\t */\n\t\tdo_softirq_own_stack();\n#endif\n\t} else {\n\t\twakeup_softirqd();\n\t}\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void invoke_softirq(void)\n{\n\tif (ksoftirqd_running(local_softirq_pending()))\n\t\treturn;\n\n\tif (!force_irqthreads() || !__this_cpu_read(ksoftirqd)) {\n#ifdef CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK\n\t\t/*\n\t\t * We can safely execute softirq on the current stack if\n\t\t * it is the irq stack, because it should be near empty\n\t\t * at this stage.\n\t\t */\n\t\t__do_softirq();\n#else\n\t\t/*\n\t\t * Otherwise, irq_exit() is called on the task stack that can\n\t\t * be potentially deep already. So call softirq in its own stack\n\t\t * to prevent from any overrun.\n\t\t */\n\t\tdo_softirq_own_stack();\n#endif\n\t} else {\n\t\twakeup_softirqd();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count_sub",
          "args": [
            "HARDIRQ_OFFSET"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_count_sub",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5468-5486",
          "snippet": "void preempt_count_sub(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(val > preempt_count()))\n\t\treturn;\n\t/*\n\t * Is the spinlock portion underflowing?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) &&\n\t\t\t!(preempt_count() & PREEMPT_MASK)))\n\t\treturn;\n#endif\n\n\tpreempt_latency_stop(val);\n\t__preempt_count_sub(val);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid preempt_count_sub(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(val > preempt_count()))\n\t\treturn;\n\t/*\n\t * Is the spinlock portion underflowing?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) &&\n\t\t\t!(preempt_count() & PREEMPT_MASK)))\n\t\treturn;\n#endif\n\n\tpreempt_latency_stop(val);\n\t__preempt_count_sub(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_hardirq_exit",
          "args": [
            "current"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void __irq_exit_rcu(void)\n{\n#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED\n\tlocal_irq_disable();\n#else\n\tlockdep_assert_irqs_disabled();\n#endif\n\taccount_hardirq_exit(current);\n\tpreempt_count_sub(HARDIRQ_OFFSET);\n\tif (!in_interrupt() && local_softirq_pending())\n\t\tinvoke_softirq();\n\n\ttick_irq_exit();\n}"
  },
  {
    "function_name": "tick_irq_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "614-625",
    "snippet": "static inline void tick_irq_exit(void)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tint cpu = smp_processor_id();\n\n\t/* Make sure that timer wheel updates are propagated */\n\tif ((idle_cpu(cpu) && !need_resched()) || tick_nohz_full_cpu(cpu)) {\n\t\tif (!in_irq())\n\t\t\ttick_nohz_irq_exit();\n\t}\n#endif\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_irq_exit",
          "args": [],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_irq_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1127-1135",
          "snippet": "void tick_nohz_irq_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->inidle)\n\t\ttick_nohz_start_idle(ts);\n\telse\n\t\ttick_nohz_full_update_tick(ts);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_irq_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->inidle)\n\t\ttick_nohz_start_idle(ts);\n\telse\n\t\ttick_nohz_full_update_tick(ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_irq",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "cpu"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_cpu",
          "args": [
            "cpu"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "available_idle_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7041-7050",
          "snippet": "int available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void tick_irq_exit(void)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tint cpu = smp_processor_id();\n\n\t/* Make sure that timer wheel updates are propagated */\n\tif ((idle_cpu(cpu) && !need_resched()) || tick_nohz_full_cpu(cpu)) {\n\t\tif (!in_irq())\n\t\t\ttick_nohz_irq_exit();\n\t}\n#endif\n}"
  },
  {
    "function_name": "irq_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "608-612",
    "snippet": "void irq_enter(void)\n{\n\trcu_irq_enter();\n\tirq_enter_rcu();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_enter_rcu",
          "args": [],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "irq_enter_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "594-603",
          "snippet": "void irq_enter_rcu(void)\n{\n\t__irq_enter_raw();\n\n\tif (tick_nohz_full_cpu(smp_processor_id()) ||\n\t    (is_idle_task(current) && (irq_count() == HARDIRQ_OFFSET)))\n\t\ttick_irq_enter();\n\n\taccount_hardirq_enter(current);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid irq_enter_rcu(void)\n{\n\t__irq_enter_raw();\n\n\tif (tick_nohz_full_cpu(smp_processor_id()) ||\n\t    (is_idle_task(current) && (irq_count() == HARDIRQ_OFFSET)))\n\t\ttick_irq_enter();\n\n\taccount_hardirq_enter(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_irq_enter",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_irq_enter_irqson",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1069-1076",
          "snippet": "void rcu_irq_enter_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_enter();\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_irq_enter_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_enter();\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid irq_enter(void)\n{\n\trcu_irq_enter();\n\tirq_enter_rcu();\n}"
  },
  {
    "function_name": "irq_enter_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "594-603",
    "snippet": "void irq_enter_rcu(void)\n{\n\t__irq_enter_raw();\n\n\tif (tick_nohz_full_cpu(smp_processor_id()) ||\n\t    (is_idle_task(current) && (irq_count() == HARDIRQ_OFFSET)))\n\t\ttick_irq_enter();\n\n\taccount_hardirq_enter(current);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_hardirq_enter",
          "args": [
            "current"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_irq_enter",
          "args": [],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "tick_irq_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1400-1404",
          "snippet": "void tick_irq_enter(void)\n{\n\ttick_check_oneshot_broadcast_this_cpu();\n\ttick_nohz_irq_enter();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_irq_enter(void)\n{\n\ttick_check_oneshot_broadcast_this_cpu();\n\ttick_nohz_irq_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_count",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_enter_raw",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid irq_enter_rcu(void)\n{\n\t__irq_enter_raw();\n\n\tif (tick_nohz_full_cpu(smp_processor_id()) ||\n\t    (is_idle_task(current) && (irq_count() == HARDIRQ_OFFSET)))\n\t\ttick_irq_enter();\n\n\taccount_hardirq_enter(current);\n}"
  },
  {
    "function_name": "lockdep_softirq_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "512-512",
    "snippet": "static inline void lockdep_softirq_end(bool in_hardirq) { }",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void lockdep_softirq_end(bool in_hardirq) { }"
  },
  {
    "function_name": "lockdep_softirq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "511-511",
    "snippet": "static inline bool lockdep_softirq_start(void) { return false; }",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline bool lockdep_softirq_start(void) { return false; }"
  },
  {
    "function_name": "lockdep_softirq_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "503-509",
    "snippet": "static inline void lockdep_softirq_end(bool in_hardirq)\n{\n\tlockdep_softirq_exit();\n\n\tif (in_hardirq)\n\t\tlockdep_hardirq_enter();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirq_enter",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_softirq_exit",
          "args": [],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void lockdep_softirq_end(bool in_hardirq)\n{\n\tlockdep_softirq_exit();\n\n\tif (in_hardirq)\n\t\tlockdep_hardirq_enter();\n}"
  },
  {
    "function_name": "lockdep_softirq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "489-501",
    "snippet": "static inline bool lockdep_softirq_start(void)\n{\n\tbool in_hardirq = false;\n\n\tif (lockdep_hardirq_context()) {\n\t\tin_hardirq = true;\n\t\tlockdep_hardirq_exit();\n\t}\n\n\tlockdep_softirq_enter();\n\n\treturn in_hardirq;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_softirq_enter",
          "args": [],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirq_exit",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirq_context",
          "args": [],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline bool lockdep_softirq_start(void)\n{\n\tbool in_hardirq = false;\n\n\tif (lockdep_hardirq_context()) {\n\t\tin_hardirq = true;\n\t\tlockdep_hardirq_exit();\n\t}\n\n\tlockdep_softirq_enter();\n\n\treturn in_hardirq;\n}"
  },
  {
    "function_name": "do_softirq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "446-462",
    "snippet": "void do_softirq(void)\n{\n\t__u32 pending;\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tpending = local_softirq_pending();\n\n\tif (pending && !ksoftirqd_running(pending))\n\t\tdo_softirq_own_stack();\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_softirq_own_stack",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksoftirqd_running",
          "args": [
            "pending"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "ksoftirqd_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "89-96",
          "snippet": "static bool ksoftirqd_running(unsigned long pending)\n{\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (pending & SOFTIRQ_NOW_MASK)\n\t\treturn false;\n\treturn tsk && task_is_running(tsk) && !__kthread_should_park(tsk);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SOFTIRQ_NOW_MASK ((1 << HI_SOFTIRQ) | (1 << TASKLET_SOFTIRQ))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\n#define SOFTIRQ_NOW_MASK ((1 << HI_SOFTIRQ) | (1 << TASKLET_SOFTIRQ))\n\nstatic bool ksoftirqd_running(unsigned long pending)\n{\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (pending & SOFTIRQ_NOW_MASK)\n\t\treturn false;\n\treturn tsk && task_is_running(tsk) && !__kthread_should_park(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid do_softirq(void)\n{\n\t__u32 pending;\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tpending = local_softirq_pending();\n\n\tif (pending && !ksoftirqd_running(pending))\n\t\tdo_softirq_own_stack();\n\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "invoke_softirq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "420-444",
    "snippet": "static inline void invoke_softirq(void)\n{\n\tif (ksoftirqd_running(local_softirq_pending()))\n\t\treturn;\n\n\tif (!force_irqthreads() || !__this_cpu_read(ksoftirqd)) {\n#ifdef CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK\n\t\t/*\n\t\t * We can safely execute softirq on the current stack if\n\t\t * it is the irq stack, because it should be near empty\n\t\t * at this stage.\n\t\t */\n\t\t__do_softirq();\n#else\n\t\t/*\n\t\t * Otherwise, irq_exit() is called on the task stack that can\n\t\t * be potentially deep already. So call softirq in its own stack\n\t\t * to prevent from any overrun.\n\t\t */\n\t\tdo_softirq_own_stack();\n#endif\n\t} else {\n\t\twakeup_softirqd();\n\t}\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_softirqd",
          "args": [],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_softirqd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "74-81",
          "snippet": "static void wakeup_softirqd(void)\n{\n\t/* Interrupts are disabled: no need to stop preemption */\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (tsk)\n\t\twake_up_process(tsk);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void wakeup_softirqd(void)\n{\n\t/* Interrupts are disabled: no need to stop preemption */\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (tsk)\n\t\twake_up_process(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_softirq_own_stack",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_softirq",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "ksoftirqd"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_irqthreads",
          "args": [],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksoftirqd_running",
          "args": [
            "local_softirq_pending()"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ksoftirqd_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "89-96",
          "snippet": "static bool ksoftirqd_running(unsigned long pending)\n{\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (pending & SOFTIRQ_NOW_MASK)\n\t\treturn false;\n\treturn tsk && task_is_running(tsk) && !__kthread_should_park(tsk);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SOFTIRQ_NOW_MASK ((1 << HI_SOFTIRQ) | (1 << TASKLET_SOFTIRQ))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\n#define SOFTIRQ_NOW_MASK ((1 << HI_SOFTIRQ) | (1 << TASKLET_SOFTIRQ))\n\nstatic bool ksoftirqd_running(unsigned long pending)\n{\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (pending & SOFTIRQ_NOW_MASK)\n\t\treturn false;\n\treturn tsk && task_is_running(tsk) && !__kthread_should_park(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void invoke_softirq(void)\n{\n\tif (ksoftirqd_running(local_softirq_pending()))\n\t\treturn;\n\n\tif (!force_irqthreads() || !__this_cpu_read(ksoftirqd)) {\n#ifdef CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK\n\t\t/*\n\t\t * We can safely execute softirq on the current stack if\n\t\t * it is the irq stack, because it should be near empty\n\t\t * at this stage.\n\t\t */\n\t\t__do_softirq();\n#else\n\t\t/*\n\t\t * Otherwise, irq_exit() is called on the task stack that can\n\t\t * be potentially deep already. So call softirq in its own stack\n\t\t * to prevent from any overrun.\n\t\t */\n\t\tdo_softirq_own_stack();\n#endif\n\t} else {\n\t\twakeup_softirqd();\n\t}\n}"
  },
  {
    "function_name": "should_wake_ksoftirqd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "415-418",
    "snippet": "static inline bool should_wake_ksoftirqd(void)\n{\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline bool should_wake_ksoftirqd(void)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "ksoftirqd_run_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "410-413",
    "snippet": "static inline void ksoftirqd_run_end(void)\n{\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void ksoftirqd_run_end(void)\n{\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "ksoftirqd_run_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "405-408",
    "snippet": "static inline void ksoftirqd_run_begin(void)\n{\n\tlocal_irq_disable();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void ksoftirqd_run_begin(void)\n{\n\tlocal_irq_disable();\n}"
  },
  {
    "function_name": "softirq_handle_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "399-403",
    "snippet": "static inline void softirq_handle_end(void)\n{\n\t__local_bh_enable(SOFTIRQ_OFFSET);\n\tWARN_ON_ONCE(in_interrupt());\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_interrupt()"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__local_bh_enable",
          "args": [
            "SOFTIRQ_OFFSET"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "__local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "336-347",
          "snippet": "static void __local_bh_enable(unsigned int cnt)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (preempt_count() == cnt)\n\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_on(_RET_IP_);\n\n\t__preempt_count_sub(cnt);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void __local_bh_enable(unsigned int cnt)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (preempt_count() == cnt)\n\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_on(_RET_IP_);\n\n\t__preempt_count_sub(cnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void softirq_handle_end(void)\n{\n\t__local_bh_enable(SOFTIRQ_OFFSET);\n\tWARN_ON_ONCE(in_interrupt());\n}"
  },
  {
    "function_name": "softirq_handle_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "394-397",
    "snippet": "static inline void softirq_handle_begin(void)\n{\n\t__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__local_bh_disable_ip",
          "args": [
            "_RET_IP_",
            "SOFTIRQ_OFFSET"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "__local_bh_disable_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "304-332",
          "snippet": "void __local_bh_disable_ip(unsigned long ip, unsigned int cnt)\n{\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(in_irq());\n\n\traw_local_irq_save(flags);\n\t/*\n\t * The preempt tracer hooks into preempt_count_add and will break\n\t * lockdep because it calls back into lockdep after SOFTIRQ_OFFSET\n\t * is set and before current->softirq_enabled is cleared.\n\t * We must manually increment preempt_count here and manually\n\t * call the trace_preempt_off later.\n\t */\n\t__preempt_count_add(cnt);\n\t/*\n\t * Were softirqs turned off above:\n\t */\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_off(ip);\n\traw_local_irq_restore(flags);\n\n\tif (preempt_count() == cnt) {\n#ifdef CONFIG_DEBUG_PREEMPT\n\t\tcurrent->preempt_disable_ip = get_lock_parent_ip();\n#endif\n\t\ttrace_preempt_off(CALLER_ADDR0, get_lock_parent_ip());\n\t}\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __local_bh_disable_ip(unsigned long ip, unsigned int cnt)\n{\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(in_irq());\n\n\traw_local_irq_save(flags);\n\t/*\n\t * The preempt tracer hooks into preempt_count_add and will break\n\t * lockdep because it calls back into lockdep after SOFTIRQ_OFFSET\n\t * is set and before current->softirq_enabled is cleared.\n\t * We must manually increment preempt_count here and manually\n\t * call the trace_preempt_off later.\n\t */\n\t__preempt_count_add(cnt);\n\t/*\n\t * Were softirqs turned off above:\n\t */\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_off(ip);\n\traw_local_irq_restore(flags);\n\n\tif (preempt_count() == cnt) {\n#ifdef CONFIG_DEBUG_PREEMPT\n\t\tcurrent->preempt_disable_ip = get_lock_parent_ip();\n#endif\n\t\ttrace_preempt_off(CALLER_ADDR0, get_lock_parent_ip());\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void softirq_handle_begin(void)\n{\n\t__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);\n}"
  },
  {
    "function_name": "__local_bh_enable_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "360-391",
    "snippet": "void __local_bh_enable_ip(unsigned long ip, unsigned int cnt)\n{\n\tWARN_ON_ONCE(in_irq());\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tlocal_irq_disable();\n#endif\n\t/*\n\t * Are softirqs going to be turned on now:\n\t */\n\tif (softirq_count() == SOFTIRQ_DISABLE_OFFSET)\n\t\tlockdep_softirqs_on(ip);\n\t/*\n\t * Keep preemption disabled until we are done with\n\t * softirq processing:\n\t */\n\t__preempt_count_sub(cnt - 1);\n\n\tif (unlikely(!in_interrupt() && local_softirq_pending())) {\n\t\t/*\n\t\t * Run softirq if any pending. And do it in its own stack\n\t\t * as we may be calling this deep in a task call stack already.\n\t\t */\n\t\tdo_softirq();\n\t}\n\n\tpreempt_count_dec();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tlocal_irq_enable();\n#endif\n\tpreempt_check_resched();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_check_resched",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count_dec",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_softirq",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "do_softirq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "446-462",
          "snippet": "void do_softirq(void)\n{\n\t__u32 pending;\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tpending = local_softirq_pending();\n\n\tif (pending && !ksoftirqd_running(pending))\n\t\tdo_softirq_own_stack();\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid do_softirq(void)\n{\n\t__u32 pending;\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tpending = local_softirq_pending();\n\n\tif (pending && !ksoftirqd_running(pending))\n\t\tdo_softirq_own_stack();\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!in_interrupt() && local_softirq_pending()"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__preempt_count_sub",
          "args": [
            "cnt - 1"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_softirqs_on",
          "args": [
            "ip"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_softirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4406-4441",
          "snippet": "void lockdep_softirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c, avoids\n\t * funny state and nesting things.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tdebug_atomic_inc(redundant_softirqs_on);\n\t\treturn;\n\t}\n\n\tlockdep_recursion_inc();\n\t/*\n\t * We'll do an OFF -> ON transition:\n\t */\n\tcurrent->softirqs_enabled = 1;\n\ttrace->softirq_enable_ip = ip;\n\ttrace->softirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(softirqs_on_events);\n\t/*\n\t * We are going to turn softirqs on, so set the\n\t * usage bit for all held locks, if hardirqs are\n\t * enabled too:\n\t */\n\tif (lockdep_hardirqs_enabled())\n\t\tmark_held_locks(current, LOCK_ENABLED_SOFTIRQ);\n\tlockdep_recursion_finish();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_softirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c, avoids\n\t * funny state and nesting things.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tdebug_atomic_inc(redundant_softirqs_on);\n\t\treturn;\n\t}\n\n\tlockdep_recursion_inc();\n\t/*\n\t * We'll do an OFF -> ON transition:\n\t */\n\tcurrent->softirqs_enabled = 1;\n\ttrace->softirq_enable_ip = ip;\n\ttrace->softirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(softirqs_on_events);\n\t/*\n\t * We are going to turn softirqs on, so set the\n\t * usage bit for all held locks, if hardirqs are\n\t * enabled too:\n\t */\n\tif (lockdep_hardirqs_enabled())\n\t\tmark_held_locks(current, LOCK_ENABLED_SOFTIRQ);\n\tlockdep_recursion_finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_irq()"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_irq",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __local_bh_enable_ip(unsigned long ip, unsigned int cnt)\n{\n\tWARN_ON_ONCE(in_irq());\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tlocal_irq_disable();\n#endif\n\t/*\n\t * Are softirqs going to be turned on now:\n\t */\n\tif (softirq_count() == SOFTIRQ_DISABLE_OFFSET)\n\t\tlockdep_softirqs_on(ip);\n\t/*\n\t * Keep preemption disabled until we are done with\n\t * softirq processing:\n\t */\n\t__preempt_count_sub(cnt - 1);\n\n\tif (unlikely(!in_interrupt() && local_softirq_pending())) {\n\t\t/*\n\t\t * Run softirq if any pending. And do it in its own stack\n\t\t * as we may be calling this deep in a task call stack already.\n\t\t */\n\t\tdo_softirq();\n\t}\n\n\tpreempt_count_dec();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tlocal_irq_enable();\n#endif\n\tpreempt_check_resched();\n}"
  },
  {
    "function_name": "_local_bh_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "353-357",
    "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__local_bh_enable",
          "args": [
            "SOFTIRQ_DISABLE_OFFSET"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "__local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "336-347",
          "snippet": "static void __local_bh_enable(unsigned int cnt)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (preempt_count() == cnt)\n\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_on(_RET_IP_);\n\n\t__preempt_count_sub(cnt);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void __local_bh_enable(unsigned int cnt)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (preempt_count() == cnt)\n\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_on(_RET_IP_);\n\n\t__preempt_count_sub(cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_irq()"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_irq",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
  },
  {
    "function_name": "__local_bh_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "336-347",
    "snippet": "static void __local_bh_enable(unsigned int cnt)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (preempt_count() == cnt)\n\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_on(_RET_IP_);\n\n\t__preempt_count_sub(cnt);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__preempt_count_sub",
          "args": [
            "cnt"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_softirqs_on",
          "args": [
            "_RET_IP_"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_softirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4406-4441",
          "snippet": "void lockdep_softirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c, avoids\n\t * funny state and nesting things.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tdebug_atomic_inc(redundant_softirqs_on);\n\t\treturn;\n\t}\n\n\tlockdep_recursion_inc();\n\t/*\n\t * We'll do an OFF -> ON transition:\n\t */\n\tcurrent->softirqs_enabled = 1;\n\ttrace->softirq_enable_ip = ip;\n\ttrace->softirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(softirqs_on_events);\n\t/*\n\t * We are going to turn softirqs on, so set the\n\t * usage bit for all held locks, if hardirqs are\n\t * enabled too:\n\t */\n\tif (lockdep_hardirqs_enabled())\n\t\tmark_held_locks(current, LOCK_ENABLED_SOFTIRQ);\n\tlockdep_recursion_finish();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_softirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c, avoids\n\t * funny state and nesting things.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tdebug_atomic_inc(redundant_softirqs_on);\n\t\treturn;\n\t}\n\n\tlockdep_recursion_inc();\n\t/*\n\t * We'll do an OFF -> ON transition:\n\t */\n\tcurrent->softirqs_enabled = 1;\n\ttrace->softirq_enable_ip = ip;\n\ttrace->softirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(softirqs_on_events);\n\t/*\n\t * We are going to turn softirqs on, so set the\n\t * usage bit for all held locks, if hardirqs are\n\t * enabled too:\n\t */\n\tif (lockdep_hardirqs_enabled())\n\t\tmark_held_locks(current, LOCK_ENABLED_SOFTIRQ);\n\tlockdep_recursion_finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_preempt_on",
          "args": [
            "CALLER_ADDR0",
            "get_lock_parent_ip()"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "trace_preempt_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
          "lines": "120-125",
          "snippet": "void trace_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_enable_rcuidle(a0, a1);\n\ttracer_preempt_on(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_enable_rcuidle(a0, a1);\n\ttracer_preempt_on(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_parent_ip",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void __local_bh_enable(unsigned int cnt)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (preempt_count() == cnt)\n\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_on(_RET_IP_);\n\n\t__preempt_count_sub(cnt);\n}"
  },
  {
    "function_name": "__local_bh_disable_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "304-332",
    "snippet": "void __local_bh_disable_ip(unsigned long ip, unsigned int cnt)\n{\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(in_irq());\n\n\traw_local_irq_save(flags);\n\t/*\n\t * The preempt tracer hooks into preempt_count_add and will break\n\t * lockdep because it calls back into lockdep after SOFTIRQ_OFFSET\n\t * is set and before current->softirq_enabled is cleared.\n\t * We must manually increment preempt_count here and manually\n\t * call the trace_preempt_off later.\n\t */\n\t__preempt_count_add(cnt);\n\t/*\n\t * Were softirqs turned off above:\n\t */\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_off(ip);\n\traw_local_irq_restore(flags);\n\n\tif (preempt_count() == cnt) {\n#ifdef CONFIG_DEBUG_PREEMPT\n\t\tcurrent->preempt_disable_ip = get_lock_parent_ip();\n#endif\n\t\ttrace_preempt_off(CALLER_ADDR0, get_lock_parent_ip());\n\t}\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_preempt_off",
          "args": [
            "CALLER_ADDR0",
            "get_lock_parent_ip()"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "trace_preempt_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
          "lines": "127-132",
          "snippet": "void trace_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_disable_rcuidle(a0, a1);\n\ttracer_preempt_off(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_disable_rcuidle(a0, a1);\n\ttracer_preempt_off(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_parent_ip",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_lock_parent_ip",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_softirqs_off",
          "args": [
            "ip"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_softirqs_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4446-4473",
          "snippet": "void lockdep_softirqs_off(unsigned long ip)\n{\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurrent->softirqs_enabled = 0;\n\t\ttrace->softirq_disable_ip = ip;\n\t\ttrace->softirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(softirqs_off_events);\n\t\t/*\n\t\t * Whoops, we wanted softirqs off, so why aren't they?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(!softirq_count());\n\t} else\n\t\tdebug_atomic_inc(redundant_softirqs_off);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_softirqs_off(unsigned long ip)\n{\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurrent->softirqs_enabled = 0;\n\t\ttrace->softirq_disable_ip = ip;\n\t\ttrace->softirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(softirqs_off_events);\n\t\t/*\n\t\t * Whoops, we wanted softirqs off, so why aren't they?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(!softirq_count());\n\t} else\n\t\tdebug_atomic_inc(redundant_softirqs_off);\n}"
        }
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__preempt_count_add",
          "args": [
            "cnt"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_irq()"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_irq",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __local_bh_disable_ip(unsigned long ip, unsigned int cnt)\n{\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(in_irq());\n\n\traw_local_irq_save(flags);\n\t/*\n\t * The preempt tracer hooks into preempt_count_add and will break\n\t * lockdep because it calls back into lockdep after SOFTIRQ_OFFSET\n\t * is set and before current->softirq_enabled is cleared.\n\t * We must manually increment preempt_count here and manually\n\t * call the trace_preempt_off later.\n\t */\n\t__preempt_count_add(cnt);\n\t/*\n\t * Were softirqs turned off above:\n\t */\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_off(ip);\n\traw_local_irq_restore(flags);\n\n\tif (preempt_count() == cnt) {\n#ifdef CONFIG_DEBUG_PREEMPT\n\t\tcurrent->preempt_disable_ip = get_lock_parent_ip();\n#endif\n\t\ttrace_preempt_off(CALLER_ADDR0, get_lock_parent_ip());\n\t}\n}"
  },
  {
    "function_name": "invoke_softirq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "291-295",
    "snippet": "static inline void invoke_softirq(void)\n{\n\tif (should_wake_ksoftirqd())\n\t\twakeup_softirqd();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_softirqd",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_softirqd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "74-81",
          "snippet": "static void wakeup_softirqd(void)\n{\n\t/* Interrupts are disabled: no need to stop preemption */\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (tsk)\n\t\twake_up_process(tsk);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void wakeup_softirqd(void)\n{\n\t/* Interrupts are disabled: no need to stop preemption */\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (tsk)\n\t\twake_up_process(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_wake_ksoftirqd",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "should_wake_ksoftirqd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "415-418",
          "snippet": "static inline bool should_wake_ksoftirqd(void)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline bool should_wake_ksoftirqd(void)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void invoke_softirq(void)\n{\n\tif (should_wake_ksoftirqd())\n\t\twakeup_softirqd();\n}"
  },
  {
    "function_name": "should_wake_ksoftirqd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "286-289",
    "snippet": "static inline bool should_wake_ksoftirqd(void)\n{\n\treturn !this_cpu_read(softirq_ctrl.cnt);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "softirq_ctrl.cnt"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline bool should_wake_ksoftirqd(void)\n{\n\treturn !this_cpu_read(softirq_ctrl.cnt);\n}"
  },
  {
    "function_name": "softirq_handle_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "284-284",
    "snippet": "static inline void softirq_handle_end(void) { }",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void softirq_handle_end(void) { }"
  },
  {
    "function_name": "softirq_handle_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "283-283",
    "snippet": "static inline void softirq_handle_begin(void) { }",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void softirq_handle_begin(void) { }"
  },
  {
    "function_name": "ksoftirqd_run_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "276-281",
    "snippet": "static inline void ksoftirqd_run_end(void)\n{\n\t__local_bh_enable(SOFTIRQ_OFFSET, true);\n\tWARN_ON_ONCE(in_interrupt());\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_interrupt()"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__local_bh_enable",
          "args": [
            "SOFTIRQ_OFFSET",
            "true"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "__local_bh_enable_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "360-391",
          "snippet": "void __local_bh_enable_ip(unsigned long ip, unsigned int cnt)\n{\n\tWARN_ON_ONCE(in_irq());\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tlocal_irq_disable();\n#endif\n\t/*\n\t * Are softirqs going to be turned on now:\n\t */\n\tif (softirq_count() == SOFTIRQ_DISABLE_OFFSET)\n\t\tlockdep_softirqs_on(ip);\n\t/*\n\t * Keep preemption disabled until we are done with\n\t * softirq processing:\n\t */\n\t__preempt_count_sub(cnt - 1);\n\n\tif (unlikely(!in_interrupt() && local_softirq_pending())) {\n\t\t/*\n\t\t * Run softirq if any pending. And do it in its own stack\n\t\t * as we may be calling this deep in a task call stack already.\n\t\t */\n\t\tdo_softirq();\n\t}\n\n\tpreempt_count_dec();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tlocal_irq_enable();\n#endif\n\tpreempt_check_resched();\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __local_bh_enable_ip(unsigned long ip, unsigned int cnt)\n{\n\tWARN_ON_ONCE(in_irq());\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tlocal_irq_disable();\n#endif\n\t/*\n\t * Are softirqs going to be turned on now:\n\t */\n\tif (softirq_count() == SOFTIRQ_DISABLE_OFFSET)\n\t\tlockdep_softirqs_on(ip);\n\t/*\n\t * Keep preemption disabled until we are done with\n\t * softirq processing:\n\t */\n\t__preempt_count_sub(cnt - 1);\n\n\tif (unlikely(!in_interrupt() && local_softirq_pending())) {\n\t\t/*\n\t\t * Run softirq if any pending. And do it in its own stack\n\t\t * as we may be calling this deep in a task call stack already.\n\t\t */\n\t\tdo_softirq();\n\t}\n\n\tpreempt_count_dec();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tlocal_irq_enable();\n#endif\n\tpreempt_check_resched();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void ksoftirqd_run_end(void)\n{\n\t__local_bh_enable(SOFTIRQ_OFFSET, true);\n\tWARN_ON_ONCE(in_interrupt());\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "ksoftirqd_run_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "269-273",
    "snippet": "static inline void ksoftirqd_run_begin(void)\n{\n\t__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);\n\tlocal_irq_disable();\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__local_bh_disable_ip",
          "args": [
            "_RET_IP_",
            "SOFTIRQ_OFFSET"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "__local_bh_disable_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "304-332",
          "snippet": "void __local_bh_disable_ip(unsigned long ip, unsigned int cnt)\n{\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(in_irq());\n\n\traw_local_irq_save(flags);\n\t/*\n\t * The preempt tracer hooks into preempt_count_add and will break\n\t * lockdep because it calls back into lockdep after SOFTIRQ_OFFSET\n\t * is set and before current->softirq_enabled is cleared.\n\t * We must manually increment preempt_count here and manually\n\t * call the trace_preempt_off later.\n\t */\n\t__preempt_count_add(cnt);\n\t/*\n\t * Were softirqs turned off above:\n\t */\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_off(ip);\n\traw_local_irq_restore(flags);\n\n\tif (preempt_count() == cnt) {\n#ifdef CONFIG_DEBUG_PREEMPT\n\t\tcurrent->preempt_disable_ip = get_lock_parent_ip();\n#endif\n\t\ttrace_preempt_off(CALLER_ADDR0, get_lock_parent_ip());\n\t}\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __local_bh_disable_ip(unsigned long ip, unsigned int cnt)\n{\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(in_irq());\n\n\traw_local_irq_save(flags);\n\t/*\n\t * The preempt tracer hooks into preempt_count_add and will break\n\t * lockdep because it calls back into lockdep after SOFTIRQ_OFFSET\n\t * is set and before current->softirq_enabled is cleared.\n\t * We must manually increment preempt_count here and manually\n\t * call the trace_preempt_off later.\n\t */\n\t__preempt_count_add(cnt);\n\t/*\n\t * Were softirqs turned off above:\n\t */\n\tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n\t\tlockdep_softirqs_off(ip);\n\traw_local_irq_restore(flags);\n\n\tif (preempt_count() == cnt) {\n#ifdef CONFIG_DEBUG_PREEMPT\n\t\tcurrent->preempt_disable_ip = get_lock_parent_ip();\n#endif\n\t\ttrace_preempt_off(CALLER_ADDR0, get_lock_parent_ip());\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic inline void ksoftirqd_run_begin(void)\n{\n\t__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);\n\tlocal_irq_disable();\n}"
  },
  {
    "function_name": "__local_bh_enable_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "218-262",
    "snippet": "void __local_bh_enable_ip(unsigned long ip, unsigned int cnt)\n{\n\tbool preempt_on = preemptible();\n\tunsigned long flags;\n\tu32 pending;\n\tint curcnt;\n\n\tWARN_ON_ONCE(in_irq());\n\tlockdep_assert_irqs_enabled();\n\n\tlocal_irq_save(flags);\n\tcurcnt = __this_cpu_read(softirq_ctrl.cnt);\n\n\t/*\n\t * If this is not reenabling soft interrupts, no point in trying to\n\t * run pending ones.\n\t */\n\tif (curcnt != cnt)\n\t\tgoto out;\n\n\tpending = local_softirq_pending();\n\tif (!pending || ksoftirqd_running(pending))\n\t\tgoto out;\n\n\t/*\n\t * If this was called from non preemptible context, wake up the\n\t * softirq daemon.\n\t */\n\tif (!preempt_on) {\n\t\twakeup_softirqd();\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Adjust softirq count to SOFTIRQ_OFFSET which makes\n\t * in_serving_softirq() become true.\n\t */\n\tcnt = SOFTIRQ_OFFSET;\n\t__local_bh_enable(cnt, false);\n\t__do_softirq();\n\nout:\n\t__local_bh_enable(cnt, preempt_on);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__local_bh_enable",
          "args": [
            "cnt",
            "preempt_on"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "__local_bh_enable_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "360-391",
          "snippet": "void __local_bh_enable_ip(unsigned long ip, unsigned int cnt)\n{\n\tWARN_ON_ONCE(in_irq());\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tlocal_irq_disable();\n#endif\n\t/*\n\t * Are softirqs going to be turned on now:\n\t */\n\tif (softirq_count() == SOFTIRQ_DISABLE_OFFSET)\n\t\tlockdep_softirqs_on(ip);\n\t/*\n\t * Keep preemption disabled until we are done with\n\t * softirq processing:\n\t */\n\t__preempt_count_sub(cnt - 1);\n\n\tif (unlikely(!in_interrupt() && local_softirq_pending())) {\n\t\t/*\n\t\t * Run softirq if any pending. And do it in its own stack\n\t\t * as we may be calling this deep in a task call stack already.\n\t\t */\n\t\tdo_softirq();\n\t}\n\n\tpreempt_count_dec();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tlocal_irq_enable();\n#endif\n\tpreempt_check_resched();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__do_softirq",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_softirqd",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_softirqd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "74-81",
          "snippet": "static void wakeup_softirqd(void)\n{\n\t/* Interrupts are disabled: no need to stop preemption */\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (tsk)\n\t\twake_up_process(tsk);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void wakeup_softirqd(void)\n{\n\t/* Interrupts are disabled: no need to stop preemption */\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (tsk)\n\t\twake_up_process(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksoftirqd_running",
          "args": [
            "pending"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "ksoftirqd_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "89-96",
          "snippet": "static bool ksoftirqd_running(unsigned long pending)\n{\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (pending & SOFTIRQ_NOW_MASK)\n\t\treturn false;\n\treturn tsk && task_is_running(tsk) && !__kthread_should_park(tsk);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SOFTIRQ_NOW_MASK ((1 << HI_SOFTIRQ) | (1 << TASKLET_SOFTIRQ))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\n#define SOFTIRQ_NOW_MASK ((1 << HI_SOFTIRQ) | (1 << TASKLET_SOFTIRQ))\n\nstatic bool ksoftirqd_running(unsigned long pending)\n{\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (pending & SOFTIRQ_NOW_MASK)\n\t\treturn false;\n\treturn tsk && task_is_running(tsk) && !__kthread_should_park(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "softirq_ctrl.cnt"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_irq()"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_irq",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __local_bh_enable_ip(unsigned long ip, unsigned int cnt)\n{\n\tbool preempt_on = preemptible();\n\tunsigned long flags;\n\tu32 pending;\n\tint curcnt;\n\n\tWARN_ON_ONCE(in_irq());\n\tlockdep_assert_irqs_enabled();\n\n\tlocal_irq_save(flags);\n\tcurcnt = __this_cpu_read(softirq_ctrl.cnt);\n\n\t/*\n\t * If this is not reenabling soft interrupts, no point in trying to\n\t * run pending ones.\n\t */\n\tif (curcnt != cnt)\n\t\tgoto out;\n\n\tpending = local_softirq_pending();\n\tif (!pending || ksoftirqd_running(pending))\n\t\tgoto out;\n\n\t/*\n\t * If this was called from non preemptible context, wake up the\n\t * softirq daemon.\n\t */\n\tif (!preempt_on) {\n\t\twakeup_softirqd();\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Adjust softirq count to SOFTIRQ_OFFSET which makes\n\t * in_serving_softirq() become true.\n\t */\n\tcnt = SOFTIRQ_OFFSET;\n\t__local_bh_enable(cnt, false);\n\t__do_softirq();\n\nout:\n\t__local_bh_enable(cnt, preempt_on);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__local_bh_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "195-216",
    "snippet": "static void __local_bh_enable(unsigned int cnt, bool unlock)\n{\n\tunsigned long flags;\n\tint newcnt;\n\n\tDEBUG_LOCKS_WARN_ON(current->softirq_disable_cnt !=\n\t\t\t    this_cpu_read(softirq_ctrl.cnt));\n\n\tif (IS_ENABLED(CONFIG_TRACE_IRQFLAGS) && softirq_count() == cnt) {\n\t\traw_local_irq_save(flags);\n\t\tlockdep_softirqs_on(_RET_IP_);\n\t\traw_local_irq_restore(flags);\n\t}\n\n\tnewcnt = __this_cpu_sub_return(softirq_ctrl.cnt, cnt);\n\tcurrent->softirq_disable_cnt = newcnt;\n\n\tif (!newcnt && unlock) {\n\t\trcu_read_unlock();\n\t\tlocal_unlock(&softirq_ctrl.lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_unlock",
          "args": [
            "&softirq_ctrl.lock"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_sub_return",
          "args": [
            "softirq_ctrl.cnt",
            "cnt"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_softirqs_on",
          "args": [
            "_RET_IP_"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_softirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4406-4441",
          "snippet": "void lockdep_softirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c, avoids\n\t * funny state and nesting things.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tdebug_atomic_inc(redundant_softirqs_on);\n\t\treturn;\n\t}\n\n\tlockdep_recursion_inc();\n\t/*\n\t * We'll do an OFF -> ON transition:\n\t */\n\tcurrent->softirqs_enabled = 1;\n\ttrace->softirq_enable_ip = ip;\n\ttrace->softirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(softirqs_on_events);\n\t/*\n\t * We are going to turn softirqs on, so set the\n\t * usage bit for all held locks, if hardirqs are\n\t * enabled too:\n\t */\n\tif (lockdep_hardirqs_enabled())\n\t\tmark_held_locks(current, LOCK_ENABLED_SOFTIRQ);\n\tlockdep_recursion_finish();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_softirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c, avoids\n\t * funny state and nesting things.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tdebug_atomic_inc(redundant_softirqs_on);\n\t\treturn;\n\t}\n\n\tlockdep_recursion_inc();\n\t/*\n\t * We'll do an OFF -> ON transition:\n\t */\n\tcurrent->softirqs_enabled = 1;\n\ttrace->softirq_enable_ip = ip;\n\ttrace->softirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(softirqs_on_events);\n\t/*\n\t * We are going to turn softirqs on, so set the\n\t * usage bit for all held locks, if hardirqs are\n\t * enabled too:\n\t */\n\tif (lockdep_hardirqs_enabled())\n\t\tmark_held_locks(current, LOCK_ENABLED_SOFTIRQ);\n\tlockdep_recursion_finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TRACE_IRQFLAGS"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "current->softirq_disable_cnt !=\n\t\t\t    this_cpu_read(softirq_ctrl.cnt)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "softirq_ctrl.cnt"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void __local_bh_enable(unsigned int cnt, bool unlock)\n{\n\tunsigned long flags;\n\tint newcnt;\n\n\tDEBUG_LOCKS_WARN_ON(current->softirq_disable_cnt !=\n\t\t\t    this_cpu_read(softirq_ctrl.cnt));\n\n\tif (IS_ENABLED(CONFIG_TRACE_IRQFLAGS) && softirq_count() == cnt) {\n\t\traw_local_irq_save(flags);\n\t\tlockdep_softirqs_on(_RET_IP_);\n\t\traw_local_irq_restore(flags);\n\t}\n\n\tnewcnt = __this_cpu_sub_return(softirq_ctrl.cnt, cnt);\n\tcurrent->softirq_disable_cnt = newcnt;\n\n\tif (!newcnt && unlock) {\n\t\trcu_read_unlock();\n\t\tlocal_unlock(&softirq_ctrl.lock);\n\t}\n}"
  },
  {
    "function_name": "__local_bh_disable_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "158-192",
    "snippet": "void __local_bh_disable_ip(unsigned long ip, unsigned int cnt)\n{\n\tunsigned long flags;\n\tint newcnt;\n\n\tWARN_ON_ONCE(in_hardirq());\n\n\t/* First entry of a task into a BH disabled section? */\n\tif (!current->softirq_disable_cnt) {\n\t\tif (preemptible()) {\n\t\t\tlocal_lock(&softirq_ctrl.lock);\n\t\t\t/* Required to meet the RCU bottomhalf requirements. */\n\t\t\trcu_read_lock();\n\t\t} else {\n\t\t\tDEBUG_LOCKS_WARN_ON(this_cpu_read(softirq_ctrl.cnt));\n\t\t}\n\t}\n\n\t/*\n\t * Track the per CPU softirq disabled state. On RT this is per CPU\n\t * state to allow preemption of bottom half disabled sections.\n\t */\n\tnewcnt = __this_cpu_add_return(softirq_ctrl.cnt, cnt);\n\t/*\n\t * Reflect the result in the task state to prevent recursion on the\n\t * local lock and to make softirq_count() & al work.\n\t */\n\tcurrent->softirq_disable_cnt = newcnt;\n\n\tif (IS_ENABLED(CONFIG_TRACE_IRQFLAGS) && newcnt == cnt) {\n\t\traw_local_irq_save(flags);\n\t\tlockdep_softirqs_off(ip);\n\t\traw_local_irq_restore(flags);\n\t}\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_softirqs_off",
          "args": [
            "ip"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_softirqs_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4446-4473",
          "snippet": "void lockdep_softirqs_off(unsigned long ip)\n{\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurrent->softirqs_enabled = 0;\n\t\ttrace->softirq_disable_ip = ip;\n\t\ttrace->softirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(softirqs_off_events);\n\t\t/*\n\t\t * Whoops, we wanted softirqs off, so why aren't they?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(!softirq_count());\n\t} else\n\t\tdebug_atomic_inc(redundant_softirqs_off);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_softirqs_off(unsigned long ip)\n{\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurrent->softirqs_enabled = 0;\n\t\ttrace->softirq_disable_ip = ip;\n\t\ttrace->softirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(softirqs_off_events);\n\t\t/*\n\t\t * Whoops, we wanted softirqs off, so why aren't they?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(!softirq_count());\n\t} else\n\t\tdebug_atomic_inc(redundant_softirqs_off);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TRACE_IRQFLAGS"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_add_return",
          "args": [
            "softirq_ctrl.cnt",
            "cnt"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "this_cpu_read(softirq_ctrl.cnt)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "softirq_ctrl.cnt"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_lock",
          "args": [
            "&softirq_ctrl.lock"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_hardirq()"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_hardirq",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __local_bh_disable_ip(unsigned long ip, unsigned int cnt)\n{\n\tunsigned long flags;\n\tint newcnt;\n\n\tWARN_ON_ONCE(in_hardirq());\n\n\t/* First entry of a task into a BH disabled section? */\n\tif (!current->softirq_disable_cnt) {\n\t\tif (preemptible()) {\n\t\t\tlocal_lock(&softirq_ctrl.lock);\n\t\t\t/* Required to meet the RCU bottomhalf requirements. */\n\t\t\trcu_read_lock();\n\t\t} else {\n\t\t\tDEBUG_LOCKS_WARN_ON(this_cpu_read(softirq_ctrl.cnt));\n\t\t}\n\t}\n\n\t/*\n\t * Track the per CPU softirq disabled state. On RT this is per CPU\n\t * state to allow preemption of bottom half disabled sections.\n\t */\n\tnewcnt = __this_cpu_add_return(softirq_ctrl.cnt, cnt);\n\t/*\n\t * Reflect the result in the task state to prevent recursion on the\n\t * local lock and to make softirq_count() & al work.\n\t */\n\tcurrent->softirq_disable_cnt = newcnt;\n\n\tif (IS_ENABLED(CONFIG_TRACE_IRQFLAGS) && newcnt == cnt) {\n\t\traw_local_irq_save(flags);\n\t\tlockdep_softirqs_off(ip);\n\t\traw_local_irq_restore(flags);\n\t}\n}"
  },
  {
    "function_name": "local_bh_blocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "153-156",
    "snippet": "bool local_bh_blocked(void)\n{\n\treturn __this_cpu_read(softirq_ctrl.cnt) != 0;\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "softirq_ctrl.cnt"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nbool local_bh_blocked(void)\n{\n\treturn __this_cpu_read(softirq_ctrl.cnt) != 0;\n}"
  },
  {
    "function_name": "ksoftirqd_running",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "89-96",
    "snippet": "static bool ksoftirqd_running(unsigned long pending)\n{\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (pending & SOFTIRQ_NOW_MASK)\n\t\treturn false;\n\treturn tsk && task_is_running(tsk) && !__kthread_should_park(tsk);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define SOFTIRQ_NOW_MASK ((1 << HI_SOFTIRQ) | (1 << TASKLET_SOFTIRQ))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kthread_should_park",
          "args": [
            "tsk"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_should_park",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "162-165",
          "snippet": "bool __kthread_should_park(struct task_struct *k)\n{\n\treturn test_bit(KTHREAD_SHOULD_PARK, &to_kthread(k)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool __kthread_should_park(struct task_struct *k)\n{\n\treturn test_bit(KTHREAD_SHOULD_PARK, &to_kthread(k)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_is_running",
          "args": [
            "tsk"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "ksoftirqd"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\n#define SOFTIRQ_NOW_MASK ((1 << HI_SOFTIRQ) | (1 << TASKLET_SOFTIRQ))\n\nstatic bool ksoftirqd_running(unsigned long pending)\n{\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (pending & SOFTIRQ_NOW_MASK)\n\t\treturn false;\n\treturn tsk && task_is_running(tsk) && !__kthread_should_park(tsk);\n}"
  },
  {
    "function_name": "wakeup_softirqd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
    "lines": "74-81",
    "snippet": "static void wakeup_softirqd(void)\n{\n\t/* Interrupts are disabled: no need to stop preemption */\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (tsk)\n\t\twake_up_process(tsk);\n}",
    "includes": [
      "#include <trace/events/irq.h>",
      "#include <asm/softirq_stack.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/local_lock.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "tsk"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "ksoftirqd"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic void wakeup_softirqd(void)\n{\n\t/* Interrupts are disabled: no need to stop preemption */\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (tsk)\n\t\twake_up_process(tsk);\n}"
  }
]