[
  {
    "function_name": "irq_domain_debugfs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1918-1930",
    "snippet": "void __init irq_domain_debugfs_init(struct dentry *root)\n{\n\tstruct irq_domain *d;\n\n\tdomain_dir = debugfs_create_dir(\"domains\", root);\n\n\tdebugfs_create_file(\"default\", 0444, domain_dir, NULL,\n\t\t\t    &irq_domain_debug_fops);\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(d, &irq_domain_list, link)\n\t\tdebugfs_add_domain_dir(d);\n\tmutex_unlock(&irq_domain_mutex);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(irq_domain_list);",
      "static DEFINE_MUTEX(irq_domain_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_add_domain_dir",
          "args": [
            "d"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_add_domain_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1905-1911",
          "snippet": "static void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir)\n\t\treturn;\n\tdebugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t    &irq_domain_debug_fops);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir)\n\t\treturn;\n\tdebugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t    &irq_domain_debug_fops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "d",
            "&irq_domain_list",
            "link"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"default\"",
            "0444",
            "domain_dir",
            "NULL",
            "&irq_domain_debug_fops"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"domains\"",
            "root"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\n\nvoid __init irq_domain_debugfs_init(struct dentry *root)\n{\n\tstruct irq_domain *d;\n\n\tdomain_dir = debugfs_create_dir(\"domains\", root);\n\n\tdebugfs_create_file(\"default\", 0444, domain_dir, NULL,\n\t\t\t    &irq_domain_debug_fops);\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(d, &irq_domain_list, link)\n\t\tdebugfs_add_domain_dir(d);\n\tmutex_unlock(&irq_domain_mutex);\n}"
  },
  {
    "function_name": "debugfs_remove_domain_dir",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1913-1916",
    "snippet": "static void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(debugfs_lookup(d->name, domain_dir));\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "debugfs_lookup(d->name, domain_dir)"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_remove_domain_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1913-1916",
          "snippet": "static void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(debugfs_lookup(d->name, domain_dir));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_lookup",
          "args": [
            "d->name",
            "domain_dir"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(debugfs_lookup(d->name, domain_dir));\n}"
  },
  {
    "function_name": "debugfs_add_domain_dir",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1905-1911",
    "snippet": "static void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir)\n\t\treturn;\n\tdebugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t    &irq_domain_debug_fops);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "d->name",
            "0444",
            "domain_dir",
            "d",
            "&irq_domain_debug_fops"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir)\n\t\treturn;\n\tdebugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t    &irq_domain_debug_fops);\n}"
  },
  {
    "function_name": "irq_domain_debug_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1890-1902",
    "snippet": "static int irq_domain_debug_show(struct seq_file *m, void *p)\n{\n\tstruct irq_domain *d = m->private;\n\n\t/* Default domain? Might be NULL */\n\tif (!d) {\n\t\tif (!irq_default_domain)\n\t\t\treturn 0;\n\t\td = irq_default_domain;\n\t}\n\tirq_domain_debug_show_one(m, d, 0);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_debug_show_one",
          "args": [
            "m",
            "d",
            "0"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_debug_show_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1873-1888",
          "snippet": "static void\nirq_domain_debug_show_one(struct seq_file *m, struct irq_domain *d, int ind)\n{\n\tseq_printf(m, \"%*sname:   %s\\n\", ind, \"\", d->name);\n\tseq_printf(m, \"%*ssize:   %u\\n\", ind + 1, \"\", d->revmap_size);\n\tseq_printf(m, \"%*smapped: %u\\n\", ind + 1, \"\", d->mapcount);\n\tseq_printf(m, \"%*sflags:  0x%08x\\n\", ind +1 , \"\", d->flags);\n\tif (d->ops && d->ops->debug_show)\n\t\td->ops->debug_show(m, d, NULL, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!d->parent)\n\t\treturn;\n\tseq_printf(m, \"%*sparent: %s\\n\", ind + 1, \"\", d->parent->name);\n\tirq_domain_debug_show_one(m, d->parent, ind + 4);\n#endif\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void\nirq_domain_debug_show_one(struct seq_file *m, struct irq_domain *d, int ind)\n{\n\tseq_printf(m, \"%*sname:   %s\\n\", ind, \"\", d->name);\n\tseq_printf(m, \"%*ssize:   %u\\n\", ind + 1, \"\", d->revmap_size);\n\tseq_printf(m, \"%*smapped: %u\\n\", ind + 1, \"\", d->mapcount);\n\tseq_printf(m, \"%*sflags:  0x%08x\\n\", ind +1 , \"\", d->flags);\n\tif (d->ops && d->ops->debug_show)\n\t\td->ops->debug_show(m, d, NULL, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!d->parent)\n\t\treturn;\n\tseq_printf(m, \"%*sparent: %s\\n\", ind + 1, \"\", d->parent->name);\n\tirq_domain_debug_show_one(m, d->parent, ind + 4);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int irq_domain_debug_show(struct seq_file *m, void *p)\n{\n\tstruct irq_domain *d = m->private;\n\n\t/* Default domain? Might be NULL */\n\tif (!d) {\n\t\tif (!irq_default_domain)\n\t\t\treturn 0;\n\t\td = irq_default_domain;\n\t}\n\tirq_domain_debug_show_one(m, d, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_debug_show_one",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1873-1888",
    "snippet": "static void\nirq_domain_debug_show_one(struct seq_file *m, struct irq_domain *d, int ind)\n{\n\tseq_printf(m, \"%*sname:   %s\\n\", ind, \"\", d->name);\n\tseq_printf(m, \"%*ssize:   %u\\n\", ind + 1, \"\", d->revmap_size);\n\tseq_printf(m, \"%*smapped: %u\\n\", ind + 1, \"\", d->mapcount);\n\tseq_printf(m, \"%*sflags:  0x%08x\\n\", ind +1 , \"\", d->flags);\n\tif (d->ops && d->ops->debug_show)\n\t\td->ops->debug_show(m, d, NULL, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!d->parent)\n\t\treturn;\n\tseq_printf(m, \"%*sparent: %s\\n\", ind + 1, \"\", d->parent->name);\n\tirq_domain_debug_show_one(m, d->parent, ind + 4);\n#endif\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_debug_show_one",
          "args": [
            "m",
            "d->parent",
            "ind + 4"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_debug_show_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1873-1888",
          "snippet": "static void\nirq_domain_debug_show_one(struct seq_file *m, struct irq_domain *d, int ind)\n{\n\tseq_printf(m, \"%*sname:   %s\\n\", ind, \"\", d->name);\n\tseq_printf(m, \"%*ssize:   %u\\n\", ind + 1, \"\", d->revmap_size);\n\tseq_printf(m, \"%*smapped: %u\\n\", ind + 1, \"\", d->mapcount);\n\tseq_printf(m, \"%*sflags:  0x%08x\\n\", ind +1 , \"\", d->flags);\n\tif (d->ops && d->ops->debug_show)\n\t\td->ops->debug_show(m, d, NULL, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!d->parent)\n\t\treturn;\n\tseq_printf(m, \"%*sparent: %s\\n\", ind + 1, \"\", d->parent->name);\n\tirq_domain_debug_show_one(m, d->parent, ind + 4);\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*sparent: %s\\n\"",
            "ind + 1",
            "\"\"",
            "d->parent->name"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->ops->debug_show",
          "args": [
            "m",
            "d",
            "NULL",
            "ind + 1"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void\nirq_domain_debug_show_one(struct seq_file *m, struct irq_domain *d, int ind)\n{\n\tseq_printf(m, \"%*sname:   %s\\n\", ind, \"\", d->name);\n\tseq_printf(m, \"%*ssize:   %u\\n\", ind + 1, \"\", d->revmap_size);\n\tseq_printf(m, \"%*smapped: %u\\n\", ind + 1, \"\", d->mapcount);\n\tseq_printf(m, \"%*sflags:  0x%08x\\n\", ind +1 , \"\", d->flags);\n\tif (d->ops && d->ops->debug_show)\n\t\td->ops->debug_show(m, d, NULL, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!d->parent)\n\t\treturn;\n\tseq_printf(m, \"%*sparent: %s\\n\", ind + 1, \"\", d->parent->name);\n\tirq_domain_debug_show_one(m, d->parent, ind + 4);\n#endif\n}"
  },
  {
    "function_name": "irq_domain_check_hierarchy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1865-1867",
    "snippet": "static void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n}"
  },
  {
    "function_name": "irq_domain_set_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1855-1863",
    "snippet": "void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_set_chip_and_handler_name(virq, chip, handler, handler_name);\n\tirq_set_chip_data(virq, chip_data);\n\tirq_set_handler_data(virq, handler_data);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_set_handler_data",
          "args": [
            "virq",
            "handler_data"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_handler_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "90-100",
          "snippet": "int irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_chip_data",
          "args": [
            "virq",
            "chip_data"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_chip_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "145-155",
          "snippet": "int irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_chip_and_handler_name",
          "args": [
            "virq",
            "chip",
            "handler",
            "handler_name"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_chip_and_handler_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1075-1081",
          "snippet": "void\nirq_set_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,\n\t\t\t      irq_flow_handler_t handle, const char *name)\n{\n\tirq_set_chip(irq, chip);\n\t__irq_set_handler(irq, handle, 0, name);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid\nirq_set_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,\n\t\t\t      irq_flow_handler_t handle, const char *name)\n{\n\tirq_set_chip(irq, chip);\n\t__irq_set_handler(irq, handle, 0, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_set_chip_and_handler_name(virq, chip, handler, handler_name);\n\tirq_set_chip_data(virq, chip_data);\n\tirq_set_handler_data(virq, handler_data);\n}"
  },
  {
    "function_name": "irq_domain_get_irq_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1835-1841",
    "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
  },
  {
    "function_name": "irq_domain_hierarchical_is_msi_remap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1821-1828",
    "snippet": "bool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)\n{\n\tfor (; domain; domain = domain->parent) {\n\t\tif (irq_domain_is_msi_remap(domain))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_is_msi_remap",
          "args": [
            "domain"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nbool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)\n{\n\tfor (; domain; domain = domain->parent) {\n\t\tif (irq_domain_is_msi_remap(domain))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "irq_domain_check_hierarchy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1809-1814",
    "snippet": "static void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n\t/* Hierarchy irq_domains must implement callback alloc() */\n\tif (domain->ops->alloc)\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_HIERARCHY;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n\t/* Hierarchy irq_domains must implement callback alloc() */\n\tif (domain->ops->alloc)\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_HIERARCHY;\n}"
  },
  {
    "function_name": "irq_domain_deactivate_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1801-1807",
    "snippet": "void irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irqd_is_activated(irq_data)) {\n\t\t__irq_domain_deactivate_irq(irq_data);\n\t\tirqd_clr_activated(irq_data);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_clr_activated",
          "args": [
            "irq_data"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_domain_deactivate_irq",
          "args": [
            "irq_data"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_deactivate_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1741-1751",
          "snippet": "static void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_activated",
          "args": [
            "irq_data"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irqd_is_activated(irq_data)) {\n\t\t__irq_domain_deactivate_irq(irq_data);\n\t\tirqd_clr_activated(irq_data);\n\t}\n}"
  },
  {
    "function_name": "irq_domain_activate_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1782-1791",
    "snippet": "int irq_domain_activate_irq(struct irq_data *irq_data, bool reserve)\n{\n\tint ret = 0;\n\n\tif (!irqd_is_activated(irq_data))\n\t\tret = __irq_domain_activate_irq(irq_data, reserve);\n\tif (!ret)\n\t\tirqd_set_activated(irq_data);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_set_activated",
          "args": [
            "irq_data"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_domain_activate_irq",
          "args": [
            "irq_data",
            "reserve"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_activate_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1753-1771",
          "snippet": "static int __irq_domain_activate_irq(struct irq_data *irqd, bool reserve)\n{\n\tint ret = 0;\n\n\tif (irqd && irqd->domain) {\n\t\tstruct irq_domain *domain = irqd->domain;\n\n\t\tif (irqd->parent_data)\n\t\t\tret = __irq_domain_activate_irq(irqd->parent_data,\n\t\t\t\t\t\t\treserve);\n\t\tif (!ret && domain->ops->activate) {\n\t\t\tret = domain->ops->activate(domain, irqd, reserve);\n\t\t\t/* Rollback in case of error */\n\t\t\tif (ret && irqd->parent_data)\n\t\t\t\t__irq_domain_deactivate_irq(irqd->parent_data);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int __irq_domain_activate_irq(struct irq_data *irqd, bool reserve)\n{\n\tint ret = 0;\n\n\tif (irqd && irqd->domain) {\n\t\tstruct irq_domain *domain = irqd->domain;\n\n\t\tif (irqd->parent_data)\n\t\t\tret = __irq_domain_activate_irq(irqd->parent_data,\n\t\t\t\t\t\t\treserve);\n\t\tif (!ret && domain->ops->activate) {\n\t\t\tret = domain->ops->activate(domain, irqd, reserve);\n\t\t\t/* Rollback in case of error */\n\t\t\tif (ret && irqd->parent_data)\n\t\t\t\t__irq_domain_deactivate_irq(irqd->parent_data);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_activated",
          "args": [
            "irq_data"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_activate_irq(struct irq_data *irq_data, bool reserve)\n{\n\tint ret = 0;\n\n\tif (!irqd_is_activated(irq_data))\n\t\tret = __irq_domain_activate_irq(irq_data, reserve);\n\tif (!ret)\n\t\tirqd_set_activated(irq_data);\n\treturn ret;\n}"
  },
  {
    "function_name": "__irq_domain_activate_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1753-1771",
    "snippet": "static int __irq_domain_activate_irq(struct irq_data *irqd, bool reserve)\n{\n\tint ret = 0;\n\n\tif (irqd && irqd->domain) {\n\t\tstruct irq_domain *domain = irqd->domain;\n\n\t\tif (irqd->parent_data)\n\t\t\tret = __irq_domain_activate_irq(irqd->parent_data,\n\t\t\t\t\t\t\treserve);\n\t\tif (!ret && domain->ops->activate) {\n\t\t\tret = domain->ops->activate(domain, irqd, reserve);\n\t\t\t/* Rollback in case of error */\n\t\t\tif (ret && irqd->parent_data)\n\t\t\t\t__irq_domain_deactivate_irq(irqd->parent_data);\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_domain_deactivate_irq",
          "args": [
            "irqd->parent_data"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_deactivate_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1741-1751",
          "snippet": "static void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "domain->ops->activate",
          "args": [
            "domain",
            "irqd",
            "reserve"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_domain_activate_irq",
          "args": [
            "irqd->parent_data",
            "reserve"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_activate_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1753-1771",
          "snippet": "static int __irq_domain_activate_irq(struct irq_data *irqd, bool reserve)\n{\n\tint ret = 0;\n\n\tif (irqd && irqd->domain) {\n\t\tstruct irq_domain *domain = irqd->domain;\n\n\t\tif (irqd->parent_data)\n\t\t\tret = __irq_domain_activate_irq(irqd->parent_data,\n\t\t\t\t\t\t\treserve);\n\t\tif (!ret && domain->ops->activate) {\n\t\t\tret = domain->ops->activate(domain, irqd, reserve);\n\t\t\t/* Rollback in case of error */\n\t\t\tif (ret && irqd->parent_data)\n\t\t\t\t__irq_domain_deactivate_irq(irqd->parent_data);\n\t\t}\n\t}\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int __irq_domain_activate_irq(struct irq_data *irqd, bool reserve)\n{\n\tint ret = 0;\n\n\tif (irqd && irqd->domain) {\n\t\tstruct irq_domain *domain = irqd->domain;\n\n\t\tif (irqd->parent_data)\n\t\t\tret = __irq_domain_activate_irq(irqd->parent_data,\n\t\t\t\t\t\t\treserve);\n\t\tif (!ret && domain->ops->activate) {\n\t\t\tret = domain->ops->activate(domain, irqd, reserve);\n\t\t\t/* Rollback in case of error */\n\t\t\tif (ret && irqd->parent_data)\n\t\t\t\t__irq_domain_deactivate_irq(irqd->parent_data);\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__irq_domain_deactivate_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1741-1751",
    "snippet": "static void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_domain_deactivate_irq",
          "args": [
            "irq_data->parent_data"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_deactivate_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1741-1751",
          "snippet": "static void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "domain->ops->deactivate",
          "args": [
            "domain",
            "irq_data"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}"
  },
  {
    "function_name": "irq_domain_free_irqs_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1731-1738",
    "snippet": "void irq_domain_free_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs)\n{\n\tif (!domain->parent)\n\t\treturn;\n\n\tirq_domain_free_irqs_hierarchy(domain->parent, irq_base, nr_irqs);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_hierarchy",
          "args": [
            "domain->parent",
            "irq_base",
            "nr_irqs"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1399-1412",
          "snippet": "static void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tunsigned int i;\n\n\tif (!domain->ops->free)\n\t\treturn;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tif (irq_domain_get_irq_data(domain, irq_base + i))\n\t\t\tdomain->ops->free(domain, irq_base + i, 1);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tunsigned int i;\n\n\tif (!domain->ops->free)\n\t\treturn;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tif (irq_domain_get_irq_data(domain, irq_base + i))\n\t\t\tdomain->ops->free(domain, irq_base + i, 1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs)\n{\n\tif (!domain->parent)\n\t\treturn;\n\n\tirq_domain_free_irqs_hierarchy(domain->parent, irq_base, nr_irqs);\n}"
  },
  {
    "function_name": "irq_domain_alloc_irqs_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1713-1722",
    "snippet": "int irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\tif (!domain->parent)\n\t\treturn -ENOSYS;\n\n\treturn irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs, arg);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_alloc_irqs_hierarchy",
          "args": [
            "domain->parent",
            "irq_base",
            "nr_irqs",
            "arg"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irqs_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1414-1424",
          "snippet": "int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\tif (!domain->parent)\n\t\treturn -ENOSYS;\n\n\treturn irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs, arg);\n}"
  },
  {
    "function_name": "irq_domain_free_irqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1687-1704",
    "snippet": "void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_free_descs",
          "args": [
            "virq",
            "nr_irqs"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "irq_free_descs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "709-722",
          "snippet": "void irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nr_irqs = NR_IRQS;",
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nint nr_irqs = NR_IRQS;\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irq_data",
          "args": [
            "virq",
            "nr_irqs"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1179-1192",
          "snippet": "static void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\t__irq_domain_free_hierarchy(tmp);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\t__irq_domain_free_hierarchy(tmp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_hierarchy",
          "args": [
            "data->domain",
            "virq",
            "nr_irqs"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1399-1412",
          "snippet": "static void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tunsigned int i;\n\n\tif (!domain->ops->free)\n\t\treturn;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tif (irq_domain_get_irq_data(domain, irq_base + i))\n\t\t\tdomain->ops->free(domain, irq_base + i, 1);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tunsigned int i;\n\n\tif (!domain->ops->free)\n\t\treturn;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tif (irq_domain_get_irq_data(domain, irq_base + i))\n\t\t\tdomain->ops->free(domain, irq_base + i, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_remove_irq",
          "args": [
            "virq + i"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_remove_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1133-1149",
          "snippet": "static void irq_domain_remove_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tirq_set_status_flags(virq, IRQ_NOREQUEST);\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tsynchronize_irq(virq);\n\tsmp_mb();\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tdomain->mapcount--;\n\t\tirq_domain_clear_mapping(domain, hwirq);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_remove_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tirq_set_status_flags(virq, IRQ_NOREQUEST);\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tsynchronize_irq(virq);\n\tsmp_mb();\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tdomain->mapcount--;\n\t\tirq_domain_clear_mapping(domain, hwirq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!data || !data->domain || !data->domain->ops->free",
            "\"NULL pointer, cannot free irq\\n\""
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}"
  },
  {
    "function_name": "irq_domain_pop_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1621-1679",
    "snippet": "int irq_domain_pop_irq(struct irq_domain *domain, int virq)\n{\n\tstruct irq_data *root_irq_data = irq_get_irq_data(virq);\n\tstruct irq_data *child_irq_data;\n\tstruct irq_data *tmp_irq_data;\n\tstruct irq_desc *desc;\n\n\t/*\n\t * Check that no action is set, which indicates the virq is in\n\t * a state where this function doesn't have to deal with races\n\t * between interrupt handling and maintaining the hierarchy.\n\t * This will catch gross misuse.  Attempting to make the check\n\t * race free would require holding locks across calls to\n\t * struct irq_domain_ops->free(), which could lead to\n\t * deadlock, so we just do a simple check before starting.\n\t */\n\tdesc = irq_to_desc(virq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (WARN_ON(desc->action))\n\t\treturn -EBUSY;\n\n\tif (domain == NULL)\n\t\treturn -EINVAL;\n\n\tif (!root_irq_data)\n\t\treturn -EINVAL;\n\n\ttmp_irq_data = irq_domain_get_irq_data(domain, virq);\n\n\t/* We can only \"pop\" if this domain is at the top of the list */\n\tif (WARN_ON(root_irq_data != tmp_irq_data))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(root_irq_data->domain != domain))\n\t\treturn -EINVAL;\n\n\tchild_irq_data = root_irq_data->parent_data;\n\tif (WARN_ON(!child_irq_data))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\troot_irq_data->parent_data = NULL;\n\n\tirq_domain_clear_mapping(domain, root_irq_data->hwirq);\n\tirq_domain_free_irqs_hierarchy(domain, virq, 1);\n\n\t/* Restore the original irq_data. */\n\t*root_irq_data = *child_irq_data;\n\n\tirq_domain_fix_revmap(root_irq_data);\n\n\tmutex_unlock(&irq_domain_mutex);\n\n\tkfree(child_irq_data);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "child_irq_data"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_fix_revmap",
          "args": [
            "root_irq_data"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_fix_revmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1508-1526",
          "snippet": "static void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (irq_domain_is_nomap(d->domain))\n\t\treturn;\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_mutex);\n\tif (d->hwirq < d->domain->revmap_size) {\n\t\t/* Not using radix tree */\n\t\trcu_assign_pointer(d->domain->revmap[d->hwirq], d);\n\t} else {\n\t\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\t\tif (slot)\n\t\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\t}\n\tmutex_unlock(&d->domain->revmap_mutex);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (irq_domain_is_nomap(d->domain))\n\t\treturn;\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_mutex);\n\tif (d->hwirq < d->domain->revmap_size) {\n\t\t/* Not using radix tree */\n\t\trcu_assign_pointer(d->domain->revmap[d->hwirq], d);\n\t} else {\n\t\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\t\tif (slot)\n\t\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\t}\n\tmutex_unlock(&d->domain->revmap_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_hierarchy",
          "args": [
            "domain",
            "virq",
            "1"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1399-1412",
          "snippet": "static void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tunsigned int i;\n\n\tif (!domain->ops->free)\n\t\treturn;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tif (irq_domain_get_irq_data(domain, irq_base + i))\n\t\t\tdomain->ops->free(domain, irq_base + i, 1);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tunsigned int i;\n\n\tif (!domain->ops->free)\n\t\treturn;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tif (irq_domain_get_irq_data(domain, irq_base + i))\n\t\t\tdomain->ops->free(domain, irq_base + i, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_clear_mapping",
          "args": [
            "domain",
            "root_irq_data->hwirq"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_clear_mapping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "502-514",
          "snippet": "static void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], NULL);\n\telse\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\tmutex_unlock(&domain->revmap_mutex);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], NULL);\n\telse\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\tmutex_unlock(&domain->revmap_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!child_irq_data"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "root_irq_data->domain != domain"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "root_irq_data != tmp_irq_data"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "virq"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1835-1841",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "desc->action"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "virq"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_pop_irq(struct irq_domain *domain, int virq)\n{\n\tstruct irq_data *root_irq_data = irq_get_irq_data(virq);\n\tstruct irq_data *child_irq_data;\n\tstruct irq_data *tmp_irq_data;\n\tstruct irq_desc *desc;\n\n\t/*\n\t * Check that no action is set, which indicates the virq is in\n\t * a state where this function doesn't have to deal with races\n\t * between interrupt handling and maintaining the hierarchy.\n\t * This will catch gross misuse.  Attempting to make the check\n\t * race free would require holding locks across calls to\n\t * struct irq_domain_ops->free(), which could lead to\n\t * deadlock, so we just do a simple check before starting.\n\t */\n\tdesc = irq_to_desc(virq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (WARN_ON(desc->action))\n\t\treturn -EBUSY;\n\n\tif (domain == NULL)\n\t\treturn -EINVAL;\n\n\tif (!root_irq_data)\n\t\treturn -EINVAL;\n\n\ttmp_irq_data = irq_domain_get_irq_data(domain, virq);\n\n\t/* We can only \"pop\" if this domain is at the top of the list */\n\tif (WARN_ON(root_irq_data != tmp_irq_data))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(root_irq_data->domain != domain))\n\t\treturn -EINVAL;\n\n\tchild_irq_data = root_irq_data->parent_data;\n\tif (WARN_ON(!child_irq_data))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\troot_irq_data->parent_data = NULL;\n\n\tirq_domain_clear_mapping(domain, root_irq_data->hwirq);\n\tirq_domain_free_irqs_hierarchy(domain, virq, 1);\n\n\t/* Restore the original irq_data. */\n\t*root_irq_data = *child_irq_data;\n\n\tirq_domain_fix_revmap(root_irq_data);\n\n\tmutex_unlock(&irq_domain_mutex);\n\n\tkfree(child_irq_data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_push_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1539-1610",
    "snippet": "int irq_domain_push_irq(struct irq_domain *domain, int virq, void *arg)\n{\n\tstruct irq_data *child_irq_data;\n\tstruct irq_data *root_irq_data = irq_get_irq_data(virq);\n\tstruct irq_desc *desc;\n\tint rv = 0;\n\n\t/*\n\t * Check that no action has been set, which indicates the virq\n\t * is in a state where this function doesn't have to deal with\n\t * races between interrupt handling and maintaining the\n\t * hierarchy.  This will catch gross misuse.  Attempting to\n\t * make the check race free would require holding locks across\n\t * calls to struct irq_domain_ops->alloc(), which could lead\n\t * to deadlock, so we just do a simple check before starting.\n\t */\n\tdesc = irq_to_desc(virq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (WARN_ON(desc->action))\n\t\treturn -EBUSY;\n\n\tif (domain == NULL)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!irq_domain_is_hierarchy(domain)))\n\t\treturn -EINVAL;\n\n\tif (!root_irq_data)\n\t\treturn -EINVAL;\n\n\tif (domain->parent != root_irq_data->domain)\n\t\treturn -EINVAL;\n\n\tchild_irq_data = kzalloc_node(sizeof(*child_irq_data), GFP_KERNEL,\n\t\t\t\t      irq_data_get_node(root_irq_data));\n\tif (!child_irq_data)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\t/* Copy the original irq_data. */\n\t*child_irq_data = *root_irq_data;\n\n\t/*\n\t * Overwrite the root_irq_data, which is embedded in struct\n\t * irq_desc, with values for this domain.\n\t */\n\troot_irq_data->parent_data = child_irq_data;\n\troot_irq_data->domain = domain;\n\troot_irq_data->mask = 0;\n\troot_irq_data->hwirq = 0;\n\troot_irq_data->chip = NULL;\n\troot_irq_data->chip_data = NULL;\n\n\t/* May (probably does) set hwirq, chip, etc. */\n\trv = irq_domain_alloc_irqs_hierarchy(domain, virq, 1, arg);\n\tif (rv) {\n\t\t/* Restore the original irq_data. */\n\t\t*root_irq_data = *child_irq_data;\n\t\tkfree(child_irq_data);\n\t\tgoto error;\n\t}\n\n\tirq_domain_fix_revmap(child_irq_data);\n\tirq_domain_set_mapping(domain, root_irq_data->hwirq, root_irq_data);\n\nerror:\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn rv;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_set_mapping",
          "args": [
            "domain",
            "root_irq_data->hwirq",
            "root_irq_data"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_set_mapping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "516-529",
          "snippet": "static void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], irq_data);\n\telse\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\tmutex_unlock(&domain->revmap_mutex);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], irq_data);\n\telse\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\tmutex_unlock(&domain->revmap_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_fix_revmap",
          "args": [
            "child_irq_data"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_fix_revmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1508-1526",
          "snippet": "static void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (irq_domain_is_nomap(d->domain))\n\t\treturn;\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_mutex);\n\tif (d->hwirq < d->domain->revmap_size) {\n\t\t/* Not using radix tree */\n\t\trcu_assign_pointer(d->domain->revmap[d->hwirq], d);\n\t} else {\n\t\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\t\tif (slot)\n\t\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\t}\n\tmutex_unlock(&d->domain->revmap_mutex);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (irq_domain_is_nomap(d->domain))\n\t\treturn;\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_mutex);\n\tif (d->hwirq < d->domain->revmap_size) {\n\t\t/* Not using radix tree */\n\t\trcu_assign_pointer(d->domain->revmap[d->hwirq], d);\n\t} else {\n\t\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\t\tif (slot)\n\t\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\t}\n\tmutex_unlock(&d->domain->revmap_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "child_irq_data"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_irqs_hierarchy",
          "args": [
            "domain",
            "virq",
            "1",
            "arg"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irqs_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1414-1424",
          "snippet": "int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*child_irq_data)",
            "GFP_KERNEL",
            "irq_data_get_node(root_irq_data)"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_node",
          "args": [
            "root_irq_data"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!irq_domain_is_hierarchy(domain)"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_is_hierarchy",
          "args": [
            "domain"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "desc->action"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "virq"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_push_irq(struct irq_domain *domain, int virq, void *arg)\n{\n\tstruct irq_data *child_irq_data;\n\tstruct irq_data *root_irq_data = irq_get_irq_data(virq);\n\tstruct irq_desc *desc;\n\tint rv = 0;\n\n\t/*\n\t * Check that no action has been set, which indicates the virq\n\t * is in a state where this function doesn't have to deal with\n\t * races between interrupt handling and maintaining the\n\t * hierarchy.  This will catch gross misuse.  Attempting to\n\t * make the check race free would require holding locks across\n\t * calls to struct irq_domain_ops->alloc(), which could lead\n\t * to deadlock, so we just do a simple check before starting.\n\t */\n\tdesc = irq_to_desc(virq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (WARN_ON(desc->action))\n\t\treturn -EBUSY;\n\n\tif (domain == NULL)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!irq_domain_is_hierarchy(domain)))\n\t\treturn -EINVAL;\n\n\tif (!root_irq_data)\n\t\treturn -EINVAL;\n\n\tif (domain->parent != root_irq_data->domain)\n\t\treturn -EINVAL;\n\n\tchild_irq_data = kzalloc_node(sizeof(*child_irq_data), GFP_KERNEL,\n\t\t\t\t      irq_data_get_node(root_irq_data));\n\tif (!child_irq_data)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\t/* Copy the original irq_data. */\n\t*child_irq_data = *root_irq_data;\n\n\t/*\n\t * Overwrite the root_irq_data, which is embedded in struct\n\t * irq_desc, with values for this domain.\n\t */\n\troot_irq_data->parent_data = child_irq_data;\n\troot_irq_data->domain = domain;\n\troot_irq_data->mask = 0;\n\troot_irq_data->hwirq = 0;\n\troot_irq_data->chip = NULL;\n\troot_irq_data->chip_data = NULL;\n\n\t/* May (probably does) set hwirq, chip, etc. */\n\trv = irq_domain_alloc_irqs_hierarchy(domain, virq, 1, arg);\n\tif (rv) {\n\t\t/* Restore the original irq_data. */\n\t\t*root_irq_data = *child_irq_data;\n\t\tkfree(child_irq_data);\n\t\tgoto error;\n\t}\n\n\tirq_domain_fix_revmap(child_irq_data);\n\tirq_domain_set_mapping(domain, root_irq_data->hwirq, root_irq_data);\n\nerror:\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn rv;\n}"
  },
  {
    "function_name": "irq_domain_fix_revmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1508-1526",
    "snippet": "static void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (irq_domain_is_nomap(d->domain))\n\t\treturn;\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_mutex);\n\tif (d->hwirq < d->domain->revmap_size) {\n\t\t/* Not using radix tree */\n\t\trcu_assign_pointer(d->domain->revmap[d->hwirq], d);\n\t} else {\n\t\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\t\tif (slot)\n\t\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\t}\n\tmutex_unlock(&d->domain->revmap_mutex);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&d->domain->revmap_mutex"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_replace_slot",
          "args": [
            "&d->domain->revmap_tree",
            "slot",
            "d"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup_slot",
          "args": [
            "&d->domain->revmap_tree",
            "d->hwirq"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "d->domain->revmap[d->hwirq]",
            "d"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&d->domain->revmap_mutex"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_nomap",
          "args": [
            "d->domain"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_is_nomap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "496-500",
          "snippet": "static bool irq_domain_is_nomap(struct irq_domain *domain)\n{\n\treturn IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&\n\t       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic bool irq_domain_is_nomap(struct irq_domain *domain)\n{\n\treturn IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&\n\t       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (irq_domain_is_nomap(d->domain))\n\t\treturn;\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_mutex);\n\tif (d->hwirq < d->domain->revmap_size) {\n\t\t/* Not using radix tree */\n\t\trcu_assign_pointer(d->domain->revmap[d->hwirq], d);\n\t} else {\n\t\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\t\tif (slot)\n\t\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\t}\n\tmutex_unlock(&d->domain->revmap_mutex);\n}"
  },
  {
    "function_name": "__irq_domain_alloc_irqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1448-1504",
    "snippet": "int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,\n\t\t\t    unsigned int nr_irqs, int node, void *arg,\n\t\t\t    bool realloc, const struct irq_affinity_desc *affinity)\n{\n\tint i, ret, virq;\n\n\tif (domain == NULL) {\n\t\tdomain = irq_default_domain;\n\t\tif (WARN(!domain, \"domain is NULL; cannot allocate IRQ\\n\"))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (realloc && irq_base >= 0) {\n\t\tvirq = irq_base;\n\t} else {\n\t\tvirq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,\n\t\t\t\t\t      affinity);\n\t\tif (virq < 0) {\n\t\t\tpr_debug(\"cannot allocate IRQ(base %d, count %d)\\n\",\n\t\t\t\t irq_base, nr_irqs);\n\t\t\treturn virq;\n\t\t}\n\t}\n\n\tif (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {\n\t\tpr_debug(\"cannot allocate memory for IRQ%d\\n\", virq);\n\t\tret = -ENOMEM;\n\t\tgoto out_free_desc;\n\t}\n\n\tmutex_lock(&irq_domain_mutex);\n\tret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\tgoto out_free_irq_data;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tret = irq_domain_trim_hierarchy(virq + i);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\tgoto out_free_irq_data;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_insert_irq(virq + i);\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn virq;\n\nout_free_irq_data:\n\tirq_domain_free_irq_data(virq, nr_irqs);\nout_free_desc:\n\tirq_free_descs(virq, nr_irqs);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_free_descs",
          "args": [
            "virq",
            "nr_irqs"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "irq_free_descs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "709-722",
          "snippet": "void irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nr_irqs = NR_IRQS;",
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nint nr_irqs = NR_IRQS;\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irq_data",
          "args": [
            "virq",
            "nr_irqs"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1179-1192",
          "snippet": "static void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\t__irq_domain_free_hierarchy(tmp);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\t__irq_domain_free_hierarchy(tmp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_insert_irq",
          "args": [
            "virq + i"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_insert_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1115-1131",
          "snippet": "static void irq_domain_insert_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\n\t\tdomain->mapcount++;\n\t\tirq_domain_set_mapping(domain, data->hwirq, data);\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && data->chip)\n\t\t\tdomain->name = data->chip->name;\n\t}\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_insert_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\n\t\tdomain->mapcount++;\n\t\tirq_domain_set_mapping(domain, data->hwirq, data);\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && data->chip)\n\t\t\tdomain->name = data->chip->name;\n\t}\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_trim_hierarchy",
          "args": [
            "virq + i"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_trim_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1221-1268",
          "snippet": "static int irq_domain_trim_hierarchy(unsigned int virq)\n{\n\tstruct irq_data *tail, *irqd, *irq_data;\n\n\tirq_data = irq_get_irq_data(virq);\n\ttail = NULL;\n\n\t/* The first entry must have a valid irqchip */\n\tif (!irq_data->chip || IS_ERR(irq_data->chip))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Validate that the irq_data chain is sane in the presence of\n\t * a hierarchy trimming marker.\n\t */\n\tfor (irqd = irq_data->parent_data; irqd; irq_data = irqd, irqd = irqd->parent_data) {\n\t\t/* Can't have a valid irqchip after a trim marker */\n\t\tif (irqd->chip && tail)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can't have an empty irqchip before a trim marker */\n\t\tif (!irqd->chip && !tail)\n\t\t\treturn -EINVAL;\n\n\t\tif (IS_ERR(irqd->chip)) {\n\t\t\t/* Only -ENOTCONN is a valid trim marker */\n\t\t\tif (PTR_ERR(irqd->chip) != -ENOTCONN)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttail = irq_data;\n\t\t}\n\t}\n\n\t/* No trim marker, nothing to do */\n\tif (!tail)\n\t\treturn 0;\n\n\tpr_info(\"IRQ%d: trimming hierarchy from %s\\n\",\n\t\tvirq, tail->parent_data->domain->name);\n\n\t/* Sever the inner part of the hierarchy...  */\n\tirqd = tail;\n\ttail = tail->parent_data;\n\tirqd->parent_data = NULL;\n\t__irq_domain_free_hierarchy(tail);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int irq_domain_trim_hierarchy(unsigned int virq)\n{\n\tstruct irq_data *tail, *irqd, *irq_data;\n\n\tirq_data = irq_get_irq_data(virq);\n\ttail = NULL;\n\n\t/* The first entry must have a valid irqchip */\n\tif (!irq_data->chip || IS_ERR(irq_data->chip))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Validate that the irq_data chain is sane in the presence of\n\t * a hierarchy trimming marker.\n\t */\n\tfor (irqd = irq_data->parent_data; irqd; irq_data = irqd, irqd = irqd->parent_data) {\n\t\t/* Can't have a valid irqchip after a trim marker */\n\t\tif (irqd->chip && tail)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can't have an empty irqchip before a trim marker */\n\t\tif (!irqd->chip && !tail)\n\t\t\treturn -EINVAL;\n\n\t\tif (IS_ERR(irqd->chip)) {\n\t\t\t/* Only -ENOTCONN is a valid trim marker */\n\t\t\tif (PTR_ERR(irqd->chip) != -ENOTCONN)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttail = irq_data;\n\t\t}\n\t}\n\n\t/* No trim marker, nothing to do */\n\tif (!tail)\n\t\treturn 0;\n\n\tpr_info(\"IRQ%d: trimming hierarchy from %s\\n\",\n\t\tvirq, tail->parent_data->domain->name);\n\n\t/* Sever the inner part of the hierarchy...  */\n\tirqd = tail;\n\ttail = tail->parent_data;\n\tirqd->parent_data = NULL;\n\t__irq_domain_free_hierarchy(tail);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_irqs_hierarchy",
          "args": [
            "domain",
            "virq",
            "nr_irqs",
            "arg"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irqs_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1414-1424",
          "snippet": "int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"cannot allocate memory for IRQ%d\\n\"",
            "virq"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_irq_data",
          "args": [
            "domain",
            "virq",
            "nr_irqs"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1270-1292",
          "snippet": "static int irq_domain_alloc_irq_data(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct irq_domain *parent;\n\tint i;\n\n\t/* The outermost irq_data is embedded in struct irq_desc */\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\tirq_data->domain = domain;\n\n\t\tfor (parent = domain->parent; parent; parent = parent->parent) {\n\t\t\tirq_data = irq_domain_insert_irq_data(parent, irq_data);\n\t\t\tif (!irq_data) {\n\t\t\t\tirq_domain_free_irq_data(virq, i + 1);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int irq_domain_alloc_irq_data(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct irq_domain *parent;\n\tint i;\n\n\t/* The outermost irq_data is embedded in struct irq_desc */\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\tirq_data->domain = domain;\n\n\t\tfor (parent = domain->parent; parent; parent = parent->parent) {\n\t\t\tirq_data = irq_domain_insert_irq_data(parent, irq_data);\n\t\t\tif (!irq_data) {\n\t\t\t\tirq_domain_free_irq_data(virq, i + 1);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"cannot allocate IRQ(base %d, count %d)\\n\"",
            "irq_base",
            "nr_irqs"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_descs",
          "args": [
            "irq_base",
            "nr_irqs",
            "0",
            "node",
            "affinity"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_descs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1042-1063",
          "snippet": "int irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct irq_affinity_desc *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct irq_affinity_desc *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!domain",
            "\"domain is NULL; cannot allocate IRQ\\n\""
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,\n\t\t\t    unsigned int nr_irqs, int node, void *arg,\n\t\t\t    bool realloc, const struct irq_affinity_desc *affinity)\n{\n\tint i, ret, virq;\n\n\tif (domain == NULL) {\n\t\tdomain = irq_default_domain;\n\t\tif (WARN(!domain, \"domain is NULL; cannot allocate IRQ\\n\"))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (realloc && irq_base >= 0) {\n\t\tvirq = irq_base;\n\t} else {\n\t\tvirq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,\n\t\t\t\t\t      affinity);\n\t\tif (virq < 0) {\n\t\t\tpr_debug(\"cannot allocate IRQ(base %d, count %d)\\n\",\n\t\t\t\t irq_base, nr_irqs);\n\t\t\treturn virq;\n\t\t}\n\t}\n\n\tif (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {\n\t\tpr_debug(\"cannot allocate memory for IRQ%d\\n\", virq);\n\t\tret = -ENOMEM;\n\t\tgoto out_free_desc;\n\t}\n\n\tmutex_lock(&irq_domain_mutex);\n\tret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\tgoto out_free_irq_data;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tret = irq_domain_trim_hierarchy(virq + i);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\tgoto out_free_irq_data;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_insert_irq(virq + i);\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn virq;\n\nout_free_irq_data:\n\tirq_domain_free_irq_data(virq, nr_irqs);\nout_free_desc:\n\tirq_free_descs(virq, nr_irqs);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_domain_alloc_irqs_hierarchy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1414-1424",
    "snippet": "int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "domain->ops->alloc",
          "args": [
            "domain",
            "irq_base",
            "nr_irqs",
            "arg"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"domain->ops->alloc() is NULL\\n\""
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}"
  },
  {
    "function_name": "irq_domain_free_irqs_hierarchy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1399-1412",
    "snippet": "static void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tunsigned int i;\n\n\tif (!domain->ops->free)\n\t\treturn;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tif (irq_domain_get_irq_data(domain, irq_base + i))\n\t\t\tdomain->ops->free(domain, irq_base + i, 1);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "domain->ops->free",
          "args": [
            "domain",
            "irq_base + i",
            "1"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "irq_base + i"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1835-1841",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tunsigned int i;\n\n\tif (!domain->ops->free)\n\t\treturn;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tif (irq_domain_get_irq_data(domain, irq_base + i))\n\t\t\tdomain->ops->free(domain, irq_base + i, 1);\n\t}\n}"
  },
  {
    "function_name": "irq_domain_free_irqs_top",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1387-1397",
    "snippet": "void irq_domain_free_irqs_top(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_handler_data(virq + i, NULL);\n\t\tirq_set_handler(virq + i, NULL);\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_common",
          "args": [
            "domain",
            "virq",
            "nr_irqs"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1366-1378",
          "snippet": "void irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_handler",
          "args": [
            "virq + i",
            "NULL"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_handler_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "90-100",
          "snippet": "int irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_top(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_handler_data(virq + i, NULL);\n\t\tirq_set_handler(virq + i, NULL);\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}"
  },
  {
    "function_name": "irq_domain_free_irqs_common",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1366-1378",
    "snippet": "void irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_parent",
          "args": [
            "domain",
            "virq",
            "nr_irqs"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1731-1738",
          "snippet": "void irq_domain_free_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs)\n{\n\tif (!domain->parent)\n\t\treturn;\n\n\tirq_domain_free_irqs_hierarchy(domain->parent, irq_base, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs)\n{\n\tif (!domain->parent)\n\t\treturn;\n\n\tirq_domain_free_irqs_hierarchy(domain->parent, irq_base, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_reset_irq_data",
          "args": [
            "irq_data"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_reset_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1069-1074",
          "snippet": "void irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "virq + i"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1835-1841",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}"
  },
  {
    "function_name": "irq_domain_set_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1349-1357",
    "snippet": "void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, chip, chip_data);\n\t__irq_set_handler(virq, handler, 0, handler_name);\n\tirq_set_handler_data(virq, handler_data);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_set_handler_data",
          "args": [
            "virq",
            "handler_data"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_handler_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "90-100",
          "snippet": "int irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_set_handler",
          "args": [
            "virq",
            "handler",
            "0",
            "handler_name"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_set_handler",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1043-1055",
          "snippet": "void\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t__irq_do_set_handler(desc, handle, is_chained, name);\n\tirq_put_desc_busunlock(desc, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t__irq_do_set_handler(desc, handle, is_chained, name);\n\tirq_put_desc_busunlock(desc, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_set_hwirq_and_chip",
          "args": [
            "domain",
            "virq",
            "hwirq",
            "chip",
            "chip_data"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_set_hwirq_and_chip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1321-1335",
          "snippet": "int irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -ENOENT;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -ENOENT;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, chip, chip_data);\n\t__irq_set_handler(virq, handler, 0, handler_name);\n\tirq_set_handler_data(virq, handler_data);\n}"
  },
  {
    "function_name": "irq_domain_set_hwirq_and_chip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1321-1335",
    "snippet": "int irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -ENOENT;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "virq"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1835-1841",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -ENOENT;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_get_irq_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1299-1310",
    "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data;\n\n\tfor (irq_data = irq_get_irq_data(virq); irq_data;\n\t     irq_data = irq_data->parent_data)\n\t\tif (irq_data->domain == domain)\n\t\t\treturn irq_data;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data;\n\n\tfor (irq_data = irq_get_irq_data(virq); irq_data;\n\t     irq_data = irq_data->parent_data)\n\t\tif (irq_data->domain == domain)\n\t\t\treturn irq_data;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "irq_domain_alloc_irq_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1270-1292",
    "snippet": "static int irq_domain_alloc_irq_data(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct irq_domain *parent;\n\tint i;\n\n\t/* The outermost irq_data is embedded in struct irq_desc */\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\tirq_data->domain = domain;\n\n\t\tfor (parent = domain->parent; parent; parent = parent->parent) {\n\t\t\tirq_data = irq_domain_insert_irq_data(parent, irq_data);\n\t\t\tif (!irq_data) {\n\t\t\t\tirq_domain_free_irq_data(virq, i + 1);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irq_data",
          "args": [
            "virq",
            "i + 1"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1179-1192",
          "snippet": "static void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\t__irq_domain_free_hierarchy(tmp);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\t__irq_domain_free_hierarchy(tmp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_insert_irq_data",
          "args": [
            "parent",
            "irq_data"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_insert_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1151-1166",
          "snippet": "static struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,\n\t\t\t\t\t\t   struct irq_data *child)\n{\n\tstruct irq_data *irq_data;\n\n\tirq_data = kzalloc_node(sizeof(*irq_data), GFP_KERNEL,\n\t\t\t\tirq_data_get_node(child));\n\tif (irq_data) {\n\t\tchild->parent_data = irq_data;\n\t\tirq_data->irq = child->irq;\n\t\tirq_data->common = child->common;\n\t\tirq_data->domain = domain;\n\t}\n\n\treturn irq_data;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,\n\t\t\t\t\t\t   struct irq_data *child)\n{\n\tstruct irq_data *irq_data;\n\n\tirq_data = kzalloc_node(sizeof(*irq_data), GFP_KERNEL,\n\t\t\t\tirq_data_get_node(child));\n\tif (irq_data) {\n\t\tchild->parent_data = irq_data;\n\t\tirq_data->irq = child->irq;\n\t\tirq_data->common = child->common;\n\t\tirq_data->domain = domain;\n\t}\n\n\treturn irq_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq + i"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int irq_domain_alloc_irq_data(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct irq_domain *parent;\n\tint i;\n\n\t/* The outermost irq_data is embedded in struct irq_desc */\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\tirq_data->domain = domain;\n\n\t\tfor (parent = domain->parent; parent; parent = parent->parent) {\n\t\t\tirq_data = irq_domain_insert_irq_data(parent, irq_data);\n\t\t\tif (!irq_data) {\n\t\t\t\tirq_domain_free_irq_data(virq, i + 1);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_trim_hierarchy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1221-1268",
    "snippet": "static int irq_domain_trim_hierarchy(unsigned int virq)\n{\n\tstruct irq_data *tail, *irqd, *irq_data;\n\n\tirq_data = irq_get_irq_data(virq);\n\ttail = NULL;\n\n\t/* The first entry must have a valid irqchip */\n\tif (!irq_data->chip || IS_ERR(irq_data->chip))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Validate that the irq_data chain is sane in the presence of\n\t * a hierarchy trimming marker.\n\t */\n\tfor (irqd = irq_data->parent_data; irqd; irq_data = irqd, irqd = irqd->parent_data) {\n\t\t/* Can't have a valid irqchip after a trim marker */\n\t\tif (irqd->chip && tail)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can't have an empty irqchip before a trim marker */\n\t\tif (!irqd->chip && !tail)\n\t\t\treturn -EINVAL;\n\n\t\tif (IS_ERR(irqd->chip)) {\n\t\t\t/* Only -ENOTCONN is a valid trim marker */\n\t\t\tif (PTR_ERR(irqd->chip) != -ENOTCONN)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttail = irq_data;\n\t\t}\n\t}\n\n\t/* No trim marker, nothing to do */\n\tif (!tail)\n\t\treturn 0;\n\n\tpr_info(\"IRQ%d: trimming hierarchy from %s\\n\",\n\t\tvirq, tail->parent_data->domain->name);\n\n\t/* Sever the inner part of the hierarchy...  */\n\tirqd = tail;\n\ttail = tail->parent_data;\n\tirqd->parent_data = NULL;\n\t__irq_domain_free_hierarchy(tail);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_domain_free_hierarchy",
          "args": [
            "tail"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_free_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1168-1177",
          "snippet": "static void __irq_domain_free_hierarchy(struct irq_data *irq_data)\n{\n\tstruct irq_data *tmp;\n\n\twhile (irq_data) {\n\t\ttmp = irq_data;\n\t\tirq_data = irq_data->parent_data;\n\t\tkfree(tmp);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void __irq_domain_free_hierarchy(struct irq_data *irq_data)\n{\n\tstruct irq_data *tmp;\n\n\twhile (irq_data) {\n\t\ttmp = irq_data;\n\t\tirq_data = irq_data->parent_data;\n\t\tkfree(tmp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"IRQ%d: trimming hierarchy from %s\\n\"",
            "virq",
            "tail->parent_data->domain->name"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "irqd->chip"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "irqd->chip"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "irq_data->chip"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int irq_domain_trim_hierarchy(unsigned int virq)\n{\n\tstruct irq_data *tail, *irqd, *irq_data;\n\n\tirq_data = irq_get_irq_data(virq);\n\ttail = NULL;\n\n\t/* The first entry must have a valid irqchip */\n\tif (!irq_data->chip || IS_ERR(irq_data->chip))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Validate that the irq_data chain is sane in the presence of\n\t * a hierarchy trimming marker.\n\t */\n\tfor (irqd = irq_data->parent_data; irqd; irq_data = irqd, irqd = irqd->parent_data) {\n\t\t/* Can't have a valid irqchip after a trim marker */\n\t\tif (irqd->chip && tail)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can't have an empty irqchip before a trim marker */\n\t\tif (!irqd->chip && !tail)\n\t\t\treturn -EINVAL;\n\n\t\tif (IS_ERR(irqd->chip)) {\n\t\t\t/* Only -ENOTCONN is a valid trim marker */\n\t\t\tif (PTR_ERR(irqd->chip) != -ENOTCONN)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttail = irq_data;\n\t\t}\n\t}\n\n\t/* No trim marker, nothing to do */\n\tif (!tail)\n\t\treturn 0;\n\n\tpr_info(\"IRQ%d: trimming hierarchy from %s\\n\",\n\t\tvirq, tail->parent_data->domain->name);\n\n\t/* Sever the inner part of the hierarchy...  */\n\tirqd = tail;\n\ttail = tail->parent_data;\n\tirqd->parent_data = NULL;\n\t__irq_domain_free_hierarchy(tail);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_disconnect_hierarchy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1207-1218",
    "snippet": "int irq_domain_disconnect_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int virq)\n{\n\tstruct irq_data *irqd;\n\n\tirqd = irq_domain_get_irq_data(domain, virq);\n\tif (!irqd)\n\t\treturn -EINVAL;\n\n\tirqd->chip = ERR_PTR(-ENOTCONN);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTCONN"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "virq"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1835-1841",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_disconnect_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int virq)\n{\n\tstruct irq_data *irqd;\n\n\tirqd = irq_domain_get_irq_data(domain, virq);\n\tif (!irqd)\n\t\treturn -EINVAL;\n\n\tirqd->chip = ERR_PTR(-ENOTCONN);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_free_irq_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1179-1192",
    "snippet": "static void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\t__irq_domain_free_hierarchy(tmp);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_domain_free_hierarchy",
          "args": [
            "tmp"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_free_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1168-1177",
          "snippet": "static void __irq_domain_free_hierarchy(struct irq_data *irq_data)\n{\n\tstruct irq_data *tmp;\n\n\twhile (irq_data) {\n\t\ttmp = irq_data;\n\t\tirq_data = irq_data->parent_data;\n\t\tkfree(tmp);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void __irq_domain_free_hierarchy(struct irq_data *irq_data)\n{\n\tstruct irq_data *tmp;\n\n\twhile (irq_data) {\n\t\ttmp = irq_data;\n\t\tirq_data = irq_data->parent_data;\n\t\tkfree(tmp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq + i"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\t__irq_domain_free_hierarchy(tmp);\n\t}\n}"
  },
  {
    "function_name": "__irq_domain_free_hierarchy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1168-1177",
    "snippet": "static void __irq_domain_free_hierarchy(struct irq_data *irq_data)\n{\n\tstruct irq_data *tmp;\n\n\twhile (irq_data) {\n\t\ttmp = irq_data;\n\t\tirq_data = irq_data->parent_data;\n\t\tkfree(tmp);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void __irq_domain_free_hierarchy(struct irq_data *irq_data)\n{\n\tstruct irq_data *tmp;\n\n\twhile (irq_data) {\n\t\ttmp = irq_data;\n\t\tirq_data = irq_data->parent_data;\n\t\tkfree(tmp);\n\t}\n}"
  },
  {
    "function_name": "irq_domain_insert_irq_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1151-1166",
    "snippet": "static struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,\n\t\t\t\t\t\t   struct irq_data *child)\n{\n\tstruct irq_data *irq_data;\n\n\tirq_data = kzalloc_node(sizeof(*irq_data), GFP_KERNEL,\n\t\t\t\tirq_data_get_node(child));\n\tif (irq_data) {\n\t\tchild->parent_data = irq_data;\n\t\tirq_data->irq = child->irq;\n\t\tirq_data->common = child->common;\n\t\tirq_data->domain = domain;\n\t}\n\n\treturn irq_data;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*irq_data)",
            "GFP_KERNEL",
            "irq_data_get_node(child)"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_node",
          "args": [
            "child"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,\n\t\t\t\t\t\t   struct irq_data *child)\n{\n\tstruct irq_data *irq_data;\n\n\tirq_data = kzalloc_node(sizeof(*irq_data), GFP_KERNEL,\n\t\t\t\tirq_data_get_node(child));\n\tif (irq_data) {\n\t\tchild->parent_data = irq_data;\n\t\tirq_data->irq = child->irq;\n\t\tirq_data->common = child->common;\n\t\tirq_data->domain = domain;\n\t}\n\n\treturn irq_data;\n}"
  },
  {
    "function_name": "irq_domain_remove_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1133-1149",
    "snippet": "static void irq_domain_remove_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tirq_set_status_flags(virq, IRQ_NOREQUEST);\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tsynchronize_irq(virq);\n\tsmp_mb();\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tdomain->mapcount--;\n\t\tirq_domain_clear_mapping(domain, hwirq);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_clear_mapping",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_clear_mapping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "502-514",
          "snippet": "static void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], NULL);\n\telse\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\tmutex_unlock(&domain->revmap_mutex);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], NULL);\n\telse\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\tmutex_unlock(&domain->revmap_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_irq",
          "args": [
            "virq"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "126-140",
          "snippet": "void synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, true);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, true);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_chip_and_handler",
          "args": [
            "virq",
            "NULL",
            "NULL"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_status_flags",
          "args": [
            "virq",
            "IRQ_NOREQUEST"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_remove_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tirq_set_status_flags(virq, IRQ_NOREQUEST);\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tsynchronize_irq(virq);\n\tsmp_mb();\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tdomain->mapcount--;\n\t\tirq_domain_clear_mapping(domain, hwirq);\n\t}\n}"
  },
  {
    "function_name": "irq_domain_insert_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1115-1131",
    "snippet": "static void irq_domain_insert_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\n\t\tdomain->mapcount++;\n\t\tirq_domain_set_mapping(domain, data->hwirq, data);\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && data->chip)\n\t\t\tdomain->name = data->chip->name;\n\t}\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_clear_status_flags",
          "args": [
            "virq",
            "IRQ_NOREQUEST"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_set_mapping",
          "args": [
            "domain",
            "data->hwirq",
            "data"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_set_mapping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "516-529",
          "snippet": "static void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], irq_data);\n\telse\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\tmutex_unlock(&domain->revmap_mutex);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], irq_data);\n\telse\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\tmutex_unlock(&domain->revmap_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_insert_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\n\t\tdomain->mapcount++;\n\t\tirq_domain_set_mapping(domain, data->hwirq, data);\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && data->chip)\n\t\t\tdomain->name = data->chip->name;\n\t}\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n}"
  },
  {
    "function_name": "irq_domain_create_hierarchy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1093-1112",
    "snippet": "struct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    struct fwnode_handle *fwnode,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tif (size)\n\t\tdomain = irq_domain_create_linear(fwnode, size, ops, host_data);\n\telse\n\t\tdomain = irq_domain_create_tree(fwnode, ops, host_data);\n\tif (domain) {\n\t\tdomain->parent = parent;\n\t\tdomain->flags |= flags;\n\t}\n\n\treturn domain;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_create_tree",
          "args": [
            "fwnode",
            "ops",
            "host_data"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_create_linear",
          "args": [
            "fwnode",
            "size",
            "ops",
            "host_data"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    struct fwnode_handle *fwnode,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tif (size)\n\t\tdomain = irq_domain_create_linear(fwnode, size, ops, host_data);\n\telse\n\t\tdomain = irq_domain_create_tree(fwnode, ops, host_data);\n\tif (domain) {\n\t\tdomain->parent = parent;\n\t\tdomain->flags |= flags;\n\t}\n\n\treturn domain;\n}"
  },
  {
    "function_name": "irq_domain_reset_irq_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1069-1074",
    "snippet": "void irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = NULL;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = NULL;\n}"
  },
  {
    "function_name": "irq_domain_alloc_descs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1042-1063",
    "snippet": "int irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct irq_affinity_desc *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_alloc_descs",
          "args": [
            "-1",
            "1",
            "cnt",
            "node",
            "THIS_MODULE",
            "affinity"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_alloc_descs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "738-777",
          "snippet": "int __ref\n__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,\n\t\t  struct module *owner, const struct irq_affinity_desc *affinity)\n{\n\tint start, ret;\n\n\tif (!cnt)\n\t\treturn -EINVAL;\n\n\tif (irq >= 0) {\n\t\tif (from > irq)\n\t\t\treturn -EINVAL;\n\t\tfrom = irq;\n\t} else {\n\t\t/*\n\t\t * For interrupts which are freely allocated the\n\t\t * architecture can force a lower bound to the @from\n\t\t * argument. x86 uses this to exclude the GSI space.\n\t\t */\n\t\tfrom = arch_dynirq_lower_bound(from);\n\t}\n\n\tmutex_lock(&sparse_irq_lock);\n\n\tstart = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,\n\t\t\t\t\t   from, cnt, 0);\n\tret = -EEXIST;\n\tif (irq >=0 && start != irq)\n\t\tgoto unlock;\n\n\tif (start + cnt > nr_irqs) {\n\t\tret = irq_expand_nr_irqs(start + cnt);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\tret = alloc_descs(start, cnt, node, affinity, owner);\nunlock:\n\tmutex_unlock(&sparse_irq_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nr_irqs = NR_IRQS;",
            "static DEFINE_MUTEX(sparse_irq_lock);",
            "static DECLARE_BITMAP(allocated_irqs, IRQ_BITMAP_BITS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nint nr_irqs = NR_IRQS;\nstatic DEFINE_MUTEX(sparse_irq_lock);\nstatic DECLARE_BITMAP(allocated_irqs, IRQ_BITMAP_BITS);\n\nint __ref\n__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,\n\t\t  struct module *owner, const struct irq_affinity_desc *affinity)\n{\n\tint start, ret;\n\n\tif (!cnt)\n\t\treturn -EINVAL;\n\n\tif (irq >= 0) {\n\t\tif (from > irq)\n\t\t\treturn -EINVAL;\n\t\tfrom = irq;\n\t} else {\n\t\t/*\n\t\t * For interrupts which are freely allocated the\n\t\t * architecture can force a lower bound to the @from\n\t\t * argument. x86 uses this to exclude the GSI space.\n\t\t */\n\t\tfrom = arch_dynirq_lower_bound(from);\n\t}\n\n\tmutex_lock(&sparse_irq_lock);\n\n\tstart = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,\n\t\t\t\t\t   from, cnt, 0);\n\tret = -EEXIST;\n\tif (irq >=0 && start != irq)\n\t\tgoto unlock;\n\n\tif (start + cnt > nr_irqs) {\n\t\tret = irq_expand_nr_irqs(start + cnt);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\tret = alloc_descs(start, cnt, node, affinity, owner);\nunlock:\n\tmutex_unlock(&sparse_irq_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct irq_affinity_desc *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}"
  },
  {
    "function_name": "irq_domain_translate_twocell",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1029-1039",
    "snippet": "int irq_domain_translate_twocell(struct irq_domain *d,\n\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t unsigned long *out_hwirq,\n\t\t\t\t unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "fwspec->param_count < 2"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_translate_twocell(struct irq_domain *d,\n\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t unsigned long *out_hwirq,\n\t\t\t\t unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_translate_onecell",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "1008-1018",
    "snippet": "int irq_domain_translate_onecell(struct irq_domain *d,\n\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t unsigned long *out_hwirq,\n\t\t\t\t unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "fwspec->param_count < 1"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_translate_onecell(struct irq_domain *d,\n\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t unsigned long *out_hwirq,\n\t\t\t\t unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_xlate_onetwocell",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "983-996",
    "snippet": "int irq_domain_xlate_onetwocell(struct irq_domain *d,\n\t\t\t\tstruct device_node *ctrlr,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tunsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\tif (intsize > 1)\n\t\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\telse\n\t\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "intsize < 1"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_xlate_onetwocell(struct irq_domain *d,\n\t\t\t\tstruct device_node *ctrlr,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tunsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\tif (intsize > 1)\n\t\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\telse\n\t\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_xlate_twocell",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "961-969",
    "snippet": "int irq_domain_xlate_twocell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\tirq_hw_number_t *out_hwirq, unsigned int *out_type)\n{\n\tstruct irq_fwspec fwspec;\n\n\tof_phandle_args_to_fwspec(ctrlr, intspec, intsize, &fwspec);\n\treturn irq_domain_translate_twocell(d, &fwspec, out_hwirq, out_type);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_translate_twocell",
          "args": [
            "d",
            "&fwspec",
            "out_hwirq",
            "out_type"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_translate_twocell",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1029-1039",
          "snippet": "int irq_domain_translate_twocell(struct irq_domain *d,\n\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t unsigned long *out_hwirq,\n\t\t\t\t unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_translate_twocell(struct irq_domain *d,\n\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t unsigned long *out_hwirq,\n\t\t\t\t unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_phandle_args_to_fwspec",
          "args": [
            "ctrlr",
            "intspec",
            "intsize",
            "&fwspec"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "of_phandle_args_to_fwspec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "747-757",
          "snippet": "void of_phandle_args_to_fwspec(struct device_node *np, const u32 *args,\n\t\t\t       unsigned int count, struct irq_fwspec *fwspec)\n{\n\tint i;\n\n\tfwspec->fwnode = of_node_to_fwnode(np);\n\tfwspec->param_count = count;\n\n\tfor (i = 0; i < count; i++)\n\t\tfwspec->param[i] = args[i];\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid of_phandle_args_to_fwspec(struct device_node *np, const u32 *args,\n\t\t\t       unsigned int count, struct irq_fwspec *fwspec)\n{\n\tint i;\n\n\tfwspec->fwnode = of_node_to_fwnode(np);\n\tfwspec->param_count = count;\n\n\tfor (i = 0; i < count; i++)\n\t\tfwspec->param[i] = args[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_xlate_twocell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\tirq_hw_number_t *out_hwirq, unsigned int *out_type)\n{\n\tstruct irq_fwspec fwspec;\n\n\tof_phandle_args_to_fwspec(ctrlr, intspec, intsize, &fwspec);\n\treturn irq_domain_translate_twocell(d, &fwspec, out_hwirq, out_type);\n}"
  },
  {
    "function_name": "irq_domain_xlate_onecell",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "942-951",
    "snippet": "int irq_domain_xlate_onecell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\t     const u32 *intspec, unsigned int intsize,\n\t\t\t     unsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "intsize < 1"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_xlate_onecell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\t     const u32 *intspec, unsigned int intsize,\n\t\t\t     unsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}"
  },
  {
    "function_name": "__irq_resolve_mapping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "895-933",
    "snippet": "struct irq_desc *__irq_resolve_mapping(struct irq_domain *domain,\n\t\t\t\t       irq_hw_number_t hwirq,\n\t\t\t\t       unsigned int *irq)\n{\n\tstruct irq_desc *desc = NULL;\n\tstruct irq_data *data;\n\n\t/* Look for default domain if necessary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL)\n\t\treturn desc;\n\n\tif (irq_domain_is_nomap(domain)) {\n\t\tif (hwirq < domain->revmap_size) {\n\t\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\t\tif (data && data->hwirq == hwirq)\n\t\t\t\tdesc = irq_data_to_desc(data);\n\t\t}\n\n\t\treturn desc;\n\t}\n\n\trcu_read_lock();\n\t/* Check if the hwirq is in the linear revmap. */\n\tif (hwirq < domain->revmap_size)\n\t\tdata = rcu_dereference(domain->revmap[hwirq]);\n\telse\n\t\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\n\tif (likely(data)) {\n\t\tdesc = irq_data_to_desc(data);\n\t\tif (irq)\n\t\t\t*irq = data->irq;\n\t}\n\n\trcu_read_unlock();\n\treturn desc;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_data_to_desc",
          "args": [
            "data"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "data"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&domain->revmap_tree",
            "hwirq"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "domain->revmap[hwirq]"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_data_to_desc",
          "args": [
            "data"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1835-1841",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_nomap",
          "args": [
            "domain"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_is_nomap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "496-500",
          "snippet": "static bool irq_domain_is_nomap(struct irq_domain *domain)\n{\n\treturn IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&\n\t       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic bool irq_domain_is_nomap(struct irq_domain *domain)\n{\n\treturn IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&\n\t       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_desc *__irq_resolve_mapping(struct irq_domain *domain,\n\t\t\t\t       irq_hw_number_t hwirq,\n\t\t\t\t       unsigned int *irq)\n{\n\tstruct irq_desc *desc = NULL;\n\tstruct irq_data *data;\n\n\t/* Look for default domain if necessary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL)\n\t\treturn desc;\n\n\tif (irq_domain_is_nomap(domain)) {\n\t\tif (hwirq < domain->revmap_size) {\n\t\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\t\tif (data && data->hwirq == hwirq)\n\t\t\t\tdesc = irq_data_to_desc(data);\n\t\t}\n\n\t\treturn desc;\n\t}\n\n\trcu_read_lock();\n\t/* Check if the hwirq is in the linear revmap. */\n\tif (hwirq < domain->revmap_size)\n\t\tdata = rcu_dereference(domain->revmap[hwirq]);\n\telse\n\t\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\n\tif (likely(data)) {\n\t\tdesc = irq_data_to_desc(data);\n\t\tif (irq)\n\t\t\t*irq = data->irq;\n\t}\n\n\trcu_read_unlock();\n\treturn desc;\n}"
  },
  {
    "function_name": "irq_dispose_mapping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "866-884",
    "snippet": "void irq_dispose_mapping(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\n\tif (!virq || !irq_data)\n\t\treturn;\n\n\tdomain = irq_data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn;\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tirq_domain_free_irqs(virq, 1);\n\t} else {\n\t\tirq_domain_disassociate(domain, virq);\n\t\tirq_free_desc(virq);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_free_desc",
          "args": [
            "virq"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_disassociate",
          "args": [
            "domain",
            "virq"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_disassociate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "531-560",
          "snippet": "static void irq_domain_disassociate(struct irq_domain *domain, unsigned int irq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(irq);\n\tirq_hw_number_t hwirq;\n\n\tif (WARN(!irq_data || irq_data->domain != domain,\n\t\t \"virq%i doesn't exist; cannot disassociate\\n\", irq))\n\t\treturn;\n\n\thwirq = irq_data->hwirq;\n\tirq_set_status_flags(irq, IRQ_NOREQUEST);\n\n\t/* remove chip and handler */\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\n\t/* Make sure it's completed */\n\tsynchronize_irq(irq);\n\n\t/* Tell the PIC about it */\n\tif (domain->ops->unmap)\n\t\tdomain->ops->unmap(domain, irq);\n\tsmp_mb();\n\n\tirq_data->domain = NULL;\n\tirq_data->hwirq = 0;\n\tdomain->mapcount--;\n\n\t/* Clear reverse map for this hwirq */\n\tirq_domain_clear_mapping(domain, hwirq);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_disassociate(struct irq_domain *domain, unsigned int irq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(irq);\n\tirq_hw_number_t hwirq;\n\n\tif (WARN(!irq_data || irq_data->domain != domain,\n\t\t \"virq%i doesn't exist; cannot disassociate\\n\", irq))\n\t\treturn;\n\n\thwirq = irq_data->hwirq;\n\tirq_set_status_flags(irq, IRQ_NOREQUEST);\n\n\t/* remove chip and handler */\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\n\t/* Make sure it's completed */\n\tsynchronize_irq(irq);\n\n\t/* Tell the PIC about it */\n\tif (domain->ops->unmap)\n\t\tdomain->ops->unmap(domain, irq);\n\tsmp_mb();\n\n\tirq_data->domain = NULL;\n\tirq_data->hwirq = 0;\n\tdomain->mapcount--;\n\n\t/* Clear reverse map for this hwirq */\n\tirq_domain_clear_mapping(domain, hwirq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irqs",
          "args": [
            "virq",
            "1"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1687-1704",
          "snippet": "void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_hierarchy",
          "args": [
            "domain"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "domain == NULL"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_dispose_mapping(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\n\tif (!virq || !irq_data)\n\t\treturn;\n\n\tdomain = irq_data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn;\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tirq_domain_free_irqs(virq, 1);\n\t} else {\n\t\tirq_domain_disassociate(domain, virq);\n\t\tirq_free_desc(virq);\n\t}\n}"
  },
  {
    "function_name": "irq_create_of_mapping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "851-859",
    "snippet": "unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)\n{\n\tstruct irq_fwspec fwspec;\n\n\tof_phandle_args_to_fwspec(irq_data->np, irq_data->args,\n\t\t\t\t  irq_data->args_count, &fwspec);\n\n\treturn irq_create_fwspec_mapping(&fwspec);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_create_fwspec_mapping",
          "args": [
            "&fwspec"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "irq_create_fwspec_mapping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "760-848",
          "snippet": "unsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec)\n{\n\tstruct irq_domain *domain;\n\tstruct irq_data *irq_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tint virq;\n\n\tif (fwspec->fwnode) {\n\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_WIRED);\n\t\tif (!domain)\n\t\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_ANY);\n\t} else {\n\t\tdomain = irq_default_domain;\n\t}\n\n\tif (!domain) {\n\t\tpr_warn(\"no irq domain found for %s !\\n\",\n\t\t\tof_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_translate(domain, fwspec, &hwirq, &type))\n\t\treturn 0;\n\n\t/*\n\t * WARN if the irqchip returns a type with bits\n\t * outside the sense mask set and clear these bits.\n\t */\n\tif (WARN_ON(type & ~IRQ_TYPE_SENSE_MASK))\n\t\ttype &= IRQ_TYPE_SENSE_MASK;\n\n\t/*\n\t * If we've already configured this interrupt,\n\t * don't do it again, or hell will break loose.\n\t */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\t/*\n\t\t * If the trigger type is not specified or matches the\n\t\t * current trigger type then we are done so return the\n\t\t * interrupt number.\n\t\t */\n\t\tif (type == IRQ_TYPE_NONE || type == irq_get_trigger_type(virq))\n\t\t\treturn virq;\n\n\t\t/*\n\t\t * If the trigger type has not been set yet, then set\n\t\t * it now and return the interrupt number.\n\t\t */\n\t\tif (irq_get_trigger_type(virq) == IRQ_TYPE_NONE) {\n\t\t\tirq_data = irq_get_irq_data(virq);\n\t\t\tif (!irq_data)\n\t\t\t\treturn 0;\n\n\t\t\tirqd_set_trigger_type(irq_data, type);\n\t\t\treturn virq;\n\t\t}\n\n\t\tpr_warn(\"type mismatch, failed to map hwirq-%lu for %s!\\n\",\n\t\t\thwirq, of_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tvirq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec);\n\t\tif (virq <= 0)\n\t\t\treturn 0;\n\t} else {\n\t\t/* Create mapping */\n\t\tvirq = irq_create_mapping(domain, hwirq);\n\t\tif (!virq)\n\t\t\treturn virq;\n\t}\n\n\tirq_data = irq_get_irq_data(virq);\n\tif (!irq_data) {\n\t\tif (irq_domain_is_hierarchy(domain))\n\t\t\tirq_domain_free_irqs(virq, 1);\n\t\telse\n\t\t\tirq_dispose_mapping(virq);\n\t\treturn 0;\n\t}\n\n\t/* Store trigger type */\n\tirqd_set_trigger_type(irq_data, type);\n\n\treturn virq;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct irq_domain *irq_default_domain;",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec)\n{\n\tstruct irq_domain *domain;\n\tstruct irq_data *irq_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tint virq;\n\n\tif (fwspec->fwnode) {\n\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_WIRED);\n\t\tif (!domain)\n\t\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_ANY);\n\t} else {\n\t\tdomain = irq_default_domain;\n\t}\n\n\tif (!domain) {\n\t\tpr_warn(\"no irq domain found for %s !\\n\",\n\t\t\tof_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_translate(domain, fwspec, &hwirq, &type))\n\t\treturn 0;\n\n\t/*\n\t * WARN if the irqchip returns a type with bits\n\t * outside the sense mask set and clear these bits.\n\t */\n\tif (WARN_ON(type & ~IRQ_TYPE_SENSE_MASK))\n\t\ttype &= IRQ_TYPE_SENSE_MASK;\n\n\t/*\n\t * If we've already configured this interrupt,\n\t * don't do it again, or hell will break loose.\n\t */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\t/*\n\t\t * If the trigger type is not specified or matches the\n\t\t * current trigger type then we are done so return the\n\t\t * interrupt number.\n\t\t */\n\t\tif (type == IRQ_TYPE_NONE || type == irq_get_trigger_type(virq))\n\t\t\treturn virq;\n\n\t\t/*\n\t\t * If the trigger type has not been set yet, then set\n\t\t * it now and return the interrupt number.\n\t\t */\n\t\tif (irq_get_trigger_type(virq) == IRQ_TYPE_NONE) {\n\t\t\tirq_data = irq_get_irq_data(virq);\n\t\t\tif (!irq_data)\n\t\t\t\treturn 0;\n\n\t\t\tirqd_set_trigger_type(irq_data, type);\n\t\t\treturn virq;\n\t\t}\n\n\t\tpr_warn(\"type mismatch, failed to map hwirq-%lu for %s!\\n\",\n\t\t\thwirq, of_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tvirq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec);\n\t\tif (virq <= 0)\n\t\t\treturn 0;\n\t} else {\n\t\t/* Create mapping */\n\t\tvirq = irq_create_mapping(domain, hwirq);\n\t\tif (!virq)\n\t\t\treturn virq;\n\t}\n\n\tirq_data = irq_get_irq_data(virq);\n\tif (!irq_data) {\n\t\tif (irq_domain_is_hierarchy(domain))\n\t\t\tirq_domain_free_irqs(virq, 1);\n\t\telse\n\t\t\tirq_dispose_mapping(virq);\n\t\treturn 0;\n\t}\n\n\t/* Store trigger type */\n\tirqd_set_trigger_type(irq_data, type);\n\n\treturn virq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_phandle_args_to_fwspec",
          "args": [
            "irq_data->np",
            "irq_data->args",
            "irq_data->args_count",
            "&fwspec"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "of_phandle_args_to_fwspec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "747-757",
          "snippet": "void of_phandle_args_to_fwspec(struct device_node *np, const u32 *args,\n\t\t\t       unsigned int count, struct irq_fwspec *fwspec)\n{\n\tint i;\n\n\tfwspec->fwnode = of_node_to_fwnode(np);\n\tfwspec->param_count = count;\n\n\tfor (i = 0; i < count; i++)\n\t\tfwspec->param[i] = args[i];\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid of_phandle_args_to_fwspec(struct device_node *np, const u32 *args,\n\t\t\t       unsigned int count, struct irq_fwspec *fwspec)\n{\n\tint i;\n\n\tfwspec->fwnode = of_node_to_fwnode(np);\n\tfwspec->param_count = count;\n\n\tfor (i = 0; i < count; i++)\n\t\tfwspec->param[i] = args[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nunsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)\n{\n\tstruct irq_fwspec fwspec;\n\n\tof_phandle_args_to_fwspec(irq_data->np, irq_data->args,\n\t\t\t\t  irq_data->args_count, &fwspec);\n\n\treturn irq_create_fwspec_mapping(&fwspec);\n}"
  },
  {
    "function_name": "irq_create_fwspec_mapping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "760-848",
    "snippet": "unsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec)\n{\n\tstruct irq_domain *domain;\n\tstruct irq_data *irq_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tint virq;\n\n\tif (fwspec->fwnode) {\n\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_WIRED);\n\t\tif (!domain)\n\t\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_ANY);\n\t} else {\n\t\tdomain = irq_default_domain;\n\t}\n\n\tif (!domain) {\n\t\tpr_warn(\"no irq domain found for %s !\\n\",\n\t\t\tof_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_translate(domain, fwspec, &hwirq, &type))\n\t\treturn 0;\n\n\t/*\n\t * WARN if the irqchip returns a type with bits\n\t * outside the sense mask set and clear these bits.\n\t */\n\tif (WARN_ON(type & ~IRQ_TYPE_SENSE_MASK))\n\t\ttype &= IRQ_TYPE_SENSE_MASK;\n\n\t/*\n\t * If we've already configured this interrupt,\n\t * don't do it again, or hell will break loose.\n\t */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\t/*\n\t\t * If the trigger type is not specified or matches the\n\t\t * current trigger type then we are done so return the\n\t\t * interrupt number.\n\t\t */\n\t\tif (type == IRQ_TYPE_NONE || type == irq_get_trigger_type(virq))\n\t\t\treturn virq;\n\n\t\t/*\n\t\t * If the trigger type has not been set yet, then set\n\t\t * it now and return the interrupt number.\n\t\t */\n\t\tif (irq_get_trigger_type(virq) == IRQ_TYPE_NONE) {\n\t\t\tirq_data = irq_get_irq_data(virq);\n\t\t\tif (!irq_data)\n\t\t\t\treturn 0;\n\n\t\t\tirqd_set_trigger_type(irq_data, type);\n\t\t\treturn virq;\n\t\t}\n\n\t\tpr_warn(\"type mismatch, failed to map hwirq-%lu for %s!\\n\",\n\t\t\thwirq, of_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tvirq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec);\n\t\tif (virq <= 0)\n\t\t\treturn 0;\n\t} else {\n\t\t/* Create mapping */\n\t\tvirq = irq_create_mapping(domain, hwirq);\n\t\tif (!virq)\n\t\t\treturn virq;\n\t}\n\n\tirq_data = irq_get_irq_data(virq);\n\tif (!irq_data) {\n\t\tif (irq_domain_is_hierarchy(domain))\n\t\t\tirq_domain_free_irqs(virq, 1);\n\t\telse\n\t\t\tirq_dispose_mapping(virq);\n\t\treturn 0;\n\t}\n\n\t/* Store trigger type */\n\tirqd_set_trigger_type(irq_data, type);\n\n\treturn virq;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_set_trigger_type",
          "args": [
            "irq_data",
            "type"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_dispose_mapping",
          "args": [
            "virq"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "irq_dispose_mapping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "866-884",
          "snippet": "void irq_dispose_mapping(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\n\tif (!virq || !irq_data)\n\t\treturn;\n\n\tdomain = irq_data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn;\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tirq_domain_free_irqs(virq, 1);\n\t} else {\n\t\tirq_domain_disassociate(domain, virq);\n\t\tirq_free_desc(virq);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_dispose_mapping(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\n\tif (!virq || !irq_data)\n\t\treturn;\n\n\tdomain = irq_data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn;\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tirq_domain_free_irqs(virq, 1);\n\t} else {\n\t\tirq_domain_disassociate(domain, virq);\n\t\tirq_free_desc(virq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irqs",
          "args": [
            "virq",
            "1"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1687-1704",
          "snippet": "void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_hierarchy",
          "args": [
            "domain"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_create_mapping",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_irqs",
          "args": [
            "domain",
            "1",
            "NUMA_NO_NODE",
            "fwspec"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irqs_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1713-1722",
          "snippet": "int irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\tif (!domain->parent)\n\t\treturn -ENOSYS;\n\n\treturn irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs, arg);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\tif (!domain->parent)\n\t\treturn -ENOSYS;\n\n\treturn irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_hierarchy",
          "args": [
            "domain"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"type mismatch, failed to map hwirq-%lu for %s!\\n\"",
            "hwirq",
            "of_node_full_name(to_of_node(fwspec->fwnode))"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "to_of_node(fwspec->fwnode)"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_of_node",
          "args": [
            "fwspec->fwnode"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_set_trigger_type",
          "args": [
            "irq_data",
            "type"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_trigger_type",
          "args": [
            "virq"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_trigger_type",
          "args": [
            "virq"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_find_mapping",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "type & ~IRQ_TYPE_SENSE_MASK"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_translate",
          "args": [
            "domain",
            "fwspec",
            "&hwirq",
            "&type"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_translate_twocell",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1029-1039",
          "snippet": "int irq_domain_translate_twocell(struct irq_domain *d,\n\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t unsigned long *out_hwirq,\n\t\t\t\t unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_translate_twocell(struct irq_domain *d,\n\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t unsigned long *out_hwirq,\n\t\t\t\t unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"no irq domain found for %s !\\n\"",
            "of_node_full_name(to_of_node(fwspec->fwnode))"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "to_of_node(fwspec->fwnode)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_of_node",
          "args": [
            "fwspec->fwnode"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_find_matching_fwspec",
          "args": [
            "fwspec",
            "DOMAIN_BUS_ANY"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "irq_find_matching_fwspec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "402-436",
          "snippet": "struct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,\n\t\t\t\t\t    enum irq_domain_bus_token bus_token)\n{\n\tstruct irq_domain *h, *found = NULL;\n\tstruct fwnode_handle *fwnode = fwspec->fwnode;\n\tint rc;\n\n\t/* We might want to match the legacy controller last since\n\t * it might potentially be set to match all interrupts in\n\t * the absence of a device node. This isn't a problem so far\n\t * yet though...\n\t *\n\t * bus_token == DOMAIN_BUS_ANY matches any domain, any other\n\t * values must generate an exact match for the domain to be\n\t * selected.\n\t */\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (h->ops->select && fwspec->param_count)\n\t\t\trc = h->ops->select(h, fwspec, bus_token);\n\t\telse if (h->ops->match)\n\t\t\trc = h->ops->match(h, to_of_node(fwnode), bus_token);\n\t\telse\n\t\t\trc = ((fwnode != NULL) && (h->fwnode == fwnode) &&\n\t\t\t      ((bus_token == DOMAIN_BUS_ANY) ||\n\t\t\t       (h->bus_token == bus_token)));\n\n\t\tif (rc) {\n\t\t\tfound = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn found;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(irq_domain_list);",
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,\n\t\t\t\t\t    enum irq_domain_bus_token bus_token)\n{\n\tstruct irq_domain *h, *found = NULL;\n\tstruct fwnode_handle *fwnode = fwspec->fwnode;\n\tint rc;\n\n\t/* We might want to match the legacy controller last since\n\t * it might potentially be set to match all interrupts in\n\t * the absence of a device node. This isn't a problem so far\n\t * yet though...\n\t *\n\t * bus_token == DOMAIN_BUS_ANY matches any domain, any other\n\t * values must generate an exact match for the domain to be\n\t * selected.\n\t */\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (h->ops->select && fwspec->param_count)\n\t\t\trc = h->ops->select(h, fwspec, bus_token);\n\t\telse if (h->ops->match)\n\t\t\trc = h->ops->match(h, to_of_node(fwnode), bus_token);\n\t\telse\n\t\t\trc = ((fwnode != NULL) && (h->fwnode == fwnode) &&\n\t\t\t      ((bus_token == DOMAIN_BUS_ANY) ||\n\t\t\t       (h->bus_token == bus_token)));\n\n\t\tif (rc) {\n\t\t\tfound = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec)\n{\n\tstruct irq_domain *domain;\n\tstruct irq_data *irq_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tint virq;\n\n\tif (fwspec->fwnode) {\n\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_WIRED);\n\t\tif (!domain)\n\t\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_ANY);\n\t} else {\n\t\tdomain = irq_default_domain;\n\t}\n\n\tif (!domain) {\n\t\tpr_warn(\"no irq domain found for %s !\\n\",\n\t\t\tof_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_translate(domain, fwspec, &hwirq, &type))\n\t\treturn 0;\n\n\t/*\n\t * WARN if the irqchip returns a type with bits\n\t * outside the sense mask set and clear these bits.\n\t */\n\tif (WARN_ON(type & ~IRQ_TYPE_SENSE_MASK))\n\t\ttype &= IRQ_TYPE_SENSE_MASK;\n\n\t/*\n\t * If we've already configured this interrupt,\n\t * don't do it again, or hell will break loose.\n\t */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\t/*\n\t\t * If the trigger type is not specified or matches the\n\t\t * current trigger type then we are done so return the\n\t\t * interrupt number.\n\t\t */\n\t\tif (type == IRQ_TYPE_NONE || type == irq_get_trigger_type(virq))\n\t\t\treturn virq;\n\n\t\t/*\n\t\t * If the trigger type has not been set yet, then set\n\t\t * it now and return the interrupt number.\n\t\t */\n\t\tif (irq_get_trigger_type(virq) == IRQ_TYPE_NONE) {\n\t\t\tirq_data = irq_get_irq_data(virq);\n\t\t\tif (!irq_data)\n\t\t\t\treturn 0;\n\n\t\t\tirqd_set_trigger_type(irq_data, type);\n\t\t\treturn virq;\n\t\t}\n\n\t\tpr_warn(\"type mismatch, failed to map hwirq-%lu for %s!\\n\",\n\t\t\thwirq, of_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tvirq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec);\n\t\tif (virq <= 0)\n\t\t\treturn 0;\n\t} else {\n\t\t/* Create mapping */\n\t\tvirq = irq_create_mapping(domain, hwirq);\n\t\tif (!virq)\n\t\t\treturn virq;\n\t}\n\n\tirq_data = irq_get_irq_data(virq);\n\tif (!irq_data) {\n\t\tif (irq_domain_is_hierarchy(domain))\n\t\t\tirq_domain_free_irqs(virq, 1);\n\t\telse\n\t\t\tirq_dispose_mapping(virq);\n\t\treturn 0;\n\t}\n\n\t/* Store trigger type */\n\tirqd_set_trigger_type(irq_data, type);\n\n\treturn virq;\n}"
  },
  {
    "function_name": "of_phandle_args_to_fwspec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "747-757",
    "snippet": "void of_phandle_args_to_fwspec(struct device_node *np, const u32 *args,\n\t\t\t       unsigned int count, struct irq_fwspec *fwspec)\n{\n\tint i;\n\n\tfwspec->fwnode = of_node_to_fwnode(np);\n\tfwspec->param_count = count;\n\n\tfor (i = 0; i < count; i++)\n\t\tfwspec->param[i] = args[i];\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_node_to_fwnode",
          "args": [
            "np"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid of_phandle_args_to_fwspec(struct device_node *np, const u32 *args,\n\t\t\t       unsigned int count, struct irq_fwspec *fwspec)\n{\n\tint i;\n\n\tfwspec->fwnode = of_node_to_fwnode(np);\n\tfwspec->param_count = count;\n\n\tfor (i = 0; i < count; i++)\n\t\tfwspec->param[i] = args[i];\n}"
  },
  {
    "function_name": "irq_domain_translate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "729-745",
    "snippet": "static int irq_domain_translate(struct irq_domain *d,\n\t\t\t\tstruct irq_fwspec *fwspec,\n\t\t\t\tirq_hw_number_t *hwirq, unsigned int *type)\n{\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (d->ops->translate)\n\t\treturn d->ops->translate(d, fwspec, hwirq, type);\n#endif\n\tif (d->ops->xlate)\n\t\treturn d->ops->xlate(d, to_of_node(fwspec->fwnode),\n\t\t\t\t     fwspec->param, fwspec->param_count,\n\t\t\t\t     hwirq, type);\n\n\t/* If domain has no translation, then we assume interrupt line */\n\t*hwirq = fwspec->param[0];\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->ops->xlate",
          "args": [
            "d",
            "to_of_node(fwspec->fwnode)",
            "fwspec->param",
            "fwspec->param_count",
            "hwirq",
            "type"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_of_node",
          "args": [
            "fwspec->fwnode"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->ops->translate",
          "args": [
            "d",
            "fwspec",
            "hwirq",
            "type"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int irq_domain_translate(struct irq_domain *d,\n\t\t\t\tstruct irq_fwspec *fwspec,\n\t\t\t\tirq_hw_number_t *hwirq, unsigned int *type)\n{\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (d->ops->translate)\n\t\treturn d->ops->translate(d, fwspec, hwirq, type);\n#endif\n\tif (d->ops->xlate)\n\t\treturn d->ops->xlate(d, to_of_node(fwspec->fwnode),\n\t\t\t\t     fwspec->param, fwspec->param_count,\n\t\t\t\t     hwirq, type);\n\n\t/* If domain has no translation, then we assume interrupt line */\n\t*hwirq = fwspec->param[0];\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_create_mapping_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "682-726",
    "snippet": "unsigned int irq_create_mapping_affinity(struct irq_domain *domain,\n\t\t\t\t       irq_hw_number_t hwirq,\n\t\t\t\t       const struct irq_affinity_desc *affinity)\n{\n\tstruct device_node *of_node;\n\tint virq;\n\n\tpr_debug(\"irq_create_mapping(0x%p, 0x%lx)\\n\", domain, hwirq);\n\n\t/* Look for default domain if necessary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL) {\n\t\tWARN(1, \"%s(, %lx) called with NULL domain\\n\", __func__, hwirq);\n\t\treturn 0;\n\t}\n\tpr_debug(\"-> using domain @%p\\n\", domain);\n\n\tof_node = irq_domain_get_of_node(domain);\n\n\t/* Check if mapping already exists */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\tpr_debug(\"-> existing mapping on virq %d\\n\", virq);\n\t\treturn virq;\n\t}\n\n\t/* Allocate a virtual interrupt number */\n\tvirq = irq_domain_alloc_descs(-1, 1, hwirq, of_node_to_nid(of_node),\n\t\t\t\t      affinity);\n\tif (virq <= 0) {\n\t\tpr_debug(\"-> virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_associate(domain, virq, hwirq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"irq %lu on domain %s mapped to virtual irq %u\\n\",\n\t\thwirq, of_node_full_name(of_node), virq);\n\n\treturn virq;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"irq %lu on domain %s mapped to virtual irq %u\\n\"",
            "hwirq",
            "of_node_full_name(of_node)",
            "virq"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "of_node"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_free_desc",
          "args": [
            "virq"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_associate",
          "args": [
            "domain",
            "virq",
            "hwirq"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_associate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "562-609",
          "snippet": "int irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"-> virq allocation failed\\n\""
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_descs",
          "args": [
            "-1",
            "1",
            "hwirq",
            "of_node_to_nid(of_node)",
            "affinity"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_descs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1042-1063",
          "snippet": "int irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct irq_affinity_desc *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct irq_affinity_desc *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "of_node"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"-> existing mapping on virq %d\\n\"",
            "virq"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_find_mapping",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_of_node",
          "args": [
            "domain"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"-> using domain @%p\\n\"",
            "domain"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s(, %lx) called with NULL domain\\n\"",
            "__func__",
            "hwirq"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"irq_create_mapping(0x%p, 0x%lx)\\n\"",
            "domain",
            "hwirq"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_create_mapping_affinity(struct irq_domain *domain,\n\t\t\t\t       irq_hw_number_t hwirq,\n\t\t\t\t       const struct irq_affinity_desc *affinity)\n{\n\tstruct device_node *of_node;\n\tint virq;\n\n\tpr_debug(\"irq_create_mapping(0x%p, 0x%lx)\\n\", domain, hwirq);\n\n\t/* Look for default domain if necessary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL) {\n\t\tWARN(1, \"%s(, %lx) called with NULL domain\\n\", __func__, hwirq);\n\t\treturn 0;\n\t}\n\tpr_debug(\"-> using domain @%p\\n\", domain);\n\n\tof_node = irq_domain_get_of_node(domain);\n\n\t/* Check if mapping already exists */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\tpr_debug(\"-> existing mapping on virq %d\\n\", virq);\n\t\treturn virq;\n\t}\n\n\t/* Allocate a virtual interrupt number */\n\tvirq = irq_domain_alloc_descs(-1, 1, hwirq, of_node_to_nid(of_node),\n\t\t\t\t      affinity);\n\tif (virq <= 0) {\n\t\tpr_debug(\"-> virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_associate(domain, virq, hwirq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"irq %lu on domain %s mapped to virtual irq %u\\n\",\n\t\thwirq, of_node_full_name(of_node), virq);\n\n\treturn virq;\n}"
  },
  {
    "function_name": "irq_create_direct_mapping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "639-667",
    "snippet": "unsigned int irq_create_direct_mapping(struct irq_domain *domain)\n{\n\tstruct device_node *of_node;\n\tunsigned int virq;\n\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tvirq = irq_alloc_desc_from(1, of_node_to_nid(of_node));\n\tif (!virq) {\n\t\tpr_debug(\"create_direct virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\tif (virq >= domain->revmap_size) {\n\t\tpr_err(\"ERROR: no free irqs available below %i maximum\\n\",\n\t\t\tdomain->revmap_size);\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\tpr_debug(\"create_direct obtained virq %d\\n\", virq);\n\n\tif (irq_domain_associate(domain, virq, virq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\treturn virq;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_free_desc",
          "args": [
            "virq"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_associate",
          "args": [
            "domain",
            "virq",
            "virq"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_associate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "562-609",
          "snippet": "int irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"create_direct obtained virq %d\\n\"",
            "virq"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_free_desc",
          "args": [
            "virq"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ERROR: no free irqs available below %i maximum\\n\"",
            "domain->revmap_size"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"create_direct virq allocation failed\\n\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_alloc_desc_from",
          "args": [
            "1",
            "of_node_to_nid(of_node)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "of_node"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_of_node",
          "args": [
            "domain"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_create_direct_mapping(struct irq_domain *domain)\n{\n\tstruct device_node *of_node;\n\tunsigned int virq;\n\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tvirq = irq_alloc_desc_from(1, of_node_to_nid(of_node));\n\tif (!virq) {\n\t\tpr_debug(\"create_direct virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\tif (virq >= domain->revmap_size) {\n\t\tpr_err(\"ERROR: no free irqs available below %i maximum\\n\",\n\t\t\tdomain->revmap_size);\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\tpr_debug(\"create_direct obtained virq %d\\n\", virq);\n\n\tif (irq_domain_associate(domain, virq, virq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\treturn virq;\n}"
  },
  {
    "function_name": "irq_domain_associate_many",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "612-625",
    "snippet": "void irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_associate",
          "args": [
            "domain",
            "irq_base + i",
            "hwirq_base + i"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_associate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "562-609",
          "snippet": "int irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\"",
            "__func__",
            "of_node_full_name(of_node)",
            "irq_base",
            "(int)hwirq_base",
            "count"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "of_node"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_of_node",
          "args": [
            "domain"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}"
  },
  {
    "function_name": "irq_domain_associate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "562-609",
    "snippet": "int irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_clear_status_flags",
          "args": [
            "virq",
            "IRQ_NOREQUEST"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_set_mapping",
          "args": [
            "domain",
            "hwirq",
            "irq_data"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_set_mapping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "516-529",
          "snippet": "static void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], irq_data);\n\telse\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\tmutex_unlock(&domain->revmap_mutex);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], irq_data);\n\telse\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\tmutex_unlock(&domain->revmap_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\"",
            "domain->name",
            "hwirq",
            "virq",
            "ret"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain->ops->map",
          "args": [
            "domain",
            "virq",
            "hwirq"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "irq_data->domain",
            "\"error: virq%i is already associated\"",
            "virq"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!irq_data",
            "\"error: virq%i is not allocated\"",
            "virq"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "hwirq >= domain->hwirq_max",
            "\"error: hwirq 0x%x is too large for %s\\n\"",
            "(int)hwirq",
            "domain->name"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_disassociate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "531-560",
    "snippet": "static void irq_domain_disassociate(struct irq_domain *domain, unsigned int irq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(irq);\n\tirq_hw_number_t hwirq;\n\n\tif (WARN(!irq_data || irq_data->domain != domain,\n\t\t \"virq%i doesn't exist; cannot disassociate\\n\", irq))\n\t\treturn;\n\n\thwirq = irq_data->hwirq;\n\tirq_set_status_flags(irq, IRQ_NOREQUEST);\n\n\t/* remove chip and handler */\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\n\t/* Make sure it's completed */\n\tsynchronize_irq(irq);\n\n\t/* Tell the PIC about it */\n\tif (domain->ops->unmap)\n\t\tdomain->ops->unmap(domain, irq);\n\tsmp_mb();\n\n\tirq_data->domain = NULL;\n\tirq_data->hwirq = 0;\n\tdomain->mapcount--;\n\n\t/* Clear reverse map for this hwirq */\n\tirq_domain_clear_mapping(domain, hwirq);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_clear_mapping",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_clear_mapping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "502-514",
          "snippet": "static void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], NULL);\n\telse\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\tmutex_unlock(&domain->revmap_mutex);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], NULL);\n\telse\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\tmutex_unlock(&domain->revmap_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain->ops->unmap",
          "args": [
            "domain",
            "irq"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_irq",
          "args": [
            "irq"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "126-140",
          "snippet": "void synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, true);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, true);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_chip_and_handler",
          "args": [
            "irq",
            "NULL",
            "NULL"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_status_flags",
          "args": [
            "irq",
            "IRQ_NOREQUEST"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!irq_data || irq_data->domain != domain",
            "\"virq%i doesn't exist; cannot disassociate\\n\"",
            "irq"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "irq"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_disassociate(struct irq_domain *domain, unsigned int irq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(irq);\n\tirq_hw_number_t hwirq;\n\n\tif (WARN(!irq_data || irq_data->domain != domain,\n\t\t \"virq%i doesn't exist; cannot disassociate\\n\", irq))\n\t\treturn;\n\n\thwirq = irq_data->hwirq;\n\tirq_set_status_flags(irq, IRQ_NOREQUEST);\n\n\t/* remove chip and handler */\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\n\t/* Make sure it's completed */\n\tsynchronize_irq(irq);\n\n\t/* Tell the PIC about it */\n\tif (domain->ops->unmap)\n\t\tdomain->ops->unmap(domain, irq);\n\tsmp_mb();\n\n\tirq_data->domain = NULL;\n\tirq_data->hwirq = 0;\n\tdomain->mapcount--;\n\n\t/* Clear reverse map for this hwirq */\n\tirq_domain_clear_mapping(domain, hwirq);\n}"
  },
  {
    "function_name": "irq_domain_set_mapping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "516-529",
    "snippet": "static void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], irq_data);\n\telse\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\tmutex_unlock(&domain->revmap_mutex);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&domain->revmap_mutex"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&domain->revmap_tree",
            "hwirq",
            "irq_data"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "domain->revmap[hwirq]",
            "irq_data"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&domain->revmap_mutex"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_nomap",
          "args": [
            "domain"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_is_nomap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "496-500",
          "snippet": "static bool irq_domain_is_nomap(struct irq_domain *domain)\n{\n\treturn IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&\n\t       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic bool irq_domain_is_nomap(struct irq_domain *domain)\n{\n\treturn IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&\n\t       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], irq_data);\n\telse\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\tmutex_unlock(&domain->revmap_mutex);\n}"
  },
  {
    "function_name": "irq_domain_clear_mapping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "502-514",
    "snippet": "static void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], NULL);\n\telse\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\tmutex_unlock(&domain->revmap_mutex);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&domain->revmap_mutex"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&domain->revmap_tree",
            "hwirq"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "domain->revmap[hwirq]",
            "NULL"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&domain->revmap_mutex"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_nomap",
          "args": [
            "domain"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_is_nomap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "496-500",
          "snippet": "static bool irq_domain_is_nomap(struct irq_domain *domain)\n{\n\treturn IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&\n\t       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic bool irq_domain_is_nomap(struct irq_domain *domain)\n{\n\treturn IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&\n\t       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tmutex_lock(&domain->revmap_mutex);\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], NULL);\n\telse\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\tmutex_unlock(&domain->revmap_mutex);\n}"
  },
  {
    "function_name": "irq_domain_is_nomap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "496-500",
    "snippet": "static bool irq_domain_is_nomap(struct irq_domain *domain)\n{\n\treturn IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&\n\t       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IRQ_DOMAIN_NOMAP"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic bool irq_domain_is_nomap(struct irq_domain *domain)\n{\n\treturn IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&\n\t       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);\n}"
  },
  {
    "function_name": "irq_get_default_host",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "490-493",
    "snippet": "struct irq_domain *irq_get_default_host(void)\n{\n\treturn irq_default_domain;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\n\nstruct irq_domain *irq_get_default_host(void)\n{\n\treturn irq_default_domain;\n}"
  },
  {
    "function_name": "irq_set_default_host",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "473-478",
    "snippet": "void irq_set_default_host(struct irq_domain *domain)\n{\n\tpr_debug(\"Default domain set to @0x%p\\n\", domain);\n\n\tirq_default_domain = domain;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Default domain set to @0x%p\\n\"",
            "domain"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_set_default_host(struct irq_domain *domain)\n{\n\tpr_debug(\"Default domain set to @0x%p\\n\", domain);\n\n\tirq_default_domain = domain;\n}"
  },
  {
    "function_name": "irq_domain_check_msi_remap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "446-461",
    "snippet": "bool irq_domain_check_msi_remap(void)\n{\n\tstruct irq_domain *h;\n\tbool ret = true;\n\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (irq_domain_is_msi(h) &&\n\t\t    !irq_domain_hierarchical_is_msi_remap(h)) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(irq_domain_list);",
      "static DEFINE_MUTEX(irq_domain_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_hierarchical_is_msi_remap",
          "args": [
            "h"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_hierarchical_is_msi_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1821-1828",
          "snippet": "bool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)\n{\n\tfor (; domain; domain = domain->parent) {\n\t\tif (irq_domain_is_msi_remap(domain))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nbool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)\n{\n\tfor (; domain; domain = domain->parent) {\n\t\tif (irq_domain_is_msi_remap(domain))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_msi",
          "args": [
            "h"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "h",
            "&irq_domain_list",
            "link"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\n\nbool irq_domain_check_msi_remap(void)\n{\n\tstruct irq_domain *h;\n\tbool ret = true;\n\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (irq_domain_is_msi(h) &&\n\t\t    !irq_domain_hierarchical_is_msi_remap(h)) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_find_matching_fwspec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "402-436",
    "snippet": "struct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,\n\t\t\t\t\t    enum irq_domain_bus_token bus_token)\n{\n\tstruct irq_domain *h, *found = NULL;\n\tstruct fwnode_handle *fwnode = fwspec->fwnode;\n\tint rc;\n\n\t/* We might want to match the legacy controller last since\n\t * it might potentially be set to match all interrupts in\n\t * the absence of a device node. This isn't a problem so far\n\t * yet though...\n\t *\n\t * bus_token == DOMAIN_BUS_ANY matches any domain, any other\n\t * values must generate an exact match for the domain to be\n\t * selected.\n\t */\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (h->ops->select && fwspec->param_count)\n\t\t\trc = h->ops->select(h, fwspec, bus_token);\n\t\telse if (h->ops->match)\n\t\t\trc = h->ops->match(h, to_of_node(fwnode), bus_token);\n\t\telse\n\t\t\trc = ((fwnode != NULL) && (h->fwnode == fwnode) &&\n\t\t\t      ((bus_token == DOMAIN_BUS_ANY) ||\n\t\t\t       (h->bus_token == bus_token)));\n\n\t\tif (rc) {\n\t\t\tfound = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn found;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(irq_domain_list);",
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "h->ops->match",
          "args": [
            "h",
            "to_of_node(fwnode)",
            "bus_token"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_of_node",
          "args": [
            "fwnode"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->ops->select",
          "args": [
            "h",
            "fwspec",
            "bus_token"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "h",
            "&irq_domain_list",
            "link"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,\n\t\t\t\t\t    enum irq_domain_bus_token bus_token)\n{\n\tstruct irq_domain *h, *found = NULL;\n\tstruct fwnode_handle *fwnode = fwspec->fwnode;\n\tint rc;\n\n\t/* We might want to match the legacy controller last since\n\t * it might potentially be set to match all interrupts in\n\t * the absence of a device node. This isn't a problem so far\n\t * yet though...\n\t *\n\t * bus_token == DOMAIN_BUS_ANY matches any domain, any other\n\t * values must generate an exact match for the domain to be\n\t * selected.\n\t */\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (h->ops->select && fwspec->param_count)\n\t\t\trc = h->ops->select(h, fwspec, bus_token);\n\t\telse if (h->ops->match)\n\t\t\trc = h->ops->match(h, to_of_node(fwnode), bus_token);\n\t\telse\n\t\t\trc = ((fwnode != NULL) && (h->fwnode == fwnode) &&\n\t\t\t      ((bus_token == DOMAIN_BUS_ANY) ||\n\t\t\t       (h->bus_token == bus_token)));\n\n\t\tif (rc) {\n\t\t\tfound = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn found;\n}"
  },
  {
    "function_name": "irq_domain_create_legacy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "380-394",
    "snippet": "struct irq_domain *irq_domain_create_legacy(struct fwnode_handle *fwnode,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(fwnode, first_hwirq + size, first_hwirq + size, 0, ops, host_data);\n\tif (domain)\n\t\tirq_domain_associate_many(domain, first_irq, first_hwirq, size);\n\n\treturn domain;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_associate_many",
          "args": [
            "domain",
            "first_irq",
            "first_hwirq",
            "size"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_associate_many",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "612-625",
          "snippet": "void irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_domain_add",
          "args": [
            "fwnode",
            "first_hwirq + size",
            "first_hwirq + size",
            "0",
            "ops",
            "host_data"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "139-237",
          "snippet": "struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, unsigned int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tif (WARN_ON((size && direct_max) ||\n\t\t    (!IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) && direct_max)))\n\t\treturn NULL;\n\n\tdomain = kzalloc_node(struct_size(domain, revmap, size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(to_of_node(fwnode)));\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n\t} else if (is_of_node(fwnode) || is_acpi_device_node(fwnode) ||\n\t\t   is_software_node(fwnode)) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * fwnode paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pfw\", fwnode);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tfwnode_handle_get(fwnode);\n\tfwnode_dev_initialized(fwnode, true);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\n\tif (direct_max) {\n\t\tsize = direct_max;\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_NO_MAP;\n\t}\n\n\tdomain->revmap_size = size;\n\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(irq_domain_list);",
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, unsigned int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tif (WARN_ON((size && direct_max) ||\n\t\t    (!IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) && direct_max)))\n\t\treturn NULL;\n\n\tdomain = kzalloc_node(struct_size(domain, revmap, size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(to_of_node(fwnode)));\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n\t} else if (is_of_node(fwnode) || is_acpi_device_node(fwnode) ||\n\t\t   is_software_node(fwnode)) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * fwnode paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pfw\", fwnode);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tfwnode_handle_get(fwnode);\n\tfwnode_dev_initialized(fwnode, true);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\n\tif (direct_max) {\n\t\tsize = direct_max;\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_NO_MAP;\n\t}\n\n\tdomain->revmap_size = size;\n\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_domain_create_legacy(struct fwnode_handle *fwnode,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(fwnode, first_hwirq + size, first_hwirq + size, 0, ops, host_data);\n\tif (domain)\n\t\tirq_domain_associate_many(domain, first_irq, first_hwirq, size);\n\n\treturn domain;\n}"
  },
  {
    "function_name": "irq_domain_add_legacy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "368-377",
    "snippet": "struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\treturn irq_domain_create_legacy(of_node_to_fwnode(of_node), size,\n\t\t\t\t\tfirst_irq, first_hwirq, ops, host_data);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_create_legacy",
          "args": [
            "of_node_to_fwnode(of_node)",
            "size",
            "first_irq",
            "first_hwirq",
            "ops",
            "host_data"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_create_legacy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "380-394",
          "snippet": "struct irq_domain *irq_domain_create_legacy(struct fwnode_handle *fwnode,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(fwnode, first_hwirq + size, first_hwirq + size, 0, ops, host_data);\n\tif (domain)\n\t\tirq_domain_associate_many(domain, first_irq, first_hwirq, size);\n\n\treturn domain;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_domain_create_legacy(struct fwnode_handle *fwnode,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(fwnode, first_hwirq + size, first_hwirq + size, 0, ops, host_data);\n\tif (domain)\n\t\tirq_domain_associate_many(domain, first_irq, first_hwirq, size);\n\n\treturn domain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_to_fwnode",
          "args": [
            "of_node"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstruct irq_domain *irq_domain_add_legacy(struct device_node *of_node,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\treturn irq_domain_create_legacy(of_node_to_fwnode(of_node), size,\n\t\t\t\t\tfirst_irq, first_hwirq, ops, host_data);\n}"
  },
  {
    "function_name": "irq_domain_create_simple",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "325-350",
    "snippet": "struct irq_domain *irq_domain_create_simple(struct fwnode_handle *fwnode,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    unsigned int first_irq,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(fwnode, size, size, 0, ops, host_data);\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (first_irq > 0) {\n\t\tif (IS_ENABLED(CONFIG_SPARSE_IRQ)) {\n\t\t\t/* attempt to allocated irq_descs */\n\t\t\tint rc = irq_alloc_descs(first_irq, first_irq, size,\n\t\t\t\t\t\t of_node_to_nid(to_of_node(fwnode)));\n\t\t\tif (rc < 0)\n\t\t\t\tpr_info(\"Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\\n\",\n\t\t\t\t\tfirst_irq);\n\t\t}\n\t\tirq_domain_associate_many(domain, first_irq, 0, size);\n\t}\n\n\treturn domain;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_associate_many",
          "args": [
            "domain",
            "first_irq",
            "0",
            "size"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_associate_many",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "612-625",
          "snippet": "void irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\\n\"",
            "first_irq"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_alloc_descs",
          "args": [
            "first_irq",
            "first_irq",
            "size",
            "of_node_to_nid(to_of_node(fwnode))"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "to_of_node(fwnode)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_of_node",
          "args": [
            "fwnode"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SPARSE_IRQ"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_domain_add",
          "args": [
            "fwnode",
            "size",
            "size",
            "0",
            "ops",
            "host_data"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "139-237",
          "snippet": "struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, unsigned int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tif (WARN_ON((size && direct_max) ||\n\t\t    (!IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) && direct_max)))\n\t\treturn NULL;\n\n\tdomain = kzalloc_node(struct_size(domain, revmap, size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(to_of_node(fwnode)));\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n\t} else if (is_of_node(fwnode) || is_acpi_device_node(fwnode) ||\n\t\t   is_software_node(fwnode)) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * fwnode paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pfw\", fwnode);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tfwnode_handle_get(fwnode);\n\tfwnode_dev_initialized(fwnode, true);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\n\tif (direct_max) {\n\t\tsize = direct_max;\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_NO_MAP;\n\t}\n\n\tdomain->revmap_size = size;\n\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(irq_domain_list);",
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, unsigned int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tif (WARN_ON((size && direct_max) ||\n\t\t    (!IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) && direct_max)))\n\t\treturn NULL;\n\n\tdomain = kzalloc_node(struct_size(domain, revmap, size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(to_of_node(fwnode)));\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n\t} else if (is_of_node(fwnode) || is_acpi_device_node(fwnode) ||\n\t\t   is_software_node(fwnode)) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * fwnode paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pfw\", fwnode);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tfwnode_handle_get(fwnode);\n\tfwnode_dev_initialized(fwnode, true);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\n\tif (direct_max) {\n\t\tsize = direct_max;\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_NO_MAP;\n\t}\n\n\tdomain->revmap_size = size;\n\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_domain_create_simple(struct fwnode_handle *fwnode,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    unsigned int first_irq,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(fwnode, size, size, 0, ops, host_data);\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (first_irq > 0) {\n\t\tif (IS_ENABLED(CONFIG_SPARSE_IRQ)) {\n\t\t\t/* attempt to allocated irq_descs */\n\t\t\tint rc = irq_alloc_descs(first_irq, first_irq, size,\n\t\t\t\t\t\t of_node_to_nid(to_of_node(fwnode)));\n\t\t\tif (rc < 0)\n\t\t\t\tpr_info(\"Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\\n\",\n\t\t\t\t\tfirst_irq);\n\t\t}\n\t\tirq_domain_associate_many(domain, first_irq, 0, size);\n\t}\n\n\treturn domain;\n}"
  },
  {
    "function_name": "irq_domain_update_bus_token",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "275-304",
    "snippet": "void irq_domain_update_bus_token(struct irq_domain *domain,\n\t\t\t\t enum irq_domain_bus_token bus_token)\n{\n\tchar *name;\n\n\tif (domain->bus_token == bus_token)\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\tdomain->bus_token = bus_token;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%d\", domain->name, bus_token);\n\tif (!name) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\treturn;\n\t}\n\n\tdebugfs_remove_domain_dir(domain);\n\n\tif (domain->flags & IRQ_DOMAIN_NAME_ALLOCATED)\n\t\tkfree(domain->name);\n\telse\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\n\tdomain->name = name;\n\tdebugfs_add_domain_dir(domain);\n\n\tmutex_unlock(&irq_domain_mutex);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_add_domain_dir",
          "args": [
            "domain"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_add_domain_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1905-1911",
          "snippet": "static void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir)\n\t\treturn;\n\tdebugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t    &irq_domain_debug_fops);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir)\n\t\treturn;\n\tdebugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t    &irq_domain_debug_fops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "domain->name"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove_domain_dir",
          "args": [
            "domain"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_remove_domain_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1913-1916",
          "snippet": "static void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(debugfs_lookup(d->name, domain_dir));\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(debugfs_lookup(d->name, domain_dir));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s-%d\"",
            "domain->name",
            "bus_token"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_update_bus_token(struct irq_domain *domain,\n\t\t\t\t enum irq_domain_bus_token bus_token)\n{\n\tchar *name;\n\n\tif (domain->bus_token == bus_token)\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\tdomain->bus_token = bus_token;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%d\", domain->name, bus_token);\n\tif (!name) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\treturn;\n\t}\n\n\tdebugfs_remove_domain_dir(domain);\n\n\tif (domain->flags & IRQ_DOMAIN_NAME_ALLOCATED)\n\t\tkfree(domain->name);\n\telse\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\n\tdomain->name = name;\n\tdebugfs_add_domain_dir(domain);\n\n\tmutex_unlock(&irq_domain_mutex);\n}"
  },
  {
    "function_name": "irq_domain_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "248-272",
    "snippet": "void irq_domain_remove(struct irq_domain *domain)\n{\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_remove_domain_dir(domain);\n\n\tWARN_ON(!radix_tree_empty(&domain->revmap_tree));\n\n\tlist_del(&domain->link);\n\n\t/*\n\t * If the going away domain is the default one, reset it.\n\t */\n\tif (unlikely(irq_default_domain == domain))\n\t\tirq_set_default_host(NULL);\n\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Removed domain %s\\n\", domain->name);\n\n\tfwnode_dev_initialized(domain->fwnode, false);\n\tfwnode_handle_put(domain->fwnode);\n\tif (domain->flags & IRQ_DOMAIN_NAME_ALLOCATED)\n\t\tkfree(domain->name);\n\tkfree(domain);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "domain"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwnode_handle_put",
          "args": [
            "domain->fwnode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwnode_dev_initialized",
          "args": [
            "domain->fwnode",
            "false"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Removed domain %s\\n\"",
            "domain->name"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_default_host",
          "args": [
            "NULL"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_default_host",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "473-478",
          "snippet": "void irq_set_default_host(struct irq_domain *domain)\n{\n\tpr_debug(\"Default domain set to @0x%p\\n\", domain);\n\n\tirq_default_domain = domain;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct irq_domain *irq_default_domain;",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_set_default_host(struct irq_domain *domain)\n{\n\tpr_debug(\"Default domain set to @0x%p\\n\", domain);\n\n\tirq_default_domain = domain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "irq_default_domain == domain"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&domain->link"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!radix_tree_empty(&domain->revmap_tree)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_empty",
          "args": [
            "&domain->revmap_tree"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_remove_domain_dir",
          "args": [
            "domain"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_remove_domain_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1913-1916",
          "snippet": "static void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(debugfs_lookup(d->name, domain_dir));\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(debugfs_lookup(d->name, domain_dir));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_remove(struct irq_domain *domain)\n{\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_remove_domain_dir(domain);\n\n\tWARN_ON(!radix_tree_empty(&domain->revmap_tree));\n\n\tlist_del(&domain->link);\n\n\t/*\n\t * If the going away domain is the default one, reset it.\n\t */\n\tif (unlikely(irq_default_domain == domain))\n\t\tirq_set_default_host(NULL);\n\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Removed domain %s\\n\", domain->name);\n\n\tfwnode_dev_initialized(domain->fwnode, false);\n\tfwnode_handle_put(domain->fwnode);\n\tif (domain->flags & IRQ_DOMAIN_NAME_ALLOCATED)\n\t\tkfree(domain->name);\n\tkfree(domain);\n}"
  },
  {
    "function_name": "__irq_domain_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "139-237",
    "snippet": "struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, unsigned int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tif (WARN_ON((size && direct_max) ||\n\t\t    (!IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) && direct_max)))\n\t\treturn NULL;\n\n\tdomain = kzalloc_node(struct_size(domain, revmap, size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(to_of_node(fwnode)));\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n\t} else if (is_of_node(fwnode) || is_acpi_device_node(fwnode) ||\n\t\t   is_software_node(fwnode)) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * fwnode paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pfw\", fwnode);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tfwnode_handle_get(fwnode);\n\tfwnode_dev_initialized(fwnode, true);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\n\tif (direct_max) {\n\t\tsize = direct_max;\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_NO_MAP;\n\t}\n\n\tdomain->revmap_size = size;\n\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(irq_domain_list);",
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Added domain %s\\n\"",
            "domain->name"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&domain->link",
            "&irq_domain_list"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_add_domain_dir",
          "args": [
            "domain"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_add_domain_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1905-1911",
          "snippet": "static void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir)\n\t\treturn;\n\tdebugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t    &irq_domain_debug_fops);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir)\n\t\treturn;\n\tdebugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t    &irq_domain_debug_fops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_check_hierarchy",
          "args": [
            "domain"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_check_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1865-1867",
          "snippet": "static void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&domain->revmap_mutex"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&domain->revmap_tree",
            "GFP_KERNEL"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwnode_dev_initialized",
          "args": [
            "fwnode",
            "true"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwnode_handle_get",
          "args": [
            "fwnode"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "domain"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"unknown-%d\"",
            "atomic_inc_return(&unknown_domains)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&unknown_domains"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid fwnode type for irqdomain\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strreplace",
          "args": [
            "name",
            "'/'",
            "':'"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%pfw\"",
            "fwnode"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_software_node",
          "args": [
            "fwnode"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_acpi_device_node",
          "args": [
            "fwnode"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_of_node",
          "args": [
            "fwnode"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "fwid->name",
            "GFP_KERNEL"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fwnode",
            "structirqchip_fwid",
            "fwnode"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_fwnode_irqchip",
          "args": [
            "fwnode"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "struct_size(domain, revmap, size)",
            "GFP_KERNEL",
            "of_node_to_nid(to_of_node(fwnode))"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "to_of_node(fwnode)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_of_node",
          "args": [
            "fwnode"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "domain",
            "revmap",
            "size"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(size && direct_max) ||\n\t\t    (!IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) && direct_max)"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IRQ_DOMAIN_NOMAP"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, unsigned int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tif (WARN_ON((size && direct_max) ||\n\t\t    (!IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) && direct_max)))\n\t\treturn NULL;\n\n\tdomain = kzalloc_node(struct_size(domain, revmap, size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(to_of_node(fwnode)));\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n\t} else if (is_of_node(fwnode) || is_acpi_device_node(fwnode) ||\n\t\t   is_software_node(fwnode)) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * fwnode paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pfw\", fwnode);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tfwnode_handle_get(fwnode);\n\tfwnode_dev_initialized(fwnode, true);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\n\tif (direct_max) {\n\t\tsize = direct_max;\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_NO_MAP;\n\t}\n\n\tdomain->revmap_size = size;\n\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}"
  },
  {
    "function_name": "irq_domain_free_fwnode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "113-123",
    "snippet": "void irq_domain_free_fwnode(struct fwnode_handle *fwnode)\n{\n\tstruct irqchip_fwid *fwid;\n\n\tif (WARN_ON(!is_fwnode_irqchip(fwnode)))\n\t\treturn;\n\n\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\tkfree(fwid->name);\n\tkfree(fwid);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fwid"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fwnode",
            "structirqchip_fwid",
            "fwnode"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!is_fwnode_irqchip(fwnode)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_fwnode_irqchip",
          "args": [
            "fwnode"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid irq_domain_free_fwnode(struct fwnode_handle *fwnode)\n{\n\tstruct irqchip_fwid *fwid;\n\n\tif (WARN_ON(!is_fwnode_irqchip(fwnode)))\n\t\treturn;\n\n\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\tkfree(fwid->name);\n\tkfree(fwid);\n}"
  },
  {
    "function_name": "__irq_domain_alloc_fwnode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "73-105",
    "snippet": "struct fwnode_handle *__irq_domain_alloc_fwnode(unsigned int type, int id,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tphys_addr_t *pa)\n{\n\tstruct irqchip_fwid *fwid;\n\tchar *n;\n\n\tfwid = kzalloc(sizeof(*fwid), GFP_KERNEL);\n\n\tswitch (type) {\n\tcase IRQCHIP_FWNODE_NAMED:\n\t\tn = kasprintf(GFP_KERNEL, \"%s\", name);\n\t\tbreak;\n\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\tn = kasprintf(GFP_KERNEL, \"%s-%d\", name, id);\n\t\tbreak;\n\tdefault:\n\t\tn = kasprintf(GFP_KERNEL, \"irqchip@%pa\", pa);\n\t\tbreak;\n\t}\n\n\tif (!fwid || !n) {\n\t\tkfree(fwid);\n\t\tkfree(n);\n\t\treturn NULL;\n\t}\n\n\tfwid->type = type;\n\tfwid->name = n;\n\tfwid->pa = pa;\n\tfwnode_init(&fwid->fwnode, &irqchip_fwnode_ops);\n\treturn &fwid->fwnode;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct fwnode_operations irqchip_fwnode_ops = {\n\t.get_name = irqchip_fwnode_get_name,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fwnode_init",
          "args": [
            "&fwid->fwnode",
            "&irqchip_fwnode_ops"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "n"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"irqchip@%pa\"",
            "pa"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s-%d\"",
            "name",
            "id"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s\"",
            "name"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*fwid)",
            "GFP_KERNEL"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nconst struct fwnode_operations irqchip_fwnode_ops = {\n\t.get_name = irqchip_fwnode_get_name,\n};\n\nstruct fwnode_handle *__irq_domain_alloc_fwnode(unsigned int type, int id,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tphys_addr_t *pa)\n{\n\tstruct irqchip_fwid *fwid;\n\tchar *n;\n\n\tfwid = kzalloc(sizeof(*fwid), GFP_KERNEL);\n\n\tswitch (type) {\n\tcase IRQCHIP_FWNODE_NAMED:\n\t\tn = kasprintf(GFP_KERNEL, \"%s\", name);\n\t\tbreak;\n\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\tn = kasprintf(GFP_KERNEL, \"%s-%d\", name, id);\n\t\tbreak;\n\tdefault:\n\t\tn = kasprintf(GFP_KERNEL, \"irqchip@%pa\", pa);\n\t\tbreak;\n\t}\n\n\tif (!fwid || !n) {\n\t\tkfree(fwid);\n\t\tkfree(n);\n\t\treturn NULL;\n\t}\n\n\tfwid->type = type;\n\tfwid->name = n;\n\tfwid->pa = pa;\n\tfwnode_init(&fwid->fwnode, &irqchip_fwnode_ops);\n\treturn &fwid->fwnode;\n}"
  },
  {
    "function_name": "irqchip_fwnode_get_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "45-50",
    "snippet": "static const char *irqchip_fwnode_get_name(const struct fwnode_handle *fwnode)\n{\n\tstruct irqchip_fwid *fwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\treturn fwid->name;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fwnode",
            "structirqchip_fwid",
            "fwnode"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic const char *irqchip_fwnode_get_name(const struct fwnode_handle *fwnode)\n{\n\tstruct irqchip_fwid *fwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\treturn fwid->name;\n}"
  },
  {
    "function_name": "debugfs_remove_domain_dir",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "42-42",
    "snippet": "static inline void debugfs_remove_domain_dir(struct irq_domain *d) { }",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic inline void debugfs_remove_domain_dir(struct irq_domain *d) { }"
  },
  {
    "function_name": "debugfs_add_domain_dir",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
    "lines": "41-41",
    "snippet": "static inline void debugfs_add_domain_dir(struct irq_domain *d) { }",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic inline void debugfs_add_domain_dir(struct irq_domain *d) { }"
  }
]