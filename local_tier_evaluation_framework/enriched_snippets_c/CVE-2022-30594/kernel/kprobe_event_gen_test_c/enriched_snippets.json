[
  {
    "function_name": "kprobe_event_gen_test_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/kprobe_event_gen_test.c",
    "lines": "195-218",
    "snippet": "static void __exit kprobe_event_gen_test_exit(void)\n{\n\t/* Disable the event or you can't remove it */\n\tWARN_ON(trace_array_set_clr_event(gen_kprobe_test->tr,\n\t\t\t\t\t  \"kprobes\",\n\t\t\t\t\t  \"gen_kprobe_test\", false));\n\n\t/* Now give the file and instance back */\n\ttrace_put_event_file(gen_kprobe_test);\n\n\t/* Now unregister and free the event */\n\tWARN_ON(kprobe_event_delete(\"gen_kprobe_test\"));\n\n\t/* Disable the event or you can't remove it */\n\tWARN_ON(trace_array_set_clr_event(gen_kprobe_test->tr,\n\t\t\t\t\t  \"kprobes\",\n\t\t\t\t\t  \"gen_kretprobe_test\", false));\n\n\t/* Now give the file and instance back */\n\ttrace_put_event_file(gen_kretprobe_test);\n\n\t/* Now unregister and free the event */\n\tWARN_ON(kprobe_event_delete(\"gen_kretprobe_test\"));\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *gen_kprobe_test;",
      "static struct trace_event_file *gen_kretprobe_test;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kprobe_event_delete(\"gen_kretprobe_test\")"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_event_delete",
          "args": [
            "\"gen_kretprobe_test\""
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_event_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1073-1080",
          "snippet": "int kprobe_event_delete(const char *name)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\n\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"-:%s\", name);\n\n\treturn create_or_delete_trace_kprobe(buf);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nint kprobe_event_delete(const char *name)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\n\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"-:%s\", name);\n\n\treturn create_or_delete_trace_kprobe(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_put_event_file",
          "args": [
            "gen_kretprobe_test"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "trace_put_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3031-3038",
          "snippet": "void trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trace_array_set_clr_event(gen_kprobe_test->tr,\n\t\t\t\t\t  \"kprobes\",\n\t\t\t\t\t  \"gen_kretprobe_test\", false)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_array_set_clr_event",
          "args": [
            "gen_kprobe_test->tr",
            "\"kprobes\"",
            "\"gen_kretprobe_test\"",
            "false"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1123-1133",
          "snippet": "int trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kprobe_event_delete(\"gen_kprobe_test\")"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trace_array_set_clr_event(gen_kprobe_test->tr,\n\t\t\t\t\t  \"kprobes\",\n\t\t\t\t\t  \"gen_kprobe_test\", false)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_kprobe_test;\nstatic struct trace_event_file *gen_kretprobe_test;\n\nstatic void __exit kprobe_event_gen_test_exit(void)\n{\n\t/* Disable the event or you can't remove it */\n\tWARN_ON(trace_array_set_clr_event(gen_kprobe_test->tr,\n\t\t\t\t\t  \"kprobes\",\n\t\t\t\t\t  \"gen_kprobe_test\", false));\n\n\t/* Now give the file and instance back */\n\ttrace_put_event_file(gen_kprobe_test);\n\n\t/* Now unregister and free the event */\n\tWARN_ON(kprobe_event_delete(\"gen_kprobe_test\"));\n\n\t/* Disable the event or you can't remove it */\n\tWARN_ON(trace_array_set_clr_event(gen_kprobe_test->tr,\n\t\t\t\t\t  \"kprobes\",\n\t\t\t\t\t  \"gen_kretprobe_test\", false));\n\n\t/* Now give the file and instance back */\n\ttrace_put_event_file(gen_kretprobe_test);\n\n\t/* Now unregister and free the event */\n\tWARN_ON(kprobe_event_delete(\"gen_kretprobe_test\"));\n}"
  },
  {
    "function_name": "kprobe_event_gen_test_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/kprobe_event_gen_test.c",
    "lines": "175-193",
    "snippet": "static int __init kprobe_event_gen_test_init(void)\n{\n\tint ret;\n\n\tret = test_gen_kprobe_cmd();\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_gen_kretprobe_cmd();\n\tif (ret) {\n\t\tWARN_ON(trace_array_set_clr_event(gen_kretprobe_test->tr,\n\t\t\t\t\t\t  \"kprobes\",\n\t\t\t\t\t\t  \"gen_kretprobe_test\", false));\n\t\ttrace_put_event_file(gen_kretprobe_test);\n\t\tWARN_ON(kprobe_event_delete(\"gen_kretprobe_test\"));\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *gen_kretprobe_test;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kprobe_event_delete(\"gen_kretprobe_test\")"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_event_delete",
          "args": [
            "\"gen_kretprobe_test\""
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_event_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1073-1080",
          "snippet": "int kprobe_event_delete(const char *name)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\n\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"-:%s\", name);\n\n\treturn create_or_delete_trace_kprobe(buf);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nint kprobe_event_delete(const char *name)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\n\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"-:%s\", name);\n\n\treturn create_or_delete_trace_kprobe(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_put_event_file",
          "args": [
            "gen_kretprobe_test"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "trace_put_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3031-3038",
          "snippet": "void trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trace_array_set_clr_event(gen_kretprobe_test->tr,\n\t\t\t\t\t\t  \"kprobes\",\n\t\t\t\t\t\t  \"gen_kretprobe_test\", false)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_array_set_clr_event",
          "args": [
            "gen_kretprobe_test->tr",
            "\"kprobes\"",
            "\"gen_kretprobe_test\"",
            "false"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1123-1133",
          "snippet": "int trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_gen_kretprobe_cmd",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "test_gen_kretprobe_cmd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/kprobe_event_gen_test.c",
          "lines": "113-173",
          "snippet": "static int __init test_gen_kretprobe_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tkprobe_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Define the kretprobe event.\n\t */\n\tret = kretprobe_event_gen_cmd_start(&cmd, \"gen_kretprobe_test\",\n\t\t\t\t\t    \"do_sys_open\",\n\t\t\t\t\t    \"$retval\");\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * This actually creates the event.\n\t */\n\tret = kretprobe_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_kretprobe_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tgen_kretprobe_test = trace_get_event_file(NULL, \"kprobes\",\n\t\t\t\t\t\t  \"gen_kretprobe_test\");\n\tif (IS_ERR(gen_kretprobe_test)) {\n\t\tret = PTR_ERR(gen_kretprobe_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_kretprobe_test->tr,\n\t\t\t\t\t\"kprobes\", \"gen_kretprobe_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_kretprobe_test);\n\t\tgoto delete;\n\t}\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tret = kprobe_event_delete(\"gen_kretprobe_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}",
          "includes": [
            "#include <linux/trace_events.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_event_file *gen_kretprobe_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_kretprobe_test;\n\nstatic int __init test_gen_kretprobe_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tkprobe_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Define the kretprobe event.\n\t */\n\tret = kretprobe_event_gen_cmd_start(&cmd, \"gen_kretprobe_test\",\n\t\t\t\t\t    \"do_sys_open\",\n\t\t\t\t\t    \"$retval\");\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * This actually creates the event.\n\t */\n\tret = kretprobe_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_kretprobe_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tgen_kretprobe_test = trace_get_event_file(NULL, \"kprobes\",\n\t\t\t\t\t\t  \"gen_kretprobe_test\");\n\tif (IS_ERR(gen_kretprobe_test)) {\n\t\tret = PTR_ERR(gen_kretprobe_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_kretprobe_test->tr,\n\t\t\t\t\t\"kprobes\", \"gen_kretprobe_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_kretprobe_test);\n\t\tgoto delete;\n\t}\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tret = kprobe_event_delete(\"gen_kretprobe_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_gen_kprobe_cmd",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "test_gen_kprobe_cmd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/kprobe_event_gen_test.c",
          "lines": "42-108",
          "snippet": "static int __init test_gen_kprobe_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tkprobe_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Define the gen_kprobe_test event with the first 2 kprobe\n\t * fields.\n\t */\n\tret = kprobe_event_gen_cmd_start(&cmd, \"gen_kprobe_test\",\n\t\t\t\t\t \"do_sys_open\",\n\t\t\t\t\t \"dfd=%ax\", \"filename=%dx\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use kprobe_event_add_fields to add the rest of the fields */\n\n\tret = kprobe_event_add_fields(&cmd, \"flags=%cx\", \"mode=+4($stack)\");\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * This actually creates the event.\n\t */\n\tret = kprobe_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_kprobe_test event file.  We need to prevent\n\t * the instance and event from disappearing from underneath\n\t * us, which trace_get_event_file() does (though in this case\n\t * we're using the top-level instance which never goes away).\n\t */\n\tgen_kprobe_test = trace_get_event_file(NULL, \"kprobes\",\n\t\t\t\t\t       \"gen_kprobe_test\");\n\tif (IS_ERR(gen_kprobe_test)) {\n\t\tret = PTR_ERR(gen_kprobe_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_kprobe_test->tr,\n\t\t\t\t\t\"kprobes\", \"gen_kprobe_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_kprobe_test);\n\t\tgoto delete;\n\t}\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tret = kprobe_event_delete(\"gen_kprobe_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}",
          "includes": [
            "#include <linux/trace_events.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_event_file *gen_kprobe_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_kprobe_test;\n\nstatic int __init test_gen_kprobe_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tkprobe_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Define the gen_kprobe_test event with the first 2 kprobe\n\t * fields.\n\t */\n\tret = kprobe_event_gen_cmd_start(&cmd, \"gen_kprobe_test\",\n\t\t\t\t\t \"do_sys_open\",\n\t\t\t\t\t \"dfd=%ax\", \"filename=%dx\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use kprobe_event_add_fields to add the rest of the fields */\n\n\tret = kprobe_event_add_fields(&cmd, \"flags=%cx\", \"mode=+4($stack)\");\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * This actually creates the event.\n\t */\n\tret = kprobe_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_kprobe_test event file.  We need to prevent\n\t * the instance and event from disappearing from underneath\n\t * us, which trace_get_event_file() does (though in this case\n\t * we're using the top-level instance which never goes away).\n\t */\n\tgen_kprobe_test = trace_get_event_file(NULL, \"kprobes\",\n\t\t\t\t\t       \"gen_kprobe_test\");\n\tif (IS_ERR(gen_kprobe_test)) {\n\t\tret = PTR_ERR(gen_kprobe_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_kprobe_test->tr,\n\t\t\t\t\t\"kprobes\", \"gen_kprobe_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_kprobe_test);\n\t\tgoto delete;\n\t}\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tret = kprobe_event_delete(\"gen_kprobe_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_kretprobe_test;\n\nstatic int __init kprobe_event_gen_test_init(void)\n{\n\tint ret;\n\n\tret = test_gen_kprobe_cmd();\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_gen_kretprobe_cmd();\n\tif (ret) {\n\t\tWARN_ON(trace_array_set_clr_event(gen_kretprobe_test->tr,\n\t\t\t\t\t\t  \"kprobes\",\n\t\t\t\t\t\t  \"gen_kretprobe_test\", false));\n\t\ttrace_put_event_file(gen_kretprobe_test);\n\t\tWARN_ON(kprobe_event_delete(\"gen_kretprobe_test\"));\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "test_gen_kretprobe_cmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/kprobe_event_gen_test.c",
    "lines": "113-173",
    "snippet": "static int __init test_gen_kretprobe_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tkprobe_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Define the kretprobe event.\n\t */\n\tret = kretprobe_event_gen_cmd_start(&cmd, \"gen_kretprobe_test\",\n\t\t\t\t\t    \"do_sys_open\",\n\t\t\t\t\t    \"$retval\");\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * This actually creates the event.\n\t */\n\tret = kretprobe_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_kretprobe_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tgen_kretprobe_test = trace_get_event_file(NULL, \"kprobes\",\n\t\t\t\t\t\t  \"gen_kretprobe_test\");\n\tif (IS_ERR(gen_kretprobe_test)) {\n\t\tret = PTR_ERR(gen_kretprobe_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_kretprobe_test->tr,\n\t\t\t\t\t\"kprobes\", \"gen_kretprobe_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_kretprobe_test);\n\t\tgoto delete;\n\t}\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tret = kprobe_event_delete(\"gen_kretprobe_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *gen_kretprobe_test;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_event_delete",
          "args": [
            "\"gen_kretprobe_test\""
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_event_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1073-1080",
          "snippet": "int kprobe_event_delete(const char *name)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\n\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"-:%s\", name);\n\n\treturn create_or_delete_trace_kprobe(buf);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nint kprobe_event_delete(const char *name)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\n\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"-:%s\", name);\n\n\treturn create_or_delete_trace_kprobe(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_put_event_file",
          "args": [
            "gen_kretprobe_test"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "trace_put_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3031-3038",
          "snippet": "void trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_set_clr_event",
          "args": [
            "gen_kretprobe_test->tr",
            "\"kprobes\"",
            "\"gen_kretprobe_test\"",
            "true"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1123-1133",
          "snippet": "int trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "gen_kretprobe_test"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "gen_kretprobe_test"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_event_file",
          "args": [
            "NULL",
            "\"kprobes\"",
            "\"gen_kretprobe_test\""
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2976-3019",
          "snippet": "struct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kretprobe_event_gen_cmd_end",
          "args": [
            "&cmd"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kretprobe_event_gen_cmd_start",
          "args": [
            "&cmd",
            "\"gen_kretprobe_test\"",
            "\"do_sys_open\"",
            "\"$retval\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_event_cmd_init",
          "args": [
            "&cmd",
            "buf",
            "MAX_DYNEVENT_CMD_LEN"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_event_cmd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "930-934",
          "snippet": "void kprobe_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_KPROBE,\n\t\t\t  trace_kprobe_run_command);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nvoid kprobe_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_KPROBE,\n\t\t\t  trace_kprobe_run_command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "MAX_DYNEVENT_CMD_LEN",
            "GFP_KERNEL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_kretprobe_test;\n\nstatic int __init test_gen_kretprobe_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tkprobe_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Define the kretprobe event.\n\t */\n\tret = kretprobe_event_gen_cmd_start(&cmd, \"gen_kretprobe_test\",\n\t\t\t\t\t    \"do_sys_open\",\n\t\t\t\t\t    \"$retval\");\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * This actually creates the event.\n\t */\n\tret = kretprobe_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_kretprobe_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tgen_kretprobe_test = trace_get_event_file(NULL, \"kprobes\",\n\t\t\t\t\t\t  \"gen_kretprobe_test\");\n\tif (IS_ERR(gen_kretprobe_test)) {\n\t\tret = PTR_ERR(gen_kretprobe_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_kretprobe_test->tr,\n\t\t\t\t\t\"kprobes\", \"gen_kretprobe_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_kretprobe_test);\n\t\tgoto delete;\n\t}\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tret = kprobe_event_delete(\"gen_kretprobe_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}"
  },
  {
    "function_name": "test_gen_kprobe_cmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/kprobe_event_gen_test.c",
    "lines": "42-108",
    "snippet": "static int __init test_gen_kprobe_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tkprobe_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Define the gen_kprobe_test event with the first 2 kprobe\n\t * fields.\n\t */\n\tret = kprobe_event_gen_cmd_start(&cmd, \"gen_kprobe_test\",\n\t\t\t\t\t \"do_sys_open\",\n\t\t\t\t\t \"dfd=%ax\", \"filename=%dx\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use kprobe_event_add_fields to add the rest of the fields */\n\n\tret = kprobe_event_add_fields(&cmd, \"flags=%cx\", \"mode=+4($stack)\");\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * This actually creates the event.\n\t */\n\tret = kprobe_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_kprobe_test event file.  We need to prevent\n\t * the instance and event from disappearing from underneath\n\t * us, which trace_get_event_file() does (though in this case\n\t * we're using the top-level instance which never goes away).\n\t */\n\tgen_kprobe_test = trace_get_event_file(NULL, \"kprobes\",\n\t\t\t\t\t       \"gen_kprobe_test\");\n\tif (IS_ERR(gen_kprobe_test)) {\n\t\tret = PTR_ERR(gen_kprobe_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_kprobe_test->tr,\n\t\t\t\t\t\"kprobes\", \"gen_kprobe_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_kprobe_test);\n\t\tgoto delete;\n\t}\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tret = kprobe_event_delete(\"gen_kprobe_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *gen_kprobe_test;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_event_delete",
          "args": [
            "\"gen_kprobe_test\""
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_event_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1073-1080",
          "snippet": "int kprobe_event_delete(const char *name)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\n\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"-:%s\", name);\n\n\treturn create_or_delete_trace_kprobe(buf);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nint kprobe_event_delete(const char *name)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\n\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"-:%s\", name);\n\n\treturn create_or_delete_trace_kprobe(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_put_event_file",
          "args": [
            "gen_kprobe_test"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "trace_put_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3031-3038",
          "snippet": "void trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_set_clr_event",
          "args": [
            "gen_kprobe_test->tr",
            "\"kprobes\"",
            "\"gen_kprobe_test\"",
            "true"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1123-1133",
          "snippet": "int trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "gen_kprobe_test"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "gen_kprobe_test"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_event_file",
          "args": [
            "NULL",
            "\"kprobes\"",
            "\"gen_kprobe_test\""
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2976-3019",
          "snippet": "struct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_event_gen_cmd_end",
          "args": [
            "&cmd"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_event_add_fields",
          "args": [
            "&cmd",
            "\"flags=%cx\"",
            "\"mode=+4($stack)\""
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "__kprobe_event_add_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1029-1061",
          "snippet": "int __kprobe_event_add_fields(struct dynevent_cmd *cmd, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret = 0;\n\n\tif (cmd->type != DYNEVENT_TYPE_KPROBE)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\n\tva_start(args, cmd);\n\tfor (;;) {\n\t\tconst char *field;\n\n\t\tfield = va_arg(args, const char *);\n\t\tif (!field)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > MAX_TRACE_ARGS) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\targ.str = field;\n\t\tret = dynevent_arg_add(cmd, &arg, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nint __kprobe_event_add_fields(struct dynevent_cmd *cmd, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret = 0;\n\n\tif (cmd->type != DYNEVENT_TYPE_KPROBE)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\n\tva_start(args, cmd);\n\tfor (;;) {\n\t\tconst char *field;\n\n\t\tfield = va_arg(args, const char *);\n\t\tif (!field)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > MAX_TRACE_ARGS) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\targ.str = field;\n\t\tret = dynevent_arg_add(cmd, &arg, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_event_gen_cmd_start",
          "args": [
            "&cmd",
            "\"gen_kprobe_test\"",
            "\"do_sys_open\"",
            "\"dfd=%ax\"",
            "\"filename=%dx\""
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "__kprobe_event_gen_cmd_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "960-1010",
          "snippet": "int __kprobe_event_gen_cmd_start(struct dynevent_cmd *cmd, bool kretprobe,\n\t\t\t\t const char *name, const char *loc, ...)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_KPROBE)\n\t\treturn -EINVAL;\n\n\tif (!loc)\n\t\treturn -EINVAL;\n\n\tif (kretprobe)\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"r:kprobes/%s\", name);\n\telse\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"p:kprobes/%s\", name);\n\n\tret = dynevent_str_add(cmd, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = loc;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, loc);\n\tfor (;;) {\n\t\tconst char *field;\n\n\t\tfield = va_arg(args, const char *);\n\t\tif (!field)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > MAX_TRACE_ARGS) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\targ.str = field;\n\t\tret = dynevent_arg_add(cmd, &arg, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nint __kprobe_event_gen_cmd_start(struct dynevent_cmd *cmd, bool kretprobe,\n\t\t\t\t const char *name, const char *loc, ...)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_KPROBE)\n\t\treturn -EINVAL;\n\n\tif (!loc)\n\t\treturn -EINVAL;\n\n\tif (kretprobe)\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"r:kprobes/%s\", name);\n\telse\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"p:kprobes/%s\", name);\n\n\tret = dynevent_str_add(cmd, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = loc;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, loc);\n\tfor (;;) {\n\t\tconst char *field;\n\n\t\tfield = va_arg(args, const char *);\n\t\tif (!field)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > MAX_TRACE_ARGS) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\targ.str = field;\n\t\tret = dynevent_arg_add(cmd, &arg, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_event_cmd_init",
          "args": [
            "&cmd",
            "buf",
            "MAX_DYNEVENT_CMD_LEN"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_event_cmd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "930-934",
          "snippet": "void kprobe_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_KPROBE,\n\t\t\t  trace_kprobe_run_command);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nvoid kprobe_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_KPROBE,\n\t\t\t  trace_kprobe_run_command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "MAX_DYNEVENT_CMD_LEN",
            "GFP_KERNEL"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_kprobe_test;\n\nstatic int __init test_gen_kprobe_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tkprobe_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Define the gen_kprobe_test event with the first 2 kprobe\n\t * fields.\n\t */\n\tret = kprobe_event_gen_cmd_start(&cmd, \"gen_kprobe_test\",\n\t\t\t\t\t \"do_sys_open\",\n\t\t\t\t\t \"dfd=%ax\", \"filename=%dx\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use kprobe_event_add_fields to add the rest of the fields */\n\n\tret = kprobe_event_add_fields(&cmd, \"flags=%cx\", \"mode=+4($stack)\");\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * This actually creates the event.\n\t */\n\tret = kprobe_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_kprobe_test event file.  We need to prevent\n\t * the instance and event from disappearing from underneath\n\t * us, which trace_get_event_file() does (though in this case\n\t * we're using the top-level instance which never goes away).\n\t */\n\tgen_kprobe_test = trace_get_event_file(NULL, \"kprobes\",\n\t\t\t\t\t       \"gen_kprobe_test\");\n\tif (IS_ERR(gen_kprobe_test)) {\n\t\tret = PTR_ERR(gen_kprobe_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_kprobe_test->tr,\n\t\t\t\t\t\"kprobes\", \"gen_kprobe_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_kprobe_test);\n\t\tgoto delete;\n\t}\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tret = kprobe_event_delete(\"gen_kprobe_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}"
  }
]