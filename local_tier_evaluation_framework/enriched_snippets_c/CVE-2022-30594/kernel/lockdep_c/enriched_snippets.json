[
  {
    "function_name": "lockdep_rcu_suspicious",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6520-6564",
    "snippet": "void lockdep_rcu_suspicious(const char *file, const int line, const char *s)\n{\n\tstruct task_struct *curr = current;\n\tint dl = READ_ONCE(debug_locks);\n\n\t/* Note: the following can be executed concurrently, so be careful. */\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================\\n\");\n\tpr_warn(\"WARNING: suspicious RCU usage\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------\\n\");\n\tpr_warn(\"%s:%d %s!\\n\", file, line, s);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tpr_warn(\"\\n%srcu_scheduler_active = %d, debug_locks = %d\\n%s\",\n\t       !rcu_lockdep_current_cpu_online()\n\t\t\t? \"RCU used illegally from offline CPU!\\n\"\n\t\t\t: \"\",\n\t       rcu_scheduler_active, dl,\n\t       dl ? \"\" : \"Possible false positive due to lockdep disabling via debug_locks = 0\\n\");\n\n\t/*\n\t * If a CPU is in the RCU-free window in idle (ie: in the section\n\t * between rcu_idle_enter() and rcu_idle_exit(), then RCU\n\t * considers that CPU to be in an \"extended quiescent state\",\n\t * which means that RCU will be completely ignoring that CPU.\n\t * Therefore, rcu_read_lock() and friends have absolutely no\n\t * effect on a CPU running in that state. In other words, even if\n\t * such an RCU-idle CPU has called rcu_read_lock(), RCU might well\n\t * delete data structures out from under it.  RCU really has no\n\t * choice here: we need to keep an RCU-free window in idle where\n\t * the CPU may possibly enter into low power mode. This way we can\n\t * notice an extended quiescent state to other CPUs that started a grace\n\t * period. Otherwise we would delay any grace period as long as we run\n\t * in the idle task.\n\t *\n\t * So complain bitterly if someone does call rcu_read_lock(),\n\t * rcu_read_lock_bh() and so on from extended quiescent states.\n\t */\n\tif (!rcu_is_watching())\n\t\tpr_warn(\"RCU used illegally from extended quiescent state!\\n\");\n\n\tlockdep_print_held_locks(curr);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 6563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 6562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 6561
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"RCU used illegally from extended quiescent state!\\n\""
          ],
          "line": 6559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 6558
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1123-1131",
          "snippet": "notrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nnotrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n%srcu_scheduler_active = %d, debug_locks = %d\\n%s\"",
            "!rcu_lockdep_current_cpu_online()\n\t\t\t? \"RCU used illegally from offline CPU!\\n\"\n\t\t\t: \"\"",
            "rcu_scheduler_active",
            "dl",
            "dl ? \"\" : \"Possible false positive due to lockdep disabling via debug_locks = 0\\n\""
          ],
          "line": 6533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lockdep_current_cpu_online",
          "args": [],
          "line": 6534
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_current_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1167-1182",
          "snippet": "bool rcu_lockdep_current_cpu_online(void)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool ret = false;\n\n\tif (in_nmi() || !rcu_scheduler_fully_active)\n\t\treturn true;\n\tpreempt_disable_notrace();\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\tif (rdp->grpmask & rcu_rnp_online_cpus(rnp) || READ_ONCE(rnp->ofl_seq) & 0x1)\n\t\tret = true;\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static int rcu_scheduler_fully_active",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic int rcu_scheduler_fully_active;\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_lockdep_current_cpu_online(void)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool ret = false;\n\n\tif (in_nmi() || !rcu_scheduler_fully_active)\n\t\treturn true;\n\tpreempt_disable_notrace();\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\tif (rdp->grpmask & rcu_rnp_online_cpus(rnp) || READ_ONCE(rnp->ofl_seq) & 0x1)\n\t\tret = true;\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\\n\""
          ],
          "line": 6532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s:%d %s!\\n\"",
            "file",
            "line",
            "s"
          ],
          "line": 6531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"-----------------------------\\n\""
          ],
          "line": 6530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 6529
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: suspicious RCU usage\\n\""
          ],
          "line": 6528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=============================\\n\""
          ],
          "line": 6527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 6526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "debug_locks"
          ],
          "line": 6523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_rcu_suspicious(const char *file, const int line, const char *s)\n{\n\tstruct task_struct *curr = current;\n\tint dl = READ_ONCE(debug_locks);\n\n\t/* Note: the following can be executed concurrently, so be careful. */\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================\\n\");\n\tpr_warn(\"WARNING: suspicious RCU usage\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------\\n\");\n\tpr_warn(\"%s:%d %s!\\n\", file, line, s);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tpr_warn(\"\\n%srcu_scheduler_active = %d, debug_locks = %d\\n%s\",\n\t       !rcu_lockdep_current_cpu_online()\n\t\t\t? \"RCU used illegally from offline CPU!\\n\"\n\t\t\t: \"\",\n\t       rcu_scheduler_active, dl,\n\t       dl ? \"\" : \"Possible false positive due to lockdep disabling via debug_locks = 0\\n\");\n\n\t/*\n\t * If a CPU is in the RCU-free window in idle (ie: in the section\n\t * between rcu_idle_enter() and rcu_idle_exit(), then RCU\n\t * considers that CPU to be in an \"extended quiescent state\",\n\t * which means that RCU will be completely ignoring that CPU.\n\t * Therefore, rcu_read_lock() and friends have absolutely no\n\t * effect on a CPU running in that state. In other words, even if\n\t * such an RCU-idle CPU has called rcu_read_lock(), RCU might well\n\t * delete data structures out from under it.  RCU really has no\n\t * choice here: we need to keep an RCU-free window in idle where\n\t * the CPU may possibly enter into low power mode. This way we can\n\t * notice an extended quiescent state to other CPUs that started a grace\n\t * period. Otherwise we would delay any grace period as long as we run\n\t * in the idle task.\n\t *\n\t * So complain bitterly if someone does call rcu_read_lock(),\n\t * rcu_read_lock_bh() and so on from extended quiescent states.\n\t */\n\tif (!rcu_is_watching())\n\t\tpr_warn(\"RCU used illegally from extended quiescent state!\\n\");\n\n\tlockdep_print_held_locks(curr);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "lockdep_sys_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6496-6518",
    "snippet": "void lockdep_sys_exit(void)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(curr->lockdep_depth)) {\n\t\tif (!debug_locks_off())\n\t\t\treturn;\n\t\tpr_warn(\"\\n\");\n\t\tpr_warn(\"================================================\\n\");\n\t\tpr_warn(\"WARNING: lock held when returning to user space!\\n\");\n\t\tprint_kernel_ident();\n\t\tpr_warn(\"------------------------------------------------\\n\");\n\t\tpr_warn(\"%s/%d is leaving the kernel with locks still held!\\n\",\n\t\t\t\tcurr->comm, curr->pid);\n\t\tlockdep_print_held_locks(curr);\n\t}\n\n\t/*\n\t * The lock history for each syscall should be independent. So wipe the\n\t * slate clean on return to userspace.\n\t */\n\tlockdep_invariant_state(false);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_invariant_state",
          "args": [
            "false"
          ],
          "line": 6517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 6510
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is leaving the kernel with locks still held!\\n\"",
            "curr->comm",
            "curr->pid"
          ],
          "line": 6508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"------------------------------------------------\\n\""
          ],
          "line": 6507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 6506
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: lock held when returning to user space!\\n\""
          ],
          "line": 6505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"================================================\\n\""
          ],
          "line": 6504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 6503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 6501
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "curr->lockdep_depth"
          ],
          "line": 6500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_sys_exit(void)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(curr->lockdep_depth)) {\n\t\tif (!debug_locks_off())\n\t\t\treturn;\n\t\tpr_warn(\"\\n\");\n\t\tpr_warn(\"================================================\\n\");\n\t\tpr_warn(\"WARNING: lock held when returning to user space!\\n\");\n\t\tprint_kernel_ident();\n\t\tpr_warn(\"------------------------------------------------\\n\");\n\t\tpr_warn(\"%s/%d is leaving the kernel with locks still held!\\n\",\n\t\t\t\tcurr->comm, curr->pid);\n\t\tlockdep_print_held_locks(curr);\n\t}\n\n\t/*\n\t * The lock history for each syscall should be independent. So wipe the\n\t * slate clean on return to userspace.\n\t */\n\tlockdep_invariant_state(false);\n}"
  },
  {
    "function_name": "debug_show_held_locks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6486-6493",
    "snippet": "void debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "task"
          ],
          "line": 6492
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"INFO: lockdep is turned off.\\n\""
          ],
          "line": 6489
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 6488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}"
  },
  {
    "function_name": "debug_show_all_locks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6456-6478",
    "snippet": "void debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=============================================\\n\\n\""
          ],
          "line": 6477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 6476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 6474
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_all_softlockup_watchdogs",
          "args": [],
          "line": 6472
        },
        "resolved": true,
        "details": {
          "function_name": "touch_all_softlockup_watchdogs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "280-297",
          "snippet": "void touch_all_softlockup_watchdogs(void)\n{\n\tint cpu;\n\n\t/*\n\t * watchdog_mutex cannpt be taken here, as this might be called\n\t * from (soft)interrupt context, so the access to\n\t * watchdog_allowed_cpumask might race with a concurrent update.\n\t *\n\t * The watchdog time stamp can race against a concurrent real\n\t * update as well, the only side effect might be a cycle delay for\n\t * the softlockup check.\n\t */\n\tfor_each_cpu(cpu, &watchdog_allowed_mask) {\n\t\tper_cpu(watchdog_report_ts, cpu) = SOFTLOCKUP_DELAY_REPORT;\n\t\twq_watchdog_touch(cpu);\n\t}\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
          ],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nvoid touch_all_softlockup_watchdogs(void)\n{\n\tint cpu;\n\n\t/*\n\t * watchdog_mutex cannpt be taken here, as this might be called\n\t * from (soft)interrupt context, so the access to\n\t * watchdog_allowed_cpumask might race with a concurrent update.\n\t *\n\t * The watchdog time stamp can race against a concurrent real\n\t * update as well, the only side effect might be a cycle delay for\n\t * the softlockup check.\n\t */\n\tfor_each_cpu(cpu, &watchdog_allowed_mask) {\n\t\tper_cpu(watchdog_report_ts, cpu) = SOFTLOCKUP_DELAY_REPORT;\n\t\twq_watchdog_touch(cpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 6471
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "p"
          ],
          "line": 6470
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 6467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 6466
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nShowing all locks held in the system:\\n\""
          ],
          "line": 6464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"INFO: lockdep is turned off.\\n\""
          ],
          "line": 6461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 6460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}"
  },
  {
    "function_name": "debug_check_no_locks_held",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6448-6452",
    "snippet": "void debug_check_no_locks_held(void)\n{\n\tif (unlikely(current->lockdep_depth > 0))\n\t\tprint_held_locks_bug();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_held_locks_bug",
          "args": [],
          "line": 6451
        },
        "resolved": true,
        "details": {
          "function_name": "print_held_locks_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6430-6446",
          "snippet": "static void print_held_locks_bug(void)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"====================================\\n\");\n\tpr_warn(\"WARNING: %s/%d still has locks held!\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------\\n\");\n\tlockdep_print_held_locks(current);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_held_locks_bug(void)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"====================================\\n\");\n\tpr_warn(\"WARNING: %s/%d still has locks held!\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------\\n\");\n\tlockdep_print_held_locks(current);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_depth > 0"
          ],
          "line": 6450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_check_no_locks_held(void)\n{\n\tif (unlikely(current->lockdep_depth > 0))\n\t\tprint_held_locks_bug();\n}"
  },
  {
    "function_name": "print_held_locks_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6430-6446",
    "snippet": "static void print_held_locks_bug(void)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"====================================\\n\");\n\tpr_warn(\"WARNING: %s/%d still has locks held!\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------\\n\");\n\tlockdep_print_held_locks(current);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 6445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 6444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "current"
          ],
          "line": 6443
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"------------------------------------\\n\""
          ],
          "line": 6442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 6441
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: %s/%d still has locks held!\\n\"",
            "current->comm",
            "task_pid_nr(current)"
          ],
          "line": 6439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 6440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"====================================\\n\""
          ],
          "line": 6438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 6437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 6432
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_held_locks_bug(void)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"====================================\\n\");\n\tpr_warn(\"WARNING: %s/%d still has locks held!\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------\\n\");\n\tlockdep_print_held_locks(current);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "debug_check_no_locks_freed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6405-6427",
    "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 6426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_freed_lock_bug",
          "args": [
            "curr",
            "mem_from",
            "mem_from + mem_len",
            "hlock"
          ],
          "line": 6423
        },
        "resolved": true,
        "details": {
          "function_name": "print_freed_lock_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6370-6391",
          "snippet": "static void\nprint_freed_lock_bug(struct task_struct *curr, const void *mem_from,\n\t\t     const void *mem_to, struct held_lock *hlock)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=========================\\n\");\n\tpr_warn(\"WARNING: held lock freed!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------\\n\");\n\tpr_warn(\"%s/%d is freeing memory %px-%px, with a lock still held there!\\n\",\n\t\tcurr->comm, task_pid_nr(curr), mem_from, mem_to-1);\n\tprint_lock(hlock);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_freed_lock_bug(struct task_struct *curr, const void *mem_from,\n\t\t     const void *mem_to, struct held_lock *hlock)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=========================\\n\");\n\tpr_warn(\"WARNING: held lock freed!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------\\n\");\n\tpr_warn(\"%s/%d is freeing memory %px-%px, with a lock still held there!\\n\",\n\t\tcurr->comm, task_pid_nr(curr), mem_from, mem_to-1);\n\tprint_lock(hlock);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "not_in_range",
          "args": [
            "mem_from",
            "mem_len",
            "hlock->instance",
            "sizeof(*hlock->instance)"
          ],
          "line": 6419
        },
        "resolved": true,
        "details": {
          "function_name": "not_in_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6393-6398",
          "snippet": "static inline int not_in_range(const void* mem_from, unsigned long mem_len,\n\t\t\t\tconst void* lock_from, unsigned long lock_len)\n{\n\treturn lock_from + lock_len <= mem_from ||\n\t\tmem_from + mem_len <= lock_from;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int not_in_range(const void* mem_from, unsigned long mem_len,\n\t\t\t\tconst void* lock_from, unsigned long lock_len)\n{\n\treturn lock_from + lock_len <= mem_from ||\n\t\tmem_from + mem_len <= lock_from;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 6415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 6412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "not_in_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6393-6398",
    "snippet": "static inline int not_in_range(const void* mem_from, unsigned long mem_len,\n\t\t\t\tconst void* lock_from, unsigned long lock_len)\n{\n\treturn lock_from + lock_len <= mem_from ||\n\t\tmem_from + mem_len <= lock_from;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int not_in_range(const void* mem_from, unsigned long mem_len,\n\t\t\t\tconst void* lock_from, unsigned long lock_len)\n{\n\treturn lock_from + lock_len <= mem_from ||\n\t\tmem_from + mem_len <= lock_from;\n}"
  },
  {
    "function_name": "print_freed_lock_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6370-6391",
    "snippet": "static void\nprint_freed_lock_bug(struct task_struct *curr, const void *mem_from,\n\t\t     const void *mem_to, struct held_lock *hlock)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=========================\\n\");\n\tpr_warn(\"WARNING: held lock freed!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------\\n\");\n\tpr_warn(\"%s/%d is freeing memory %px-%px, with a lock still held there!\\n\",\n\t\tcurr->comm, task_pid_nr(curr), mem_from, mem_to-1);\n\tprint_lock(hlock);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 6390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 6389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 6387
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "hlock"
          ],
          "line": 6386
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "726-748",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is freeing memory %px-%px, with a lock still held there!\\n\"",
            "curr->comm",
            "task_pid_nr(curr)",
            "mem_from",
            "mem_to-1"
          ],
          "line": 6384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 6385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"-------------------------\\n\""
          ],
          "line": 6383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 6382
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: held lock freed!\\n\""
          ],
          "line": 6381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=========================\\n\""
          ],
          "line": 6380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 6379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 6374
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_freed_lock_bug(struct task_struct *curr, const void *mem_from,\n\t\t     const void *mem_to, struct held_lock *hlock)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=========================\\n\");\n\tpr_warn(\"WARNING: held lock freed!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------\\n\");\n\tpr_warn(\"%s/%d is freeing memory %px-%px, with a lock still held there!\\n\",\n\t\tcurr->comm, task_pid_nr(curr), mem_from, mem_to-1);\n\tprint_lock(hlock);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "lockdep_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6331-6368",
    "snippet": "void __init lockdep_init(void)\n{\n\tprintk(\"Lock dependency validator: Copyright (c) 2006 Red Hat, Inc., Ingo Molnar\\n\");\n\n\tprintk(\"... MAX_LOCKDEP_SUBCLASSES:  %lu\\n\", MAX_LOCKDEP_SUBCLASSES);\n\tprintk(\"... MAX_LOCK_DEPTH:          %lu\\n\", MAX_LOCK_DEPTH);\n\tprintk(\"... MAX_LOCKDEP_KEYS:        %lu\\n\", MAX_LOCKDEP_KEYS);\n\tprintk(\"... CLASSHASH_SIZE:          %lu\\n\", CLASSHASH_SIZE);\n\tprintk(\"... MAX_LOCKDEP_ENTRIES:     %lu\\n\", MAX_LOCKDEP_ENTRIES);\n\tprintk(\"... MAX_LOCKDEP_CHAINS:      %lu\\n\", MAX_LOCKDEP_CHAINS);\n\tprintk(\"... CHAINHASH_SIZE:          %lu\\n\", CHAINHASH_SIZE);\n\n\tprintk(\" memory used by lock dependency info: %zu kB\\n\",\n\t       (sizeof(lock_classes) +\n\t\tsizeof(lock_classes_in_use) +\n\t\tsizeof(classhash_table) +\n\t\tsizeof(list_entries) +\n\t\tsizeof(list_entries_in_use) +\n\t\tsizeof(chainhash_table) +\n\t\tsizeof(delayed_free)\n#ifdef CONFIG_PROVE_LOCKING\n\t\t+ sizeof(lock_cq)\n\t\t+ sizeof(lock_chains)\n\t\t+ sizeof(lock_chains_in_use)\n\t\t+ sizeof(chain_hlocks)\n#endif\n\t\t) / 1024\n\t\t);\n\n#if defined(CONFIG_TRACE_IRQFLAGS) && defined(CONFIG_PROVE_LOCKING)\n\tprintk(\" memory used for stack traces: %zu kB\\n\",\n\t       (sizeof(stack_trace) + sizeof(stack_trace_hash)) / 1024\n\t       );\n#endif\n\n\tprintk(\" per task-struct memory footprint: %zu bytes\\n\",\n\t       sizeof(((struct task_struct *)NULL)->held_locks));\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CHAINHASH_SIZE\t\t(1UL << CHAINHASH_BITS)",
      "#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)"
    ],
    "globals_used": [
      "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];",
      "static DECLARE_BITMAP(list_entries_in_use, MAX_LOCKDEP_ENTRIES);",
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);",
      "static struct hlist_head classhash_table[CLASSHASH_SIZE];",
      "static struct hlist_head chainhash_table[CHAINHASH_SIZE];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" per task-struct memory footprint: %zu bytes\\n\"",
            "sizeof(((struct task_struct *)NULL)->held_locks)"
          ],
          "line": 6366
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Lock dependency validator: Copyright (c) 2006 Red Hat, Inc., Ingo Molnar\\n\""
          ],
          "line": 6333
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAINHASH_SIZE\t\t(1UL << CHAINHASH_BITS)\n#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)\n\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\nstatic DECLARE_BITMAP(list_entries_in_use, MAX_LOCKDEP_ENTRIES);\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\nstatic struct hlist_head classhash_table[CLASSHASH_SIZE];\nstatic struct hlist_head chainhash_table[CHAINHASH_SIZE];\nstatic noinstr struct;\n\nvoid __init lockdep_init(void)\n{\n\tprintk(\"Lock dependency validator: Copyright (c) 2006 Red Hat, Inc., Ingo Molnar\\n\");\n\n\tprintk(\"... MAX_LOCKDEP_SUBCLASSES:  %lu\\n\", MAX_LOCKDEP_SUBCLASSES);\n\tprintk(\"... MAX_LOCK_DEPTH:          %lu\\n\", MAX_LOCK_DEPTH);\n\tprintk(\"... MAX_LOCKDEP_KEYS:        %lu\\n\", MAX_LOCKDEP_KEYS);\n\tprintk(\"... CLASSHASH_SIZE:          %lu\\n\", CLASSHASH_SIZE);\n\tprintk(\"... MAX_LOCKDEP_ENTRIES:     %lu\\n\", MAX_LOCKDEP_ENTRIES);\n\tprintk(\"... MAX_LOCKDEP_CHAINS:      %lu\\n\", MAX_LOCKDEP_CHAINS);\n\tprintk(\"... CHAINHASH_SIZE:          %lu\\n\", CHAINHASH_SIZE);\n\n\tprintk(\" memory used by lock dependency info: %zu kB\\n\",\n\t       (sizeof(lock_classes) +\n\t\tsizeof(lock_classes_in_use) +\n\t\tsizeof(classhash_table) +\n\t\tsizeof(list_entries) +\n\t\tsizeof(list_entries_in_use) +\n\t\tsizeof(chainhash_table) +\n\t\tsizeof(delayed_free)\n#ifdef CONFIG_PROVE_LOCKING\n\t\t+ sizeof(lock_cq)\n\t\t+ sizeof(lock_chains)\n\t\t+ sizeof(lock_chains_in_use)\n\t\t+ sizeof(chain_hlocks)\n#endif\n\t\t) / 1024\n\t\t);\n\n#if defined(CONFIG_TRACE_IRQFLAGS) && defined(CONFIG_PROVE_LOCKING)\n\tprintk(\" memory used for stack traces: %zu kB\\n\",\n\t       (sizeof(stack_trace) + sizeof(stack_trace_hash)) / 1024\n\t       );\n#endif\n\n\tprintk(\" per task-struct memory footprint: %zu bytes\\n\",\n\t       sizeof(((struct task_struct *)NULL)->held_locks));\n}"
  },
  {
    "function_name": "lockdep_unregister_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6294-6328",
    "snippet": "void lockdep_unregister_key(struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head = keyhashentry(key);\n\tstruct lock_class_key *k;\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\tbool found = false;\n\n\tmight_sleep();\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tif (!graph_lock())\n\t\tgoto out_irq;\n\n\tpf = get_pending_free();\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (k == key) {\n\t\t\thlist_del_rcu(&k->hash_entry);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tWARN_ON_ONCE(!found);\n\t__lockdep_free_key_range(pf, key, 1);\n\tcall_rcu_zapped(pf);\n\tgraph_unlock();\nout_irq:\n\traw_local_irq_restore(flags);\n\n\t/* Wait until is_dynamic_key() has finished accessing k->hash_entry. */\n\tsynchronize_rcu();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 6327
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 6324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 6322
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu_zapped",
          "args": [
            "pf"
          ],
          "line": 6321
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_zapped",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6048-6064",
          "snippet": "static void call_rcu_zapped(struct pending_free *pf)\n{\n\tWARN_ON_ONCE(inside_selftest());\n\n\tif (list_empty(&pf->zapped))\n\t\treturn;\n\n\tif (delayed_free.scheduled)\n\t\treturn;\n\n\tdelayed_free.scheduled = true;\n\n\tWARN_ON_ONCE(delayed_free.pf + delayed_free.index != pf);\n\tdelayed_free.index ^= 1;\n\n\tcall_rcu(&delayed_free.rcu_head, free_zapped_rcu);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void call_rcu_zapped(struct pending_free *pf)\n{\n\tWARN_ON_ONCE(inside_selftest());\n\n\tif (list_empty(&pf->zapped))\n\t\treturn;\n\n\tif (delayed_free.scheduled)\n\t\treturn;\n\n\tdelayed_free.scheduled = true;\n\n\tWARN_ON_ONCE(delayed_free.pf + delayed_free.index != pf);\n\tdelayed_free.index ^= 1;\n\n\tcall_rcu(&delayed_free.rcu_head, free_zapped_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lockdep_free_key_range",
          "args": [
            "pf",
            "key",
            "1"
          ],
          "line": 6320
        },
        "resolved": true,
        "details": {
          "function_name": "__lockdep_free_key_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6116-6133",
          "snippet": "static void __lockdep_free_key_range(struct pending_free *pf, void *start,\n\t\t\t\t     unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i;\n\n\t/* Unhash all classes that were created by a module. */\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (!within(class->key, start, size) &&\n\t\t\t    !within(class->name, start, size))\n\t\t\t\tcontinue;\n\t\t\tzap_class(pf, class);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)"
          ],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static struct hlist_head classhash_table[CLASSHASH_SIZE];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic struct hlist_head classhash_table[CLASSHASH_SIZE];\nstatic noinstr struct;\n\nstatic void __lockdep_free_key_range(struct pending_free *pf, void *start,\n\t\t\t\t     unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i;\n\n\t/* Unhash all classes that were created by a module. */\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (!within(class->key, start, size) &&\n\t\t\t    !within(class->name, start, size))\n\t\t\t\tcontinue;\n\t\t\tzap_class(pf, class);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!found"
          ],
          "line": 6319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&k->hash_entry"
          ],
          "line": 6314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "k",
            "hash_head",
            "hash_entry"
          ],
          "line": 6312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pending_free",
          "args": [],
          "line": 6311
        },
        "resolved": true,
        "details": {
          "function_name": "get_pending_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6037-6040",
          "snippet": "static struct pending_free *get_pending_free(void)\n{\n\treturn delayed_free.pf + delayed_free.index;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic struct pending_free *get_pending_free(void)\n{\n\treturn delayed_free.pf + delayed_free.index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_lock",
          "args": [],
          "line": 6308
        },
        "resolved": true,
        "details": {
          "function_name": "graph_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "137-151",
          "snippet": "static int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 6307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "static_obj(key)"
          ],
          "line": 6304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_obj",
          "args": [
            "key"
          ],
          "line": 6304
        },
        "resolved": true,
        "details": {
          "function_name": "static_obj",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "806-831",
          "snippet": "static int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 6302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyhashentry",
          "args": [
            "key"
          ],
          "line": 6296
        },
        "resolved": true,
        "details": {
          "function_name": "keyhashentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1179-1184",
          "snippet": "static inline struct hlist_head *keyhashentry(const struct lock_class_key *key)\n{\n\tunsigned long hash = hash_long((uintptr_t)key, KEYHASH_BITS);\n\n\treturn lock_keys_hash + hash;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define KEYHASH_BITS\t\t(MAX_LOCKDEP_KEYS_BITS - 1)"
          ],
          "globals_used": [
            "static struct hlist_head lock_keys_hash[KEYHASH_SIZE];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define KEYHASH_BITS\t\t(MAX_LOCKDEP_KEYS_BITS - 1)\n\nstatic struct hlist_head lock_keys_hash[KEYHASH_SIZE];\nstatic noinstr struct;\n\nstatic inline struct hlist_head *keyhashentry(const struct lock_class_key *key)\n{\n\tunsigned long hash = hash_long((uintptr_t)key, KEYHASH_BITS);\n\n\treturn lock_keys_hash + hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nvoid lockdep_unregister_key(struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head = keyhashentry(key);\n\tstruct lock_class_key *k;\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\tbool found = false;\n\n\tmight_sleep();\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tif (!graph_lock())\n\t\tgoto out_irq;\n\n\tpf = get_pending_free();\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (k == key) {\n\t\t\thlist_del_rcu(&k->hash_entry);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tWARN_ON_ONCE(!found);\n\t__lockdep_free_key_range(pf, key, 1);\n\tcall_rcu_zapped(pf);\n\tgraph_unlock();\nout_irq:\n\traw_local_irq_restore(flags);\n\n\t/* Wait until is_dynamic_key() has finished accessing k->hash_entry. */\n\tsynchronize_rcu();\n}"
  },
  {
    "function_name": "lockdep_reset_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6283-6291",
    "snippet": "void lockdep_reset_lock(struct lockdep_map *lock)\n{\n\tinit_data_structures_once();\n\n\tif (inside_selftest())\n\t\tlockdep_reset_lock_imm(lock);\n\telse\n\t\tlockdep_reset_lock_reg(lock);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_reset_lock_reg",
          "args": [
            "lock"
          ],
          "line": 6290
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_reset_lock_reg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6246-6264",
          "snippet": "static void lockdep_reset_lock_reg(struct lockdep_map *lock)\n{\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\tint locked;\n\n\traw_local_irq_save(flags);\n\tlocked = graph_lock();\n\tif (!locked)\n\t\tgoto out_irq;\n\n\tpf = get_pending_free();\n\t__lockdep_reset_lock(pf, lock);\n\tcall_rcu_zapped(pf);\n\n\tgraph_unlock();\nout_irq:\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void lockdep_reset_lock_reg(struct lockdep_map *lock)\n{\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\tint locked;\n\n\traw_local_irq_save(flags);\n\tlocked = graph_lock();\n\tif (!locked)\n\t\tgoto out_irq;\n\n\tpf = get_pending_free();\n\t__lockdep_reset_lock(pf, lock);\n\tcall_rcu_zapped(pf);\n\n\tgraph_unlock();\nout_irq:\n\traw_local_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_reset_lock_imm",
          "args": [
            "lock"
          ],
          "line": 6288
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_reset_lock_imm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6270-6281",
          "snippet": "static void lockdep_reset_lock_imm(struct lockdep_map *lock)\n{\n\tstruct pending_free *pf = delayed_free.pf;\n\tunsigned long flags;\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\t__lockdep_reset_lock(pf, lock);\n\t__free_zapped_classes(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void lockdep_reset_lock_imm(struct lockdep_map *lock)\n{\n\tstruct pending_free *pf = delayed_free.pf;\n\tunsigned long flags;\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\t__lockdep_reset_lock(pf, lock);\n\t__free_zapped_classes(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inside_selftest",
          "args": [],
          "line": 6287
        },
        "resolved": true,
        "details": {
          "function_name": "inside_selftest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6031-6034",
          "snippet": "static bool inside_selftest(void)\n{\n\treturn current == lockdep_selftest_task_struct;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *lockdep_selftest_task_struct;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct task_struct *lockdep_selftest_task_struct;\n\nstatic bool inside_selftest(void)\n{\n\treturn current == lockdep_selftest_task_struct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_data_structures_once",
          "args": [],
          "line": 6285
        },
        "resolved": true,
        "details": {
          "function_name": "init_data_structures_once",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1150-1177",
          "snippet": "static void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static LIST_HEAD(free_lock_classes);",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static void init_chain_block_buckets(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic LIST_HEAD(free_lock_classes);\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic void init_chain_block_buckets(void);\n\nstatic void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_reset_lock(struct lockdep_map *lock)\n{\n\tinit_data_structures_once();\n\n\tif (inside_selftest())\n\t\tlockdep_reset_lock_imm(lock);\n\telse\n\t\tlockdep_reset_lock_reg(lock);\n}"
  },
  {
    "function_name": "lockdep_reset_lock_imm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6270-6281",
    "snippet": "static void lockdep_reset_lock_imm(struct lockdep_map *lock)\n{\n\tstruct pending_free *pf = delayed_free.pf;\n\tunsigned long flags;\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\t__lockdep_reset_lock(pf, lock);\n\t__free_zapped_classes(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 6280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_unlock",
          "args": [],
          "line": 6279
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "117-127",
          "snippet": "static inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_zapped_classes",
          "args": [
            "pf"
          ],
          "line": 6278
        },
        "resolved": true,
        "details": {
          "function_name": "__free_zapped_classes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6067-6083",
          "snippet": "static void __free_zapped_classes(struct pending_free *pf)\n{\n\tstruct lock_class *class;\n\n\tcheck_data_structures();\n\n\tlist_for_each_entry(class, &pf->zapped, lock_entry)\n\t\treinit_class(class);\n\n\tlist_splice_init(&pf->zapped, &free_lock_classes);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tbitmap_andnot(lock_chains_in_use, lock_chains_in_use,\n\t\t      pf->lock_chains_being_freed, ARRAY_SIZE(lock_chains));\n\tbitmap_clear(pf->lock_chains_being_freed, 0, ARRAY_SIZE(lock_chains));\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(free_lock_classes);",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic LIST_HEAD(free_lock_classes);\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void __free_zapped_classes(struct pending_free *pf)\n{\n\tstruct lock_class *class;\n\n\tcheck_data_structures();\n\n\tlist_for_each_entry(class, &pf->zapped, lock_entry)\n\t\treinit_class(class);\n\n\tlist_splice_init(&pf->zapped, &free_lock_classes);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tbitmap_andnot(lock_chains_in_use, lock_chains_in_use,\n\t\t      pf->lock_chains_being_freed, ARRAY_SIZE(lock_chains));\n\tbitmap_clear(pf->lock_chains_being_freed, 0, ARRAY_SIZE(lock_chains));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lockdep_reset_lock",
          "args": [
            "pf",
            "lock"
          ],
          "line": 6277
        },
        "resolved": true,
        "details": {
          "function_name": "__lockdep_reset_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6217-6240",
          "snippet": "static void __lockdep_reset_lock(struct pending_free *pf,\n\t\t\t\t struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tint j;\n\n\t/*\n\t * Remove all classes this lock might have:\n\t */\n\tfor (j = 0; j < MAX_LOCKDEP_SUBCLASSES; j++) {\n\t\t/*\n\t\t * If the class exists we look it up and zap it:\n\t\t */\n\t\tclass = look_up_lock_class(lock, j);\n\t\tif (class)\n\t\t\tzap_class(pf, class);\n\t}\n\t/*\n\t * Debug check: in the end all mapped classes should\n\t * be gone.\n\t */\n\tif (WARN_ON_ONCE(lock_class_cache_is_registered(lock)))\n\t\tdebug_locks_off();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void __lockdep_reset_lock(struct pending_free *pf,\n\t\t\t\t struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tint j;\n\n\t/*\n\t * Remove all classes this lock might have:\n\t */\n\tfor (j = 0; j < MAX_LOCKDEP_SUBCLASSES; j++) {\n\t\t/*\n\t\t * If the class exists we look it up and zap it:\n\t\t */\n\t\tclass = look_up_lock_class(lock, j);\n\t\tif (class)\n\t\t\tzap_class(pf, class);\n\t}\n\t/*\n\t * Debug check: in the end all mapped classes should\n\t * be gone.\n\t */\n\tif (WARN_ON_ONCE(lock_class_cache_is_registered(lock)))\n\t\tdebug_locks_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_lock",
          "args": [],
          "line": 6276
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "108-115",
          "snippet": "static inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 6275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void lockdep_reset_lock_imm(struct lockdep_map *lock)\n{\n\tstruct pending_free *pf = delayed_free.pf;\n\tunsigned long flags;\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\t__lockdep_reset_lock(pf, lock);\n\t__free_zapped_classes(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lockdep_reset_lock_reg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6246-6264",
    "snippet": "static void lockdep_reset_lock_reg(struct lockdep_map *lock)\n{\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\tint locked;\n\n\traw_local_irq_save(flags);\n\tlocked = graph_lock();\n\tif (!locked)\n\t\tgoto out_irq;\n\n\tpf = get_pending_free();\n\t__lockdep_reset_lock(pf, lock);\n\tcall_rcu_zapped(pf);\n\n\tgraph_unlock();\nout_irq:\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 6263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 6261
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu_zapped",
          "args": [
            "pf"
          ],
          "line": 6259
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_zapped",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6048-6064",
          "snippet": "static void call_rcu_zapped(struct pending_free *pf)\n{\n\tWARN_ON_ONCE(inside_selftest());\n\n\tif (list_empty(&pf->zapped))\n\t\treturn;\n\n\tif (delayed_free.scheduled)\n\t\treturn;\n\n\tdelayed_free.scheduled = true;\n\n\tWARN_ON_ONCE(delayed_free.pf + delayed_free.index != pf);\n\tdelayed_free.index ^= 1;\n\n\tcall_rcu(&delayed_free.rcu_head, free_zapped_rcu);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void call_rcu_zapped(struct pending_free *pf)\n{\n\tWARN_ON_ONCE(inside_selftest());\n\n\tif (list_empty(&pf->zapped))\n\t\treturn;\n\n\tif (delayed_free.scheduled)\n\t\treturn;\n\n\tdelayed_free.scheduled = true;\n\n\tWARN_ON_ONCE(delayed_free.pf + delayed_free.index != pf);\n\tdelayed_free.index ^= 1;\n\n\tcall_rcu(&delayed_free.rcu_head, free_zapped_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lockdep_reset_lock",
          "args": [
            "pf",
            "lock"
          ],
          "line": 6258
        },
        "resolved": true,
        "details": {
          "function_name": "__lockdep_reset_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6217-6240",
          "snippet": "static void __lockdep_reset_lock(struct pending_free *pf,\n\t\t\t\t struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tint j;\n\n\t/*\n\t * Remove all classes this lock might have:\n\t */\n\tfor (j = 0; j < MAX_LOCKDEP_SUBCLASSES; j++) {\n\t\t/*\n\t\t * If the class exists we look it up and zap it:\n\t\t */\n\t\tclass = look_up_lock_class(lock, j);\n\t\tif (class)\n\t\t\tzap_class(pf, class);\n\t}\n\t/*\n\t * Debug check: in the end all mapped classes should\n\t * be gone.\n\t */\n\tif (WARN_ON_ONCE(lock_class_cache_is_registered(lock)))\n\t\tdebug_locks_off();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void __lockdep_reset_lock(struct pending_free *pf,\n\t\t\t\t struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tint j;\n\n\t/*\n\t * Remove all classes this lock might have:\n\t */\n\tfor (j = 0; j < MAX_LOCKDEP_SUBCLASSES; j++) {\n\t\t/*\n\t\t * If the class exists we look it up and zap it:\n\t\t */\n\t\tclass = look_up_lock_class(lock, j);\n\t\tif (class)\n\t\t\tzap_class(pf, class);\n\t}\n\t/*\n\t * Debug check: in the end all mapped classes should\n\t * be gone.\n\t */\n\tif (WARN_ON_ONCE(lock_class_cache_is_registered(lock)))\n\t\tdebug_locks_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pending_free",
          "args": [],
          "line": 6257
        },
        "resolved": true,
        "details": {
          "function_name": "get_pending_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6037-6040",
          "snippet": "static struct pending_free *get_pending_free(void)\n{\n\treturn delayed_free.pf + delayed_free.index;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic struct pending_free *get_pending_free(void)\n{\n\treturn delayed_free.pf + delayed_free.index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_lock",
          "args": [],
          "line": 6253
        },
        "resolved": true,
        "details": {
          "function_name": "graph_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "137-151",
          "snippet": "static int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 6252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void lockdep_reset_lock_reg(struct lockdep_map *lock)\n{\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\tint locked;\n\n\traw_local_irq_save(flags);\n\tlocked = graph_lock();\n\tif (!locked)\n\t\tgoto out_irq;\n\n\tpf = get_pending_free();\n\t__lockdep_reset_lock(pf, lock);\n\tcall_rcu_zapped(pf);\n\n\tgraph_unlock();\nout_irq:\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "__lockdep_reset_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6217-6240",
    "snippet": "static void __lockdep_reset_lock(struct pending_free *pf,\n\t\t\t\t struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tint j;\n\n\t/*\n\t * Remove all classes this lock might have:\n\t */\n\tfor (j = 0; j < MAX_LOCKDEP_SUBCLASSES; j++) {\n\t\t/*\n\t\t * If the class exists we look it up and zap it:\n\t\t */\n\t\tclass = look_up_lock_class(lock, j);\n\t\tif (class)\n\t\t\tzap_class(pf, class);\n\t}\n\t/*\n\t * Debug check: in the end all mapped classes should\n\t * be gone.\n\t */\n\tif (WARN_ON_ONCE(lock_class_cache_is_registered(lock)))\n\t\tdebug_locks_off();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 6239
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "lock_class_cache_is_registered(lock)"
          ],
          "line": 6238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_class_cache_is_registered",
          "args": [
            "lock"
          ],
          "line": 6238
        },
        "resolved": true,
        "details": {
          "function_name": "lock_class_cache_is_registered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6199-6214",
          "snippet": "static bool lock_class_cache_is_registered(struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i, j;\n\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tfor (j = 0; j < NR_LOCKDEP_CACHING_CLASSES; j++)\n\t\t\t\tif (lock->class_cache[j] == class)\n\t\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)"
          ],
          "globals_used": [
            "static struct hlist_head classhash_table[CLASSHASH_SIZE];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)\n\nstatic struct hlist_head classhash_table[CLASSHASH_SIZE];\nstatic noinstr struct;\n\nstatic bool lock_class_cache_is_registered(struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i, j;\n\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tfor (j = 0; j < NR_LOCKDEP_CACHING_CLASSES; j++)\n\t\t\t\tif (lock->class_cache[j] == class)\n\t\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zap_class",
          "args": [
            "pf",
            "class"
          ],
          "line": 6232
        },
        "resolved": true,
        "details": {
          "function_name": "zap_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5976-6010",
          "snippet": "static void zap_class(struct pending_free *pf, struct lock_class *class)\n{\n\tstruct lock_list *entry;\n\tint i;\n\n\tWARN_ON_ONCE(!class->key);\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\tentry = list_entries + i;\n\t\tif (entry->class != class && entry->links_to != class)\n\t\t\tcontinue;\n\t\t__clear_bit(i, list_entries_in_use);\n\t\tnr_list_entries--;\n\t\tlist_del_rcu(&entry->entry);\n\t}\n\tif (list_empty(&class->locks_after) &&\n\t    list_empty(&class->locks_before)) {\n\t\tlist_move_tail(&class->lock_entry, &pf->zapped);\n\t\thlist_del_rcu(&class->hash_entry);\n\t\tWRITE_ONCE(class->key, NULL);\n\t\tWRITE_ONCE(class->name, NULL);\n\t\tnr_lock_classes--;\n\t\t__clear_bit(class - lock_classes, lock_classes_in_use);\n\t} else {\n\t\tWARN_ONCE(true, \"%s() failed for class %s\\n\", __func__,\n\t\t\t  class->name);\n\t}\n\n\tremove_class_from_lock_chains(pf, class);\n\tnr_zapped_classes++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_list_entries;",
            "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];",
            "unsigned long nr_lock_classes;",
            "unsigned long nr_zapped_classes;",
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\nunsigned long nr_lock_classes;\nunsigned long nr_zapped_classes;\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void zap_class(struct pending_free *pf, struct lock_class *class)\n{\n\tstruct lock_list *entry;\n\tint i;\n\n\tWARN_ON_ONCE(!class->key);\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\tentry = list_entries + i;\n\t\tif (entry->class != class && entry->links_to != class)\n\t\t\tcontinue;\n\t\t__clear_bit(i, list_entries_in_use);\n\t\tnr_list_entries--;\n\t\tlist_del_rcu(&entry->entry);\n\t}\n\tif (list_empty(&class->locks_after) &&\n\t    list_empty(&class->locks_before)) {\n\t\tlist_move_tail(&class->lock_entry, &pf->zapped);\n\t\thlist_del_rcu(&class->hash_entry);\n\t\tWRITE_ONCE(class->key, NULL);\n\t\tWRITE_ONCE(class->name, NULL);\n\t\tnr_lock_classes--;\n\t\t__clear_bit(class - lock_classes, lock_classes_in_use);\n\t} else {\n\t\tWARN_ONCE(true, \"%s() failed for class %s\\n\", __func__,\n\t\t\t  class->name);\n\t}\n\n\tremove_class_from_lock_chains(pf, class);\n\tnr_zapped_classes++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "look_up_lock_class",
          "args": [
            "lock",
            "j"
          ],
          "line": 6230
        },
        "resolved": true,
        "details": {
          "function_name": "look_up_lock_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "858-916",
          "snippet": "lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tinstrumentation_begin();\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\tinstrumentation_end();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name &&\n\t\t\t\t     lock->key != &__lockdep_no_validate__);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "struct lock_class_key __lockdep_no_validate__;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstruct lock_class_key __lockdep_no_validate__;\n\nlock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tinstrumentation_begin();\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\tinstrumentation_end();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name &&\n\t\t\t\t     lock->key != &__lockdep_no_validate__);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void __lockdep_reset_lock(struct pending_free *pf,\n\t\t\t\t struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tint j;\n\n\t/*\n\t * Remove all classes this lock might have:\n\t */\n\tfor (j = 0; j < MAX_LOCKDEP_SUBCLASSES; j++) {\n\t\t/*\n\t\t * If the class exists we look it up and zap it:\n\t\t */\n\t\tclass = look_up_lock_class(lock, j);\n\t\tif (class)\n\t\t\tzap_class(pf, class);\n\t}\n\t/*\n\t * Debug check: in the end all mapped classes should\n\t * be gone.\n\t */\n\tif (WARN_ON_ONCE(lock_class_cache_is_registered(lock)))\n\t\tdebug_locks_off();\n}"
  },
  {
    "function_name": "lock_class_cache_is_registered",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6199-6214",
    "snippet": "static bool lock_class_cache_is_registered(struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i, j;\n\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tfor (j = 0; j < NR_LOCKDEP_CACHING_CLASSES; j++)\n\t\t\t\tif (lock->class_cache[j] == class)\n\t\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head classhash_table[CLASSHASH_SIZE];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "class",
            "head",
            "hash_entry"
          ],
          "line": 6207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)\n\nstatic struct hlist_head classhash_table[CLASSHASH_SIZE];\nstatic noinstr struct;\n\nstatic bool lock_class_cache_is_registered(struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i, j;\n\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tfor (j = 0; j < NR_LOCKDEP_CACHING_CLASSES; j++)\n\t\t\t\tif (lock->class_cache[j] == class)\n\t\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "lockdep_free_key_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6184-6192",
    "snippet": "void lockdep_free_key_range(void *start, unsigned long size)\n{\n\tinit_data_structures_once();\n\n\tif (inside_selftest())\n\t\tlockdep_free_key_range_imm(start, size);\n\telse\n\t\tlockdep_free_key_range_reg(start, size);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_free_key_range_reg",
          "args": [
            "start",
            "size"
          ],
          "line": 6191
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_free_key_range_reg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6143-6163",
          "snippet": "static void lockdep_free_key_range_reg(void *start, unsigned long size)\n{\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\n\tinit_data_structures_once();\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\tpf = get_pending_free();\n\t__lockdep_free_key_range(pf, start, size);\n\tcall_rcu_zapped(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n\n\t/*\n\t * Wait for any possible iterators from look_up_lock_class() to pass\n\t * before continuing to free the memory they refer to.\n\t */\n\tsynchronize_rcu();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void lockdep_free_key_range_reg(void *start, unsigned long size)\n{\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\n\tinit_data_structures_once();\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\tpf = get_pending_free();\n\t__lockdep_free_key_range(pf, start, size);\n\tcall_rcu_zapped(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n\n\t/*\n\t * Wait for any possible iterators from look_up_lock_class() to pass\n\t * before continuing to free the memory they refer to.\n\t */\n\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_free_key_range_imm",
          "args": [
            "start",
            "size"
          ],
          "line": 6189
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_free_key_range_imm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6169-6182",
          "snippet": "static void lockdep_free_key_range_imm(void *start, unsigned long size)\n{\n\tstruct pending_free *pf = delayed_free.pf;\n\tunsigned long flags;\n\n\tinit_data_structures_once();\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\t__lockdep_free_key_range(pf, start, size);\n\t__free_zapped_classes(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void lockdep_free_key_range_imm(void *start, unsigned long size)\n{\n\tstruct pending_free *pf = delayed_free.pf;\n\tunsigned long flags;\n\n\tinit_data_structures_once();\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\t__lockdep_free_key_range(pf, start, size);\n\t__free_zapped_classes(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inside_selftest",
          "args": [],
          "line": 6188
        },
        "resolved": true,
        "details": {
          "function_name": "inside_selftest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6031-6034",
          "snippet": "static bool inside_selftest(void)\n{\n\treturn current == lockdep_selftest_task_struct;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *lockdep_selftest_task_struct;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct task_struct *lockdep_selftest_task_struct;\n\nstatic bool inside_selftest(void)\n{\n\treturn current == lockdep_selftest_task_struct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_data_structures_once",
          "args": [],
          "line": 6186
        },
        "resolved": true,
        "details": {
          "function_name": "init_data_structures_once",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1150-1177",
          "snippet": "static void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static LIST_HEAD(free_lock_classes);",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static void init_chain_block_buckets(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic LIST_HEAD(free_lock_classes);\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic void init_chain_block_buckets(void);\n\nstatic void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_free_key_range(void *start, unsigned long size)\n{\n\tinit_data_structures_once();\n\n\tif (inside_selftest())\n\t\tlockdep_free_key_range_imm(start, size);\n\telse\n\t\tlockdep_free_key_range_reg(start, size);\n}"
  },
  {
    "function_name": "lockdep_free_key_range_imm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6169-6182",
    "snippet": "static void lockdep_free_key_range_imm(void *start, unsigned long size)\n{\n\tstruct pending_free *pf = delayed_free.pf;\n\tunsigned long flags;\n\n\tinit_data_structures_once();\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\t__lockdep_free_key_range(pf, start, size);\n\t__free_zapped_classes(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 6181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_unlock",
          "args": [],
          "line": 6180
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "117-127",
          "snippet": "static inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_zapped_classes",
          "args": [
            "pf"
          ],
          "line": 6179
        },
        "resolved": true,
        "details": {
          "function_name": "__free_zapped_classes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6067-6083",
          "snippet": "static void __free_zapped_classes(struct pending_free *pf)\n{\n\tstruct lock_class *class;\n\n\tcheck_data_structures();\n\n\tlist_for_each_entry(class, &pf->zapped, lock_entry)\n\t\treinit_class(class);\n\n\tlist_splice_init(&pf->zapped, &free_lock_classes);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tbitmap_andnot(lock_chains_in_use, lock_chains_in_use,\n\t\t      pf->lock_chains_being_freed, ARRAY_SIZE(lock_chains));\n\tbitmap_clear(pf->lock_chains_being_freed, 0, ARRAY_SIZE(lock_chains));\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(free_lock_classes);",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic LIST_HEAD(free_lock_classes);\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void __free_zapped_classes(struct pending_free *pf)\n{\n\tstruct lock_class *class;\n\n\tcheck_data_structures();\n\n\tlist_for_each_entry(class, &pf->zapped, lock_entry)\n\t\treinit_class(class);\n\n\tlist_splice_init(&pf->zapped, &free_lock_classes);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tbitmap_andnot(lock_chains_in_use, lock_chains_in_use,\n\t\t      pf->lock_chains_being_freed, ARRAY_SIZE(lock_chains));\n\tbitmap_clear(pf->lock_chains_being_freed, 0, ARRAY_SIZE(lock_chains));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lockdep_free_key_range",
          "args": [
            "pf",
            "start",
            "size"
          ],
          "line": 6178
        },
        "resolved": true,
        "details": {
          "function_name": "__lockdep_free_key_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6116-6133",
          "snippet": "static void __lockdep_free_key_range(struct pending_free *pf, void *start,\n\t\t\t\t     unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i;\n\n\t/* Unhash all classes that were created by a module. */\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (!within(class->key, start, size) &&\n\t\t\t    !within(class->name, start, size))\n\t\t\t\tcontinue;\n\t\t\tzap_class(pf, class);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)"
          ],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static struct hlist_head classhash_table[CLASSHASH_SIZE];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic struct hlist_head classhash_table[CLASSHASH_SIZE];\nstatic noinstr struct;\n\nstatic void __lockdep_free_key_range(struct pending_free *pf, void *start,\n\t\t\t\t     unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i;\n\n\t/* Unhash all classes that were created by a module. */\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (!within(class->key, start, size) &&\n\t\t\t    !within(class->name, start, size))\n\t\t\t\tcontinue;\n\t\t\tzap_class(pf, class);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_lock",
          "args": [],
          "line": 6177
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "108-115",
          "snippet": "static inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 6176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_data_structures_once",
          "args": [],
          "line": 6174
        },
        "resolved": true,
        "details": {
          "function_name": "init_data_structures_once",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1150-1177",
          "snippet": "static void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static LIST_HEAD(free_lock_classes);",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static void init_chain_block_buckets(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic LIST_HEAD(free_lock_classes);\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic void init_chain_block_buckets(void);\n\nstatic void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void lockdep_free_key_range_imm(void *start, unsigned long size)\n{\n\tstruct pending_free *pf = delayed_free.pf;\n\tunsigned long flags;\n\n\tinit_data_structures_once();\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\t__lockdep_free_key_range(pf, start, size);\n\t__free_zapped_classes(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lockdep_free_key_range_reg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6143-6163",
    "snippet": "static void lockdep_free_key_range_reg(void *start, unsigned long size)\n{\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\n\tinit_data_structures_once();\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\tpf = get_pending_free();\n\t__lockdep_free_key_range(pf, start, size);\n\tcall_rcu_zapped(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n\n\t/*\n\t * Wait for any possible iterators from look_up_lock_class() to pass\n\t * before continuing to free the memory they refer to.\n\t */\n\tsynchronize_rcu();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 6162
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 6156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_unlock",
          "args": [],
          "line": 6155
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "117-127",
          "snippet": "static inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu_zapped",
          "args": [
            "pf"
          ],
          "line": 6154
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_zapped",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6048-6064",
          "snippet": "static void call_rcu_zapped(struct pending_free *pf)\n{\n\tWARN_ON_ONCE(inside_selftest());\n\n\tif (list_empty(&pf->zapped))\n\t\treturn;\n\n\tif (delayed_free.scheduled)\n\t\treturn;\n\n\tdelayed_free.scheduled = true;\n\n\tWARN_ON_ONCE(delayed_free.pf + delayed_free.index != pf);\n\tdelayed_free.index ^= 1;\n\n\tcall_rcu(&delayed_free.rcu_head, free_zapped_rcu);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void call_rcu_zapped(struct pending_free *pf)\n{\n\tWARN_ON_ONCE(inside_selftest());\n\n\tif (list_empty(&pf->zapped))\n\t\treturn;\n\n\tif (delayed_free.scheduled)\n\t\treturn;\n\n\tdelayed_free.scheduled = true;\n\n\tWARN_ON_ONCE(delayed_free.pf + delayed_free.index != pf);\n\tdelayed_free.index ^= 1;\n\n\tcall_rcu(&delayed_free.rcu_head, free_zapped_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lockdep_free_key_range",
          "args": [
            "pf",
            "start",
            "size"
          ],
          "line": 6153
        },
        "resolved": true,
        "details": {
          "function_name": "__lockdep_free_key_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6116-6133",
          "snippet": "static void __lockdep_free_key_range(struct pending_free *pf, void *start,\n\t\t\t\t     unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i;\n\n\t/* Unhash all classes that were created by a module. */\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (!within(class->key, start, size) &&\n\t\t\t    !within(class->name, start, size))\n\t\t\t\tcontinue;\n\t\t\tzap_class(pf, class);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)"
          ],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static struct hlist_head classhash_table[CLASSHASH_SIZE];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic struct hlist_head classhash_table[CLASSHASH_SIZE];\nstatic noinstr struct;\n\nstatic void __lockdep_free_key_range(struct pending_free *pf, void *start,\n\t\t\t\t     unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i;\n\n\t/* Unhash all classes that were created by a module. */\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (!within(class->key, start, size) &&\n\t\t\t    !within(class->name, start, size))\n\t\t\t\tcontinue;\n\t\t\tzap_class(pf, class);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pending_free",
          "args": [],
          "line": 6152
        },
        "resolved": true,
        "details": {
          "function_name": "get_pending_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6037-6040",
          "snippet": "static struct pending_free *get_pending_free(void)\n{\n\treturn delayed_free.pf + delayed_free.index;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic struct pending_free *get_pending_free(void)\n{\n\treturn delayed_free.pf + delayed_free.index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_lock",
          "args": [],
          "line": 6151
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "108-115",
          "snippet": "static inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 6150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_data_structures_once",
          "args": [],
          "line": 6148
        },
        "resolved": true,
        "details": {
          "function_name": "init_data_structures_once",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1150-1177",
          "snippet": "static void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static LIST_HEAD(free_lock_classes);",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static void init_chain_block_buckets(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic LIST_HEAD(free_lock_classes);\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic void init_chain_block_buckets(void);\n\nstatic void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void lockdep_free_key_range_reg(void *start, unsigned long size)\n{\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\n\tinit_data_structures_once();\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\tpf = get_pending_free();\n\t__lockdep_free_key_range(pf, start, size);\n\tcall_rcu_zapped(pf);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n\n\t/*\n\t * Wait for any possible iterators from look_up_lock_class() to pass\n\t * before continuing to free the memory they refer to.\n\t */\n\tsynchronize_rcu();\n}"
  },
  {
    "function_name": "__lockdep_free_key_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6116-6133",
    "snippet": "static void __lockdep_free_key_range(struct pending_free *pf, void *start,\n\t\t\t\t     unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i;\n\n\t/* Unhash all classes that were created by a module. */\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (!within(class->key, start, size) &&\n\t\t\t    !within(class->name, start, size))\n\t\t\t\tcontinue;\n\t\t\tzap_class(pf, class);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)"
    ],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static struct hlist_head classhash_table[CLASSHASH_SIZE];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zap_class",
          "args": [
            "pf",
            "class"
          ],
          "line": 6130
        },
        "resolved": true,
        "details": {
          "function_name": "zap_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5976-6010",
          "snippet": "static void zap_class(struct pending_free *pf, struct lock_class *class)\n{\n\tstruct lock_list *entry;\n\tint i;\n\n\tWARN_ON_ONCE(!class->key);\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\tentry = list_entries + i;\n\t\tif (entry->class != class && entry->links_to != class)\n\t\t\tcontinue;\n\t\t__clear_bit(i, list_entries_in_use);\n\t\tnr_list_entries--;\n\t\tlist_del_rcu(&entry->entry);\n\t}\n\tif (list_empty(&class->locks_after) &&\n\t    list_empty(&class->locks_before)) {\n\t\tlist_move_tail(&class->lock_entry, &pf->zapped);\n\t\thlist_del_rcu(&class->hash_entry);\n\t\tWRITE_ONCE(class->key, NULL);\n\t\tWRITE_ONCE(class->name, NULL);\n\t\tnr_lock_classes--;\n\t\t__clear_bit(class - lock_classes, lock_classes_in_use);\n\t} else {\n\t\tWARN_ONCE(true, \"%s() failed for class %s\\n\", __func__,\n\t\t\t  class->name);\n\t}\n\n\tremove_class_from_lock_chains(pf, class);\n\tnr_zapped_classes++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_list_entries;",
            "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];",
            "unsigned long nr_lock_classes;",
            "unsigned long nr_zapped_classes;",
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\nunsigned long nr_lock_classes;\nunsigned long nr_zapped_classes;\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void zap_class(struct pending_free *pf, struct lock_class *class)\n{\n\tstruct lock_list *entry;\n\tint i;\n\n\tWARN_ON_ONCE(!class->key);\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\tentry = list_entries + i;\n\t\tif (entry->class != class && entry->links_to != class)\n\t\t\tcontinue;\n\t\t__clear_bit(i, list_entries_in_use);\n\t\tnr_list_entries--;\n\t\tlist_del_rcu(&entry->entry);\n\t}\n\tif (list_empty(&class->locks_after) &&\n\t    list_empty(&class->locks_before)) {\n\t\tlist_move_tail(&class->lock_entry, &pf->zapped);\n\t\thlist_del_rcu(&class->hash_entry);\n\t\tWRITE_ONCE(class->key, NULL);\n\t\tWRITE_ONCE(class->name, NULL);\n\t\tnr_lock_classes--;\n\t\t__clear_bit(class - lock_classes, lock_classes_in_use);\n\t} else {\n\t\tWARN_ONCE(true, \"%s() failed for class %s\\n\", __func__,\n\t\t\t  class->name);\n\t}\n\n\tremove_class_from_lock_chains(pf, class);\n\tnr_zapped_classes++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "within",
          "args": [
            "class->name",
            "start",
            "size"
          ],
          "line": 6128
        },
        "resolved": true,
        "details": {
          "function_name": "within",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6026-6029",
          "snippet": "static inline int within(const void *addr, void *start, unsigned long size)\n{\n\treturn addr >= start && addr < start + size;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int within(const void *addr, void *start, unsigned long size)\n{\n\treturn addr >= start && addr < start + size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "class",
            "head",
            "hash_entry"
          ],
          "line": 6126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic struct hlist_head classhash_table[CLASSHASH_SIZE];\nstatic noinstr struct;\n\nstatic void __lockdep_free_key_range(struct pending_free *pf, void *start,\n\t\t\t\t     unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tint i;\n\n\t/* Unhash all classes that were created by a module. */\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (!within(class->key, start, size) &&\n\t\t\t    !within(class->name, start, size))\n\t\t\t\tcontinue;\n\t\t\tzap_class(pf, class);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "free_zapped_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6085-6108",
    "snippet": "static void free_zapped_rcu(struct rcu_head *ch)\n{\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(ch != &delayed_free.rcu_head))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\n\t/* closed head */\n\tpf = delayed_free.pf + (delayed_free.index ^ 1);\n\t__free_zapped_classes(pf);\n\tdelayed_free.scheduled = false;\n\n\t/*\n\t * If there's anything on the open list, close and start a new callback.\n\t */\n\tcall_rcu_zapped(delayed_free.pf + delayed_free.index);\n\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 6107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_unlock",
          "args": [],
          "line": 6106
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "117-127",
          "snippet": "static inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu_zapped",
          "args": [
            "delayed_free.pf + delayed_free.index"
          ],
          "line": 6104
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_zapped",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6048-6064",
          "snippet": "static void call_rcu_zapped(struct pending_free *pf)\n{\n\tWARN_ON_ONCE(inside_selftest());\n\n\tif (list_empty(&pf->zapped))\n\t\treturn;\n\n\tif (delayed_free.scheduled)\n\t\treturn;\n\n\tdelayed_free.scheduled = true;\n\n\tWARN_ON_ONCE(delayed_free.pf + delayed_free.index != pf);\n\tdelayed_free.index ^= 1;\n\n\tcall_rcu(&delayed_free.rcu_head, free_zapped_rcu);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void call_rcu_zapped(struct pending_free *pf)\n{\n\tWARN_ON_ONCE(inside_selftest());\n\n\tif (list_empty(&pf->zapped))\n\t\treturn;\n\n\tif (delayed_free.scheduled)\n\t\treturn;\n\n\tdelayed_free.scheduled = true;\n\n\tWARN_ON_ONCE(delayed_free.pf + delayed_free.index != pf);\n\tdelayed_free.index ^= 1;\n\n\tcall_rcu(&delayed_free.rcu_head, free_zapped_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_zapped_classes",
          "args": [
            "pf"
          ],
          "line": 6098
        },
        "resolved": true,
        "details": {
          "function_name": "__free_zapped_classes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6067-6083",
          "snippet": "static void __free_zapped_classes(struct pending_free *pf)\n{\n\tstruct lock_class *class;\n\n\tcheck_data_structures();\n\n\tlist_for_each_entry(class, &pf->zapped, lock_entry)\n\t\treinit_class(class);\n\n\tlist_splice_init(&pf->zapped, &free_lock_classes);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tbitmap_andnot(lock_chains_in_use, lock_chains_in_use,\n\t\t      pf->lock_chains_being_freed, ARRAY_SIZE(lock_chains));\n\tbitmap_clear(pf->lock_chains_being_freed, 0, ARRAY_SIZE(lock_chains));\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(free_lock_classes);",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic LIST_HEAD(free_lock_classes);\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void __free_zapped_classes(struct pending_free *pf)\n{\n\tstruct lock_class *class;\n\n\tcheck_data_structures();\n\n\tlist_for_each_entry(class, &pf->zapped, lock_entry)\n\t\treinit_class(class);\n\n\tlist_splice_init(&pf->zapped, &free_lock_classes);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tbitmap_andnot(lock_chains_in_use, lock_chains_in_use,\n\t\t      pf->lock_chains_being_freed, ARRAY_SIZE(lock_chains));\n\tbitmap_clear(pf->lock_chains_being_freed, 0, ARRAY_SIZE(lock_chains));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_lock",
          "args": [],
          "line": 6094
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "108-115",
          "snippet": "static inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 6093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ch != &delayed_free.rcu_head"
          ],
          "line": 6090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void free_zapped_rcu(struct rcu_head *ch)\n{\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(ch != &delayed_free.rcu_head))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\n\t/* closed head */\n\tpf = delayed_free.pf + (delayed_free.index ^ 1);\n\t__free_zapped_classes(pf);\n\tdelayed_free.scheduled = false;\n\n\t/*\n\t * If there's anything on the open list, close and start a new callback.\n\t */\n\tcall_rcu_zapped(delayed_free.pf + delayed_free.index);\n\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "__free_zapped_classes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6067-6083",
    "snippet": "static void __free_zapped_classes(struct pending_free *pf)\n{\n\tstruct lock_class *class;\n\n\tcheck_data_structures();\n\n\tlist_for_each_entry(class, &pf->zapped, lock_entry)\n\t\treinit_class(class);\n\n\tlist_splice_init(&pf->zapped, &free_lock_classes);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tbitmap_andnot(lock_chains_in_use, lock_chains_in_use,\n\t\t      pf->lock_chains_being_freed, ARRAY_SIZE(lock_chains));\n\tbitmap_clear(pf->lock_chains_being_freed, 0, ARRAY_SIZE(lock_chains));\n#endif\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(free_lock_classes);",
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_clear",
          "args": [
            "pf->lock_chains_being_freed",
            "0",
            "ARRAY_SIZE(lock_chains)"
          ],
          "line": 6081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_chains"
          ],
          "line": 6081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_andnot",
          "args": [
            "lock_chains_in_use",
            "lock_chains_in_use",
            "pf->lock_chains_being_freed",
            "ARRAY_SIZE(lock_chains)"
          ],
          "line": 6079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_chains"
          ],
          "line": 6080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&pf->zapped",
            "&free_lock_classes"
          ],
          "line": 6076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinit_class",
          "args": [
            "class"
          ],
          "line": 6074
        },
        "resolved": true,
        "details": {
          "function_name": "reinit_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6012-6024",
          "snippet": "static void reinit_class(struct lock_class *class)\n{\n\tvoid *const p = class;\n\tconst unsigned int offset = offsetof(struct lock_class, key);\n\n\tWARN_ON_ONCE(!class->lock_entry.next);\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tmemset(p + offset, 0, sizeof(*class) - offset);\n\tWARN_ON_ONCE(!class->lock_entry.next);\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void reinit_class(struct lock_class *class)\n{\n\tvoid *const p = class;\n\tconst unsigned int offset = offsetof(struct lock_class, key);\n\n\tWARN_ON_ONCE(!class->lock_entry.next);\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tmemset(p + offset, 0, sizeof(*class) - offset);\n\tWARN_ON_ONCE(!class->lock_entry.next);\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "class",
            "&pf->zapped",
            "lock_entry"
          ],
          "line": 6073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_data_structures",
          "args": [],
          "line": 6071
        },
        "resolved": true,
        "details": {
          "function_name": "check_data_structures",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1140-1140",
          "snippet": "static inline void check_data_structures(void) { }",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void check_data_structures(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic LIST_HEAD(free_lock_classes);\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void __free_zapped_classes(struct pending_free *pf)\n{\n\tstruct lock_class *class;\n\n\tcheck_data_structures();\n\n\tlist_for_each_entry(class, &pf->zapped, lock_entry)\n\t\treinit_class(class);\n\n\tlist_splice_init(&pf->zapped, &free_lock_classes);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tbitmap_andnot(lock_chains_in_use, lock_chains_in_use,\n\t\t      pf->lock_chains_being_freed, ARRAY_SIZE(lock_chains));\n\tbitmap_clear(pf->lock_chains_being_freed, 0, ARRAY_SIZE(lock_chains));\n#endif\n}"
  },
  {
    "function_name": "call_rcu_zapped",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6048-6064",
    "snippet": "static void call_rcu_zapped(struct pending_free *pf)\n{\n\tWARN_ON_ONCE(inside_selftest());\n\n\tif (list_empty(&pf->zapped))\n\t\treturn;\n\n\tif (delayed_free.scheduled)\n\t\treturn;\n\n\tdelayed_free.scheduled = true;\n\n\tWARN_ON_ONCE(delayed_free.pf + delayed_free.index != pf);\n\tdelayed_free.index ^= 1;\n\n\tcall_rcu(&delayed_free.rcu_head, free_zapped_rcu);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&delayed_free.rcu_head",
            "free_zapped_rcu"
          ],
          "line": 6063
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "delayed_free.pf + delayed_free.index != pf"
          ],
          "line": 6060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pf->zapped"
          ],
          "line": 6052
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "inside_selftest()"
          ],
          "line": 6050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside_selftest",
          "args": [],
          "line": 6050
        },
        "resolved": true,
        "details": {
          "function_name": "inside_selftest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6031-6034",
          "snippet": "static bool inside_selftest(void)\n{\n\treturn current == lockdep_selftest_task_struct;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *lockdep_selftest_task_struct;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct task_struct *lockdep_selftest_task_struct;\n\nstatic bool inside_selftest(void)\n{\n\treturn current == lockdep_selftest_task_struct;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void call_rcu_zapped(struct pending_free *pf)\n{\n\tWARN_ON_ONCE(inside_selftest());\n\n\tif (list_empty(&pf->zapped))\n\t\treturn;\n\n\tif (delayed_free.scheduled)\n\t\treturn;\n\n\tdelayed_free.scheduled = true;\n\n\tWARN_ON_ONCE(delayed_free.pf + delayed_free.index != pf);\n\tdelayed_free.index ^= 1;\n\n\tcall_rcu(&delayed_free.rcu_head, free_zapped_rcu);\n}"
  },
  {
    "function_name": "get_pending_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6037-6040",
    "snippet": "static struct pending_free *get_pending_free(void)\n{\n\treturn delayed_free.pf + delayed_free.index;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic struct pending_free *get_pending_free(void)\n{\n\treturn delayed_free.pf + delayed_free.index;\n}"
  },
  {
    "function_name": "inside_selftest",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6031-6034",
    "snippet": "static bool inside_selftest(void)\n{\n\treturn current == lockdep_selftest_task_struct;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *lockdep_selftest_task_struct;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct task_struct *lockdep_selftest_task_struct;\n\nstatic bool inside_selftest(void)\n{\n\treturn current == lockdep_selftest_task_struct;\n}"
  },
  {
    "function_name": "within",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6026-6029",
    "snippet": "static inline int within(const void *addr, void *start, unsigned long size)\n{\n\treturn addr >= start && addr < start + size;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int within(const void *addr, void *start, unsigned long size)\n{\n\treturn addr >= start && addr < start + size;\n}"
  },
  {
    "function_name": "reinit_class",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "6012-6024",
    "snippet": "static void reinit_class(struct lock_class *class)\n{\n\tvoid *const p = class;\n\tconst unsigned int offset = offsetof(struct lock_class, key);\n\n\tWARN_ON_ONCE(!class->lock_entry.next);\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tmemset(p + offset, 0, sizeof(*class) - offset);\n\tWARN_ON_ONCE(!class->lock_entry.next);\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&class->locks_before)"
          ],
          "line": 6023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&class->locks_before"
          ],
          "line": 6023
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&class->locks_after)"
          ],
          "line": 6022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!class->lock_entry.next"
          ],
          "line": 6021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p + offset",
            "0",
            "sizeof(*class) - offset"
          ],
          "line": 6020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&class->locks_before)"
          ],
          "line": 6019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&class->locks_after)"
          ],
          "line": 6018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!class->lock_entry.next"
          ],
          "line": 6017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void reinit_class(struct lock_class *class)\n{\n\tvoid *const p = class;\n\tconst unsigned int offset = offsetof(struct lock_class, key);\n\n\tWARN_ON_ONCE(!class->lock_entry.next);\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tmemset(p + offset, 0, sizeof(*class) - offset);\n\tWARN_ON_ONCE(!class->lock_entry.next);\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n}"
  },
  {
    "function_name": "zap_class",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5976-6010",
    "snippet": "static void zap_class(struct pending_free *pf, struct lock_class *class)\n{\n\tstruct lock_list *entry;\n\tint i;\n\n\tWARN_ON_ONCE(!class->key);\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\tentry = list_entries + i;\n\t\tif (entry->class != class && entry->links_to != class)\n\t\t\tcontinue;\n\t\t__clear_bit(i, list_entries_in_use);\n\t\tnr_list_entries--;\n\t\tlist_del_rcu(&entry->entry);\n\t}\n\tif (list_empty(&class->locks_after) &&\n\t    list_empty(&class->locks_before)) {\n\t\tlist_move_tail(&class->lock_entry, &pf->zapped);\n\t\thlist_del_rcu(&class->hash_entry);\n\t\tWRITE_ONCE(class->key, NULL);\n\t\tWRITE_ONCE(class->name, NULL);\n\t\tnr_lock_classes--;\n\t\t__clear_bit(class - lock_classes, lock_classes_in_use);\n\t} else {\n\t\tWARN_ONCE(true, \"%s() failed for class %s\\n\", __func__,\n\t\t\t  class->name);\n\t}\n\n\tremove_class_from_lock_chains(pf, class);\n\tnr_zapped_classes++;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long nr_list_entries;",
      "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];",
      "unsigned long nr_lock_classes;",
      "unsigned long nr_zapped_classes;",
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_class_from_lock_chains",
          "args": [
            "pf",
            "class"
          ],
          "line": 6008
        },
        "resolved": true,
        "details": {
          "function_name": "remove_class_from_lock_chains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5958-5971",
          "snippet": "static void remove_class_from_lock_chains(struct pending_free *pf,\n\t\t\t\t\t  struct lock_class *class)\n{\n\tstruct lock_chain *chain;\n\tstruct hlist_head *head;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(chainhash_table); i++) {\n\t\thead = chainhash_table + i;\n\t\thlist_for_each_entry_rcu(chain, head, entry) {\n\t\t\tremove_class_from_lock_chain(pf, chain, class);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static struct hlist_head chainhash_table[CHAINHASH_SIZE];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic struct hlist_head chainhash_table[CHAINHASH_SIZE];\nstatic noinstr struct;\n\nstatic void remove_class_from_lock_chains(struct pending_free *pf,\n\t\t\t\t\t  struct lock_class *class)\n{\n\tstruct lock_chain *chain;\n\tstruct hlist_head *head;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(chainhash_table); i++) {\n\t\thead = chainhash_table + i;\n\t\thlist_for_each_entry_rcu(chain, head, entry) {\n\t\t\tremove_class_from_lock_chain(pf, chain, class);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "true",
            "\"%s() failed for class %s\\n\"",
            "__func__",
            "class->name"
          ],
          "line": 6004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "class - lock_classes",
            "lock_classes_in_use"
          ],
          "line": 6002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "class->name",
            "NULL"
          ],
          "line": 6000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "class->key",
            "NULL"
          ],
          "line": 5999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&class->hash_entry"
          ],
          "line": 5998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&class->lock_entry",
            "&pf->zapped"
          ],
          "line": 5997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&class->locks_before"
          ],
          "line": 5996
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&entry->entry"
          ],
          "line": 5993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "i",
            "list_entries_in_use"
          ],
          "line": 5991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "list_entries_in_use",
            "ARRAY_SIZE(list_entries)"
          ],
          "line": 5987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "list_entries"
          ],
          "line": 5987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!class->key"
          ],
          "line": 5981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\nunsigned long nr_lock_classes;\nunsigned long nr_zapped_classes;\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void zap_class(struct pending_free *pf, struct lock_class *class)\n{\n\tstruct lock_list *entry;\n\tint i;\n\n\tWARN_ON_ONCE(!class->key);\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\tentry = list_entries + i;\n\t\tif (entry->class != class && entry->links_to != class)\n\t\t\tcontinue;\n\t\t__clear_bit(i, list_entries_in_use);\n\t\tnr_list_entries--;\n\t\tlist_del_rcu(&entry->entry);\n\t}\n\tif (list_empty(&class->locks_after) &&\n\t    list_empty(&class->locks_before)) {\n\t\tlist_move_tail(&class->lock_entry, &pf->zapped);\n\t\thlist_del_rcu(&class->hash_entry);\n\t\tWRITE_ONCE(class->key, NULL);\n\t\tWRITE_ONCE(class->name, NULL);\n\t\tnr_lock_classes--;\n\t\t__clear_bit(class - lock_classes, lock_classes_in_use);\n\t} else {\n\t\tWARN_ONCE(true, \"%s() failed for class %s\\n\", __func__,\n\t\t\t  class->name);\n\t}\n\n\tremove_class_from_lock_chains(pf, class);\n\tnr_zapped_classes++;\n}"
  },
  {
    "function_name": "remove_class_from_lock_chains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5958-5971",
    "snippet": "static void remove_class_from_lock_chains(struct pending_free *pf,\n\t\t\t\t\t  struct lock_class *class)\n{\n\tstruct lock_chain *chain;\n\tstruct hlist_head *head;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(chainhash_table); i++) {\n\t\thead = chainhash_table + i;\n\t\thlist_for_each_entry_rcu(chain, head, entry) {\n\t\t\tremove_class_from_lock_chain(pf, chain, class);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static struct hlist_head chainhash_table[CHAINHASH_SIZE];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_class_from_lock_chain",
          "args": [
            "pf",
            "chain",
            "class"
          ],
          "line": 5968
        },
        "resolved": true,
        "details": {
          "function_name": "remove_class_from_lock_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5922-5955",
          "snippet": "static void remove_class_from_lock_chain(struct pending_free *pf,\n\t\t\t\t\t struct lock_chain *chain,\n\t\t\t\t\t struct lock_class *class)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tint i;\n\n\tfor (i = chain->base; i < chain->base + chain->depth; i++) {\n\t\tif (chain_hlock_class_idx(chain_hlocks[i]) != class - lock_classes)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Each lock class occurs at most once in a lock chain so once\n\t\t * we found a match we can break out of this loop.\n\t\t */\n\t\tgoto free_lock_chain;\n\t}\n\t/* Since the chain has not been modified, return. */\n\treturn;\n\nfree_lock_chain:\n\tfree_chain_hlocks(chain->base, chain->depth);\n\t/* Overwrite the chain key for concurrent RCU readers. */\n\tWRITE_ONCE(chain->chain_key, INITIAL_CHAIN_KEY);\n\tdec_chains(chain->irq_context);\n\n\t/*\n\t * Note: calling hlist_del_rcu() from inside a\n\t * hlist_for_each_entry_rcu() loop is safe.\n\t */\n\thlist_del_rcu(&chain->entry);\n\t__set_bit(chain - lock_chains, pf->lock_chains_being_freed);\n\tnr_zapped_lock_chains++;\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void remove_class_from_lock_chain(struct pending_free *pf,\n\t\t\t\t\t struct lock_chain *chain,\n\t\t\t\t\t struct lock_class *class)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tint i;\n\n\tfor (i = chain->base; i < chain->base + chain->depth; i++) {\n\t\tif (chain_hlock_class_idx(chain_hlocks[i]) != class - lock_classes)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Each lock class occurs at most once in a lock chain so once\n\t\t * we found a match we can break out of this loop.\n\t\t */\n\t\tgoto free_lock_chain;\n\t}\n\t/* Since the chain has not been modified, return. */\n\treturn;\n\nfree_lock_chain:\n\tfree_chain_hlocks(chain->base, chain->depth);\n\t/* Overwrite the chain key for concurrent RCU readers. */\n\tWRITE_ONCE(chain->chain_key, INITIAL_CHAIN_KEY);\n\tdec_chains(chain->irq_context);\n\n\t/*\n\t * Note: calling hlist_del_rcu() from inside a\n\t * hlist_for_each_entry_rcu() loop is safe.\n\t */\n\thlist_del_rcu(&chain->entry);\n\t__set_bit(chain - lock_chains, pf->lock_chains_being_freed);\n\tnr_zapped_lock_chains++;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "chain",
            "head",
            "entry"
          ],
          "line": 5967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "chainhash_table"
          ],
          "line": 5965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic struct hlist_head chainhash_table[CHAINHASH_SIZE];\nstatic noinstr struct;\n\nstatic void remove_class_from_lock_chains(struct pending_free *pf,\n\t\t\t\t\t  struct lock_class *class)\n{\n\tstruct lock_chain *chain;\n\tstruct hlist_head *head;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(chainhash_table); i++) {\n\t\thead = chainhash_table + i;\n\t\thlist_for_each_entry_rcu(chain, head, entry) {\n\t\t\tremove_class_from_lock_chain(pf, chain, class);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "remove_class_from_lock_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5922-5955",
    "snippet": "static void remove_class_from_lock_chain(struct pending_free *pf,\n\t\t\t\t\t struct lock_chain *chain,\n\t\t\t\t\t struct lock_class *class)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tint i;\n\n\tfor (i = chain->base; i < chain->base + chain->depth; i++) {\n\t\tif (chain_hlock_class_idx(chain_hlocks[i]) != class - lock_classes)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Each lock class occurs at most once in a lock chain so once\n\t\t * we found a match we can break out of this loop.\n\t\t */\n\t\tgoto free_lock_chain;\n\t}\n\t/* Since the chain has not been modified, return. */\n\treturn;\n\nfree_lock_chain:\n\tfree_chain_hlocks(chain->base, chain->depth);\n\t/* Overwrite the chain key for concurrent RCU readers. */\n\tWRITE_ONCE(chain->chain_key, INITIAL_CHAIN_KEY);\n\tdec_chains(chain->irq_context);\n\n\t/*\n\t * Note: calling hlist_del_rcu() from inside a\n\t * hlist_for_each_entry_rcu() loop is safe.\n\t */\n\thlist_del_rcu(&chain->entry);\n\t__set_bit(chain - lock_chains, pf->lock_chains_being_freed);\n\tnr_zapped_lock_chains++;\n#endif\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "chain - lock_chains",
            "pf->lock_chains_being_freed"
          ],
          "line": 5952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&chain->entry"
          ],
          "line": 5951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_chains",
          "args": [
            "chain->irq_context"
          ],
          "line": 5945
        },
        "resolved": true,
        "details": {
          "function_name": "dec_chains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2904-2912",
          "snippet": "static void dec_chains(int irq_context)\n{\n\tif (irq_context & LOCK_CHAIN_HARDIRQ_CONTEXT)\n\t\tnr_hardirq_chains--;\n\telse if (irq_context & LOCK_CHAIN_SOFTIRQ_CONTEXT)\n\t\tnr_softirq_chains--;\n\telse\n\t\tnr_process_chains--;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nr_hardirq_chains;",
            "unsigned int nr_softirq_chains;",
            "unsigned int nr_process_chains;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned int nr_hardirq_chains;\nunsigned int nr_softirq_chains;\nunsigned int nr_process_chains;\n\nstatic void dec_chains(int irq_context)\n{\n\tif (irq_context & LOCK_CHAIN_HARDIRQ_CONTEXT)\n\t\tnr_hardirq_chains--;\n\telse if (irq_context & LOCK_CHAIN_SOFTIRQ_CONTEXT)\n\t\tnr_softirq_chains--;\n\telse\n\t\tnr_process_chains--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "chain->chain_key",
            "INITIAL_CHAIN_KEY"
          ],
          "line": 5944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_chain_hlocks",
          "args": [
            "chain->base",
            "chain->depth"
          ],
          "line": 5942
        },
        "resolved": true,
        "details": {
          "function_name": "free_chain_hlocks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3455-3458",
          "snippet": "static inline void free_chain_hlocks(int base, int size)\n{\n\tadd_chain_block(base, max(size, 2));\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void free_chain_hlocks(int base, int size)\n{\n\tadd_chain_block(base, max(size, 2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "chain_hlock_class_idx",
          "args": [
            "chain_hlocks[i]"
          ],
          "line": 5930
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic void remove_class_from_lock_chain(struct pending_free *pf,\n\t\t\t\t\t struct lock_chain *chain,\n\t\t\t\t\t struct lock_class *class)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tint i;\n\n\tfor (i = chain->base; i < chain->base + chain->depth; i++) {\n\t\tif (chain_hlock_class_idx(chain_hlocks[i]) != class - lock_classes)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Each lock class occurs at most once in a lock chain so once\n\t\t * we found a match we can break out of this loop.\n\t\t */\n\t\tgoto free_lock_chain;\n\t}\n\t/* Since the chain has not been modified, return. */\n\treturn;\n\nfree_lock_chain:\n\tfree_chain_hlocks(chain->base, chain->depth);\n\t/* Overwrite the chain key for concurrent RCU readers. */\n\tWRITE_ONCE(chain->chain_key, INITIAL_CHAIN_KEY);\n\tdec_chains(chain->irq_context);\n\n\t/*\n\t * Note: calling hlist_del_rcu() from inside a\n\t * hlist_for_each_entry_rcu() loop is safe.\n\t */\n\thlist_del_rcu(&chain->entry);\n\t__set_bit(chain - lock_chains, pf->lock_chains_being_freed);\n\tnr_zapped_lock_chains++;\n#endif\n}"
  },
  {
    "function_name": "lockdep_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5904-5919",
    "snippet": "void lockdep_reset(void)\n{\n\tunsigned long flags;\n\tint i;\n\n\traw_local_irq_save(flags);\n\tlockdep_init_task(current);\n\tmemset(current->held_locks, 0, MAX_LOCK_DEPTH*sizeof(struct held_lock));\n\tnr_hardirq_chains = 0;\n\tnr_softirq_chains = 0;\n\tnr_process_chains = 0;\n\tdebug_locks = 1;\n\tfor (i = 0; i < CHAINHASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(chainhash_table + i);\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CHAINHASH_SIZE\t\t(1UL << CHAINHASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head chainhash_table[CHAINHASH_SIZE];",
      "unsigned int nr_hardirq_chains;",
      "unsigned int nr_softirq_chains;",
      "unsigned int nr_process_chains;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "chainhash_table + i"
          ],
          "line": 5917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "current->held_locks",
            "0",
            "MAX_LOCK_DEPTH*sizeof(struct held_lock)"
          ],
          "line": 5911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_init_task",
          "args": [
            "current"
          ],
          "line": 5910
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "424-429",
          "snippet": "void lockdep_init_task(struct task_struct *task)\n{\n\ttask->lockdep_depth = 0; /* no locks held yet */\n\ttask->curr_chain_key = INITIAL_CHAIN_KEY;\n\ttask->lockdep_recursion = 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_init_task(struct task_struct *task)\n{\n\ttask->lockdep_depth = 0; /* no locks held yet */\n\ttask->curr_chain_key = INITIAL_CHAIN_KEY;\n\ttask->lockdep_recursion = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAINHASH_SIZE\t\t(1UL << CHAINHASH_BITS)\n\nstatic struct hlist_head chainhash_table[CHAINHASH_SIZE];\nunsigned int nr_hardirq_chains;\nunsigned int nr_softirq_chains;\nunsigned int nr_process_chains;\nstatic noinstr struct;\n\nvoid lockdep_reset(void)\n{\n\tunsigned long flags;\n\tint i;\n\n\traw_local_irq_save(flags);\n\tlockdep_init_task(current);\n\tmemset(current->held_locks, 0, MAX_LOCK_DEPTH*sizeof(struct held_lock));\n\tnr_hardirq_chains = 0;\n\tnr_softirq_chains = 0;\n\tnr_process_chains = 0;\n\tdebug_locks = 1;\n\tfor (i = 0; i < CHAINHASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(chainhash_table + i);\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_acquired",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5880-5895",
    "snippet": "void lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\ttrace_lock_acquired(lock, ip);\n\n\tif (unlikely(!lock_stat || !lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\tlockdep_recursion_inc();\n\t__lock_acquired(lock, ip);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define lock_stat 0"
    ],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 5893
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_acquired",
          "args": [
            "lock",
            "ip"
          ],
          "line": 5892
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5814-5860",
          "snippet": "static void\n__lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tu64 now, waittime = 0;\n\tint i, cpu;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Yay, we acquired ownership of this lock we didn't try to\n\t * acquire, how the heck did that happen?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, _RET_IP_);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tif (hlock->waittime_stamp) {\n\t\tnow = lockstat_clock();\n\t\twaittime = now - hlock->waittime_stamp;\n\t\thlock->holdtime_stamp = now;\n\t}\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (waittime) {\n\t\tif (hlock->read)\n\t\t\tlock_time_inc(&stats->read_waittime, waittime);\n\t\telse\n\t\t\tlock_time_inc(&stats->write_waittime, waittime);\n\t}\n\tif (lock->cpu != cpu)\n\t\tstats->bounces[bounce_acquired + !!hlock->read]++;\n\n\tlock->cpu = cpu;\n\tlock->ip = ip;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void\n__lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tu64 now, waittime = 0;\n\tint i, cpu;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Yay, we acquired ownership of this lock we didn't try to\n\t * acquire, how the heck did that happen?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, _RET_IP_);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tif (hlock->waittime_stamp) {\n\t\tnow = lockstat_clock();\n\t\twaittime = now - hlock->waittime_stamp;\n\t\thlock->holdtime_stamp = now;\n\t}\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (waittime) {\n\t\tif (hlock->read)\n\t\t\tlock_time_inc(&stats->read_waittime, waittime);\n\t\telse\n\t\t\tlock_time_inc(&stats->write_waittime, waittime);\n\t}\n\tif (lock->cpu != cpu)\n\t\tstats->bounces[bounce_acquired + !!hlock->read]++;\n\n\tlock->cpu = cpu;\n\tlock->ip = ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 5891
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 5890
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5469-5510",
          "snippet": "static noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lock_stat || !lockdep_enabled()"
          ],
          "line": 5886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 5886
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_lock_acquired",
          "args": [
            "lock",
            "ip"
          ],
          "line": 5884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic noinstr struct;\n\nvoid lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\ttrace_lock_acquired(lock, ip);\n\n\tif (unlikely(!lock_stat || !lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\tlockdep_recursion_inc();\n\t__lock_acquired(lock, ip);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_contended",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5862-5877",
    "snippet": "void lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\ttrace_lock_contended(lock, ip);\n\n\tif (unlikely(!lock_stat || !lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\tlockdep_recursion_inc();\n\t__lock_contended(lock, ip);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define lock_stat 0"
    ],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 5875
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_contended",
          "args": [
            "lock",
            "ip"
          ],
          "line": 5874
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_contended",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5773-5812",
          "snippet": "static void\n__lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tint i, contention_point, contending_point;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Whee, we contended on this lock, except it seems we're not\n\t * actually trying to acquire anything much at all..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, ip);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\thlock->waittime_stamp = lockstat_clock();\n\n\tcontention_point = lock_point(hlock_class(hlock)->contention_point, ip);\n\tcontending_point = lock_point(hlock_class(hlock)->contending_point,\n\t\t\t\t      lock->ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (contention_point < LOCKSTAT_POINTS)\n\t\tstats->contention_point[contention_point]++;\n\tif (contending_point < LOCKSTAT_POINTS)\n\t\tstats->contending_point[contending_point]++;\n\tif (lock->cpu != smp_processor_id())\n\t\tstats->bounces[bounce_contended + !!hlock->read]++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void\n__lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tint i, contention_point, contending_point;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Whee, we contended on this lock, except it seems we're not\n\t * actually trying to acquire anything much at all..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, ip);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\thlock->waittime_stamp = lockstat_clock();\n\n\tcontention_point = lock_point(hlock_class(hlock)->contention_point, ip);\n\tcontending_point = lock_point(hlock_class(hlock)->contending_point,\n\t\t\t\t      lock->ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (contention_point < LOCKSTAT_POINTS)\n\t\tstats->contention_point[contention_point]++;\n\tif (contending_point < LOCKSTAT_POINTS)\n\t\tstats->contending_point[contending_point]++;\n\tif (lock->cpu != smp_processor_id())\n\t\tstats->bounces[bounce_contended + !!hlock->read]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 5873
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 5872
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5469-5510",
          "snippet": "static noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lock_stat || !lockdep_enabled()"
          ],
          "line": 5868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 5868
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_lock_contended",
          "args": [
            "lock",
            "ip"
          ],
          "line": 5866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic noinstr struct;\n\nvoid lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\ttrace_lock_contended(lock, ip);\n\n\tif (unlikely(!lock_stat || !lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\tlockdep_recursion_inc();\n\t__lock_contended(lock, ip);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "__lock_acquired",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5814-5860",
    "snippet": "static void\n__lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tu64 now, waittime = 0;\n\tint i, cpu;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Yay, we acquired ownership of this lock we didn't try to\n\t * acquire, how the heck did that happen?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, _RET_IP_);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tif (hlock->waittime_stamp) {\n\t\tnow = lockstat_clock();\n\t\twaittime = now - hlock->waittime_stamp;\n\t\thlock->holdtime_stamp = now;\n\t}\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (waittime) {\n\t\tif (hlock->read)\n\t\t\tlock_time_inc(&stats->read_waittime, waittime);\n\t\telse\n\t\t\tlock_time_inc(&stats->write_waittime, waittime);\n\t}\n\tif (lock->cpu != cpu)\n\t\tstats->bounces[bounce_acquired + !!hlock->read]++;\n\n\tlock->cpu = cpu;\n\tlock->ip = ip;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_time_inc",
          "args": [
            "&stats->write_waittime",
            "waittime"
          ],
          "line": 5853
        },
        "resolved": true,
        "details": {
          "function_name": "lock_time_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "238-248",
          "snippet": "static void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_stats",
          "args": [
            "hlock_class(hlock)"
          ],
          "line": 5848
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "308-311",
          "snippet": "static struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 5848
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockstat_clock",
          "args": [],
          "line": 5843
        },
        "resolved": true,
        "details": {
          "function_name": "lockstat_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "217-220",
          "snippet": "static inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 5841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock_contention_bug",
          "args": [
            "curr",
            "lock",
            "_RET_IP_"
          ],
          "line": 5834
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_contention_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5746-5771",
          "snippet": "static void print_lock_contention_bug(struct task_struct *curr,\n\t\t\t\t      struct lockdep_map *lock,\n\t\t\t\t      unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_contention_bug(struct task_struct *curr,\n\t\t\t\t      struct lockdep_map *lock,\n\t\t\t\t      unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_held_lock",
          "args": [
            "curr",
            "lock",
            "depth",
            "&i"
          ],
          "line": 5832
        },
        "resolved": true,
        "details": {
          "function_name": "find_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5120-5153",
          "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!depth"
          ],
          "line": 5829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void\n__lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tu64 now, waittime = 0;\n\tint i, cpu;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Yay, we acquired ownership of this lock we didn't try to\n\t * acquire, how the heck did that happen?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, _RET_IP_);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tif (hlock->waittime_stamp) {\n\t\tnow = lockstat_clock();\n\t\twaittime = now - hlock->waittime_stamp;\n\t\thlock->holdtime_stamp = now;\n\t}\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (waittime) {\n\t\tif (hlock->read)\n\t\t\tlock_time_inc(&stats->read_waittime, waittime);\n\t\telse\n\t\t\tlock_time_inc(&stats->write_waittime, waittime);\n\t}\n\tif (lock->cpu != cpu)\n\t\tstats->bounces[bounce_acquired + !!hlock->read]++;\n\n\tlock->cpu = cpu;\n\tlock->ip = ip;\n}"
  },
  {
    "function_name": "__lock_contended",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5773-5812",
    "snippet": "static void\n__lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tint i, contention_point, contending_point;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Whee, we contended on this lock, except it seems we're not\n\t * actually trying to acquire anything much at all..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, ip);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\thlock->waittime_stamp = lockstat_clock();\n\n\tcontention_point = lock_point(hlock_class(hlock)->contention_point, ip);\n\tcontending_point = lock_point(hlock_class(hlock)->contending_point,\n\t\t\t\t      lock->ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (contention_point < LOCKSTAT_POINTS)\n\t\tstats->contention_point[contention_point]++;\n\tif (contending_point < LOCKSTAT_POINTS)\n\t\tstats->contending_point[contending_point]++;\n\tif (lock->cpu != smp_processor_id())\n\t\tstats->bounces[bounce_contended + !!hlock->read]++;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 5810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_lock_stats",
          "args": [
            "hlock_class(hlock)"
          ],
          "line": 5805
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "308-311",
          "snippet": "static struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 5805
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_point",
          "args": [
            "hlock_class(hlock)->contending_point",
            "lock->ip"
          ],
          "line": 5802
        },
        "resolved": true,
        "details": {
          "function_name": "lock_point",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "222-236",
          "snippet": "static int lock_point(unsigned long points[], unsigned long ip)\n{\n\tint i;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tif (points[i] == 0) {\n\t\t\tpoints[i] = ip;\n\t\t\tbreak;\n\t\t}\n\t\tif (points[i] == ip)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int lock_point(unsigned long points[], unsigned long ip)\n{\n\tint i;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tif (points[i] == 0) {\n\t\t\tpoints[i] = ip;\n\t\t\tbreak;\n\t\t}\n\t\tif (points[i] == ip)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockstat_clock",
          "args": [],
          "line": 5799
        },
        "resolved": true,
        "details": {
          "function_name": "lockstat_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "217-220",
          "snippet": "static inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_contention_bug",
          "args": [
            "curr",
            "lock",
            "ip"
          ],
          "line": 5792
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_contention_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5746-5771",
          "snippet": "static void print_lock_contention_bug(struct task_struct *curr,\n\t\t\t\t      struct lockdep_map *lock,\n\t\t\t\t      unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_contention_bug(struct task_struct *curr,\n\t\t\t\t      struct lockdep_map *lock,\n\t\t\t\t      unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_held_lock",
          "args": [
            "curr",
            "lock",
            "depth",
            "&i"
          ],
          "line": 5790
        },
        "resolved": true,
        "details": {
          "function_name": "find_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5120-5153",
          "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!depth"
          ],
          "line": 5787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void\n__lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tint i, contention_point, contending_point;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Whee, we contended on this lock, except it seems we're not\n\t * actually trying to acquire anything much at all..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, ip);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\thlock->waittime_stamp = lockstat_clock();\n\n\tcontention_point = lock_point(hlock_class(hlock)->contention_point, ip);\n\tcontending_point = lock_point(hlock_class(hlock)->contending_point,\n\t\t\t\t      lock->ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (contention_point < LOCKSTAT_POINTS)\n\t\tstats->contention_point[contention_point]++;\n\tif (contending_point < LOCKSTAT_POINTS)\n\t\tstats->contending_point[contending_point]++;\n\tif (lock->cpu != smp_processor_id())\n\t\tstats->bounces[bounce_contended + !!hlock->read]++;\n}"
  },
  {
    "function_name": "print_lock_contention_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5746-5771",
    "snippet": "static void print_lock_contention_bug(struct task_struct *curr,\n\t\t\t\t      struct lockdep_map *lock,\n\t\t\t\t      unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 5770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 5769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 5767
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 5766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"but there are no locks held!\\n\""
          ],
          "line": 5765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "KERN_WARNING",
            "ip"
          ],
          "line": 5764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\") at:\\n\""
          ],
          "line": 5763
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lockdep_cache",
          "args": [
            "lock"
          ],
          "line": 5762
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "714-724",
          "snippet": "static void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is trying to contend lock (\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 5760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 5761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"---------------------------------\\n\""
          ],
          "line": 5759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 5758
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: bad contention detected!\\n\""
          ],
          "line": 5757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=================================\\n\""
          ],
          "line": 5756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 5755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 5750
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_contention_bug(struct task_struct *curr,\n\t\t\t\t      struct lockdep_map *lock,\n\t\t\t\t      unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "lock_unpin_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5728-5742",
    "snippet": "void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\t__lock_unpin_lock(lock, cookie);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 5740
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_unpin_lock",
          "args": [
            "lock",
            "cookie"
          ],
          "line": 5739
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_unpin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5439-5464",
          "snippet": "static void __lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (WARN(!hlock->pin_count, \"unpinning an unpinned lock\\n\"))\n\t\t\t\treturn;\n\n\t\t\thlock->pin_count -= cookie.val;\n\n\t\t\tif (WARN((int)hlock->pin_count < 0, \"pin count corrupted\\n\"))\n\t\t\t\thlock->pin_count = 0;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"unpinning an unheld lock\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (WARN(!hlock->pin_count, \"unpinning an unpinned lock\\n\"))\n\t\t\t\treturn;\n\n\t\t\thlock->pin_count -= cookie.val;\n\n\t\t\tif (WARN((int)hlock->pin_count < 0, \"pin count corrupted\\n\"))\n\t\t\t\thlock->pin_count = 0;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"unpinning an unheld lock\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 5738
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 5736
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5469-5510",
          "snippet": "static noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lockdep_enabled()"
          ],
          "line": 5732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 5732
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\t__lock_unpin_lock(lock, cookie);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_repin_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5711-5725",
    "snippet": "void lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\t__lock_repin_lock(lock, cookie);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 5723
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_repin_lock",
          "args": [
            "lock",
            "cookie"
          ],
          "line": 5722
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_repin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5419-5437",
          "snippet": "static void __lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 5721
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 5719
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5469-5510",
          "snippet": "static noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lockdep_enabled()"
          ],
          "line": 5715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 5715
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\t__lock_repin_lock(lock, cookie);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_pin_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5691-5708",
    "snippet": "struct pin_cookie lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tunsigned long flags;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn cookie;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\tcookie = __lock_pin_lock(lock);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n\n\treturn cookie;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 5704
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_pin_lock",
          "args": [
            "lock"
          ],
          "line": 5703
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_pin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5391-5417",
          "snippet": "static struct pin_cookie __lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn cookie;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\t/*\n\t\t\t * Grab 16bits of randomness; this is sufficient to not\n\t\t\t * be guessable and still allows some pin nesting in\n\t\t\t * our u32 pin_count.\n\t\t\t */\n\t\t\tcookie.val = 1 + (prandom_u32() >> 16);\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn cookie;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n\treturn cookie;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic struct pin_cookie __lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn cookie;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\t/*\n\t\t\t * Grab 16bits of randomness; this is sufficient to not\n\t\t\t * be guessable and still allows some pin nesting in\n\t\t\t * our u32 pin_count.\n\t\t\t */\n\t\t\tcookie.val = 1 + (prandom_u32() >> 16);\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn cookie;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 5702
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 5700
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5469-5510",
          "snippet": "static noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lockdep_enabled()"
          ],
          "line": 5696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 5696
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstruct pin_cookie lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tunsigned long flags;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn cookie;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\tcookie = __lock_pin_lock(lock);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n\n\treturn cookie;\n}"
  },
  {
    "function_name": "lock_is_held_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5666-5687",
    "snippet": "noinstr int lock_is_held_type(const struct lockdep_map *lock, int read)\n{\n\tunsigned long flags;\n\tint ret = LOCK_STATE_NOT_HELD;\n\n\t/*\n\t * Avoid false negative lockdep_assert_held() and\n\t * lockdep_assert_not_held().\n\t */\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn LOCK_STATE_UNKNOWN;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\tret = __lock_is_held(lock, read);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 5683
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_is_held",
          "args": [
            "lock",
            "read"
          ],
          "line": 5682
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_is_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5371-5389",
          "snippet": "static __always_inline\nint __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || !!hlock->read == read)\n\t\t\t\treturn LOCK_STATE_HELD;\n\n\t\t\treturn LOCK_STATE_NOT_HELD;\n\t\t}\n\t}\n\n\treturn LOCK_STATE_NOT_HELD;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic __always_inline\nint __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || !!hlock->read == read)\n\t\t\t\treturn LOCK_STATE_HELD;\n\n\t\t\treturn LOCK_STATE_NOT_HELD;\n\t\t}\n\t}\n\n\treturn LOCK_STATE_NOT_HELD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 5681
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 5679
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5469-5510",
          "snippet": "static noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lockdep_enabled()"
          ],
          "line": 5675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 5675
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nnoinstr int lock_is_held_type(const struct lockdep_map *lock, int read)\n{\n\tunsigned long flags;\n\tint ret = LOCK_STATE_NOT_HELD;\n\n\t/*\n\t * Avoid false negative lockdep_assert_held() and\n\t * lockdep_assert_not_held().\n\t */\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn LOCK_STATE_UNKNOWN;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\tret = __lock_is_held(lock, read);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lock_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5646-5663",
    "snippet": "void lock_release(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\ttrace_lock_release(lock, ip);\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\tif (__lock_release(lock, ip))\n\t\tcheck_chain_key(current);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 5661
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_chain_key",
          "args": [
            "current"
          ],
          "line": 5660
        },
        "resolved": true,
        "details": {
          "function_name": "check_chain_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3829-3876",
          "snippet": "static void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * hlock->class_idx can't go beyond MAX_LOCKDEP_KEYS, but is\n\t\t * it registered lock class index?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!test_bit(hlock->class_idx, lock_classes_in_use)))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\nstatic noinstr struct;\n\nstatic void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * hlock->class_idx can't go beyond MAX_LOCKDEP_KEYS, but is\n\t\t * it registered lock class index?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!test_bit(hlock->class_idx, lock_classes_in_use)))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_release",
          "args": [
            "lock",
            "ip"
          ],
          "line": 5659
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5289-5369",
          "snippet": "static int\n__lock_release(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 1;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * So we're all set to release this lock.. wait what lock? We don't\n\t * own any locks, you've been drinking again?\n\t */\n\tif (depth <= 0) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check whether the lock exists in the current stack\n\t * of held locks:\n\t */\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tif (hlock->instance == lock)\n\t\tlock_release_holdtime(hlock);\n\n\tWARN(hlock->pin_count, \"releasing a pinned lock\\n\");\n\n\tif (hlock->references) {\n\t\thlock->references--;\n\t\tif (hlock->references) {\n\t\t\t/*\n\t\t\t * We had, and after removing one, still have\n\t\t\t * references, the current lock stack is still\n\t\t\t * valid. We're done!\n\t\t\t */\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * We have the right lock to unlock, 'hlock' points to it.\n\t * Now we remove it from the stack, and add back the other\n\t * entries (if any), recalculating the hash along the way:\n\t */\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\t/*\n\t * The most likely case is when the unlock is on the innermost\n\t * lock. In this case, we are done!\n\t */\n\tif (i == depth-1)\n\t\treturn 1;\n\n\tif (reacquire_held_locks(curr, depth, i + 1, &merged))\n\t\treturn 0;\n\n\t/*\n\t * We had N bottles of beer on the wall, we drank one, but now\n\t * there's not N-1 bottles of beer left on the wall...\n\t * Pouring two of the bottles together is acceptable.\n\t */\n\tDEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth - merged);\n\n\t/*\n\t * Since reacquire_held_locks() would have called check_chain_key()\n\t * indirectly via __lock_acquire(), we don't need to do it again\n\t * on return.\n\t */\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int\n__lock_release(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 1;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * So we're all set to release this lock.. wait what lock? We don't\n\t * own any locks, you've been drinking again?\n\t */\n\tif (depth <= 0) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check whether the lock exists in the current stack\n\t * of held locks:\n\t */\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tif (hlock->instance == lock)\n\t\tlock_release_holdtime(hlock);\n\n\tWARN(hlock->pin_count, \"releasing a pinned lock\\n\");\n\n\tif (hlock->references) {\n\t\thlock->references--;\n\t\tif (hlock->references) {\n\t\t\t/*\n\t\t\t * We had, and after removing one, still have\n\t\t\t * references, the current lock stack is still\n\t\t\t * valid. We're done!\n\t\t\t */\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * We have the right lock to unlock, 'hlock' points to it.\n\t * Now we remove it from the stack, and add back the other\n\t * entries (if any), recalculating the hash along the way:\n\t */\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\t/*\n\t * The most likely case is when the unlock is on the innermost\n\t * lock. In this case, we are done!\n\t */\n\tif (i == depth-1)\n\t\treturn 1;\n\n\tif (reacquire_held_locks(curr, depth, i + 1, &merged))\n\t\treturn 0;\n\n\t/*\n\t * We had N bottles of beer on the wall, we drank one, but now\n\t * there's not N-1 bottles of beer left on the wall...\n\t * Pouring two of the bottles together is acceptable.\n\t */\n\tDEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth - merged);\n\n\t/*\n\t * Since reacquire_held_locks() would have called check_chain_key()\n\t * indirectly via __lock_acquire(), we don't need to do it again\n\t * on return.\n\t */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 5658
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 5656
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5469-5510",
          "snippet": "static noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lockdep_enabled()"
          ],
          "line": 5652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 5652
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_lock_release",
          "args": [
            "lock",
            "ip"
          ],
          "line": 5650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lock_release(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\ttrace_lock_release(lock, ip);\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\tif (__lock_release(lock, ip))\n\t\tcheck_chain_key(current);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_acquire",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5604-5643",
    "snippet": "void lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\ttrace_lock_acquire(lock, subclass, trylock, read, check, nest_lock, ip);\n\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (unlikely(!lockdep_enabled())) {\n\t\t/* XXX allow trylock from NMI ?!? */\n\t\tif (lockdep_nmi() && !trylock) {\n\t\t\tstruct held_lock hlock;\n\n\t\t\thlock.acquire_ip = ip;\n\t\t\thlock.instance = lock;\n\t\t\thlock.nest_lock = nest_lock;\n\t\t\thlock.irq_context = 2; // XXX\n\t\t\thlock.trylock = trylock;\n\t\t\thlock.read = read;\n\t\t\thlock.check = check;\n\t\t\thlock.hardirqs_off = true;\n\t\t\thlock.references = 0;\n\n\t\t\tverify_lock_unused(lock, &hlock, subclass);\n\t\t}\n\t\treturn;\n\t}\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\t__lock_acquire(lock, subclass, trylock, read, check,\n\t\t       irqs_disabled_flags(flags), nest_lock, ip, 0, 0);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 5641
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_acquire",
          "args": [
            "lock",
            "subclass",
            "trylock",
            "read",
            "check",
            "irqs_disabled_flags(flags)",
            "nest_lock",
            "ip",
            "0",
            "0"
          ],
          "line": 5639
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_acquire",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4881-5054",
          "snippet": "static int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes;\n\n\tif (depth) { /* we're holding locks */\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (!references)\n\t\t\t\treferences++;\n\n\t\t\tif (!hlock->references)\n\t\t\t\thlock->references++;\n\n\t\t\thlock->references += references;\n\n\t\t\t/* Overflow */\n\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references < references))\n\t\t\t\treturn 0;\n\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check_wait_context(curr, hlock))\n\t\treturn 0;\n\n\t/* Initialize the lock usage bit */\n\tif (!mark_usage(curr, hlock, check))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. class_idx is invalid.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!test_bit(class_idx, lock_classes_in_use)))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != INITIAL_CHAIN_KEY))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1)) {\n\t\tprint_lock_nested_lock_not_held(curr, hlock, ip);\n\t\treturn 0;\n\t}\n\n\tif (!debug_locks_silent) {\n\t\tWARN_ON_ONCE(depth && !hlock_class(hlock - 1)->key);\n\t\tWARN_ON_ONCE(!hlock_class(hlock)->key);\n\t}\n\n\tif (!validate_chain(curr, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define prove_locking 0"
          ],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "unsigned int max_lockdep_depth;",
            "static noinstr struct",
            "struct lock_class_key __lockdep_no_validate__;",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define prove_locking 0\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nunsigned int max_lockdep_depth;\nstatic noinstr struct;\nstruct lock_class_key __lockdep_no_validate__;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes;\n\n\tif (depth) { /* we're holding locks */\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (!references)\n\t\t\t\treferences++;\n\n\t\t\tif (!hlock->references)\n\t\t\t\thlock->references++;\n\n\t\t\thlock->references += references;\n\n\t\t\t/* Overflow */\n\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references < references))\n\t\t\t\treturn 0;\n\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check_wait_context(curr, hlock))\n\t\treturn 0;\n\n\t/* Initialize the lock usage bit */\n\tif (!mark_usage(curr, hlock, check))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. class_idx is invalid.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!test_bit(class_idx, lock_classes_in_use)))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != INITIAL_CHAIN_KEY))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1)) {\n\t\tprint_lock_nested_lock_not_held(curr, hlock, ip);\n\t\treturn 0;\n\t}\n\n\tif (!debug_locks_silent) {\n\t\tWARN_ON_ONCE(depth && !hlock_class(hlock - 1)->key);\n\t\tWARN_ON_ONCE(!hlock_class(hlock)->key);\n\t}\n\n\tif (!validate_chain(curr, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 5640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 5638
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 5636
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5469-5510",
          "snippet": "static noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_lock_unused",
          "args": [
            "lock",
            "&hlock",
            "subclass"
          ],
          "line": 5630
        },
        "resolved": true,
        "details": {
          "function_name": "verify_lock_unused",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5549-5573",
          "snippet": "static void verify_lock_unused(struct lockdep_map *lock, struct held_lock *hlock, int subclass)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tstruct lock_class *class = look_up_lock_class(lock, subclass);\n\tunsigned long mask = LOCKF_USED;\n\n\t/* if it doesn't have a class (yet), it certainly hasn't been used yet */\n\tif (!class)\n\t\treturn;\n\n\t/*\n\t * READ locks only conflict with USED, such that if we only ever use\n\t * READ locks, there is no deadlock possible -- RCU.\n\t */\n\tif (!hlock->read)\n\t\tmask |= LOCKF_USED_READ;\n\n\tif (!(class->usage_mask & mask))\n\t\treturn;\n\n\thlock->class_idx = class - lock_classes;\n\n\tprint_usage_bug(current, hlock, LOCK_USED, LOCK_USAGE_STATES);\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void verify_lock_unused(struct lockdep_map *lock, struct held_lock *hlock, int subclass)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tstruct lock_class *class = look_up_lock_class(lock, subclass);\n\tunsigned long mask = LOCKF_USED;\n\n\t/* if it doesn't have a class (yet), it certainly hasn't been used yet */\n\tif (!class)\n\t\treturn;\n\n\t/*\n\t * READ locks only conflict with USED, such that if we only ever use\n\t * READ locks, there is no deadlock possible -- RCU.\n\t */\n\tif (!hlock->read)\n\t\tmask |= LOCKF_USED_READ;\n\n\tif (!(class->usage_mask & mask))\n\t\treturn;\n\n\thlock->class_idx = class - lock_classes;\n\n\tprint_usage_bug(current, hlock, LOCK_USED, LOCK_USAGE_STATES);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_nmi",
          "args": [],
          "line": 5617
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_nmi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5575-5584",
          "snippet": "static bool lockdep_nmi(void)\n{\n\tif (raw_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (!in_nmi())\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic bool lockdep_nmi(void)\n{\n\tif (raw_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (!in_nmi())\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lockdep_enabled()"
          ],
          "line": 5615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 5615
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_lock_acquire",
          "args": [
            "lock",
            "subclass",
            "trylock",
            "read",
            "check",
            "nest_lock",
            "ip"
          ],
          "line": 5610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nvoid lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\ttrace_lock_acquire(lock, subclass, trylock, read, check, nest_lock, ip);\n\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (unlikely(!lockdep_enabled())) {\n\t\t/* XXX allow trylock from NMI ?!? */\n\t\tif (lockdep_nmi() && !trylock) {\n\t\t\tstruct held_lock hlock;\n\n\t\t\thlock.acquire_ip = ip;\n\t\t\thlock.instance = lock;\n\t\t\thlock.nest_lock = nest_lock;\n\t\t\thlock.irq_context = 2; // XXX\n\t\t\thlock.trylock = trylock;\n\t\t\thlock.read = read;\n\t\t\thlock.check = check;\n\t\t\thlock.hardirqs_off = true;\n\t\t\thlock.references = 0;\n\n\t\t\tverify_lock_unused(lock, &hlock, subclass);\n\t\t}\n\t\treturn;\n\t}\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tlockdep_recursion_inc();\n\t__lock_acquire(lock, subclass, trylock, read, check,\n\t\t       irqs_disabled_flags(flags), nest_lock, ip, 0, 0);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "read_lock_is_recursive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5592-5597",
    "snippet": "bool read_lock_is_recursive(void)\n{\n\treturn force_read_lock_recursive ||\n\t       !IS_ENABLED(CONFIG_QUEUED_RWLOCKS) ||\n\t       in_interrupt();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 5596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_QUEUED_RWLOCKS"
          ],
          "line": 5595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nbool read_lock_is_recursive(void)\n{\n\treturn force_read_lock_recursive ||\n\t       !IS_ENABLED(CONFIG_QUEUED_RWLOCKS) ||\n\t       in_interrupt();\n}"
  },
  {
    "function_name": "lockdep_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5575-5584",
    "snippet": "static bool lockdep_nmi(void)\n{\n\tif (raw_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (!in_nmi())\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 5580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_read",
          "args": [
            "lockdep_recursion"
          ],
          "line": 5577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic bool lockdep_nmi(void)\n{\n\tif (raw_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (!in_nmi())\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "verify_lock_unused",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5549-5573",
    "snippet": "static void verify_lock_unused(struct lockdep_map *lock, struct held_lock *hlock, int subclass)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tstruct lock_class *class = look_up_lock_class(lock, subclass);\n\tunsigned long mask = LOCKF_USED;\n\n\t/* if it doesn't have a class (yet), it certainly hasn't been used yet */\n\tif (!class)\n\t\treturn;\n\n\t/*\n\t * READ locks only conflict with USED, such that if we only ever use\n\t * READ locks, there is no deadlock possible -- RCU.\n\t */\n\tif (!hlock->read)\n\t\tmask |= LOCKF_USED_READ;\n\n\tif (!(class->usage_mask & mask))\n\t\treturn;\n\n\thlock->class_idx = class - lock_classes;\n\n\tprint_usage_bug(current, hlock, LOCK_USED, LOCK_USAGE_STATES);\n#endif\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_usage_bug",
          "args": [
            "current",
            "hlock",
            "LOCK_USED",
            "LOCK_USAGE_STATES"
          ],
          "line": 5571
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3899-3934",
          "snippet": "static void\nprint_usage_bug(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)\n{\n\tif (!debug_locks_off() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"================================\\n\");\n\tpr_warn(\"WARNING: inconsistent lock state\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------\\n\");\n\n\tpr_warn(\"inconsistent {%s} -> {%s} usage.\\n\",\n\t\tusage_str[prev_bit], usage_str[new_bit]);\n\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tlockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,\n\t\tlockdep_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,\n\t\tlockdep_hardirqs_enabled(),\n\t\tlockdep_softirqs_enabled(curr));\n\tprint_lock(this);\n\n\tpr_warn(\"{%s} state was registered at:\\n\", usage_str[prev_bit]);\n\tprint_lock_trace(hlock_class(this)->usage_traces[prev_bit], 1);\n\n\tprint_irqtrace_events(curr);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_usage_bug_scenario(this);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_usage_bug(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)\n{\n\tif (!debug_locks_off() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"================================\\n\");\n\tpr_warn(\"WARNING: inconsistent lock state\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------\\n\");\n\n\tpr_warn(\"inconsistent {%s} -> {%s} usage.\\n\",\n\t\tusage_str[prev_bit], usage_str[new_bit]);\n\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tlockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,\n\t\tlockdep_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,\n\t\tlockdep_hardirqs_enabled(),\n\t\tlockdep_softirqs_enabled(curr));\n\tprint_lock(this);\n\n\tpr_warn(\"{%s} state was registered at:\\n\", usage_str[prev_bit]);\n\tprint_lock_trace(hlock_class(this)->usage_traces[prev_bit], 1);\n\n\tprint_irqtrace_events(curr);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_usage_bug_scenario(this);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "look_up_lock_class",
          "args": [
            "lock",
            "subclass"
          ],
          "line": 5552
        },
        "resolved": true,
        "details": {
          "function_name": "look_up_lock_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "858-916",
          "snippet": "lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tinstrumentation_begin();\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\tinstrumentation_end();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name &&\n\t\t\t\t     lock->key != &__lockdep_no_validate__);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "struct lock_class_key __lockdep_no_validate__;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstruct lock_class_key __lockdep_no_validate__;\n\nlock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tinstrumentation_begin();\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\tinstrumentation_end();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name &&\n\t\t\t\t     lock->key != &__lockdep_no_validate__);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void verify_lock_unused(struct lockdep_map *lock, struct held_lock *hlock, int subclass)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tstruct lock_class *class = look_up_lock_class(lock, subclass);\n\tunsigned long mask = LOCKF_USED;\n\n\t/* if it doesn't have a class (yet), it certainly hasn't been used yet */\n\tif (!class)\n\t\treturn;\n\n\t/*\n\t * READ locks only conflict with USED, such that if we only ever use\n\t * READ locks, there is no deadlock possible -- RCU.\n\t */\n\tif (!hlock->read)\n\t\tmask |= LOCKF_USED_READ;\n\n\tif (!(class->usage_mask & mask))\n\t\treturn;\n\n\thlock->class_idx = class - lock_classes;\n\n\tprint_usage_bug(current, hlock, LOCK_USED, LOCK_USAGE_STATES);\n#endif\n}"
  },
  {
    "function_name": "lock_downgrade",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5531-5545",
    "snippet": "void lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tlockdep_recursion_inc();\n\tcheck_flags(flags);\n\tif (__lock_downgrade(lock, ip))\n\t\tcheck_chain_key(current);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 5543
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_chain_key",
          "args": [
            "current"
          ],
          "line": 5542
        },
        "resolved": true,
        "details": {
          "function_name": "check_chain_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3829-3876",
          "snippet": "static void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * hlock->class_idx can't go beyond MAX_LOCKDEP_KEYS, but is\n\t\t * it registered lock class index?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!test_bit(hlock->class_idx, lock_classes_in_use)))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\nstatic noinstr struct;\n\nstatic void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * hlock->class_idx can't go beyond MAX_LOCKDEP_KEYS, but is\n\t\t * it registered lock class index?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!test_bit(hlock->class_idx, lock_classes_in_use)))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_downgrade",
          "args": [
            "lock",
            "ip"
          ],
          "line": 5541
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_downgrade",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5236-5282",
          "snippet": "static int __lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 0;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tWARN(hlock->read, \"downgrading a read lock\");\n\thlock->read = 1;\n\thlock->acquire_ip = ip;\n\n\tif (reacquire_held_locks(curr, depth, i, &merged))\n\t\treturn 0;\n\n\t/* Merging can't happen with unchanged classes.. */\n\tif (DEBUG_LOCKS_WARN_ON(merged))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 0;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tWARN(hlock->read, \"downgrading a read lock\");\n\thlock->read = 1;\n\thlock->acquire_ip = ip;\n\n\tif (reacquire_held_locks(curr, depth, i, &merged))\n\t\treturn 0;\n\n\t/* Merging can't happen with unchanged classes.. */\n\tif (DEBUG_LOCKS_WARN_ON(merged))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 5540
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5469-5510",
          "snippet": "static noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 5539
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lockdep_enabled()"
          ],
          "line": 5535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 5535
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tlockdep_recursion_inc();\n\tcheck_flags(flags);\n\tif (__lock_downgrade(lock, ip))\n\t\tcheck_chain_key(current);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_set_class",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5512-5528",
    "snippet": "void lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t    struct lock_class_key *key, unsigned int subclass,\n\t\t    unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tlockdep_recursion_inc();\n\tcheck_flags(flags);\n\tif (__lock_set_class(lock, name, key, subclass, ip))\n\t\tcheck_chain_key(current);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 5526
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_chain_key",
          "args": [
            "current"
          ],
          "line": 5525
        },
        "resolved": true,
        "details": {
          "function_name": "check_chain_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3829-3876",
          "snippet": "static void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * hlock->class_idx can't go beyond MAX_LOCKDEP_KEYS, but is\n\t\t * it registered lock class index?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!test_bit(hlock->class_idx, lock_classes_in_use)))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\nstatic noinstr struct;\n\nstatic void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * hlock->class_idx can't go beyond MAX_LOCKDEP_KEYS, but is\n\t\t * it registered lock class index?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!test_bit(hlock->class_idx, lock_classes_in_use)))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_set_class",
          "args": [
            "lock",
            "name",
            "key",
            "subclass",
            "ip"
          ],
          "line": 5524
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_set_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5187-5234",
          "snippet": "static int\n__lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t struct lock_class_key *key, unsigned int subclass,\n\t\t unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 0;\n\tstruct held_lock *hlock;\n\tstruct lock_class *class;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tlockdep_init_map_waits(lock, name, key, 0,\n\t\t\t       lock->wait_type_inner,\n\t\t\t       lock->wait_type_outer);\n\tclass = register_lock_class(lock, subclass, 0);\n\thlock->class_idx = class - lock_classes;\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tif (reacquire_held_locks(curr, depth, i, &merged))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth - merged))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic int\n__lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t struct lock_class_key *key, unsigned int subclass,\n\t\t unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 0;\n\tstruct held_lock *hlock;\n\tstruct lock_class *class;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tlockdep_init_map_waits(lock, name, key, 0,\n\t\t\t       lock->wait_type_inner,\n\t\t\t       lock->wait_type_outer);\n\tclass = register_lock_class(lock, subclass, 0);\n\thlock->class_idx = class - lock_classes;\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tif (reacquire_held_locks(curr, depth, i, &merged))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth - merged))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 5523
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5469-5510",
          "snippet": "static noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 5522
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lockdep_enabled()"
          ],
          "line": 5518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 5518
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t    struct lock_class_key *key, unsigned int subclass,\n\t\t    unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tlockdep_recursion_inc();\n\tcheck_flags(flags);\n\tif (__lock_set_class(lock, name, key, subclass, ip))\n\t\tcheck_chain_key(current);\n\tlockdep_recursion_finish();\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "check_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5469-5510",
    "snippet": "static noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 5508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "current"
          ],
          "line": 5506
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4085-4102",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!current->softirqs_enabled"
          ],
          "line": 5500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "current->softirqs_enabled"
          ],
          "line": 5497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 5495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hardirq_count",
          "args": [],
          "line": 5494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"possible reason: unannotated irqs-on.\\n\""
          ],
          "line": 5484
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!lockdep_hardirqs_enabled()"
          ],
          "line": 5483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_enabled",
          "args": [],
          "line": 5483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "lockdep_hardirqs_enabled()"
          ],
          "line": 5479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_enabled",
          "args": [],
          "line": 5479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 5478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 5476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP)\n\tif (!debug_locks)\n\t\treturn;\n\n\t/* Get the warning out..  */\n\tinstrumentation_begin();\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_hardirqs_enabled())) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n#ifndef CONFIG_PREEMPT_RT\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n#endif\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n\n\tinstrumentation_end();\n#endif\n}"
  },
  {
    "function_name": "__lock_unpin_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5439-5464",
    "snippet": "static void __lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (WARN(!hlock->pin_count, \"unpinning an unpinned lock\\n\"))\n\t\t\t\treturn;\n\n\t\t\thlock->pin_count -= cookie.val;\n\n\t\t\tif (WARN((int)hlock->pin_count < 0, \"pin count corrupted\\n\"))\n\t\t\t\thlock->pin_count = 0;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"unpinning an unheld lock\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"unpinning an unheld lock\\n\""
          ],
          "line": 5463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "(int)hlock->pin_count < 0",
            "\"pin count corrupted\\n\""
          ],
          "line": 5456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!hlock->pin_count",
            "\"unpinning an unpinned lock\\n\""
          ],
          "line": 5451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_held_lock",
          "args": [
            "hlock",
            "lock"
          ],
          "line": 5450
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5083-5117",
          "snippet": "static noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 5444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (WARN(!hlock->pin_count, \"unpinning an unpinned lock\\n\"))\n\t\t\t\treturn;\n\n\t\t\thlock->pin_count -= cookie.val;\n\n\t\t\tif (WARN((int)hlock->pin_count < 0, \"pin count corrupted\\n\"))\n\t\t\t\thlock->pin_count = 0;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"unpinning an unheld lock\\n\");\n}"
  },
  {
    "function_name": "__lock_repin_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5419-5437",
    "snippet": "static void __lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"pinning an unheld lock\\n\""
          ],
          "line": 5436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_held_lock",
          "args": [
            "hlock",
            "lock"
          ],
          "line": 5430
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5083-5117",
          "snippet": "static noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 5424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n}"
  },
  {
    "function_name": "__lock_pin_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5391-5417",
    "snippet": "static struct pin_cookie __lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn cookie;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\t/*\n\t\t\t * Grab 16bits of randomness; this is sufficient to not\n\t\t\t * be guessable and still allows some pin nesting in\n\t\t\t * our u32 pin_count.\n\t\t\t */\n\t\t\tcookie.val = 1 + (prandom_u32() >> 16);\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn cookie;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n\treturn cookie;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"pinning an unheld lock\\n\""
          ],
          "line": 5415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 5409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_held_lock",
          "args": [
            "hlock",
            "lock"
          ],
          "line": 5403
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5083-5117",
          "snippet": "static noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 5397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic struct pin_cookie __lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn cookie;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\t/*\n\t\t\t * Grab 16bits of randomness; this is sufficient to not\n\t\t\t * be guessable and still allows some pin nesting in\n\t\t\t * our u32 pin_count.\n\t\t\t */\n\t\t\tcookie.val = 1 + (prandom_u32() >> 16);\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn cookie;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n\treturn cookie;\n}"
  },
  {
    "function_name": "__lock_is_held",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5371-5389",
    "snippet": "static __always_inline\nint __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || !!hlock->read == read)\n\t\t\t\treturn LOCK_STATE_HELD;\n\n\t\t\treturn LOCK_STATE_NOT_HELD;\n\t\t}\n\t}\n\n\treturn LOCK_STATE_NOT_HELD;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_held_lock",
          "args": [
            "hlock",
            "lock"
          ],
          "line": 5380
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5083-5117",
          "snippet": "static noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic __always_inline\nint __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || !!hlock->read == read)\n\t\t\t\treturn LOCK_STATE_HELD;\n\n\t\t\treturn LOCK_STATE_NOT_HELD;\n\t\t}\n\t}\n\n\treturn LOCK_STATE_NOT_HELD;\n}"
  },
  {
    "function_name": "__lock_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5289-5369",
    "snippet": "static int\n__lock_release(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 1;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * So we're all set to release this lock.. wait what lock? We don't\n\t * own any locks, you've been drinking again?\n\t */\n\tif (depth <= 0) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check whether the lock exists in the current stack\n\t * of held locks:\n\t */\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tif (hlock->instance == lock)\n\t\tlock_release_holdtime(hlock);\n\n\tWARN(hlock->pin_count, \"releasing a pinned lock\\n\");\n\n\tif (hlock->references) {\n\t\thlock->references--;\n\t\tif (hlock->references) {\n\t\t\t/*\n\t\t\t * We had, and after removing one, still have\n\t\t\t * references, the current lock stack is still\n\t\t\t * valid. We're done!\n\t\t\t */\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * We have the right lock to unlock, 'hlock' points to it.\n\t * Now we remove it from the stack, and add back the other\n\t * entries (if any), recalculating the hash along the way:\n\t */\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\t/*\n\t * The most likely case is when the unlock is on the innermost\n\t * lock. In this case, we are done!\n\t */\n\tif (i == depth-1)\n\t\treturn 1;\n\n\tif (reacquire_held_locks(curr, depth, i + 1, &merged))\n\t\treturn 0;\n\n\t/*\n\t * We had N bottles of beer on the wall, we drank one, but now\n\t * there's not N-1 bottles of beer left on the wall...\n\t * Pouring two of the bottles together is acceptable.\n\t */\n\tDEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth - merged);\n\n\t/*\n\t * Since reacquire_held_locks() would have called check_chain_key()\n\t * indirectly via __lock_acquire(), we don't need to do it again\n\t * on return.\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "curr->lockdep_depth != depth - merged"
          ],
          "line": 5361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reacquire_held_locks",
          "args": [
            "curr",
            "depth",
            "i + 1",
            "&merged"
          ],
          "line": 5353
        },
        "resolved": true,
        "details": {
          "function_name": "reacquire_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5155-5185",
          "snippet": "static int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t\tint idx, unsigned int *merged)\n{\n\tstruct held_lock *hlock;\n\tint first_idx = idx;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tswitch (__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count)) {\n\t\tcase 0:\n\t\t\treturn 1;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*merged += (idx == first_idx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t\tint idx, unsigned int *merged)\n{\n\tstruct held_lock *hlock;\n\tint first_idx = idx;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tswitch (__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count)) {\n\t\tcase 0:\n\t\t\treturn 1;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*merged += (idx == first_idx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "hlock->pin_count",
            "\"releasing a pinned lock\\n\""
          ],
          "line": 5323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_release_holdtime",
          "args": [
            "hlock"
          ],
          "line": 5321
        },
        "resolved": true,
        "details": {
          "function_name": "lock_release_holdtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "330-332",
          "snippet": "static inline void lock_release_holdtime(struct held_lock *hlock)\n{\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void lock_release_holdtime(struct held_lock *hlock)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_unlock_imbalance_bug",
          "args": [
            "curr",
            "lock",
            "ip"
          ],
          "line": 5316
        },
        "resolved": true,
        "details": {
          "function_name": "print_unlock_imbalance_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5056-5081",
          "snippet": "static void print_unlock_imbalance_bug(struct task_struct *curr,\n\t\t\t\t       struct lockdep_map *lock,\n\t\t\t\t       unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_unlock_imbalance_bug(struct task_struct *curr,\n\t\t\t\t       struct lockdep_map *lock,\n\t\t\t\t       unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_held_lock",
          "args": [
            "curr",
            "lock",
            "depth",
            "&i"
          ],
          "line": 5314
        },
        "resolved": true,
        "details": {
          "function_name": "find_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5120-5153",
          "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 5297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int\n__lock_release(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 1;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * So we're all set to release this lock.. wait what lock? We don't\n\t * own any locks, you've been drinking again?\n\t */\n\tif (depth <= 0) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check whether the lock exists in the current stack\n\t * of held locks:\n\t */\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tif (hlock->instance == lock)\n\t\tlock_release_holdtime(hlock);\n\n\tWARN(hlock->pin_count, \"releasing a pinned lock\\n\");\n\n\tif (hlock->references) {\n\t\thlock->references--;\n\t\tif (hlock->references) {\n\t\t\t/*\n\t\t\t * We had, and after removing one, still have\n\t\t\t * references, the current lock stack is still\n\t\t\t * valid. We're done!\n\t\t\t */\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * We have the right lock to unlock, 'hlock' points to it.\n\t * Now we remove it from the stack, and add back the other\n\t * entries (if any), recalculating the hash along the way:\n\t */\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\t/*\n\t * The most likely case is when the unlock is on the innermost\n\t * lock. In this case, we are done!\n\t */\n\tif (i == depth-1)\n\t\treturn 1;\n\n\tif (reacquire_held_locks(curr, depth, i + 1, &merged))\n\t\treturn 0;\n\n\t/*\n\t * We had N bottles of beer on the wall, we drank one, but now\n\t * there's not N-1 bottles of beer left on the wall...\n\t * Pouring two of the bottles together is acceptable.\n\t */\n\tDEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth - merged);\n\n\t/*\n\t * Since reacquire_held_locks() would have called check_chain_key()\n\t * indirectly via __lock_acquire(), we don't need to do it again\n\t * on return.\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "__lock_downgrade",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5236-5282",
    "snippet": "static int __lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 0;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tWARN(hlock->read, \"downgrading a read lock\");\n\thlock->read = 1;\n\thlock->acquire_ip = ip;\n\n\tif (reacquire_held_locks(curr, depth, i, &merged))\n\t\treturn 0;\n\n\t/* Merging can't happen with unchanged classes.. */\n\tif (DEBUG_LOCKS_WARN_ON(merged))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "curr->lockdep_depth != depth"
          ],
          "line": 5278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "merged"
          ],
          "line": 5271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reacquire_held_locks",
          "args": [
            "curr",
            "depth",
            "i",
            "&merged"
          ],
          "line": 5267
        },
        "resolved": true,
        "details": {
          "function_name": "reacquire_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5155-5185",
          "snippet": "static int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t\tint idx, unsigned int *merged)\n{\n\tstruct held_lock *hlock;\n\tint first_idx = idx;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tswitch (__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count)) {\n\t\tcase 0:\n\t\t\treturn 1;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*merged += (idx == first_idx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t\tint idx, unsigned int *merged)\n{\n\tstruct held_lock *hlock;\n\tint first_idx = idx;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tswitch (__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count)) {\n\t\tcase 0:\n\t\t\treturn 1;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*merged += (idx == first_idx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "hlock->read",
            "\"downgrading a read lock\""
          ],
          "line": 5263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_unlock_imbalance_bug",
          "args": [
            "curr",
            "lock",
            "ip"
          ],
          "line": 5256
        },
        "resolved": true,
        "details": {
          "function_name": "print_unlock_imbalance_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5056-5081",
          "snippet": "static void print_unlock_imbalance_bug(struct task_struct *curr,\n\t\t\t\t       struct lockdep_map *lock,\n\t\t\t\t       unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_unlock_imbalance_bug(struct task_struct *curr,\n\t\t\t\t       struct lockdep_map *lock,\n\t\t\t\t       unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_held_lock",
          "args": [
            "curr",
            "lock",
            "depth",
            "&i"
          ],
          "line": 5254
        },
        "resolved": true,
        "details": {
          "function_name": "find_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5120-5153",
          "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!depth"
          ],
          "line": 5251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 5243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 0;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tWARN(hlock->read, \"downgrading a read lock\");\n\thlock->read = 1;\n\thlock->acquire_ip = ip;\n\n\tif (reacquire_held_locks(curr, depth, i, &merged))\n\t\treturn 0;\n\n\t/* Merging can't happen with unchanged classes.. */\n\tif (DEBUG_LOCKS_WARN_ON(merged))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "__lock_set_class",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5187-5234",
    "snippet": "static int\n__lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t struct lock_class_key *key, unsigned int subclass,\n\t\t unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 0;\n\tstruct held_lock *hlock;\n\tstruct lock_class *class;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tlockdep_init_map_waits(lock, name, key, 0,\n\t\t\t       lock->wait_type_inner,\n\t\t\t       lock->wait_type_outer);\n\tclass = register_lock_class(lock, subclass, 0);\n\thlock->class_idx = class - lock_classes;\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tif (reacquire_held_locks(curr, depth, i, &merged))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth - merged))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "curr->lockdep_depth != depth - merged"
          ],
          "line": 5231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reacquire_held_locks",
          "args": [
            "curr",
            "depth",
            "i",
            "&merged"
          ],
          "line": 5224
        },
        "resolved": true,
        "details": {
          "function_name": "reacquire_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5155-5185",
          "snippet": "static int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t\tint idx, unsigned int *merged)\n{\n\tstruct held_lock *hlock;\n\tint first_idx = idx;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tswitch (__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count)) {\n\t\tcase 0:\n\t\t\treturn 1;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*merged += (idx == first_idx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t\tint idx, unsigned int *merged)\n{\n\tstruct held_lock *hlock;\n\tint first_idx = idx;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tswitch (__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count)) {\n\t\tcase 0:\n\t\t\treturn 1;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*merged += (idx == first_idx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_lock_class",
          "args": [
            "lock",
            "subclass",
            "0"
          ],
          "line": 5218
        },
        "resolved": true,
        "details": {
          "function_name": "register_lock_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1249-1351",
          "snippet": "static struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key) && !is_dynamic_key(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\tinit_data_structures_once();\n\n\t/* Allocate a new lock class and add it to the hash. */\n\tclass = list_first_entry_or_null(&free_lock_classes, typeof(*class),\n\t\t\t\t\t lock_entry);\n\tif (!class) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_lock_classes++;\n\t__set_bit(class - lock_classes, lock_classes_in_use);\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tclass->name_version = count_matching_names(class);\n\tclass->wait_type_inner = lock->wait_type_inner;\n\tclass->wait_type_outer = lock->wait_type_outer;\n\tclass->lock_type = lock->lock_type;\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Remove the class from the free list and add it to the global list\n\t * of classes.\n\t */\n\tlist_move_tail(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_lock_classes;",
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);",
            "static LIST_HEAD(free_lock_classes);",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_lock_classes;\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\nstatic LIST_HEAD(free_lock_classes);\nstatic noinstr struct;\n\nstatic struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key) && !is_dynamic_key(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\tinit_data_structures_once();\n\n\t/* Allocate a new lock class and add it to the hash. */\n\tclass = list_first_entry_or_null(&free_lock_classes, typeof(*class),\n\t\t\t\t\t lock_entry);\n\tif (!class) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_lock_classes++;\n\t__set_bit(class - lock_classes, lock_classes_in_use);\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tclass->name_version = count_matching_names(class);\n\tclass->wait_type_inner = lock->wait_type_inner;\n\tclass->wait_type_outer = lock->wait_type_outer;\n\tclass->lock_type = lock->lock_type;\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Remove the class from the free list and add it to the global list\n\t * of classes.\n\t */\n\tlist_move_tail(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_init_map_waits",
          "args": [
            "lock",
            "name",
            "key",
            "0",
            "lock->wait_type_inner",
            "lock->wait_type_outer"
          ],
          "line": 5215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_unlock_imbalance_bug",
          "args": [
            "curr",
            "lock",
            "ip"
          ],
          "line": 5211
        },
        "resolved": true,
        "details": {
          "function_name": "print_unlock_imbalance_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5056-5081",
          "snippet": "static void print_unlock_imbalance_bug(struct task_struct *curr,\n\t\t\t\t       struct lockdep_map *lock,\n\t\t\t\t       unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_unlock_imbalance_bug(struct task_struct *curr,\n\t\t\t\t       struct lockdep_map *lock,\n\t\t\t\t       unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_held_lock",
          "args": [
            "curr",
            "lock",
            "depth",
            "&i"
          ],
          "line": 5209
        },
        "resolved": true,
        "details": {
          "function_name": "find_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5120-5153",
          "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!depth"
          ],
          "line": 5206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 5198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic int\n__lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t struct lock_class_key *key, unsigned int subclass,\n\t\t unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tunsigned int depth, merged = 0;\n\tstruct held_lock *hlock;\n\tstruct lock_class *class;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_unlock_imbalance_bug(curr, lock, ip);\n\t\treturn 0;\n\t}\n\n\tlockdep_init_map_waits(lock, name, key, 0,\n\t\t\t       lock->wait_type_inner,\n\t\t\t       lock->wait_type_outer);\n\tclass = register_lock_class(lock, subclass, 0);\n\thlock->class_idx = class - lock_classes;\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tif (reacquire_held_locks(curr, depth, i, &merged))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth - merged))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "reacquire_held_locks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5155-5185",
    "snippet": "static int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t\tint idx, unsigned int *merged)\n{\n\tstruct held_lock *hlock;\n\tint first_idx = idx;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tswitch (__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count)) {\n\t\tcase 0:\n\t\t\treturn 1;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*merged += (idx == first_idx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 5180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lock_acquire",
          "args": [
            "hlock->instance",
            "hlock_class(hlock)->subclass",
            "hlock->trylock",
            "hlock->read",
            "hlock->check",
            "hlock->hardirqs_off",
            "hlock->nest_lock",
            "hlock->acquire_ip",
            "hlock->references",
            "hlock->pin_count"
          ],
          "line": 5165
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_acquire",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4881-5054",
          "snippet": "static int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes;\n\n\tif (depth) { /* we're holding locks */\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (!references)\n\t\t\t\treferences++;\n\n\t\t\tif (!hlock->references)\n\t\t\t\thlock->references++;\n\n\t\t\thlock->references += references;\n\n\t\t\t/* Overflow */\n\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references < references))\n\t\t\t\treturn 0;\n\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check_wait_context(curr, hlock))\n\t\treturn 0;\n\n\t/* Initialize the lock usage bit */\n\tif (!mark_usage(curr, hlock, check))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. class_idx is invalid.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!test_bit(class_idx, lock_classes_in_use)))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != INITIAL_CHAIN_KEY))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1)) {\n\t\tprint_lock_nested_lock_not_held(curr, hlock, ip);\n\t\treturn 0;\n\t}\n\n\tif (!debug_locks_silent) {\n\t\tWARN_ON_ONCE(depth && !hlock_class(hlock - 1)->key);\n\t\tWARN_ON_ONCE(!hlock_class(hlock)->key);\n\t}\n\n\tif (!validate_chain(curr, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define prove_locking 0"
          ],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "unsigned int max_lockdep_depth;",
            "static noinstr struct",
            "struct lock_class_key __lockdep_no_validate__;",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define prove_locking 0\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nunsigned int max_lockdep_depth;\nstatic noinstr struct;\nstruct lock_class_key __lockdep_no_validate__;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes;\n\n\tif (depth) { /* we're holding locks */\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (!references)\n\t\t\t\treferences++;\n\n\t\t\tif (!hlock->references)\n\t\t\t\thlock->references++;\n\n\t\t\thlock->references += references;\n\n\t\t\t/* Overflow */\n\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references < references))\n\t\t\t\treturn 0;\n\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check_wait_context(curr, hlock))\n\t\treturn 0;\n\n\t/* Initialize the lock usage bit */\n\tif (!mark_usage(curr, hlock, check))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. class_idx is invalid.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!test_bit(class_idx, lock_classes_in_use)))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != INITIAL_CHAIN_KEY))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1)) {\n\t\tprint_lock_nested_lock_not_held(curr, hlock, ip);\n\t\treturn 0;\n\t}\n\n\tif (!debug_locks_silent) {\n\t\tWARN_ON_ONCE(depth && !hlock_class(hlock - 1)->key);\n\t\tWARN_ON_ONCE(!hlock_class(hlock)->key);\n\t}\n\n\tif (!validate_chain(curr, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 5166
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 5161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 5161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t\tint idx, unsigned int *merged)\n{\n\tstruct held_lock *hlock;\n\tint first_idx = idx;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tswitch (__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count)) {\n\t\tcase 0:\n\t\t\treturn 1;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*merged += (idx == first_idx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "find_held_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5120-5153",
    "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_held_lock",
          "args": [
            "hlock",
            "lock"
          ],
          "line": 5144
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5083-5117",
          "snippet": "static noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
  },
  {
    "function_name": "match_held_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5083-5117",
    "snippet": "static noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!hlock->nest_lock"
          ],
          "line": 5109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "look_up_lock_class",
          "args": [
            "lock",
            "0"
          ],
          "line": 5093
        },
        "resolved": true,
        "details": {
          "function_name": "look_up_lock_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "858-916",
          "snippet": "lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tinstrumentation_begin();\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\tinstrumentation_end();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name &&\n\t\t\t\t     lock->key != &__lockdep_no_validate__);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "struct lock_class_key __lockdep_no_validate__;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstruct lock_class_key __lockdep_no_validate__;\n\nlock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tinstrumentation_begin();\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\tinstrumentation_end();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name &&\n\t\t\t\t     lock->key != &__lockdep_no_validate__);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_unlock_imbalance_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "5056-5081",
    "snippet": "static void print_unlock_imbalance_bug(struct task_struct *curr,\n\t\t\t\t       struct lockdep_map *lock,\n\t\t\t\t       unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 5080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 5079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 5077
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 5076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"but there are no more locks to release!\\n\""
          ],
          "line": 5075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "KERN_WARNING",
            "ip"
          ],
          "line": 5074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\") at:\\n\""
          ],
          "line": 5073
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lockdep_cache",
          "args": [
            "lock"
          ],
          "line": 5072
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "714-724",
          "snippet": "static void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is trying to release lock (\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 5070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 5071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"-------------------------------------\\n\""
          ],
          "line": 5069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 5068
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: bad unlock balance detected!\\n\""
          ],
          "line": 5067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=====================================\\n\""
          ],
          "line": 5066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 5065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 5060
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_unlock_imbalance_bug(struct task_struct *curr,\n\t\t\t\t       struct lockdep_map *lock,\n\t\t\t\t       unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(KERN_WARNING, ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "__lock_acquire",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4881-5054",
    "snippet": "static int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes;\n\n\tif (depth) { /* we're holding locks */\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (!references)\n\t\t\t\treferences++;\n\n\t\t\tif (!hlock->references)\n\t\t\t\thlock->references++;\n\n\t\t\thlock->references += references;\n\n\t\t\t/* Overflow */\n\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references < references))\n\t\t\t\treturn 0;\n\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check_wait_context(curr, hlock))\n\t\treturn 0;\n\n\t/* Initialize the lock usage bit */\n\tif (!mark_usage(curr, hlock, check))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. class_idx is invalid.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!test_bit(class_idx, lock_classes_in_use)))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != INITIAL_CHAIN_KEY))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1)) {\n\t\tprint_lock_nested_lock_not_held(curr, hlock, ip);\n\t\treturn 0;\n\t}\n\n\tif (!debug_locks_silent) {\n\t\tWARN_ON_ONCE(depth && !hlock_class(hlock - 1)->key);\n\t\tWARN_ON_ONCE(!hlock_class(hlock)->key);\n\t}\n\n\tif (!validate_chain(curr, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define prove_locking 0"
    ],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "unsigned int max_lockdep_depth;",
      "static noinstr struct",
      "struct lock_class_key __lockdep_no_validate__;",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "curr->lockdep_depth > max_lockdep_depth"
          ],
          "line": 5050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 5045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_show_all_locks",
          "args": [],
          "line": 5044
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_all_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6456-6478",
          "snippet": "void debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "current"
          ],
          "line": 5043
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"depth: %i  max: %lu!\\n\"",
            "curr->lockdep_depth",
            "MAX_LOCK_DEPTH"
          ],
          "line": 5040
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lockdep_off",
          "args": [
            "\"BUG: MAX_LOCK_DEPTH too low!\""
          ],
          "line": 5039
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "490-497",
          "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define lock_stat 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 5038
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "curr->lockdep_depth >= MAX_LOCK_DEPTH"
          ],
          "line": 5037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 5034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_chain_key",
          "args": [
            "curr"
          ],
          "line": 5032
        },
        "resolved": true,
        "details": {
          "function_name": "check_chain_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3829-3876",
          "snippet": "static void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * hlock->class_idx can't go beyond MAX_LOCKDEP_KEYS, but is\n\t\t * it registered lock class index?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!test_bit(hlock->class_idx, lock_classes_in_use)))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\nstatic noinstr struct;\n\nstatic void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * hlock->class_idx can't go beyond MAX_LOCKDEP_KEYS, but is\n\t\t * it registered lock class index?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!test_bit(hlock->class_idx, lock_classes_in_use)))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_chain",
          "args": [
            "curr",
            "hlock",
            "chain_head",
            "chain_key"
          ],
          "line": 5027
        },
        "resolved": true,
        "details": {
          "function_name": "validate_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3815-3820",
          "snippet": "static inline int validate_chain(struct task_struct *curr,\n\t\t\t\t struct held_lock *hlock,\n\t\t\t\t int chain_head, u64 chain_key)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int validate_chain(struct task_struct *curr,\n\t\t\t\t struct held_lock *hlock,\n\t\t\t\t int chain_head, u64 chain_key)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!hlock_class(hlock)->key"
          ],
          "line": 5024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 5024
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "depth && !hlock_class(hlock - 1)->key"
          ],
          "line": 5023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock_nested_lock_not_held",
          "args": [
            "curr",
            "hlock",
            "ip"
          ],
          "line": 5018
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_nested_lock_not_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4839-4869",
          "snippet": "static void\nprint_lock_nested_lock_not_held(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock,\n\t\t\t\tunsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"==================================\\n\");\n\tpr_warn(\"WARNING: Nested lock was not taken\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"\\nbut this task is not holding:\\n\");\n\tpr_warn(\"%s\\n\", hlock->nest_lock->name);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_lock_nested_lock_not_held(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock,\n\t\t\t\tunsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"==================================\\n\");\n\tpr_warn(\"WARNING: Nested lock was not taken\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"\\nbut this task is not holding:\\n\");\n\tpr_warn(\"%s\\n\", hlock->nest_lock->name);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_is_held",
          "args": [
            "nest_lock",
            "-1"
          ],
          "line": 5017
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_is_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5371-5389",
          "snippet": "static __always_inline\nint __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || !!hlock->read == read)\n\t\t\t\treturn LOCK_STATE_HELD;\n\n\t\t\treturn LOCK_STATE_NOT_HELD;\n\t\t}\n\t}\n\n\treturn LOCK_STATE_NOT_HELD;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic __always_inline\nint __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || !!hlock->read == read)\n\t\t\t\treturn LOCK_STATE_HELD;\n\n\t\t\treturn LOCK_STATE_NOT_HELD;\n\t\t}\n\t}\n\n\treturn LOCK_STATE_NOT_HELD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_chain_key",
          "args": [
            "chain_key",
            "hlock_id(hlock)"
          ],
          "line": 5015
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_chain_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "415-422",
          "snippet": "static inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_id",
          "args": [
            "hlock"
          ],
          "line": 5015
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "397-402",
          "snippet": "static inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "separate_irq_context",
          "args": [
            "curr",
            "hlock"
          ],
          "line": 5011
        },
        "resolved": true,
        "details": {
          "function_name": "separate_irq_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4757-4761",
          "snippet": "static inline int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "chain_key != INITIAL_CHAIN_KEY"
          ],
          "line": 5005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!test_bit(class_idx, lock_classes_in_use)"
          ],
          "line": 4997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "class_idx",
            "lock_classes_in_use"
          ],
          "line": 4997
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_usage",
          "args": [
            "curr",
            "hlock",
            "check"
          ],
          "line": 4981
        },
        "resolved": true,
        "details": {
          "function_name": "mark_usage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4746-4750",
          "snippet": "static inline int\nmark_usage(struct task_struct *curr, struct held_lock *hlock, int check)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int\nmark_usage(struct task_struct *curr, struct held_lock *hlock, int check)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_wait_context",
          "args": [
            "curr",
            "hlock"
          ],
          "line": 4977
        },
        "resolved": true,
        "details": {
          "function_name": "check_wait_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4763-4767",
          "snippet": "static inline int check_wait_context(struct task_struct *curr,\n\t\t\t\t     struct held_lock *next)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int check_wait_context(struct task_struct *curr,\n\t\t\t\t     struct held_lock *next)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockstat_clock",
          "args": [],
          "line": 4973
        },
        "resolved": true,
        "details": {
          "function_name": "lockstat_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "217-220",
          "snippet": "static inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_irq_context",
          "args": [
            "curr"
          ],
          "line": 4965
        },
        "resolved": true,
        "details": {
          "function_name": "task_irq_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4752-4755",
          "snippet": "static inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!class"
          ],
          "line": 4959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "hlock->references < references"
          ],
          "line": 4947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "depth >= MAX_LOCK_DEPTH"
          ],
          "line": 4930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 4918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"\\n\""
          ],
          "line": 4917
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "very_verbose",
          "args": [
            "class"
          ],
          "line": 4913
        },
        "resolved": true,
        "details": {
          "function_name": "very_verbose",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "779-785",
          "snippet": "static int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define VERY_VERBOSE\t\t0"
          ],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define VERY_VERBOSE\t\t0\n\nstatic noinstr struct;\n\nstatic int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_class_ops_inc",
          "args": [
            "class"
          ],
          "line": 4911
        },
        "resolved": true,
        "details": {
          "function_name": "debug_class_ops_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_internals.h",
          "lines": "234-240",
          "snippet": "static inline void debug_class_ops_inc(struct lock_class *class)\n{\n\tint idx;\n\n\tidx = class - lock_classes;\n\t__debug_atomic_inc(lock_class_ops[idx]);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n\nstatic inline void debug_class_ops_inc(struct lock_class *class)\n{\n\tint idx;\n\n\tidx = class - lock_classes;\n\t__debug_atomic_inc(lock_class_ops[idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_lock_class",
          "args": [
            "lock",
            "subclass",
            "0"
          ],
          "line": 4906
        },
        "resolved": true,
        "details": {
          "function_name": "register_lock_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1249-1351",
          "snippet": "static struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key) && !is_dynamic_key(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\tinit_data_structures_once();\n\n\t/* Allocate a new lock class and add it to the hash. */\n\tclass = list_first_entry_or_null(&free_lock_classes, typeof(*class),\n\t\t\t\t\t lock_entry);\n\tif (!class) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_lock_classes++;\n\t__set_bit(class - lock_classes, lock_classes_in_use);\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tclass->name_version = count_matching_names(class);\n\tclass->wait_type_inner = lock->wait_type_inner;\n\tclass->wait_type_outer = lock->wait_type_outer;\n\tclass->lock_type = lock->lock_type;\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Remove the class from the free list and add it to the global list\n\t * of classes.\n\t */\n\tlist_move_tail(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_lock_classes;",
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);",
            "static LIST_HEAD(free_lock_classes);",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_lock_classes;\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\nstatic LIST_HEAD(free_lock_classes);\nstatic noinstr struct;\n\nstatic struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key) && !is_dynamic_key(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\tinit_data_structures_once();\n\n\t/* Allocate a new lock class and add it to the hash. */\n\tclass = list_first_entry_or_null(&free_lock_classes, typeof(*class),\n\t\t\t\t\t lock_entry);\n\tif (!class) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_lock_classes++;\n\t__set_bit(class - lock_classes, lock_classes_in_use);\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tclass->name_version = count_matching_names(class);\n\tclass->wait_type_inner = lock->wait_type_inner;\n\tclass->wait_type_outer = lock->wait_type_outer;\n\tclass->lock_type = lock->lock_type;\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Remove the class from the free list and add it to the global list\n\t * of classes.\n\t */\n\tlist_move_tail(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!class"
          ],
          "line": 4905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 4894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define prove_locking 0\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nunsigned int max_lockdep_depth;\nstatic noinstr struct;\nstruct lock_class_key __lockdep_no_validate__;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes;\n\n\tif (depth) { /* we're holding locks */\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (!references)\n\t\t\t\treferences++;\n\n\t\t\tif (!hlock->references)\n\t\t\t\thlock->references++;\n\n\t\t\thlock->references += references;\n\n\t\t\t/* Overflow */\n\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references < references))\n\t\t\t\treturn 0;\n\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check_wait_context(curr, hlock))\n\t\treturn 0;\n\n\t/* Initialize the lock usage bit */\n\tif (!mark_usage(curr, hlock, check))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. class_idx is invalid.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!test_bit(class_idx, lock_classes_in_use)))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != INITIAL_CHAIN_KEY))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1)) {\n\t\tprint_lock_nested_lock_not_held(curr, hlock, ip);\n\t\treturn 0;\n\t}\n\n\tif (!debug_locks_silent) {\n\t\tWARN_ON_ONCE(depth && !hlock_class(hlock - 1)->key);\n\t\tWARN_ON_ONCE(!hlock_class(hlock)->key);\n\t}\n\n\tif (!validate_chain(curr, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "print_lock_nested_lock_not_held",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4839-4869",
    "snippet": "static void\nprint_lock_nested_lock_not_held(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock,\n\t\t\t\tunsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"==================================\\n\");\n\tpr_warn(\"WARNING: Nested lock was not taken\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"\\nbut this task is not holding:\\n\");\n\tpr_warn(\"%s\\n\", hlock->nest_lock->name);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 4868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 4867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 4865
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 4864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s\\n\"",
            "hlock->nest_lock->name"
          ],
          "line": 4859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nbut this task is not holding:\\n\""
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "hlock"
          ],
          "line": 4856
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "726-748",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is trying to lock:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 4855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 4855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"----------------------------------\\n\""
          ],
          "line": 4853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 4852
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: Nested lock was not taken\\n\""
          ],
          "line": 4851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"==================================\\n\""
          ],
          "line": 4850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 4844
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_lock_nested_lock_not_held(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock,\n\t\t\t\tunsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"==================================\\n\");\n\tpr_warn(\"WARNING: Nested lock was not taken\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"\\nbut this task is not holding:\\n\");\n\tpr_warn(\"%s\\n\", hlock->nest_lock->name);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "lockdep_init_map_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4774-4833",
    "snippet": "void lockdep_init_map_type(struct lockdep_map *lock, const char *name,\n\t\t\t    struct lock_class_key *key, int subclass,\n\t\t\t    u8 inner, u8 outer, u8 lock_type)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_LOCKDEP_CACHING_CLASSES; i++)\n\t\tlock->class_cache[i] = NULL;\n\n#ifdef CONFIG_LOCK_STAT\n\tlock->cpu = raw_smp_processor_id();\n#endif\n\n\t/*\n\t * Can't be having no nameless bastards around this place!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!name)) {\n\t\tlock->name = \"NULL\";\n\t\treturn;\n\t}\n\n\tlock->name = name;\n\n\tlock->wait_type_outer = outer;\n\tlock->wait_type_inner = inner;\n\tlock->lock_type = lock_type;\n\n\t/*\n\t * No key, no joy, we need to hash something.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!key))\n\t\treturn;\n\t/*\n\t * Sanity check, the lock-class key must either have been allocated\n\t * statically or must have been registered as a dynamic key.\n\t */\n\tif (!static_obj(key) && !is_dynamic_key(key)) {\n\t\tif (debug_locks)\n\t\t\tprintk(KERN_ERR \"BUG: key %px has not been registered!\\n\", key);\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn;\n\t}\n\tlock->key = key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tif (subclass) {\n\t\tunsigned long flags;\n\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_enabled()))\n\t\t\treturn;\n\n\t\traw_local_irq_save(flags);\n\t\tlockdep_recursion_inc();\n\t\tregister_lock_class(lock, subclass, 1);\n\t\tlockdep_recursion_finish();\n\t\traw_local_irq_restore(flags);\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 4831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 4830
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_lock_class",
          "args": [
            "lock",
            "subclass",
            "1"
          ],
          "line": 4829
        },
        "resolved": true,
        "details": {
          "function_name": "register_lock_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1249-1351",
          "snippet": "static struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key) && !is_dynamic_key(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\tinit_data_structures_once();\n\n\t/* Allocate a new lock class and add it to the hash. */\n\tclass = list_first_entry_or_null(&free_lock_classes, typeof(*class),\n\t\t\t\t\t lock_entry);\n\tif (!class) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_lock_classes++;\n\t__set_bit(class - lock_classes, lock_classes_in_use);\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tclass->name_version = count_matching_names(class);\n\tclass->wait_type_inner = lock->wait_type_inner;\n\tclass->wait_type_outer = lock->wait_type_outer;\n\tclass->lock_type = lock->lock_type;\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Remove the class from the free list and add it to the global list\n\t * of classes.\n\t */\n\tlist_move_tail(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_lock_classes;",
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);",
            "static LIST_HEAD(free_lock_classes);",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_lock_classes;\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\nstatic LIST_HEAD(free_lock_classes);\nstatic noinstr struct;\n\nstatic struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key) && !is_dynamic_key(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\tinit_data_structures_once();\n\n\t/* Allocate a new lock class and add it to the hash. */\n\tclass = list_first_entry_or_null(&free_lock_classes, typeof(*class),\n\t\t\t\t\t lock_entry);\n\tif (!class) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_lock_classes++;\n\t__set_bit(class - lock_classes, lock_classes_in_use);\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tclass->name_version = count_matching_names(class);\n\tclass->wait_type_inner = lock->wait_type_inner;\n\tclass->wait_type_outer = lock->wait_type_outer;\n\tclass->lock_type = lock->lock_type;\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Remove the class from the free list and add it to the global list\n\t * of classes.\n\t */\n\tlist_move_tail(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 4828
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 4827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!lockdep_enabled()"
          ],
          "line": 4824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 4824
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 4818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "1"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BUG: key %px has not been registered!\\n\"",
            "key"
          ],
          "line": 4812
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dynamic_key",
          "args": [
            "key"
          ],
          "line": 4810
        },
        "resolved": true,
        "details": {
          "function_name": "is_dynamic_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1213-1242",
          "snippet": "static bool is_dynamic_key(const struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head;\n\tstruct lock_class_key *k;\n\tbool found = false;\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn false;\n\n\t/*\n\t * If lock debugging is disabled lock_keys_hash[] may contain\n\t * pointers to memory that has already been freed. Avoid triggering\n\t * a use-after-free in that case by returning early.\n\t */\n\tif (!debug_locks)\n\t\treturn true;\n\n\thash_head = keyhashentry(key);\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (k == key) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head lock_keys_hash[KEYHASH_SIZE];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct hlist_head lock_keys_hash[KEYHASH_SIZE];\nstatic noinstr struct;\n\nstatic bool is_dynamic_key(const struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head;\n\tstruct lock_class_key *k;\n\tbool found = false;\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn false;\n\n\t/*\n\t * If lock debugging is disabled lock_keys_hash[] may contain\n\t * pointers to memory that has already been freed. Avoid triggering\n\t * a use-after-free in that case by returning early.\n\t */\n\tif (!debug_locks)\n\t\treturn true;\n\n\thash_head = keyhashentry(key);\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (k == key) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_obj",
          "args": [
            "key"
          ],
          "line": 4810
        },
        "resolved": true,
        "details": {
          "function_name": "static_obj",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "806-831",
          "snippet": "static int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!key"
          ],
          "line": 4804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!name"
          ],
          "line": 4790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_init_map_type(struct lockdep_map *lock, const char *name,\n\t\t\t    struct lock_class_key *key, int subclass,\n\t\t\t    u8 inner, u8 outer, u8 lock_type)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_LOCKDEP_CACHING_CLASSES; i++)\n\t\tlock->class_cache[i] = NULL;\n\n#ifdef CONFIG_LOCK_STAT\n\tlock->cpu = raw_smp_processor_id();\n#endif\n\n\t/*\n\t * Can't be having no nameless bastards around this place!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!name)) {\n\t\tlock->name = \"NULL\";\n\t\treturn;\n\t}\n\n\tlock->name = name;\n\n\tlock->wait_type_outer = outer;\n\tlock->wait_type_inner = inner;\n\tlock->lock_type = lock_type;\n\n\t/*\n\t * No key, no joy, we need to hash something.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!key))\n\t\treturn;\n\t/*\n\t * Sanity check, the lock-class key must either have been allocated\n\t * statically or must have been registered as a dynamic key.\n\t */\n\tif (!static_obj(key) && !is_dynamic_key(key)) {\n\t\tif (debug_locks)\n\t\t\tprintk(KERN_ERR \"BUG: key %px has not been registered!\\n\", key);\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn;\n\t}\n\tlock->key = key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tif (subclass) {\n\t\tunsigned long flags;\n\n\t\tif (DEBUG_LOCKS_WARN_ON(!lockdep_enabled()))\n\t\t\treturn;\n\n\t\traw_local_irq_save(flags);\n\t\tlockdep_recursion_inc();\n\t\tregister_lock_class(lock, subclass, 1);\n\t\tlockdep_recursion_finish();\n\t\traw_local_irq_restore(flags);\n\t}\n}"
  },
  {
    "function_name": "check_wait_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4763-4767",
    "snippet": "static inline int check_wait_context(struct task_struct *curr,\n\t\t\t\t     struct held_lock *next)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int check_wait_context(struct task_struct *curr,\n\t\t\t\t     struct held_lock *next)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "separate_irq_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4757-4761",
    "snippet": "static inline int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "task_irq_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4752-4755",
    "snippet": "static inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "mark_usage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4746-4750",
    "snippet": "static inline int\nmark_usage(struct task_struct *curr, struct held_lock *hlock, int check)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int\nmark_usage(struct task_struct *curr, struct held_lock *hlock, int check)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "check_wait_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4698-4742",
    "snippet": "static int check_wait_context(struct task_struct *curr, struct held_lock *next)\n{\n\tu8 next_inner = hlock_class(next)->wait_type_inner;\n\tu8 next_outer = hlock_class(next)->wait_type_outer;\n\tu8 curr_inner;\n\tint depth;\n\n\tif (!next_inner || next->trylock)\n\t\treturn 0;\n\n\tif (!next_outer)\n\t\tnext_outer = next_inner;\n\n\t/*\n\t * Find start of current irq_context..\n\t */\n\tfor (depth = curr->lockdep_depth - 1; depth >= 0; depth--) {\n\t\tstruct held_lock *prev = curr->held_locks + depth;\n\t\tif (prev->irq_context != next->irq_context)\n\t\t\tbreak;\n\t}\n\tdepth++;\n\n\tcurr_inner = task_wait_context(curr);\n\n\tfor (; depth < curr->lockdep_depth; depth++) {\n\t\tstruct held_lock *prev = curr->held_locks + depth;\n\t\tu8 prev_inner = hlock_class(prev)->wait_type_inner;\n\n\t\tif (prev_inner) {\n\t\t\t/*\n\t\t\t * We can have a bigger inner than a previous one\n\t\t\t * when outer is smaller than inner, as with RCU.\n\t\t\t *\n\t\t\t * Also due to trylocks.\n\t\t\t */\n\t\t\tcurr_inner = min(curr_inner, prev_inner);\n\t\t}\n\t}\n\n\tif (next_outer > curr_inner)\n\t\treturn print_lock_invalid_wait_context(curr, next);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_lock_invalid_wait_context",
          "args": [
            "curr",
            "next"
          ],
          "line": 4739
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_invalid_wait_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4650-4681",
          "snippet": "static int\nprint_lock_invalid_wait_context(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock)\n{\n\tshort curr_inner;\n\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================\\n\");\n\tpr_warn(\"[ BUG: Invalid wait context ]\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"other info that might help us debug this:\\n\");\n\n\tcurr_inner = task_wait_context(curr);\n\tpr_warn(\"context-{%d:%d}\\n\", curr_inner, curr_inner);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"stack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int\nprint_lock_invalid_wait_context(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock)\n{\n\tshort curr_inner;\n\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================\\n\");\n\tpr_warn(\"[ BUG: Invalid wait context ]\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"other info that might help us debug this:\\n\");\n\n\tcurr_inner = task_wait_context(curr);\n\tpr_warn(\"context-{%d:%d}\\n\", curr_inner, curr_inner);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"stack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "curr_inner",
            "prev_inner"
          ],
          "line": 4734
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "prev"
          ],
          "line": 4725
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_wait_context",
          "args": [
            "curr"
          ],
          "line": 4721
        },
        "resolved": true,
        "details": {
          "function_name": "task_wait_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4626-4648",
          "snippet": "static inline short task_wait_context(struct task_struct *curr)\n{\n\t/*\n\t * Set appropriate wait type for the context; for IRQs we have to take\n\t * into account force_irqthread as that is implied by PREEMPT_RT.\n\t */\n\tif (lockdep_hardirq_context()) {\n\t\t/*\n\t\t * Check if force_irqthreads will run us threaded.\n\t\t */\n\t\tif (curr->hardirq_threaded || curr->irq_config)\n\t\t\treturn LD_WAIT_CONFIG;\n\n\t\treturn LD_WAIT_SPIN;\n\t} else if (curr->softirq_context) {\n\t\t/*\n\t\t * Softirqs are always threaded.\n\t\t */\n\t\treturn LD_WAIT_CONFIG;\n\t}\n\n\treturn LD_WAIT_MAX;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline short task_wait_context(struct task_struct *curr)\n{\n\t/*\n\t * Set appropriate wait type for the context; for IRQs we have to take\n\t * into account force_irqthread as that is implied by PREEMPT_RT.\n\t */\n\tif (lockdep_hardirq_context()) {\n\t\t/*\n\t\t * Check if force_irqthreads will run us threaded.\n\t\t */\n\t\tif (curr->hardirq_threaded || curr->irq_config)\n\t\t\treturn LD_WAIT_CONFIG;\n\n\t\treturn LD_WAIT_SPIN;\n\t} else if (curr->softirq_context) {\n\t\t/*\n\t\t * Softirqs are always threaded.\n\t\t */\n\t\treturn LD_WAIT_CONFIG;\n\t}\n\n\treturn LD_WAIT_MAX;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int check_wait_context(struct task_struct *curr, struct held_lock *next)\n{\n\tu8 next_inner = hlock_class(next)->wait_type_inner;\n\tu8 next_outer = hlock_class(next)->wait_type_outer;\n\tu8 curr_inner;\n\tint depth;\n\n\tif (!next_inner || next->trylock)\n\t\treturn 0;\n\n\tif (!next_outer)\n\t\tnext_outer = next_inner;\n\n\t/*\n\t * Find start of current irq_context..\n\t */\n\tfor (depth = curr->lockdep_depth - 1; depth >= 0; depth--) {\n\t\tstruct held_lock *prev = curr->held_locks + depth;\n\t\tif (prev->irq_context != next->irq_context)\n\t\t\tbreak;\n\t}\n\tdepth++;\n\n\tcurr_inner = task_wait_context(curr);\n\n\tfor (; depth < curr->lockdep_depth; depth++) {\n\t\tstruct held_lock *prev = curr->held_locks + depth;\n\t\tu8 prev_inner = hlock_class(prev)->wait_type_inner;\n\n\t\tif (prev_inner) {\n\t\t\t/*\n\t\t\t * We can have a bigger inner than a previous one\n\t\t\t * when outer is smaller than inner, as with RCU.\n\t\t\t *\n\t\t\t * Also due to trylocks.\n\t\t\t */\n\t\t\tcurr_inner = min(curr_inner, prev_inner);\n\t\t}\n\t}\n\n\tif (next_outer > curr_inner)\n\t\treturn print_lock_invalid_wait_context(curr, next);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_lock_invalid_wait_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4650-4681",
    "snippet": "static int\nprint_lock_invalid_wait_context(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock)\n{\n\tshort curr_inner;\n\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================\\n\");\n\tpr_warn(\"[ BUG: Invalid wait context ]\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"other info that might help us debug this:\\n\");\n\n\tcurr_inner = task_wait_context(curr);\n\tpr_warn(\"context-{%d:%d}\\n\", curr_inner, curr_inner);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"stack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 4678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"stack backtrace:\\n\""
          ],
          "line": 4677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 4675
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"context-{%d:%d}\\n\"",
            "curr_inner",
            "curr_inner"
          ],
          "line": 4673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_wait_context",
          "args": [
            "curr"
          ],
          "line": 4672
        },
        "resolved": true,
        "details": {
          "function_name": "task_wait_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4626-4648",
          "snippet": "static inline short task_wait_context(struct task_struct *curr)\n{\n\t/*\n\t * Set appropriate wait type for the context; for IRQs we have to take\n\t * into account force_irqthread as that is implied by PREEMPT_RT.\n\t */\n\tif (lockdep_hardirq_context()) {\n\t\t/*\n\t\t * Check if force_irqthreads will run us threaded.\n\t\t */\n\t\tif (curr->hardirq_threaded || curr->irq_config)\n\t\t\treturn LD_WAIT_CONFIG;\n\n\t\treturn LD_WAIT_SPIN;\n\t} else if (curr->softirq_context) {\n\t\t/*\n\t\t * Softirqs are always threaded.\n\t\t */\n\t\treturn LD_WAIT_CONFIG;\n\t}\n\n\treturn LD_WAIT_MAX;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline short task_wait_context(struct task_struct *curr)\n{\n\t/*\n\t * Set appropriate wait type for the context; for IRQs we have to take\n\t * into account force_irqthread as that is implied by PREEMPT_RT.\n\t */\n\tif (lockdep_hardirq_context()) {\n\t\t/*\n\t\t * Check if force_irqthreads will run us threaded.\n\t\t */\n\t\tif (curr->hardirq_threaded || curr->irq_config)\n\t\t\treturn LD_WAIT_CONFIG;\n\n\t\treturn LD_WAIT_SPIN;\n\t} else if (curr->softirq_context) {\n\t\t/*\n\t\t * Softirqs are always threaded.\n\t\t */\n\t\treturn LD_WAIT_CONFIG;\n\t}\n\n\treturn LD_WAIT_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"other info that might help us debug this:\\n\""
          ],
          "line": 4670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "hlock"
          ],
          "line": 4668
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "726-748",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is trying to lock:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 4667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 4667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"-----------------------------\\n\""
          ],
          "line": 4665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 4664
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"[ BUG: Invalid wait context ]\\n\""
          ],
          "line": 4663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=============================\\n\""
          ],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 4661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 4656
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int\nprint_lock_invalid_wait_context(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock)\n{\n\tshort curr_inner;\n\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================\\n\");\n\tpr_warn(\"[ BUG: Invalid wait context ]\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"other info that might help us debug this:\\n\");\n\n\tcurr_inner = task_wait_context(curr);\n\tpr_warn(\"context-{%d:%d}\\n\", curr_inner, curr_inner);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"stack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "task_wait_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4626-4648",
    "snippet": "static inline short task_wait_context(struct task_struct *curr)\n{\n\t/*\n\t * Set appropriate wait type for the context; for IRQs we have to take\n\t * into account force_irqthread as that is implied by PREEMPT_RT.\n\t */\n\tif (lockdep_hardirq_context()) {\n\t\t/*\n\t\t * Check if force_irqthreads will run us threaded.\n\t\t */\n\t\tif (curr->hardirq_threaded || curr->irq_config)\n\t\t\treturn LD_WAIT_CONFIG;\n\n\t\treturn LD_WAIT_SPIN;\n\t} else if (curr->softirq_context) {\n\t\t/*\n\t\t * Softirqs are always threaded.\n\t\t */\n\t\treturn LD_WAIT_CONFIG;\n\t}\n\n\treturn LD_WAIT_MAX;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirq_context",
          "args": [],
          "line": 4632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline short task_wait_context(struct task_struct *curr)\n{\n\t/*\n\t * Set appropriate wait type for the context; for IRQs we have to take\n\t * into account force_irqthread as that is implied by PREEMPT_RT.\n\t */\n\tif (lockdep_hardirq_context()) {\n\t\t/*\n\t\t * Check if force_irqthreads will run us threaded.\n\t\t */\n\t\tif (curr->hardirq_threaded || curr->irq_config)\n\t\t\treturn LD_WAIT_CONFIG;\n\n\t\treturn LD_WAIT_SPIN;\n\t} else if (curr->softirq_context) {\n\t\t/*\n\t\t * Softirqs are always threaded.\n\t\t */\n\t\treturn LD_WAIT_CONFIG;\n\t}\n\n\treturn LD_WAIT_MAX;\n}"
  },
  {
    "function_name": "mark_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4564-4624",
    "snippet": "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask, ret = 1;\n\n\tif (new_bit >= LOCK_USAGE_STATES) {\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (new_bit == LOCK_USED && this->read)\n\t\tnew_bit = LOCK_USED_READ;\n\n\tnew_mask = 1 << new_bit;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask))\n\t\tgoto unlock;\n\n\tif (!hlock_class(this)->usage_mask)\n\t\tdebug_atomic_dec(nr_unused_locks);\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (new_bit < LOCK_TRACE_STATES) {\n\t\tif (!(hlock_class(this)->usage_traces[new_bit] = save_trace()))\n\t\t\treturn 0;\n\t}\n\n\tif (new_bit < LOCK_USED) {\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\nunlock:\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 4620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "curr"
          ],
          "line": 4619
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4085-4102",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "this"
          ],
          "line": 4618
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "726-748",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\nmarked lock as {%s}:\\n\"",
            "usage_str[new_bit]"
          ],
          "line": 4617
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 4611
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_lock_irq",
          "args": [
            "curr",
            "this",
            "new_bit"
          ],
          "line": 4605
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4136-4183",
          "snippet": "static int\nmark_lock_irq(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit new_bit)\n{\n\tint excl_bit = exclusive_bit(new_bit);\n\tint read = new_bit & LOCK_USAGE_READ_MASK;\n\tint dir = new_bit & LOCK_USAGE_DIR_MASK;\n\n\t/*\n\t * Validate that this particular lock does not have conflicting\n\t * usage states.\n\t */\n\tif (!valid_state(curr, this, new_bit, excl_bit))\n\t\treturn 0;\n\n\t/*\n\t * Check for read in write conflicts\n\t */\n\tif (!read && !valid_state(curr, this, new_bit,\n\t\t\t\t  excl_bit + LOCK_USAGE_READ_MASK))\n\t\treturn 0;\n\n\n\t/*\n\t * Validate that the lock dependencies don't have conflicting usage\n\t * states.\n\t */\n\tif (dir) {\n\t\t/*\n\t\t * mark ENABLED has to look backwards -- to ensure no dependee\n\t\t * has USED_IN state, which, again, would allow  recursion deadlocks.\n\t\t */\n\t\tif (!check_usage_backwards(curr, this, excl_bit))\n\t\t\treturn 0;\n\t} else {\n\t\t/*\n\t\t * mark USED_IN has to look forwards -- to ensure no dependency\n\t\t * has ENABLED state, which would allow recursion deadlocks.\n\t\t */\n\t\tif (!check_usage_forwards(curr, this, excl_bit))\n\t\t\treturn 0;\n\t}\n\n\tif (state_verbose(new_bit, hlock_class(this)))\n\t\treturn 2;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\nmark_lock_irq(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit new_bit)\n{\n\tint excl_bit = exclusive_bit(new_bit);\n\tint read = new_bit & LOCK_USAGE_READ_MASK;\n\tint dir = new_bit & LOCK_USAGE_DIR_MASK;\n\n\t/*\n\t * Validate that this particular lock does not have conflicting\n\t * usage states.\n\t */\n\tif (!valid_state(curr, this, new_bit, excl_bit))\n\t\treturn 0;\n\n\t/*\n\t * Check for read in write conflicts\n\t */\n\tif (!read && !valid_state(curr, this, new_bit,\n\t\t\t\t  excl_bit + LOCK_USAGE_READ_MASK))\n\t\treturn 0;\n\n\n\t/*\n\t * Validate that the lock dependencies don't have conflicting usage\n\t * states.\n\t */\n\tif (dir) {\n\t\t/*\n\t\t * mark ENABLED has to look backwards -- to ensure no dependee\n\t\t * has USED_IN state, which, again, would allow  recursion deadlocks.\n\t\t */\n\t\tif (!check_usage_backwards(curr, this, excl_bit))\n\t\t\treturn 0;\n\t} else {\n\t\t/*\n\t\t * mark USED_IN has to look forwards -- to ensure no dependency\n\t\t * has ENABLED state, which would allow recursion deadlocks.\n\t\t */\n\t\tif (!check_usage_forwards(curr, this, excl_bit))\n\t\t\treturn 0;\n\t}\n\n\tif (state_verbose(new_bit, hlock_class(this)))\n\t\treturn 2;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_trace",
          "args": [],
          "line": 4600
        },
        "resolved": true,
        "details": {
          "function_name": "save_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "530-567",
          "snippet": "static struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))"
          ],
          "globals_used": [
            "unsigned long nr_stack_trace_entries;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))\n\nunsigned long nr_stack_trace_entries;\nstatic noinstr struct;\n\nstatic struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "this"
          ],
          "line": 4600
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_dec",
          "args": [
            "nr_unused_locks"
          ],
          "line": 4595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "hlock_class(this)->usage_mask & new_mask"
          ],
          "line": 4591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_lock",
          "args": [],
          "line": 4586
        },
        "resolved": true,
        "details": {
          "function_name": "graph_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "137-151",
          "snippet": "static int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "hlock_class(this)->usage_mask & new_mask"
          ],
          "line": 4583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "1"
          ],
          "line": 4570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask, ret = 1;\n\n\tif (new_bit >= LOCK_USAGE_STATES) {\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (new_bit == LOCK_USED && this->read)\n\t\tnew_bit = LOCK_USED_READ;\n\n\tnew_mask = 1 << new_bit;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask))\n\t\tgoto unlock;\n\n\tif (!hlock_class(this)->usage_mask)\n\t\tdebug_atomic_dec(nr_unused_locks);\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (new_bit < LOCK_TRACE_STATES) {\n\t\tif (!(hlock_class(this)->usage_traces[new_bit] = save_trace()))\n\t\t\treturn 0;\n\t}\n\n\tif (new_bit < LOCK_USED) {\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\nunlock:\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "separate_irq_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4538-4559",
    "snippet": "static int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\tunsigned int depth = curr->lockdep_depth;\n\n\t/*\n\t * Keep track of points where we cross into an interrupt context:\n\t */\n\tif (depth) {\n\t\tstruct held_lock *prev_hlock;\n\n\t\tprev_hlock = curr->held_locks + depth-1;\n\t\t/*\n\t\t * If we cross into another context, reset the\n\t\t * hash key (this also prevents the checking and the\n\t\t * adding of the dependency to 'prev'):\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\tunsigned int depth = curr->lockdep_depth;\n\n\t/*\n\t * Keep track of points where we cross into an interrupt context:\n\t */\n\tif (depth) {\n\t\tstruct held_lock *prev_hlock;\n\n\t\tprev_hlock = curr->held_locks + depth-1;\n\t\t/*\n\t\t * If we cross into another context, reset the\n\t\t * hash key (this also prevents the checking and the\n\t\t * adding of the dependency to 'prev'):\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "task_irq_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4532-4536",
    "snippet": "static inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn LOCK_CHAIN_HARDIRQ_CONTEXT * !!lockdep_hardirq_context() +\n\t       LOCK_CHAIN_SOFTIRQ_CONTEXT * !!task->softirq_context;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirq_context",
          "args": [],
          "line": 4534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn LOCK_CHAIN_HARDIRQ_CONTEXT * !!lockdep_hardirq_context() +\n\t       LOCK_CHAIN_SOFTIRQ_CONTEXT * !!task->softirq_context;\n}"
  },
  {
    "function_name": "mark_usage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4475-4530",
    "snippet": "static int\nmark_usage(struct task_struct *curr, struct held_lock *hlock, int check)\n{\n\tif (!check)\n\t\tgoto lock_used;\n\n\t/*\n\t * If non-trylock use in a hardirq or softirq context, then\n\t * mark the lock as used in these contexts:\n\t */\n\tif (!hlock->trylock) {\n\t\tif (hlock->read) {\n\t\t\tif (lockdep_hardirq_context())\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_USED_IN_HARDIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t\tif (curr->softirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_USED_IN_SOFTIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (lockdep_hardirq_context())\n\t\t\t\tif (!mark_lock(curr, hlock, LOCK_USED_IN_HARDIRQ))\n\t\t\t\t\treturn 0;\n\t\t\tif (curr->softirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock, LOCK_USED_IN_SOFTIRQ))\n\t\t\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!hlock->hardirqs_off) {\n\t\tif (hlock->read) {\n\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\tLOCK_ENABLED_HARDIRQ_READ))\n\t\t\t\treturn 0;\n\t\t\tif (curr->softirqs_enabled)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_ENABLED_SOFTIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\tLOCK_ENABLED_HARDIRQ))\n\t\t\t\treturn 0;\n\t\t\tif (curr->softirqs_enabled)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_ENABLED_SOFTIRQ))\n\t\t\t\t\treturn 0;\n\t\t}\n\t}\n\nlock_used:\n\t/* mark it as used: */\n\tif (!mark_lock(curr, hlock, LOCK_USED))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_lock",
          "args": [
            "curr",
            "hlock",
            "LOCK_USED"
          ],
          "line": 4526
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4564-4624",
          "snippet": "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask, ret = 1;\n\n\tif (new_bit >= LOCK_USAGE_STATES) {\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (new_bit == LOCK_USED && this->read)\n\t\tnew_bit = LOCK_USED_READ;\n\n\tnew_mask = 1 << new_bit;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask))\n\t\tgoto unlock;\n\n\tif (!hlock_class(this)->usage_mask)\n\t\tdebug_atomic_dec(nr_unused_locks);\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (new_bit < LOCK_TRACE_STATES) {\n\t\tif (!(hlock_class(this)->usage_traces[new_bit] = save_trace()))\n\t\t\treturn 0;\n\t}\n\n\tif (new_bit < LOCK_USED) {\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\nunlock:\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask, ret = 1;\n\n\tif (new_bit >= LOCK_USAGE_STATES) {\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (new_bit == LOCK_USED && this->read)\n\t\tnew_bit = LOCK_USED_READ;\n\n\tnew_mask = 1 << new_bit;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask))\n\t\tgoto unlock;\n\n\tif (!hlock_class(this)->usage_mask)\n\t\tdebug_atomic_dec(nr_unused_locks);\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (new_bit < LOCK_TRACE_STATES) {\n\t\tif (!(hlock_class(this)->usage_traces[new_bit] = save_trace()))\n\t\t\treturn 0;\n\t}\n\n\tif (new_bit < LOCK_USED) {\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\nunlock:\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_hardirq_context",
          "args": [],
          "line": 4496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirq_context",
          "args": [],
          "line": 4487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\nmark_usage(struct task_struct *curr, struct held_lock *hlock, int check)\n{\n\tif (!check)\n\t\tgoto lock_used;\n\n\t/*\n\t * If non-trylock use in a hardirq or softirq context, then\n\t * mark the lock as used in these contexts:\n\t */\n\tif (!hlock->trylock) {\n\t\tif (hlock->read) {\n\t\t\tif (lockdep_hardirq_context())\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_USED_IN_HARDIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t\tif (curr->softirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_USED_IN_SOFTIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (lockdep_hardirq_context())\n\t\t\t\tif (!mark_lock(curr, hlock, LOCK_USED_IN_HARDIRQ))\n\t\t\t\t\treturn 0;\n\t\t\tif (curr->softirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock, LOCK_USED_IN_SOFTIRQ))\n\t\t\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!hlock->hardirqs_off) {\n\t\tif (hlock->read) {\n\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\tLOCK_ENABLED_HARDIRQ_READ))\n\t\t\t\treturn 0;\n\t\t\tif (curr->softirqs_enabled)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_ENABLED_SOFTIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\tLOCK_ENABLED_HARDIRQ))\n\t\t\t\treturn 0;\n\t\t\tif (curr->softirqs_enabled)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_ENABLED_SOFTIRQ))\n\t\t\t\t\treturn 0;\n\t\t}\n\t}\n\nlock_used:\n\t/* mark it as used: */\n\tif (!mark_lock(curr, hlock, LOCK_USED))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "lockdep_softirqs_off",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4446-4473",
    "snippet": "void lockdep_softirqs_off(unsigned long ip)\n{\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurrent->softirqs_enabled = 0;\n\t\ttrace->softirq_disable_ip = ip;\n\t\ttrace->softirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(softirqs_off_events);\n\t\t/*\n\t\t * Whoops, we wanted softirqs off, so why aren't they?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(!softirq_count());\n\t} else\n\t\tdebug_atomic_inc(redundant_softirqs_off);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "redundant_softirqs_off"
          ],
          "line": 4472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!softirq_count()"
          ],
          "line": 4470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 4470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "softirqs_off_events"
          ],
          "line": 4466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 4454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 4454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lockdep_enabled()"
          ],
          "line": 4448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 4448
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_softirqs_off(unsigned long ip)\n{\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurrent->softirqs_enabled = 0;\n\t\ttrace->softirq_disable_ip = ip;\n\t\ttrace->softirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(softirqs_off_events);\n\t\t/*\n\t\t * Whoops, we wanted softirqs off, so why aren't they?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(!softirq_count());\n\t} else\n\t\tdebug_atomic_inc(redundant_softirqs_off);\n}"
  },
  {
    "function_name": "lockdep_softirqs_on",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4406-4441",
    "snippet": "void lockdep_softirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c, avoids\n\t * funny state and nesting things.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tdebug_atomic_inc(redundant_softirqs_on);\n\t\treturn;\n\t}\n\n\tlockdep_recursion_inc();\n\t/*\n\t * We'll do an OFF -> ON transition:\n\t */\n\tcurrent->softirqs_enabled = 1;\n\ttrace->softirq_enable_ip = ip;\n\ttrace->softirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(softirqs_on_events);\n\t/*\n\t * We are going to turn softirqs on, so set the\n\t * usage bit for all held locks, if hardirqs are\n\t * enabled too:\n\t */\n\tif (lockdep_hardirqs_enabled())\n\t\tmark_held_locks(current, LOCK_ENABLED_SOFTIRQ);\n\tlockdep_recursion_finish();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 4440
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_held_locks",
          "args": [
            "current",
            "LOCK_ENABLED_SOFTIRQ"
          ],
          "line": 4439
        },
        "resolved": true,
        "details": {
          "function_name": "mark_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4188-4211",
          "snippet": "static int\nmark_held_locks(struct task_struct *curr, enum lock_usage_bit base_bit)\n{\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tenum lock_usage_bit hlock_bit = base_bit;\n\t\thlock = curr->held_locks + i;\n\n\t\tif (hlock->read)\n\t\t\thlock_bit += LOCK_USAGE_READ_MASK;\n\n\t\tBUG_ON(hlock_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, hlock_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\nmark_held_locks(struct task_struct *curr, enum lock_usage_bit base_bit)\n{\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tenum lock_usage_bit hlock_bit = base_bit;\n\t\thlock = curr->held_locks + i;\n\n\t\tif (hlock->read)\n\t\t\thlock_bit += LOCK_USAGE_READ_MASK;\n\n\t\tBUG_ON(hlock_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, hlock_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_enabled",
          "args": [],
          "line": 4438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "softirqs_on_events"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 4425
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "redundant_softirqs_on"
          ],
          "line": 4421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lockdep_enabled()"
          ],
          "line": 4410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_enabled",
          "args": [],
          "line": 4410
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "83-95",
          "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_softirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!lockdep_enabled()))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c, avoids\n\t * funny state and nesting things.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (current->softirqs_enabled) {\n\t\tdebug_atomic_inc(redundant_softirqs_on);\n\t\treturn;\n\t}\n\n\tlockdep_recursion_inc();\n\t/*\n\t * We'll do an OFF -> ON transition:\n\t */\n\tcurrent->softirqs_enabled = 1;\n\ttrace->softirq_enable_ip = ip;\n\ttrace->softirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(softirqs_on_events);\n\t/*\n\t * We are going to turn softirqs on, so set the\n\t * usage bit for all held locks, if hardirqs are\n\t * enabled too:\n\t */\n\tif (lockdep_hardirqs_enabled())\n\t\tmark_held_locks(current, LOCK_ENABLED_SOFTIRQ);\n\tlockdep_recursion_finish();\n}"
  },
  {
    "function_name": "lockdep_hardirqs_off",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4364-4400",
    "snippet": "void noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "redundant_hardirqs_off"
          ],
          "line": 4398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "hardirqs_off_events"
          ],
          "line": 4396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "hardirqs_enabled",
            "0"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_enabled",
          "args": [],
          "line": 4387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "lockdep_recursion"
          ],
          "line": 4377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TRACE_IRQFLAGS_NMI"
          ],
          "line": 4375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 4374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 4366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}"
  },
  {
    "function_name": "lockdep_hardirqs_on",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4297-4358",
    "snippet": "void noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "hardirqs_on_events"
          ],
          "line": 4357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "hardirqs_enabled",
            "1"
          ],
          "line": 4354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key"
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 4342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 4342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__debug_atomic_inc",
          "args": [
            "redundant_hardirqs_on"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_enabled",
          "args": [],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "this_cpu_read(lockdep_recursion)"
          ],
          "line": 4324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "lockdep_recursion"
          ],
          "line": 4324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TRACE_IRQFLAGS_NMI"
          ],
          "line": 4312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_nmi()"
          ],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 4301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}"
  },
  {
    "function_name": "lockdep_hardirqs_on_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4244-4294",
    "snippet": "void lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_recursion_finish",
          "args": [],
          "line": 4293
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "436-440",
          "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_hardirqs_on_caller",
          "args": [],
          "line": 4292
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_hardirqs_on_caller",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4216-4233",
          "snippet": "static void __trace_hardirqs_on_caller(void)\n{\n\tstruct task_struct *curr = current;\n\n\t/*\n\t * We are going to turn hardirqs on, so set the\n\t * usage bit for all held locks:\n\t */\n\tif (!mark_held_locks(curr, LOCK_ENABLED_HARDIRQ))\n\t\treturn;\n\t/*\n\t * If we have softirqs enabled, then set the usage\n\t * bit for all held locks. (disabled hardirqs prevented\n\t * this bit from being set before)\n\t */\n\tif (curr->softirqs_enabled)\n\t\tmark_held_locks(curr, LOCK_ENABLED_SOFTIRQ);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __trace_hardirqs_on_caller(void)\n{\n\tstruct task_struct *curr = current;\n\n\t/*\n\t * We are going to turn hardirqs on, so set the\n\t * usage bit for all held locks:\n\t */\n\tif (!mark_held_locks(curr, LOCK_ENABLED_HARDIRQ))\n\t\treturn;\n\t/*\n\t * If we have softirqs enabled, then set the usage\n\t * bit for all held locks. (disabled hardirqs prevented\n\t * this bit from being set before)\n\t */\n\tif (curr->softirqs_enabled)\n\t\tmark_held_locks(curr, LOCK_ENABLED_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_recursion_inc",
          "args": [],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_recursion_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "431-434",
          "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "lockdep_hardirq_context()"
          ],
          "line": 4286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirq_context",
          "args": [],
          "line": 4286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "early_boot_irqs_disabled"
          ],
          "line": 4279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 4273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 4273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__debug_atomic_inc",
          "args": [
            "redundant_hardirqs_on"
          ],
          "line": 4264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lockdep_hardirqs_enabled()"
          ],
          "line": 4258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_enabled",
          "args": [],
          "line": 4258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "this_cpu_read(lockdep_recursion)"
          ],
          "line": 4255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "lockdep_recursion"
          ],
          "line": 4255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_nmi()"
          ],
          "line": 4252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 4252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 4246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}"
  },
  {
    "function_name": "__trace_hardirqs_on_caller",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4216-4233",
    "snippet": "static void __trace_hardirqs_on_caller(void)\n{\n\tstruct task_struct *curr = current;\n\n\t/*\n\t * We are going to turn hardirqs on, so set the\n\t * usage bit for all held locks:\n\t */\n\tif (!mark_held_locks(curr, LOCK_ENABLED_HARDIRQ))\n\t\treturn;\n\t/*\n\t * If we have softirqs enabled, then set the usage\n\t * bit for all held locks. (disabled hardirqs prevented\n\t * this bit from being set before)\n\t */\n\tif (curr->softirqs_enabled)\n\t\tmark_held_locks(curr, LOCK_ENABLED_SOFTIRQ);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_held_locks",
          "args": [
            "curr",
            "LOCK_ENABLED_SOFTIRQ"
          ],
          "line": 4232
        },
        "resolved": true,
        "details": {
          "function_name": "mark_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4188-4211",
          "snippet": "static int\nmark_held_locks(struct task_struct *curr, enum lock_usage_bit base_bit)\n{\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tenum lock_usage_bit hlock_bit = base_bit;\n\t\thlock = curr->held_locks + i;\n\n\t\tif (hlock->read)\n\t\t\thlock_bit += LOCK_USAGE_READ_MASK;\n\n\t\tBUG_ON(hlock_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, hlock_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\nmark_held_locks(struct task_struct *curr, enum lock_usage_bit base_bit)\n{\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tenum lock_usage_bit hlock_bit = base_bit;\n\t\thlock = curr->held_locks + i;\n\n\t\tif (hlock->read)\n\t\t\thlock_bit += LOCK_USAGE_READ_MASK;\n\n\t\tBUG_ON(hlock_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, hlock_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __trace_hardirqs_on_caller(void)\n{\n\tstruct task_struct *curr = current;\n\n\t/*\n\t * We are going to turn hardirqs on, so set the\n\t * usage bit for all held locks:\n\t */\n\tif (!mark_held_locks(curr, LOCK_ENABLED_HARDIRQ))\n\t\treturn;\n\t/*\n\t * If we have softirqs enabled, then set the usage\n\t * bit for all held locks. (disabled hardirqs prevented\n\t * this bit from being set before)\n\t */\n\tif (curr->softirqs_enabled)\n\t\tmark_held_locks(curr, LOCK_ENABLED_SOFTIRQ);\n}"
  },
  {
    "function_name": "mark_held_locks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4188-4211",
    "snippet": "static int\nmark_held_locks(struct task_struct *curr, enum lock_usage_bit base_bit)\n{\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tenum lock_usage_bit hlock_bit = base_bit;\n\t\thlock = curr->held_locks + i;\n\n\t\tif (hlock->read)\n\t\t\thlock_bit += LOCK_USAGE_READ_MASK;\n\n\t\tBUG_ON(hlock_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, hlock_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_lock",
          "args": [
            "curr",
            "hlock",
            "hlock_bit"
          ],
          "line": 4206
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4564-4624",
          "snippet": "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask, ret = 1;\n\n\tif (new_bit >= LOCK_USAGE_STATES) {\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (new_bit == LOCK_USED && this->read)\n\t\tnew_bit = LOCK_USED_READ;\n\n\tnew_mask = 1 << new_bit;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask))\n\t\tgoto unlock;\n\n\tif (!hlock_class(this)->usage_mask)\n\t\tdebug_atomic_dec(nr_unused_locks);\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (new_bit < LOCK_TRACE_STATES) {\n\t\tif (!(hlock_class(this)->usage_traces[new_bit] = save_trace()))\n\t\t\treturn 0;\n\t}\n\n\tif (new_bit < LOCK_USED) {\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\nunlock:\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask, ret = 1;\n\n\tif (new_bit >= LOCK_USAGE_STATES) {\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (new_bit == LOCK_USED && this->read)\n\t\tnew_bit = LOCK_USED_READ;\n\n\tnew_mask = 1 << new_bit;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask))\n\t\tgoto unlock;\n\n\tif (!hlock_class(this)->usage_mask)\n\t\tdebug_atomic_dec(nr_unused_locks);\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (new_bit < LOCK_TRACE_STATES) {\n\t\tif (!(hlock_class(this)->usage_traces[new_bit] = save_trace()))\n\t\t\treturn 0;\n\t}\n\n\tif (new_bit < LOCK_USED) {\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\nunlock:\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "hlock_bit >= LOCK_USAGE_STATES"
          ],
          "line": 4201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\nmark_held_locks(struct task_struct *curr, enum lock_usage_bit base_bit)\n{\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tenum lock_usage_bit hlock_bit = base_bit;\n\t\thlock = curr->held_locks + i;\n\n\t\tif (hlock->read)\n\t\t\thlock_bit += LOCK_USAGE_READ_MASK;\n\n\t\tBUG_ON(hlock_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, hlock_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "mark_lock_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4136-4183",
    "snippet": "static int\nmark_lock_irq(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit new_bit)\n{\n\tint excl_bit = exclusive_bit(new_bit);\n\tint read = new_bit & LOCK_USAGE_READ_MASK;\n\tint dir = new_bit & LOCK_USAGE_DIR_MASK;\n\n\t/*\n\t * Validate that this particular lock does not have conflicting\n\t * usage states.\n\t */\n\tif (!valid_state(curr, this, new_bit, excl_bit))\n\t\treturn 0;\n\n\t/*\n\t * Check for read in write conflicts\n\t */\n\tif (!read && !valid_state(curr, this, new_bit,\n\t\t\t\t  excl_bit + LOCK_USAGE_READ_MASK))\n\t\treturn 0;\n\n\n\t/*\n\t * Validate that the lock dependencies don't have conflicting usage\n\t * states.\n\t */\n\tif (dir) {\n\t\t/*\n\t\t * mark ENABLED has to look backwards -- to ensure no dependee\n\t\t * has USED_IN state, which, again, would allow  recursion deadlocks.\n\t\t */\n\t\tif (!check_usage_backwards(curr, this, excl_bit))\n\t\t\treturn 0;\n\t} else {\n\t\t/*\n\t\t * mark USED_IN has to look forwards -- to ensure no dependency\n\t\t * has ENABLED state, which would allow recursion deadlocks.\n\t\t */\n\t\tif (!check_usage_forwards(curr, this, excl_bit))\n\t\t\treturn 0;\n\t}\n\n\tif (state_verbose(new_bit, hlock_class(this)))\n\t\treturn 2;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "state_verbose",
          "args": [
            "new_bit",
            "hlock_class(this)"
          ],
          "line": 4179
        },
        "resolved": true,
        "details": {
          "function_name": "state_verbose",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4127-4131",
          "snippet": "static inline int state_verbose(enum lock_usage_bit bit,\n\t\t\t\tstruct lock_class *class)\n{\n\treturn state_verbose_f[bit >> LOCK_USAGE_DIR_MASK](class);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int state_verbose(enum lock_usage_bit bit,\n\t\t\t\tstruct lock_class *class)\n{\n\treturn state_verbose_f[bit >> LOCK_USAGE_DIR_MASK](class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "this"
          ],
          "line": 4179
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_usage_forwards",
          "args": [
            "curr",
            "this",
            "excl_bit"
          ],
          "line": 4175
        },
        "resolved": true,
        "details": {
          "function_name": "check_usage_forwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4019-4048",
          "snippet": "static int\ncheck_usage_forwards(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit bit)\n{\n\tenum bfs_result ret;\n\tstruct lock_list root;\n\tstruct lock_list *target_entry;\n\tenum lock_usage_bit read_bit = bit + LOCK_USAGE_READ_MASK;\n\tunsigned usage_mask = lock_flag(bit) | lock_flag(read_bit);\n\n\tbfs_init_root(&root, this);\n\tret = find_usage_forwards(&root, usage_mask, &target_entry);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (ret == BFS_RNOMATCH)\n\t\treturn 1;\n\n\t/* Check whether write or read usage is the match */\n\tif (target_entry->class->usage_mask & lock_flag(bit)) {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, state_name(bit));\n\t} else {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, state_name(read_bit));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_usage_forwards(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit bit)\n{\n\tenum bfs_result ret;\n\tstruct lock_list root;\n\tstruct lock_list *target_entry;\n\tenum lock_usage_bit read_bit = bit + LOCK_USAGE_READ_MASK;\n\tunsigned usage_mask = lock_flag(bit) | lock_flag(read_bit);\n\n\tbfs_init_root(&root, this);\n\tret = find_usage_forwards(&root, usage_mask, &target_entry);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (ret == BFS_RNOMATCH)\n\t\treturn 1;\n\n\t/* Check whether write or read usage is the match */\n\tif (target_entry->class->usage_mask & lock_flag(bit)) {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, state_name(bit));\n\t} else {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, state_name(read_bit));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_usage_backwards",
          "args": [
            "curr",
            "this",
            "excl_bit"
          ],
          "line": 4168
        },
        "resolved": true,
        "details": {
          "function_name": "check_usage_backwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4054-4083",
          "snippet": "static int\ncheck_usage_backwards(struct task_struct *curr, struct held_lock *this,\n\t\t      enum lock_usage_bit bit)\n{\n\tenum bfs_result ret;\n\tstruct lock_list root;\n\tstruct lock_list *target_entry;\n\tenum lock_usage_bit read_bit = bit + LOCK_USAGE_READ_MASK;\n\tunsigned usage_mask = lock_flag(bit) | lock_flag(read_bit);\n\n\tbfs_init_rootb(&root, this);\n\tret = find_usage_backwards(&root, usage_mask, &target_entry);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (ret == BFS_RNOMATCH)\n\t\treturn 1;\n\n\t/* Check whether write or read usage is the match */\n\tif (target_entry->class->usage_mask & lock_flag(bit)) {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, state_name(bit));\n\t} else {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, state_name(read_bit));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_usage_backwards(struct task_struct *curr, struct held_lock *this,\n\t\t      enum lock_usage_bit bit)\n{\n\tenum bfs_result ret;\n\tstruct lock_list root;\n\tstruct lock_list *target_entry;\n\tenum lock_usage_bit read_bit = bit + LOCK_USAGE_READ_MASK;\n\tunsigned usage_mask = lock_flag(bit) | lock_flag(read_bit);\n\n\tbfs_init_rootb(&root, this);\n\tret = find_usage_backwards(&root, usage_mask, &target_entry);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (ret == BFS_RNOMATCH)\n\t\treturn 1;\n\n\t/* Check whether write or read usage is the match */\n\tif (target_entry->class->usage_mask & lock_flag(bit)) {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, state_name(bit));\n\t} else {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, state_name(read_bit));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_state",
          "args": [
            "curr",
            "this",
            "new_bit",
            "excl_bit + LOCK_USAGE_READ_MASK"
          ],
          "line": 4154
        },
        "resolved": true,
        "details": {
          "function_name": "valid_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3939-3949",
          "snippet": "static inline int\nvalid_state(struct task_struct *curr, struct held_lock *this,\n\t    enum lock_usage_bit new_bit, enum lock_usage_bit bad_bit)\n{\n\tif (unlikely(hlock_class(this)->usage_mask & (1 << bad_bit))) {\n\t\tgraph_unlock();\n\t\tprint_usage_bug(curr, this, bad_bit, new_bit);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int\nvalid_state(struct task_struct *curr, struct held_lock *this,\n\t    enum lock_usage_bit new_bit, enum lock_usage_bit bad_bit)\n{\n\tif (unlikely(hlock_class(this)->usage_mask & (1 << bad_bit))) {\n\t\tgraph_unlock();\n\t\tprint_usage_bug(curr, this, bad_bit, new_bit);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exclusive_bit",
          "args": [
            "new_bit"
          ],
          "line": 4140
        },
        "resolved": true,
        "details": {
          "function_name": "exclusive_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2609-2618",
          "snippet": "static int exclusive_bit(int new_bit)\n{\n\tint state = new_bit & LOCK_USAGE_STATE_MASK;\n\tint dir = new_bit & LOCK_USAGE_DIR_MASK;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ LOCK_USAGE_DIR_MASK);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int exclusive_bit(int new_bit)\n{\n\tint state = new_bit & LOCK_USAGE_STATE_MASK;\n\tint dir = new_bit & LOCK_USAGE_DIR_MASK;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ LOCK_USAGE_DIR_MASK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\nmark_lock_irq(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit new_bit)\n{\n\tint excl_bit = exclusive_bit(new_bit);\n\tint read = new_bit & LOCK_USAGE_READ_MASK;\n\tint dir = new_bit & LOCK_USAGE_DIR_MASK;\n\n\t/*\n\t * Validate that this particular lock does not have conflicting\n\t * usage states.\n\t */\n\tif (!valid_state(curr, this, new_bit, excl_bit))\n\t\treturn 0;\n\n\t/*\n\t * Check for read in write conflicts\n\t */\n\tif (!read && !valid_state(curr, this, new_bit,\n\t\t\t\t  excl_bit + LOCK_USAGE_READ_MASK))\n\t\treturn 0;\n\n\n\t/*\n\t * Validate that the lock dependencies don't have conflicting usage\n\t * states.\n\t */\n\tif (dir) {\n\t\t/*\n\t\t * mark ENABLED has to look backwards -- to ensure no dependee\n\t\t * has USED_IN state, which, again, would allow  recursion deadlocks.\n\t\t */\n\t\tif (!check_usage_backwards(curr, this, excl_bit))\n\t\t\treturn 0;\n\t} else {\n\t\t/*\n\t\t * mark USED_IN has to look forwards -- to ensure no dependency\n\t\t * has ENABLED state, which would allow recursion deadlocks.\n\t\t */\n\t\tif (!check_usage_forwards(curr, this, excl_bit))\n\t\t\treturn 0;\n\t}\n\n\tif (state_verbose(new_bit, hlock_class(this)))\n\t\treturn 2;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "state_verbose",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4127-4131",
    "snippet": "static inline int state_verbose(enum lock_usage_bit bit,\n\t\t\t\tstruct lock_class *class)\n{\n\treturn state_verbose_f[bit >> LOCK_USAGE_DIR_MASK](class);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "state_verbose_f[bit >> LOCK_USAGE_DIR_MASK]",
          "args": [
            "class"
          ],
          "line": 4130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int state_verbose(enum lock_usage_bit bit,\n\t\t\t\tstruct lock_class *class)\n{\n\treturn state_verbose_f[bit >> LOCK_USAGE_DIR_MASK](class);\n}"
  },
  {
    "function_name": "SOFTIRQ_verbose",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4112-4118",
    "snippet": "static int SOFTIRQ_verbose(struct lock_class *class)\n{\n#if SOFTIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_filter",
          "args": [
            "class"
          ],
          "line": 4115
        },
        "resolved": true,
        "details": {
          "function_name": "class_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "466-479",
          "snippet": "static int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int SOFTIRQ_verbose(struct lock_class *class)\n{\n#if SOFTIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "HARDIRQ_verbose",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4104-4110",
    "snippet": "static int HARDIRQ_verbose(struct lock_class *class)\n{\n#if HARDIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_filter",
          "args": [
            "class"
          ],
          "line": 4107
        },
        "resolved": true,
        "details": {
          "function_name": "class_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "466-479",
          "snippet": "static int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int HARDIRQ_verbose(struct lock_class *class)\n{\n#if HARDIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "print_irqtrace_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4085-4102",
    "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"softirqs last disabled at (%u): [<%px>] %pS\\n\"",
            "trace->softirq_disable_event",
            "(void *)trace->softirq_disable_ip",
            "(void *)trace->softirq_disable_ip"
          ],
          "line": 4099
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}"
  },
  {
    "function_name": "check_usage_backwards",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4054-4083",
    "snippet": "static int\ncheck_usage_backwards(struct task_struct *curr, struct held_lock *this,\n\t\t      enum lock_usage_bit bit)\n{\n\tenum bfs_result ret;\n\tstruct lock_list root;\n\tstruct lock_list *target_entry;\n\tenum lock_usage_bit read_bit = bit + LOCK_USAGE_READ_MASK;\n\tunsigned usage_mask = lock_flag(bit) | lock_flag(read_bit);\n\n\tbfs_init_rootb(&root, this);\n\tret = find_usage_backwards(&root, usage_mask, &target_entry);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (ret == BFS_RNOMATCH)\n\t\treturn 1;\n\n\t/* Check whether write or read usage is the match */\n\tif (target_entry->class->usage_mask & lock_flag(bit)) {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, state_name(bit));\n\t} else {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, state_name(read_bit));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_irq_inversion_bug",
          "args": [
            "curr",
            "&root",
            "target_entry",
            "this",
            "0",
            "state_name(read_bit)"
          ],
          "line": 4078
        },
        "resolved": true,
        "details": {
          "function_name": "print_irq_inversion_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3955-4013",
          "snippet": "static void\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\troot->trace = save_trace();\n\tif (!root->trace)\n\t\treturn;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\troot->trace = save_trace();\n\tif (!root->trace)\n\t\treturn;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "state_name",
          "args": [
            "read_bit"
          ],
          "line": 4079
        },
        "resolved": true,
        "details": {
          "function_name": "state_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2594-2600",
          "snippet": "static inline const char *state_name(enum lock_usage_bit bit)\n{\n\tif (bit & LOCK_USAGE_READ_MASK)\n\t\treturn state_rnames[bit >> LOCK_USAGE_DIR_MASK];\n\telse\n\t\treturn state_names[bit >> LOCK_USAGE_DIR_MASK];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline const char *state_name(enum lock_usage_bit bit)\n{\n\tif (bit & LOCK_USAGE_READ_MASK)\n\t\treturn state_rnames[bit >> LOCK_USAGE_DIR_MASK];\n\telse\n\t\treturn state_names[bit >> LOCK_USAGE_DIR_MASK];\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_flag",
          "args": [
            "bit"
          ],
          "line": 4074
        },
        "resolved": true,
        "details": {
          "function_name": "lock_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "639-642",
          "snippet": "static inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_bfs_bug",
          "args": [
            "ret"
          ],
          "line": 4067
        },
        "resolved": true,
        "details": {
          "function_name": "print_bfs_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2024-2033",
          "snippet": "static noinline void print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline void print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_error",
          "args": [
            "ret"
          ],
          "line": 4066
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1555-1558",
          "snippet": "static inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_usage_backwards",
          "args": [
            "&root",
            "usage_mask",
            "&target_entry"
          ],
          "line": 4065
        },
        "resolved": true,
        "details": {
          "function_name": "find_usage_backwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2281-2292",
          "snippet": "static enum bfs_result\nfind_usage_backwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic enum bfs_result\nfind_usage_backwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_init_rootb",
          "args": [
            "&root",
            "this"
          ],
          "line": 4064
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_init_rootb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1645-1650",
          "snippet": "static inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_usage_backwards(struct task_struct *curr, struct held_lock *this,\n\t\t      enum lock_usage_bit bit)\n{\n\tenum bfs_result ret;\n\tstruct lock_list root;\n\tstruct lock_list *target_entry;\n\tenum lock_usage_bit read_bit = bit + LOCK_USAGE_READ_MASK;\n\tunsigned usage_mask = lock_flag(bit) | lock_flag(read_bit);\n\n\tbfs_init_rootb(&root, this);\n\tret = find_usage_backwards(&root, usage_mask, &target_entry);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (ret == BFS_RNOMATCH)\n\t\treturn 1;\n\n\t/* Check whether write or read usage is the match */\n\tif (target_entry->class->usage_mask & lock_flag(bit)) {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, state_name(bit));\n\t} else {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, state_name(read_bit));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_usage_forwards",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "4019-4048",
    "snippet": "static int\ncheck_usage_forwards(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit bit)\n{\n\tenum bfs_result ret;\n\tstruct lock_list root;\n\tstruct lock_list *target_entry;\n\tenum lock_usage_bit read_bit = bit + LOCK_USAGE_READ_MASK;\n\tunsigned usage_mask = lock_flag(bit) | lock_flag(read_bit);\n\n\tbfs_init_root(&root, this);\n\tret = find_usage_forwards(&root, usage_mask, &target_entry);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (ret == BFS_RNOMATCH)\n\t\treturn 1;\n\n\t/* Check whether write or read usage is the match */\n\tif (target_entry->class->usage_mask & lock_flag(bit)) {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, state_name(bit));\n\t} else {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, state_name(read_bit));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_irq_inversion_bug",
          "args": [
            "curr",
            "&root",
            "target_entry",
            "this",
            "1",
            "state_name(read_bit)"
          ],
          "line": 4043
        },
        "resolved": true,
        "details": {
          "function_name": "print_irq_inversion_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3955-4013",
          "snippet": "static void\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\troot->trace = save_trace();\n\tif (!root->trace)\n\t\treturn;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\troot->trace = save_trace();\n\tif (!root->trace)\n\t\treturn;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "state_name",
          "args": [
            "read_bit"
          ],
          "line": 4044
        },
        "resolved": true,
        "details": {
          "function_name": "state_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2594-2600",
          "snippet": "static inline const char *state_name(enum lock_usage_bit bit)\n{\n\tif (bit & LOCK_USAGE_READ_MASK)\n\t\treturn state_rnames[bit >> LOCK_USAGE_DIR_MASK];\n\telse\n\t\treturn state_names[bit >> LOCK_USAGE_DIR_MASK];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline const char *state_name(enum lock_usage_bit bit)\n{\n\tif (bit & LOCK_USAGE_READ_MASK)\n\t\treturn state_rnames[bit >> LOCK_USAGE_DIR_MASK];\n\telse\n\t\treturn state_names[bit >> LOCK_USAGE_DIR_MASK];\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_flag",
          "args": [
            "bit"
          ],
          "line": 4039
        },
        "resolved": true,
        "details": {
          "function_name": "lock_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "639-642",
          "snippet": "static inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_bfs_bug",
          "args": [
            "ret"
          ],
          "line": 4032
        },
        "resolved": true,
        "details": {
          "function_name": "print_bfs_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2024-2033",
          "snippet": "static noinline void print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline void print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_error",
          "args": [
            "ret"
          ],
          "line": 4031
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1555-1558",
          "snippet": "static inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_usage_forwards",
          "args": [
            "&root",
            "usage_mask",
            "&target_entry"
          ],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "find_usage_forwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2264-2275",
          "snippet": "static enum bfs_result\nfind_usage_forwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic enum bfs_result\nfind_usage_forwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_init_root",
          "args": [
            "&root",
            "this"
          ],
          "line": 4029
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_init_rootb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1645-1650",
          "snippet": "static inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_usage_forwards(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit bit)\n{\n\tenum bfs_result ret;\n\tstruct lock_list root;\n\tstruct lock_list *target_entry;\n\tenum lock_usage_bit read_bit = bit + LOCK_USAGE_READ_MASK;\n\tunsigned usage_mask = lock_flag(bit) | lock_flag(read_bit);\n\n\tbfs_init_root(&root, this);\n\tret = find_usage_forwards(&root, usage_mask, &target_entry);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (ret == BFS_RNOMATCH)\n\t\treturn 1;\n\n\t/* Check whether write or read usage is the match */\n\tif (target_entry->class->usage_mask & lock_flag(bit)) {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, state_name(bit));\n\t} else {\n\t\tprint_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, state_name(read_bit));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_irq_inversion_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3955-4013",
    "snippet": "static void\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\troot->trace = save_trace();\n\tif (!root->trace)\n\t\treturn;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 4012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_shortest_lock_dependencies",
          "args": [
            "other",
            "root"
          ],
          "line": 4009
        },
        "resolved": true,
        "details": {
          "function_name": "print_shortest_lock_dependencies_backwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2418-2451",
          "snippet": "static void __used\nprint_shortest_lock_dependencies_backwards(struct lock_list *leaf,\n\t\t\t\t\t   struct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tconst struct lock_trace *trace = NULL;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tif (trace) {\n\t\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\t\tprint_lock_trace(trace, 2);\n\t\t\tprintk(\"\\n\");\n\t\t}\n\n\t\t/*\n\t\t * Record the pointer to the trace for the next lock_list\n\t\t * entry, see the comments for the function.\n\t\t */\n\t\ttrace = entry->trace;\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __used\nprint_shortest_lock_dependencies_backwards(struct lock_list *leaf,\n\t\t\t\t\t   struct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tconst struct lock_trace *trace = NULL;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tif (trace) {\n\t\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\t\tprint_lock_trace(trace, 2);\n\t\t\tprintk(\"\\n\");\n\t\t}\n\n\t\t/*\n\t\t * Record the pointer to the trace for the next lock_list\n\t\t * entry, see the comments for the function.\n\t\t */\n\t\ttrace = entry->trace;\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_trace",
          "args": [],
          "line": 4006
        },
        "resolved": true,
        "details": {
          "function_name": "save_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "530-567",
          "snippet": "static struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))"
          ],
          "globals_used": [
            "unsigned long nr_stack_trace_entries;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))\n\nunsigned long nr_stack_trace_entries;\nstatic noinstr struct;\n\nstatic struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\""
          ],
          "line": 4005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 4003
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_irq_lock_scenario",
          "args": [
            "other",
            "root",
            "middle ? middle->class : other->class",
            "root->class"
          ],
          "line": 4000
        },
        "resolved": true,
        "details": {
          "function_name": "print_irq_lock_scenario",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2453-2507",
          "snippet": "static void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_parent",
          "args": [
            "entry"
          ],
          "line": 3993
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1499-1502",
          "snippet": "static inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"lockdep:%s bad path found in chain graph\\n\"",
            "__func__"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_lock_depth",
          "args": [
            "other"
          ],
          "line": 3986
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_depth",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1504-1514",
          "snippet": "static inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\""
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "other->class"
          ],
          "line": 3980
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "701-712",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"but this lock was taken by another, %s-safe lock in the past:\\n\"",
            "irqclass"
          ],
          "line": 3979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"but this lock took another, %s-unsafe lock in the past:\\n\"",
            "irqclass"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "this"
          ],
          "line": 3975
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "726-748",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d just changed the state of lock:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"--------------------------------------------------------\\n\""
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: possible irq lock inversion dependency detected\\n\""
          ],
          "line": 3970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"========================================================\\n\""
          ],
          "line": 3969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 3965
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\troot->trace = save_trace();\n\tif (!root->trace)\n\t\treturn;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "valid_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3939-3949",
    "snippet": "static inline int\nvalid_state(struct task_struct *curr, struct held_lock *this,\n\t    enum lock_usage_bit new_bit, enum lock_usage_bit bad_bit)\n{\n\tif (unlikely(hlock_class(this)->usage_mask & (1 << bad_bit))) {\n\t\tgraph_unlock();\n\t\tprint_usage_bug(curr, this, bad_bit, new_bit);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_usage_bug",
          "args": [
            "curr",
            "this",
            "bad_bit",
            "new_bit"
          ],
          "line": 3945
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3899-3934",
          "snippet": "static void\nprint_usage_bug(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)\n{\n\tif (!debug_locks_off() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"================================\\n\");\n\tpr_warn(\"WARNING: inconsistent lock state\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------\\n\");\n\n\tpr_warn(\"inconsistent {%s} -> {%s} usage.\\n\",\n\t\tusage_str[prev_bit], usage_str[new_bit]);\n\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tlockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,\n\t\tlockdep_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,\n\t\tlockdep_hardirqs_enabled(),\n\t\tlockdep_softirqs_enabled(curr));\n\tprint_lock(this);\n\n\tpr_warn(\"{%s} state was registered at:\\n\", usage_str[prev_bit]);\n\tprint_lock_trace(hlock_class(this)->usage_traces[prev_bit], 1);\n\n\tprint_irqtrace_events(curr);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_usage_bug_scenario(this);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_usage_bug(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)\n{\n\tif (!debug_locks_off() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"================================\\n\");\n\tpr_warn(\"WARNING: inconsistent lock state\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------\\n\");\n\n\tpr_warn(\"inconsistent {%s} -> {%s} usage.\\n\",\n\t\tusage_str[prev_bit], usage_str[new_bit]);\n\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tlockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,\n\t\tlockdep_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,\n\t\tlockdep_hardirqs_enabled(),\n\t\tlockdep_softirqs_enabled(curr));\n\tprint_lock(this);\n\n\tpr_warn(\"{%s} state was registered at:\\n\", usage_str[prev_bit]);\n\tprint_lock_trace(hlock_class(this)->usage_traces[prev_bit], 1);\n\n\tprint_irqtrace_events(curr);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_usage_bug_scenario(this);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "hlock_class(this)->usage_mask & (1 << bad_bit)"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "this"
          ],
          "line": 3943
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int\nvalid_state(struct task_struct *curr, struct held_lock *this,\n\t    enum lock_usage_bit new_bit, enum lock_usage_bit bad_bit)\n{\n\tif (unlikely(hlock_class(this)->usage_mask & (1 << bad_bit))) {\n\t\tgraph_unlock();\n\t\tprint_usage_bug(curr, this, bad_bit, new_bit);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "print_usage_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3899-3934",
    "snippet": "static void\nprint_usage_bug(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)\n{\n\tif (!debug_locks_off() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"================================\\n\");\n\tpr_warn(\"WARNING: inconsistent lock state\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------\\n\");\n\n\tpr_warn(\"inconsistent {%s} -> {%s} usage.\\n\",\n\t\tusage_str[prev_bit], usage_str[new_bit]);\n\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tlockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,\n\t\tlockdep_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,\n\t\tlockdep_hardirqs_enabled(),\n\t\tlockdep_softirqs_enabled(curr));\n\tprint_lock(this);\n\n\tpr_warn(\"{%s} state was registered at:\\n\", usage_str[prev_bit]);\n\tprint_lock_trace(hlock_class(this)->usage_traces[prev_bit], 1);\n\n\tprint_irqtrace_events(curr);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_usage_bug_scenario(this);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 3932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 3930
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_usage_bug_scenario",
          "args": [
            "this"
          ],
          "line": 3928
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage_bug_scenario",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3882-3897",
          "snippet": "static void print_usage_bug_scenario(struct held_lock *lock)\n{\n\tstruct lock_class *class = hlock_class(lock);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_usage_bug_scenario(struct held_lock *lock)\n{\n\tstruct lock_class *class = hlock_class(lock);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "curr"
          ],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4085-4102",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_trace",
          "args": [
            "hlock_class(this)->usage_traces[prev_bit]",
            "1"
          ],
          "line": 3924
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1820-1824",
          "snippet": "static void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "this"
          ],
          "line": 3924
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"{%s} state was registered at:\\n\"",
            "usage_str[prev_bit]"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "this"
          ],
          "line": 3921
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "726-748",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)",
            "lockdep_hardirq_context()",
            "hardirq_count() >> HARDIRQ_SHIFT",
            "lockdep_softirq_context(curr)",
            "softirq_count() >> SOFTIRQ_SHIFT",
            "lockdep_hardirqs_enabled()",
            "lockdep_softirqs_enabled(curr)"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_softirqs_enabled",
          "args": [
            "curr"
          ],
          "line": 3920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_enabled",
          "args": [],
          "line": 3919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_softirq_context",
          "args": [
            "curr"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hardirq_count",
          "args": [],
          "line": 3917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirq_context",
          "args": [],
          "line": 3917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"inconsistent {%s} -> {%s} usage.\\n\"",
            "usage_str[prev_bit]",
            "usage_str[new_bit]"
          ],
          "line": 3912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"--------------------------------\\n\""
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 3909
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: inconsistent lock state\\n\""
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"================================\\n\""
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 3903
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_usage_bug(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)\n{\n\tif (!debug_locks_off() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"================================\\n\");\n\tpr_warn(\"WARNING: inconsistent lock state\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------\\n\");\n\n\tpr_warn(\"inconsistent {%s} -> {%s} usage.\\n\",\n\t\tusage_str[prev_bit], usage_str[new_bit]);\n\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tlockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,\n\t\tlockdep_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,\n\t\tlockdep_hardirqs_enabled(),\n\t\tlockdep_softirqs_enabled(curr));\n\tprint_lock(this);\n\n\tpr_warn(\"{%s} state was registered at:\\n\", usage_str[prev_bit]);\n\tprint_lock_trace(hlock_class(this)->usage_traces[prev_bit], 1);\n\n\tprint_irqtrace_events(curr);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_usage_bug_scenario(this);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "print_usage_bug_scenario",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3882-3897",
    "snippet": "static void print_usage_bug_scenario(struct held_lock *lock)\n{\n\tstruct lock_class *class = hlock_class(lock);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n *** DEADLOCK ***\\n\\n\""
          ],
          "line": 3896
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__print_lock_name",
          "args": [
            "class"
          ],
          "line": 3894
        },
        "resolved": true,
        "details": {
          "function_name": "__print_lock_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "683-699",
          "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "lock"
          ],
          "line": 3884
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_usage_bug_scenario(struct held_lock *lock)\n{\n\tstruct lock_class *class = hlock_class(lock);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
  },
  {
    "function_name": "check_chain_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3829-3876",
    "snippet": "static void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * hlock->class_idx can't go beyond MAX_LOCKDEP_KEYS, but is\n\t\t * it registered lock class index?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!test_bit(hlock->class_idx, lock_classes_in_use)))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\"",
            "curr->lockdep_depth",
            "i",
            "(unsigned long long)chain_key",
            "(unsigned long long)curr->curr_chain_key"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 3865
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_chain_key",
          "args": [
            "chain_key",
            "hlock_id(hlock)"
          ],
          "line": 3861
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_chain_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "415-422",
          "snippet": "static inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_id",
          "args": [
            "hlock"
          ],
          "line": 3861
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "397-402",
          "snippet": "static inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!test_bit(hlock->class_idx, lock_classes_in_use)"
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "hlock->class_idx",
            "lock_classes_in_use"
          ],
          "line": 3855
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\"",
            "curr->lockdep_depth",
            "i",
            "(unsigned long long)chain_key",
            "(unsigned long long)hlock->prev_chain_key"
          ],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\nstatic noinstr struct;\n\nstatic void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * hlock->class_idx can't go beyond MAX_LOCKDEP_KEYS, but is\n\t\t * it registered lock class index?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!test_bit(hlock->class_idx, lock_classes_in_use)))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = INITIAL_CHAIN_KEY;\n\t\tchain_key = iterate_chain_key(chain_key, hlock_id(hlock));\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}"
  },
  {
    "function_name": "init_chain_block_buckets",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3822-3822",
    "snippet": "static void init_chain_block_buckets(void)\t{ }",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_chain_block_buckets(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void init_chain_block_buckets(void);\n\nstatic void init_chain_block_buckets(void)\t{ }"
  },
  {
    "function_name": "validate_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3815-3820",
    "snippet": "static inline int validate_chain(struct task_struct *curr,\n\t\t\t\t struct held_lock *hlock,\n\t\t\t\t int chain_head, u64 chain_key)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int validate_chain(struct task_struct *curr,\n\t\t\t\t struct held_lock *hlock,\n\t\t\t\t int chain_head, u64 chain_key)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "validate_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3754-3813",
    "snippet": "static int validate_chain(struct task_struct *curr,\n\t\t\t  struct held_lock *hlock,\n\t\t\t  int chain_head, u64 chain_key)\n{\n\t/*\n\t * Trylock needs to maintain the stack of held locks, but it\n\t * does not add new dependencies, because trylock can be done\n\t * in any order.\n\t *\n\t * We look up the chain_key and do the O(N^2) check and update of\n\t * the dependencies only if this is a new dependency chain.\n\t * (If lookup_chain_cache_add() return with 1 it acquires\n\t * graph_lock for us)\n\t */\n\tif (!hlock->trylock && hlock->check &&\n\t    lookup_chain_cache_add(curr, hlock, chain_key)) {\n\t\t/*\n\t\t * Check whether last held lock:\n\t\t *\n\t\t * - is irq-safe, if this lock is irq-unsafe\n\t\t * - is softirq-safe, if this lock is hardirq-unsafe\n\t\t *\n\t\t * And check whether the new lock's dependency graph\n\t\t * could lead back to the previous lock:\n\t\t *\n\t\t * - within the current held-lock stack\n\t\t * - across our accumulated lock dependency records\n\t\t *\n\t\t * any of these scenarios could lead to a deadlock.\n\t\t */\n\t\t/*\n\t\t * The simple case: does the current hold the same lock\n\t\t * already?\n\t\t */\n\t\tint ret = check_deadlock(curr, hlock);\n\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Add dependency only if this lock is not the head\n\t\t * of the chain, and if the new lock introduces no more\n\t\t * lock dependency (because we already hold a lock with the\n\t\t * same lock class) nor deadlock (because the nest_lock\n\t\t * serializes nesting locks), see the comments for\n\t\t * check_deadlock().\n\t\t */\n\t\tif (!chain_head && ret != 2) {\n\t\t\tif (!check_prevs_add(curr, hlock))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tgraph_unlock();\n\t} else {\n\t\t/* after lookup_chain_cache_add(): */\n\t\tif (unlikely(!debug_locks))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 3808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 3805
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_prevs_add",
          "args": [
            "curr",
            "hlock"
          ],
          "line": 3801
        },
        "resolved": true,
        "details": {
          "function_name": "check_prevs_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3159-3226",
          "snippet": "static int\ncheck_prevs_add(struct task_struct *curr, struct held_lock *next)\n{\n\tstruct lock_trace *trace = NULL;\n\tint depth = curr->lockdep_depth;\n\tstruct held_lock *hlock;\n\n\t/*\n\t * Debugging checks.\n\t *\n\t * Depth must not be zero for a non-head lock:\n\t */\n\tif (!depth)\n\t\tgoto out_bug;\n\t/*\n\t * At least two relevant locks must exist for this\n\t * to be a head:\n\t */\n\tif (curr->held_locks[depth].irq_context !=\n\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\tgoto out_bug;\n\n\tfor (;;) {\n\t\tu16 distance = curr->lockdep_depth - depth + 1;\n\t\thlock = curr->held_locks + depth - 1;\n\n\t\tif (hlock->check) {\n\t\t\tint ret = check_prev_add(curr, hlock, next, distance, &trace);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Stop after the first non-trylock entry,\n\t\t\t * as non-trylock entries have added their\n\t\t\t * own direct dependencies already, so this\n\t\t\t * lock is connected to them indirectly:\n\t\t\t */\n\t\t\tif (!hlock->trylock)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdepth--;\n\t\t/*\n\t\t * End of lock-stack?\n\t\t */\n\t\tif (!depth)\n\t\t\tbreak;\n\t\t/*\n\t\t * Stop the search if we cross into another context:\n\t\t */\n\t\tif (curr->held_locks[depth].irq_context !=\n\t\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\t\tbreak;\n\t}\n\treturn 1;\nout_bug:\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Clearly we all shouldn't be here, but since we made it we\n\t * can reliable say we messed up our state. See the above two\n\t * gotos for reasons why we could possibly end up here.\n\t */\n\tWARN_ON(1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int\ncheck_prevs_add(struct task_struct *curr, struct held_lock *next)\n{\n\tstruct lock_trace *trace = NULL;\n\tint depth = curr->lockdep_depth;\n\tstruct held_lock *hlock;\n\n\t/*\n\t * Debugging checks.\n\t *\n\t * Depth must not be zero for a non-head lock:\n\t */\n\tif (!depth)\n\t\tgoto out_bug;\n\t/*\n\t * At least two relevant locks must exist for this\n\t * to be a head:\n\t */\n\tif (curr->held_locks[depth].irq_context !=\n\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\tgoto out_bug;\n\n\tfor (;;) {\n\t\tu16 distance = curr->lockdep_depth - depth + 1;\n\t\thlock = curr->held_locks + depth - 1;\n\n\t\tif (hlock->check) {\n\t\t\tint ret = check_prev_add(curr, hlock, next, distance, &trace);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Stop after the first non-trylock entry,\n\t\t\t * as non-trylock entries have added their\n\t\t\t * own direct dependencies already, so this\n\t\t\t * lock is connected to them indirectly:\n\t\t\t */\n\t\t\tif (!hlock->trylock)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdepth--;\n\t\t/*\n\t\t * End of lock-stack?\n\t\t */\n\t\tif (!depth)\n\t\t\tbreak;\n\t\t/*\n\t\t * Stop the search if we cross into another context:\n\t\t */\n\t\tif (curr->held_locks[depth].irq_context !=\n\t\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\t\tbreak;\n\t}\n\treturn 1;\nout_bug:\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Clearly we all shouldn't be here, but since we made it we\n\t * can reliable say we messed up our state. See the above two\n\t * gotos for reasons why we could possibly end up here.\n\t */\n\tWARN_ON(1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_deadlock",
          "args": [
            "curr",
            "hlock"
          ],
          "line": 3788
        },
        "resolved": true,
        "details": {
          "function_name": "check_deadlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2969-3003",
          "snippet": "static int\ncheck_deadlock(struct task_struct *curr, struct held_lock *next)\n{\n\tstruct held_lock *prev;\n\tstruct held_lock *nest = NULL;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tprev = curr->held_locks + i;\n\n\t\tif (prev->instance == next->nest_lock)\n\t\t\tnest = prev;\n\n\t\tif (hlock_class(prev) != hlock_class(next))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Allow read-after-read recursion of the same\n\t\t * lock class (i.e. read_lock(lock)+read_lock(lock)):\n\t\t */\n\t\tif ((next->read == 2) && prev->read)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We're holding the nest_lock, which serializes this lock's\n\t\t * nesting behaviour.\n\t\t */\n\t\tif (nest)\n\t\t\treturn 2;\n\n\t\tprint_deadlock_bug(curr, prev, next);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_deadlock(struct task_struct *curr, struct held_lock *next)\n{\n\tstruct held_lock *prev;\n\tstruct held_lock *nest = NULL;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tprev = curr->held_locks + i;\n\n\t\tif (prev->instance == next->nest_lock)\n\t\t\tnest = prev;\n\n\t\tif (hlock_class(prev) != hlock_class(next))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Allow read-after-read recursion of the same\n\t\t * lock class (i.e. read_lock(lock)+read_lock(lock)):\n\t\t */\n\t\tif ((next->read == 2) && prev->read)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We're holding the nest_lock, which serializes this lock's\n\t\t * nesting behaviour.\n\t\t */\n\t\tif (nest)\n\t\t\treturn 2;\n\n\t\tprint_deadlock_bug(curr, prev, next);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_chain_cache_add",
          "args": [
            "curr",
            "hlock",
            "chain_key"
          ],
          "line": 3769
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_chain_cache_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3709-3752",
          "snippet": "static inline int lookup_chain_cache_add(struct task_struct *curr,\n\t\t\t\t\t struct held_lock *hlock,\n\t\t\t\t\t u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct lock_chain *chain = lookup_chain_cache(chain_key);\n\n\tif (chain) {\ncache_hit:\n\t\tif (!check_no_collision(curr, hlock, chain))\n\t\t\treturn 0;\n\n\t\tif (very_verbose(class)) {\n\t\t\tprintk(\"\\nhash chain already cached, key: \"\n\t\t\t\t\t\"%016Lx tail class: [%px] %s\\n\",\n\t\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t\tclass->key, class->name);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nnew hash chain, key: %016Lx tail class: [%px] %s\\n\",\n\t\t\t(unsigned long long)chain_key, class->key, class->name);\n\t}\n\n\tif (!graph_lock())\n\t\treturn 0;\n\n\t/*\n\t * We have to walk the chain again locked - to avoid duplicates:\n\t */\n\tchain = lookup_chain_cache(chain_key);\n\tif (chain) {\n\t\tgraph_unlock();\n\t\tgoto cache_hit;\n\t}\n\n\tif (!add_chain_cache(curr, hlock, chain_key))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int lookup_chain_cache_add(struct task_struct *curr,\n\t\t\t\t\t struct held_lock *hlock,\n\t\t\t\t\t u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct lock_chain *chain = lookup_chain_cache(chain_key);\n\n\tif (chain) {\ncache_hit:\n\t\tif (!check_no_collision(curr, hlock, chain))\n\t\t\treturn 0;\n\n\t\tif (very_verbose(class)) {\n\t\t\tprintk(\"\\nhash chain already cached, key: \"\n\t\t\t\t\t\"%016Lx tail class: [%px] %s\\n\",\n\t\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t\tclass->key, class->name);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nnew hash chain, key: %016Lx tail class: [%px] %s\\n\",\n\t\t\t(unsigned long long)chain_key, class->key, class->name);\n\t}\n\n\tif (!graph_lock())\n\t\treturn 0;\n\n\t/*\n\t * We have to walk the chain again locked - to avoid duplicates:\n\t */\n\tchain = lookup_chain_cache(chain_key);\n\tif (chain) {\n\t\tgraph_unlock();\n\t\tgoto cache_hit;\n\t}\n\n\tif (!add_chain_cache(curr, hlock, chain_key))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int validate_chain(struct task_struct *curr,\n\t\t\t  struct held_lock *hlock,\n\t\t\t  int chain_head, u64 chain_key)\n{\n\t/*\n\t * Trylock needs to maintain the stack of held locks, but it\n\t * does not add new dependencies, because trylock can be done\n\t * in any order.\n\t *\n\t * We look up the chain_key and do the O(N^2) check and update of\n\t * the dependencies only if this is a new dependency chain.\n\t * (If lookup_chain_cache_add() return with 1 it acquires\n\t * graph_lock for us)\n\t */\n\tif (!hlock->trylock && hlock->check &&\n\t    lookup_chain_cache_add(curr, hlock, chain_key)) {\n\t\t/*\n\t\t * Check whether last held lock:\n\t\t *\n\t\t * - is irq-safe, if this lock is irq-unsafe\n\t\t * - is softirq-safe, if this lock is hardirq-unsafe\n\t\t *\n\t\t * And check whether the new lock's dependency graph\n\t\t * could lead back to the previous lock:\n\t\t *\n\t\t * - within the current held-lock stack\n\t\t * - across our accumulated lock dependency records\n\t\t *\n\t\t * any of these scenarios could lead to a deadlock.\n\t\t */\n\t\t/*\n\t\t * The simple case: does the current hold the same lock\n\t\t * already?\n\t\t */\n\t\tint ret = check_deadlock(curr, hlock);\n\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Add dependency only if this lock is not the head\n\t\t * of the chain, and if the new lock introduces no more\n\t\t * lock dependency (because we already hold a lock with the\n\t\t * same lock class) nor deadlock (because the nest_lock\n\t\t * serializes nesting locks), see the comments for\n\t\t * check_deadlock().\n\t\t */\n\t\tif (!chain_head && ret != 2) {\n\t\t\tif (!check_prevs_add(curr, hlock))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tgraph_unlock();\n\t} else {\n\t\t/* after lookup_chain_cache_add(): */\n\t\tif (unlikely(!debug_locks))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "lookup_chain_cache_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3709-3752",
    "snippet": "static inline int lookup_chain_cache_add(struct task_struct *curr,\n\t\t\t\t\t struct held_lock *hlock,\n\t\t\t\t\t u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct lock_chain *chain = lookup_chain_cache(chain_key);\n\n\tif (chain) {\ncache_hit:\n\t\tif (!check_no_collision(curr, hlock, chain))\n\t\t\treturn 0;\n\n\t\tif (very_verbose(class)) {\n\t\t\tprintk(\"\\nhash chain already cached, key: \"\n\t\t\t\t\t\"%016Lx tail class: [%px] %s\\n\",\n\t\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t\tclass->key, class->name);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nnew hash chain, key: %016Lx tail class: [%px] %s\\n\",\n\t\t\t(unsigned long long)chain_key, class->key, class->name);\n\t}\n\n\tif (!graph_lock())\n\t\treturn 0;\n\n\t/*\n\t * We have to walk the chain again locked - to avoid duplicates:\n\t */\n\tchain = lookup_chain_cache(chain_key);\n\tif (chain) {\n\t\tgraph_unlock();\n\t\tgoto cache_hit;\n\t}\n\n\tif (!add_chain_cache(curr, hlock, chain_key))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_chain_cache",
          "args": [
            "curr",
            "hlock",
            "chain_key"
          ],
          "line": 3748
        },
        "resolved": true,
        "details": {
          "function_name": "add_chain_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3627-3683",
          "snippet": "static inline int add_chain_cache(struct task_struct *curr,\n\t\t\t\t  struct held_lock *hlock,\n\t\t\t\t  u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\tint i, j;\n\n\t/*\n\t * The caller must hold the graph lock, ensure we've got IRQs\n\t * disabled to make this an IRQ-safe lock.. for recursion reasons\n\t * lockdep won't complain about its own locking errors.\n\t */\n\tif (lockdep_assert_locked())\n\t\treturn 0;\n\n\tchain = alloc_lock_chain();\n\tif (!chain) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAINS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\tchain->chain_key = chain_key;\n\tchain->irq_context = hlock->irq_context;\n\ti = get_first_held_lock(curr, hlock);\n\tchain->depth = curr->lockdep_depth + 1 - i;\n\n\tBUILD_BUG_ON((1UL << 24) <= ARRAY_SIZE(chain_hlocks));\n\tBUILD_BUG_ON((1UL << 6)  <= ARRAY_SIZE(curr->held_locks));\n\tBUILD_BUG_ON((1UL << 8*sizeof(chain_hlocks[0])) <= ARRAY_SIZE(lock_classes));\n\n\tj = alloc_chain_hlocks(chain->depth);\n\tif (j < 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\n\tchain->base = j;\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tint lock_id = hlock_id(curr->held_locks + i);\n\n\t\tchain_hlocks[chain->base + j] = lock_id;\n\t}\n\tchain_hlocks[chain->base + j] = hlock_id(hlock);\n\thlist_add_head_rcu(&chain->entry, hash_head);\n\tdebug_atomic_inc(chain_lookup_misses);\n\tinc_chains(chain->irq_context);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic inline int add_chain_cache(struct task_struct *curr,\n\t\t\t\t  struct held_lock *hlock,\n\t\t\t\t  u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\tint i, j;\n\n\t/*\n\t * The caller must hold the graph lock, ensure we've got IRQs\n\t * disabled to make this an IRQ-safe lock.. for recursion reasons\n\t * lockdep won't complain about its own locking errors.\n\t */\n\tif (lockdep_assert_locked())\n\t\treturn 0;\n\n\tchain = alloc_lock_chain();\n\tif (!chain) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAINS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\tchain->chain_key = chain_key;\n\tchain->irq_context = hlock->irq_context;\n\ti = get_first_held_lock(curr, hlock);\n\tchain->depth = curr->lockdep_depth + 1 - i;\n\n\tBUILD_BUG_ON((1UL << 24) <= ARRAY_SIZE(chain_hlocks));\n\tBUILD_BUG_ON((1UL << 6)  <= ARRAY_SIZE(curr->held_locks));\n\tBUILD_BUG_ON((1UL << 8*sizeof(chain_hlocks[0])) <= ARRAY_SIZE(lock_classes));\n\n\tj = alloc_chain_hlocks(chain->depth);\n\tif (j < 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\n\tchain->base = j;\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tint lock_id = hlock_id(curr->held_locks + i);\n\n\t\tchain_hlocks[chain->base + j] = lock_id;\n\t}\n\tchain_hlocks[chain->base + j] = hlock_id(hlock);\n\thlist_add_head_rcu(&chain->entry, hash_head);\n\tdebug_atomic_inc(chain_lookup_misses);\n\tinc_chains(chain->irq_context);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 3744
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_chain_cache",
          "args": [
            "chain_key"
          ],
          "line": 3742
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_chain_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3689-3701",
          "snippet": "static inline struct lock_chain *lookup_chain_cache(u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\n\thlist_for_each_entry_rcu(chain, hash_head, entry) {\n\t\tif (READ_ONCE(chain->chain_key) == chain_key) {\n\t\t\tdebug_atomic_inc(chain_lookup_hits);\n\t\t\treturn chain;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct lock_chain *lookup_chain_cache(u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\n\thlist_for_each_entry_rcu(chain, hash_head, entry) {\n\t\tif (READ_ONCE(chain->chain_key) == chain_key) {\n\t\t\tdebug_atomic_inc(chain_lookup_hits);\n\t\t\treturn chain;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_lock",
          "args": [],
          "line": 3736
        },
        "resolved": true,
        "details": {
          "function_name": "graph_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "137-151",
          "snippet": "static int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\nnew hash chain, key: %016Lx tail class: [%px] %s\\n\"",
            "(unsigned long long)chain_key",
            "class->key",
            "class->name"
          ],
          "line": 3732
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "very_verbose",
          "args": [
            "class"
          ],
          "line": 3731
        },
        "resolved": true,
        "details": {
          "function_name": "very_verbose",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "779-785",
          "snippet": "static int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define VERY_VERBOSE\t\t0"
          ],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define VERY_VERBOSE\t\t0\n\nstatic noinstr struct;\n\nstatic int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_no_collision",
          "args": [
            "curr",
            "hlock",
            "chain"
          ],
          "line": 3718
        },
        "resolved": true,
        "details": {
          "function_name": "check_no_collision",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3567-3591",
          "snippet": "static int check_no_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock,\n\t\t\tstruct lock_chain *chain)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tint i, j, id;\n\n\ti = get_first_held_lock(curr, hlock);\n\n\tif (DEBUG_LOCKS_WARN_ON(chain->depth != curr->lockdep_depth - (i - 1))) {\n\t\tprint_collision(curr, hlock, chain);\n\t\treturn 0;\n\t}\n\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tid = hlock_id(&curr->held_locks[i]);\n\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_hlocks[chain->base + j] != id)) {\n\t\t\tprint_collision(curr, hlock, chain);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int check_no_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock,\n\t\t\tstruct lock_chain *chain)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tint i, j, id;\n\n\ti = get_first_held_lock(curr, hlock);\n\n\tif (DEBUG_LOCKS_WARN_ON(chain->depth != curr->lockdep_depth - (i - 1))) {\n\t\tprint_collision(curr, hlock, chain);\n\t\treturn 0;\n\t}\n\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tid = hlock_id(&curr->held_locks[i]);\n\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_hlocks[chain->base + j] != id)) {\n\t\t\tprint_collision(curr, hlock, chain);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 3713
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int lookup_chain_cache_add(struct task_struct *curr,\n\t\t\t\t\t struct held_lock *hlock,\n\t\t\t\t\t u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct lock_chain *chain = lookup_chain_cache(chain_key);\n\n\tif (chain) {\ncache_hit:\n\t\tif (!check_no_collision(curr, hlock, chain))\n\t\t\treturn 0;\n\n\t\tif (very_verbose(class)) {\n\t\t\tprintk(\"\\nhash chain already cached, key: \"\n\t\t\t\t\t\"%016Lx tail class: [%px] %s\\n\",\n\t\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t\tclass->key, class->name);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nnew hash chain, key: %016Lx tail class: [%px] %s\\n\",\n\t\t\t(unsigned long long)chain_key, class->key, class->name);\n\t}\n\n\tif (!graph_lock())\n\t\treturn 0;\n\n\t/*\n\t * We have to walk the chain again locked - to avoid duplicates:\n\t */\n\tchain = lookup_chain_cache(chain_key);\n\tif (chain) {\n\t\tgraph_unlock();\n\t\tgoto cache_hit;\n\t}\n\n\tif (!add_chain_cache(curr, hlock, chain_key))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "lookup_chain_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3689-3701",
    "snippet": "static inline struct lock_chain *lookup_chain_cache(u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\n\thlist_for_each_entry_rcu(chain, hash_head, entry) {\n\t\tif (READ_ONCE(chain->chain_key) == chain_key) {\n\t\t\tdebug_atomic_inc(chain_lookup_hits);\n\t\t\treturn chain;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "chain_lookup_hits"
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "chain->chain_key"
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "chain",
            "hash_head",
            "entry"
          ],
          "line": 3694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chainhashentry",
          "args": [
            "chain_key"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct lock_chain *lookup_chain_cache(u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\n\thlist_for_each_entry_rcu(chain, hash_head, entry) {\n\t\tif (READ_ONCE(chain->chain_key) == chain_key) {\n\t\t\tdebug_atomic_inc(chain_lookup_hits);\n\t\t\treturn chain;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "add_chain_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3627-3683",
    "snippet": "static inline int add_chain_cache(struct task_struct *curr,\n\t\t\t\t  struct held_lock *hlock,\n\t\t\t\t  u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\tint i, j;\n\n\t/*\n\t * The caller must hold the graph lock, ensure we've got IRQs\n\t * disabled to make this an IRQ-safe lock.. for recursion reasons\n\t * lockdep won't complain about its own locking errors.\n\t */\n\tif (lockdep_assert_locked())\n\t\treturn 0;\n\n\tchain = alloc_lock_chain();\n\tif (!chain) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAINS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\tchain->chain_key = chain_key;\n\tchain->irq_context = hlock->irq_context;\n\ti = get_first_held_lock(curr, hlock);\n\tchain->depth = curr->lockdep_depth + 1 - i;\n\n\tBUILD_BUG_ON((1UL << 24) <= ARRAY_SIZE(chain_hlocks));\n\tBUILD_BUG_ON((1UL << 6)  <= ARRAY_SIZE(curr->held_locks));\n\tBUILD_BUG_ON((1UL << 8*sizeof(chain_hlocks[0])) <= ARRAY_SIZE(lock_classes));\n\n\tj = alloc_chain_hlocks(chain->depth);\n\tif (j < 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\n\tchain->base = j;\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tint lock_id = hlock_id(curr->held_locks + i);\n\n\t\tchain_hlocks[chain->base + j] = lock_id;\n\t}\n\tchain_hlocks[chain->base + j] = hlock_id(hlock);\n\thlist_add_head_rcu(&chain->entry, hash_head);\n\tdebug_atomic_inc(chain_lookup_misses);\n\tinc_chains(chain->irq_context);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_chains",
          "args": [
            "chain->irq_context"
          ],
          "line": 3680
        },
        "resolved": true,
        "details": {
          "function_name": "inc_chains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2894-2902",
          "snippet": "static void inc_chains(int irq_context)\n{\n\tif (irq_context & LOCK_CHAIN_HARDIRQ_CONTEXT)\n\t\tnr_hardirq_chains++;\n\telse if (irq_context & LOCK_CHAIN_SOFTIRQ_CONTEXT)\n\t\tnr_softirq_chains++;\n\telse\n\t\tnr_process_chains++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nr_hardirq_chains;",
            "unsigned int nr_softirq_chains;",
            "unsigned int nr_process_chains;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned int nr_hardirq_chains;\nunsigned int nr_softirq_chains;\nunsigned int nr_process_chains;\n\nstatic void inc_chains(int irq_context)\n{\n\tif (irq_context & LOCK_CHAIN_HARDIRQ_CONTEXT)\n\t\tnr_hardirq_chains++;\n\telse if (irq_context & LOCK_CHAIN_SOFTIRQ_CONTEXT)\n\t\tnr_softirq_chains++;\n\telse\n\t\tnr_process_chains++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "chain_lookup_misses"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&chain->entry",
            "hash_head"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlock_id",
          "args": [
            "hlock"
          ],
          "line": 3677
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "397-402",
          "snippet": "static inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lockdep_off",
          "args": [
            "\"BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!\""
          ],
          "line": 3666
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "490-497",
          "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define lock_stat 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 3663
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_chain_hlocks",
          "args": [
            "chain->depth"
          ],
          "line": 3661
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_chain_hlocks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3393-3453",
          "snippet": "static int alloc_chain_hlocks(int req)\n{\n\tint bucket, curr, size;\n\n\t/*\n\t * We rely on the MSB to act as an escape bit to denote freelist\n\t * pointers. Make sure this bit isn't set in 'normal' class_idx usage.\n\t */\n\tBUILD_BUG_ON((MAX_LOCKDEP_KEYS-1) & CHAIN_BLK_FLAG);\n\n\tinit_data_structures_once();\n\n\tif (nr_free_chain_hlocks < req)\n\t\treturn -1;\n\n\t/*\n\t * We require a minimum of 2 (u16) entries to encode a freelist\n\t * 'pointer'.\n\t */\n\treq = max(req, 2);\n\tbucket = size_to_bucket(req);\n\tcurr = chain_block_buckets[bucket];\n\n\tif (bucket) {\n\t\tif (curr >= 0) {\n\t\t\tdel_chain_block(bucket, req, chain_block_next(curr));\n\t\t\treturn curr;\n\t\t}\n\t\t/* Try bucket 0 */\n\t\tcurr = chain_block_buckets[0];\n\t}\n\n\t/*\n\t * The variable sized freelist is sorted by size; the first entry is\n\t * the largest. Use it if it fits.\n\t */\n\tif (curr >= 0) {\n\t\tsize = chain_block_size(curr);\n\t\tif (likely(size >= req)) {\n\t\t\tdel_chain_block(0, size, chain_block_next(curr));\n\t\t\tadd_chain_block(curr + req, size - req);\n\t\t\treturn curr;\n\t\t}\n\t}\n\n\t/*\n\t * Last resort, split a block in a larger sized bucket.\n\t */\n\tfor (size = MAX_CHAIN_BUCKETS; size > req; size--) {\n\t\tbucket = size_to_bucket(size);\n\t\tcurr = chain_block_buckets[bucket];\n\t\tif (curr < 0)\n\t\t\tcontinue;\n\n\t\tdel_chain_block(bucket, size, chain_block_next(curr));\n\t\tadd_chain_block(curr + req, size - req);\n\t\treturn curr;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CHAIN_BLK_FLAG\t\t(1U << 15)",
            "#define MAX_CHAIN_BUCKETS\t16"
          ],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAIN_BLK_FLAG\t\t(1U << 15)\n#define MAX_CHAIN_BUCKETS\t16\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic int alloc_chain_hlocks(int req)\n{\n\tint bucket, curr, size;\n\n\t/*\n\t * We rely on the MSB to act as an escape bit to denote freelist\n\t * pointers. Make sure this bit isn't set in 'normal' class_idx usage.\n\t */\n\tBUILD_BUG_ON((MAX_LOCKDEP_KEYS-1) & CHAIN_BLK_FLAG);\n\n\tinit_data_structures_once();\n\n\tif (nr_free_chain_hlocks < req)\n\t\treturn -1;\n\n\t/*\n\t * We require a minimum of 2 (u16) entries to encode a freelist\n\t * 'pointer'.\n\t */\n\treq = max(req, 2);\n\tbucket = size_to_bucket(req);\n\tcurr = chain_block_buckets[bucket];\n\n\tif (bucket) {\n\t\tif (curr >= 0) {\n\t\t\tdel_chain_block(bucket, req, chain_block_next(curr));\n\t\t\treturn curr;\n\t\t}\n\t\t/* Try bucket 0 */\n\t\tcurr = chain_block_buckets[0];\n\t}\n\n\t/*\n\t * The variable sized freelist is sorted by size; the first entry is\n\t * the largest. Use it if it fits.\n\t */\n\tif (curr >= 0) {\n\t\tsize = chain_block_size(curr);\n\t\tif (likely(size >= req)) {\n\t\t\tdel_chain_block(0, size, chain_block_next(curr));\n\t\t\tadd_chain_block(curr + req, size - req);\n\t\t\treturn curr;\n\t\t}\n\t}\n\n\t/*\n\t * Last resort, split a block in a larger sized bucket.\n\t */\n\tfor (size = MAX_CHAIN_BUCKETS; size > req; size--) {\n\t\tbucket = size_to_bucket(size);\n\t\tcurr = chain_block_buckets[bucket];\n\t\tif (curr < 0)\n\t\t\tcontinue;\n\n\t\tdel_chain_block(bucket, size, chain_block_next(curr));\n\t\tadd_chain_block(curr + req, size - req);\n\t\treturn curr;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "(1UL << 8*sizeof(chain_hlocks[0])) <= ARRAY_SIZE(lock_classes)"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_classes"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "(1UL << 6)  <= ARRAY_SIZE(curr->held_locks)"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "curr->held_locks"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "(1UL << 24) <= ARRAY_SIZE(chain_hlocks)"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "chain_hlocks"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_first_held_lock",
          "args": [
            "curr",
            "hlock"
          ],
          "line": 3654
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3471-3485",
          "snippet": "static inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_lock_chain",
          "args": [],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_lock_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3609-3618",
          "snippet": "static struct lock_chain *alloc_lock_chain(void)\n{\n\tint idx = find_first_zero_bit(lock_chains_in_use,\n\t\t\t\t      ARRAY_SIZE(lock_chains));\n\n\tif (unlikely(idx >= ARRAY_SIZE(lock_chains)))\n\t\treturn NULL;\n\t__set_bit(idx, lock_chains_in_use);\n\treturn lock_chains + idx;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic struct lock_chain *alloc_lock_chain(void)\n{\n\tint idx = find_first_zero_bit(lock_chains_in_use,\n\t\t\t\t      ARRAY_SIZE(lock_chains));\n\n\tif (unlikely(idx >= ARRAY_SIZE(lock_chains)))\n\t\treturn NULL;\n\t__set_bit(idx, lock_chains_in_use);\n\treturn lock_chains + idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_locked",
          "args": [],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "129-132",
          "snippet": "static inline bool lockdep_assert_locked(void)\n{\n\treturn DEBUG_LOCKS_WARN_ON(__owner != current);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct task_struct *__owner;\n\nstatic inline bool lockdep_assert_locked(void)\n{\n\treturn DEBUG_LOCKS_WARN_ON(__owner != current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chainhashentry",
          "args": [
            "chain_key"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic inline int add_chain_cache(struct task_struct *curr,\n\t\t\t\t  struct held_lock *hlock,\n\t\t\t\t  u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\tint i, j;\n\n\t/*\n\t * The caller must hold the graph lock, ensure we've got IRQs\n\t * disabled to make this an IRQ-safe lock.. for recursion reasons\n\t * lockdep won't complain about its own locking errors.\n\t */\n\tif (lockdep_assert_locked())\n\t\treturn 0;\n\n\tchain = alloc_lock_chain();\n\tif (!chain) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAINS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\tchain->chain_key = chain_key;\n\tchain->irq_context = hlock->irq_context;\n\ti = get_first_held_lock(curr, hlock);\n\tchain->depth = curr->lockdep_depth + 1 - i;\n\n\tBUILD_BUG_ON((1UL << 24) <= ARRAY_SIZE(chain_hlocks));\n\tBUILD_BUG_ON((1UL << 6)  <= ARRAY_SIZE(curr->held_locks));\n\tBUILD_BUG_ON((1UL << 8*sizeof(chain_hlocks[0])) <= ARRAY_SIZE(lock_classes));\n\n\tj = alloc_chain_hlocks(chain->depth);\n\tif (j < 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\n\tchain->base = j;\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tint lock_id = hlock_id(curr->held_locks + i);\n\n\t\tchain_hlocks[chain->base + j] = lock_id;\n\t}\n\tchain_hlocks[chain->base + j] = hlock_id(hlock);\n\thlist_add_head_rcu(&chain->entry, hash_head);\n\tdebug_atomic_inc(chain_lookup_misses);\n\tinc_chains(chain->irq_context);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "alloc_lock_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3609-3618",
    "snippet": "static struct lock_chain *alloc_lock_chain(void)\n{\n\tint idx = find_first_zero_bit(lock_chains_in_use,\n\t\t\t\t      ARRAY_SIZE(lock_chains));\n\n\tif (unlikely(idx >= ARRAY_SIZE(lock_chains)))\n\t\treturn NULL;\n\t__set_bit(idx, lock_chains_in_use);\n\treturn lock_chains + idx;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "idx",
            "lock_chains_in_use"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "idx >= ARRAY_SIZE(lock_chains)"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_chains"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "lock_chains_in_use",
            "ARRAY_SIZE(lock_chains)"
          ],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_chains"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic struct lock_chain *alloc_lock_chain(void)\n{\n\tint idx = find_first_zero_bit(lock_chains_in_use,\n\t\t\t\t      ARRAY_SIZE(lock_chains));\n\n\tif (unlikely(idx >= ARRAY_SIZE(lock_chains)))\n\t\treturn NULL;\n\t__set_bit(idx, lock_chains_in_use);\n\treturn lock_chains + idx;\n}"
  },
  {
    "function_name": "lock_chain_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3603-3606",
    "snippet": "unsigned long lock_chain_count(void)\n{\n\treturn bitmap_weight(lock_chains_in_use, ARRAY_SIZE(lock_chains));\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "lock_chains_in_use",
            "ARRAY_SIZE(lock_chains)"
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_chains"
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long lock_chain_count(void)\n{\n\treturn bitmap_weight(lock_chains_in_use, ARRAY_SIZE(lock_chains));\n}"
  },
  {
    "function_name": "lockdep_next_lockchain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3597-3601",
    "snippet": "long lockdep_next_lockchain(long i)\n{\n\ti = find_next_bit(lock_chains_in_use, ARRAY_SIZE(lock_chains), i + 1);\n\treturn i < ARRAY_SIZE(lock_chains) ? i : -2;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_chains"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "lock_chains_in_use",
            "ARRAY_SIZE(lock_chains)",
            "i + 1"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_chains"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nlong lockdep_next_lockchain(long i)\n{\n\ti = find_next_bit(lock_chains_in_use, ARRAY_SIZE(lock_chains), i + 1);\n\treturn i < ARRAY_SIZE(lock_chains) ? i : -2;\n}"
  },
  {
    "function_name": "check_no_collision",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3567-3591",
    "snippet": "static int check_no_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock,\n\t\t\tstruct lock_chain *chain)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tint i, j, id;\n\n\ti = get_first_held_lock(curr, hlock);\n\n\tif (DEBUG_LOCKS_WARN_ON(chain->depth != curr->lockdep_depth - (i - 1))) {\n\t\tprint_collision(curr, hlock, chain);\n\t\treturn 0;\n\t}\n\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tid = hlock_id(&curr->held_locks[i]);\n\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_hlocks[chain->base + j] != id)) {\n\t\t\tprint_collision(curr, hlock, chain);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_collision",
          "args": [
            "curr",
            "hlock",
            "chain"
          ],
          "line": 3585
        },
        "resolved": true,
        "details": {
          "function_name": "print_collision",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3538-3558",
          "snippet": "static void print_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock_next,\n\t\t\tstruct lock_chain *chain)\n{\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================\\n\");\n\tpr_warn(\"WARNING: chain_key collision\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------\\n\");\n\tpr_warn(\"%s/%d: \", current->comm, task_pid_nr(current));\n\tpr_warn(\"Hash chain already cached but the contents don't match!\\n\");\n\n\tpr_warn(\"Held locks:\");\n\tprint_chain_keys_held_locks(curr, hlock_next);\n\n\tpr_warn(\"Locks in cached chain:\");\n\tprint_chain_keys_chain(chain);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock_next,\n\t\t\tstruct lock_chain *chain)\n{\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================\\n\");\n\tpr_warn(\"WARNING: chain_key collision\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------\\n\");\n\tpr_warn(\"%s/%d: \", current->comm, task_pid_nr(current));\n\tpr_warn(\"Hash chain already cached but the contents don't match!\\n\");\n\n\tpr_warn(\"Held locks:\");\n\tprint_chain_keys_held_locks(curr, hlock_next);\n\n\tpr_warn(\"Locks in cached chain:\");\n\tprint_chain_keys_chain(chain);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "chain_hlocks[chain->base + j] != id"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlock_id",
          "args": [
            "&curr->held_locks[i]"
          ],
          "line": 3582
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "397-402",
          "snippet": "static inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "chain->depth != curr->lockdep_depth - (i - 1)"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_first_held_lock",
          "args": [
            "curr",
            "hlock"
          ],
          "line": 3574
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3471-3485",
          "snippet": "static inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int check_no_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock,\n\t\t\tstruct lock_chain *chain)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tint i, j, id;\n\n\ti = get_first_held_lock(curr, hlock);\n\n\tif (DEBUG_LOCKS_WARN_ON(chain->depth != curr->lockdep_depth - (i - 1))) {\n\t\tprint_collision(curr, hlock, chain);\n\t\treturn 0;\n\t}\n\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tid = hlock_id(&curr->held_locks[i]);\n\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_hlocks[chain->base + j] != id)) {\n\t\t\tprint_collision(curr, hlock, chain);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "print_collision",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3538-3558",
    "snippet": "static void print_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock_next,\n\t\t\tstruct lock_chain *chain)\n{\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================\\n\");\n\tpr_warn(\"WARNING: chain_key collision\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------\\n\");\n\tpr_warn(\"%s/%d: \", current->comm, task_pid_nr(current));\n\tpr_warn(\"Hash chain already cached but the contents don't match!\\n\");\n\n\tpr_warn(\"Held locks:\");\n\tprint_chain_keys_held_locks(curr, hlock_next);\n\n\tpr_warn(\"Locks in cached chain:\");\n\tprint_chain_keys_chain(chain);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_chain_keys_chain",
          "args": [
            "chain"
          ],
          "line": 3554
        },
        "resolved": true,
        "details": {
          "function_name": "print_chain_keys_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3522-3536",
          "snippet": "static void print_chain_keys_chain(struct lock_chain *chain)\n{\n\tint i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tu16 hlock_id;\n\n\tprintk(\"depth: %u\\n\", chain->depth);\n\tfor (i = 0; i < chain->depth; i++) {\n\t\thlock_id = chain_hlocks[chain->base + i];\n\t\tchain_key = print_chain_key_iteration(hlock_id, chain_key);\n\n\t\tprint_lock_name(lock_classes + chain_hlock_class_idx(hlock_id) - 1);\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic void print_chain_keys_chain(struct lock_chain *chain)\n{\n\tint i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tu16 hlock_id;\n\n\tprintk(\"depth: %u\\n\", chain->depth);\n\tfor (i = 0; i < chain->depth; i++) {\n\t\thlock_id = chain_hlocks[chain->base + i];\n\t\tchain_key = print_chain_key_iteration(hlock_id, chain_key);\n\n\t\tprint_lock_name(lock_classes + chain_hlock_class_idx(hlock_id) - 1);\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Locks in cached chain:\""
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_chain_keys_held_locks",
          "args": [
            "curr",
            "hlock_next"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "print_chain_keys_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3501-3520",
          "snippet": "static void\nprint_chain_keys_held_locks(struct task_struct *curr, struct held_lock *hlock_next)\n{\n\tstruct held_lock *hlock;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tint depth = curr->lockdep_depth;\n\tint i = get_first_held_lock(curr, hlock_next);\n\n\tprintk(\"depth: %u (irq_context %u)\\n\", depth - i + 1,\n\t\thlock_next->irq_context);\n\tfor (; i < depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tchain_key = print_chain_key_iteration(hlock_id(hlock), chain_key);\n\n\t\tprint_lock(hlock);\n\t}\n\n\tprint_chain_key_iteration(hlock_id(hlock_next), chain_key);\n\tprint_lock(hlock_next);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_chain_keys_held_locks(struct task_struct *curr, struct held_lock *hlock_next)\n{\n\tstruct held_lock *hlock;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tint depth = curr->lockdep_depth;\n\tint i = get_first_held_lock(curr, hlock_next);\n\n\tprintk(\"depth: %u (irq_context %u)\\n\", depth - i + 1,\n\t\thlock_next->irq_context);\n\tfor (; i < depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tchain_key = print_chain_key_iteration(hlock_id(hlock), chain_key);\n\n\t\tprint_lock(hlock);\n\t}\n\n\tprint_chain_key_iteration(hlock_id(hlock_next), chain_key);\n\tprint_lock(hlock_next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Held locks:\""
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Hash chain already cached but the contents don't match!\\n\""
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d: \"",
            "current->comm",
            "task_pid_nr(current)"
          ],
          "line": 3547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 3547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"----------------------------\\n\""
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 3545
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: chain_key collision\\n\""
          ],
          "line": 3544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"============================\\n\""
          ],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock_next,\n\t\t\tstruct lock_chain *chain)\n{\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================\\n\");\n\tpr_warn(\"WARNING: chain_key collision\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------\\n\");\n\tpr_warn(\"%s/%d: \", current->comm, task_pid_nr(current));\n\tpr_warn(\"Hash chain already cached but the contents don't match!\\n\");\n\n\tpr_warn(\"Held locks:\");\n\tprint_chain_keys_held_locks(curr, hlock_next);\n\n\tpr_warn(\"Locks in cached chain:\");\n\tprint_chain_keys_chain(chain);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "print_chain_keys_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3522-3536",
    "snippet": "static void print_chain_keys_chain(struct lock_chain *chain)\n{\n\tint i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tu16 hlock_id;\n\n\tprintk(\"depth: %u\\n\", chain->depth);\n\tfor (i = 0; i < chain->depth; i++) {\n\t\thlock_id = chain_hlocks[chain->base + i];\n\t\tchain_key = print_chain_key_iteration(hlock_id, chain_key);\n\n\t\tprint_lock_name(lock_classes + chain_hlock_class_idx(hlock_id) - 1);\n\t\tprintk(\"\\n\");\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 3534
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "lock_classes + chain_hlock_class_idx(hlock_id) - 1"
          ],
          "line": 3533
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "701-712",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chain_hlock_class_idx",
          "args": [
            "hlock_id"
          ],
          "line": 3533
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_chain_key_iteration",
          "args": [
            "hlock_id",
            "chain_key"
          ],
          "line": 3531
        },
        "resolved": true,
        "details": {
          "function_name": "print_chain_key_iteration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3491-3499",
          "snippet": "static u64 print_chain_key_iteration(u16 hlock_id, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, hlock_id);\n\n\tprintk(\" hlock_id:%d -> chain_key:%016Lx\",\n\t\t(unsigned int)hlock_id,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic u64 print_chain_key_iteration(u16 hlock_id, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, hlock_id);\n\n\tprintk(\" hlock_id:%d -> chain_key:%016Lx\",\n\t\t(unsigned int)hlock_id,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"depth: %u\\n\"",
            "chain->depth"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic void print_chain_keys_chain(struct lock_chain *chain)\n{\n\tint i;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tu16 hlock_id;\n\n\tprintk(\"depth: %u\\n\", chain->depth);\n\tfor (i = 0; i < chain->depth; i++) {\n\t\thlock_id = chain_hlocks[chain->base + i];\n\t\tchain_key = print_chain_key_iteration(hlock_id, chain_key);\n\n\t\tprint_lock_name(lock_classes + chain_hlock_class_idx(hlock_id) - 1);\n\t\tprintk(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "print_chain_keys_held_locks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3501-3520",
    "snippet": "static void\nprint_chain_keys_held_locks(struct task_struct *curr, struct held_lock *hlock_next)\n{\n\tstruct held_lock *hlock;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tint depth = curr->lockdep_depth;\n\tint i = get_first_held_lock(curr, hlock_next);\n\n\tprintk(\"depth: %u (irq_context %u)\\n\", depth - i + 1,\n\t\thlock_next->irq_context);\n\tfor (; i < depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tchain_key = print_chain_key_iteration(hlock_id(hlock), chain_key);\n\n\t\tprint_lock(hlock);\n\t}\n\n\tprint_chain_key_iteration(hlock_id(hlock_next), chain_key);\n\tprint_lock(hlock_next);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "hlock_next"
          ],
          "line": 3519
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "726-748",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_chain_key_iteration",
          "args": [
            "hlock_id(hlock_next)",
            "chain_key"
          ],
          "line": 3518
        },
        "resolved": true,
        "details": {
          "function_name": "print_chain_key_iteration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3491-3499",
          "snippet": "static u64 print_chain_key_iteration(u16 hlock_id, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, hlock_id);\n\n\tprintk(\" hlock_id:%d -> chain_key:%016Lx\",\n\t\t(unsigned int)hlock_id,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic u64 print_chain_key_iteration(u16 hlock_id, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, hlock_id);\n\n\tprintk(\" hlock_id:%d -> chain_key:%016Lx\",\n\t\t(unsigned int)hlock_id,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_id",
          "args": [
            "hlock_next"
          ],
          "line": 3518
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "397-402",
          "snippet": "static inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"depth: %u (irq_context %u)\\n\"",
            "depth - i + 1",
            "hlock_next->irq_context"
          ],
          "line": 3509
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_first_held_lock",
          "args": [
            "curr",
            "hlock_next"
          ],
          "line": 3507
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3471-3485",
          "snippet": "static inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_chain_keys_held_locks(struct task_struct *curr, struct held_lock *hlock_next)\n{\n\tstruct held_lock *hlock;\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tint depth = curr->lockdep_depth;\n\tint i = get_first_held_lock(curr, hlock_next);\n\n\tprintk(\"depth: %u (irq_context %u)\\n\", depth - i + 1,\n\t\thlock_next->irq_context);\n\tfor (; i < depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tchain_key = print_chain_key_iteration(hlock_id(hlock), chain_key);\n\n\t\tprint_lock(hlock);\n\t}\n\n\tprint_chain_key_iteration(hlock_id(hlock_next), chain_key);\n\tprint_lock(hlock_next);\n}"
  },
  {
    "function_name": "print_chain_key_iteration",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3491-3499",
    "snippet": "static u64 print_chain_key_iteration(u16 hlock_id, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, hlock_id);\n\n\tprintk(\" hlock_id:%d -> chain_key:%016Lx\",\n\t\t(unsigned int)hlock_id,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" hlock_id:%d -> chain_key:%016Lx\"",
            "(unsigned int)hlock_id",
            "(unsigned long long)new_chain_key"
          ],
          "line": 3495
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_chain_key",
          "args": [
            "chain_key",
            "hlock_id"
          ],
          "line": 3493
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_chain_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "415-422",
          "snippet": "static inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic u64 print_chain_key_iteration(u16 hlock_id, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, hlock_id);\n\n\tprintk(\" hlock_id:%d -> chain_key:%016Lx\",\n\t\t(unsigned int)hlock_id,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}"
  },
  {
    "function_name": "get_first_held_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3471-3485",
    "snippet": "static inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}"
  },
  {
    "function_name": "lock_chain_get_class",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3460-3466",
    "snippet": "struct lock_class *lock_chain_get_class(struct lock_chain *chain, int i)\n{\n\tu16 chain_hlock = chain_hlocks[chain->base + i];\n\tunsigned int class_idx = chain_hlock_class_idx(chain_hlock);\n\n\treturn lock_classes + class_idx - 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chain_hlock_class_idx",
          "args": [
            "chain_hlock"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstruct lock_class *lock_chain_get_class(struct lock_chain *chain, int i)\n{\n\tu16 chain_hlock = chain_hlocks[chain->base + i];\n\tunsigned int class_idx = chain_hlock_class_idx(chain_hlock);\n\n\treturn lock_classes + class_idx - 1;\n}"
  },
  {
    "function_name": "free_chain_hlocks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3455-3458",
    "snippet": "static inline void free_chain_hlocks(int base, int size)\n{\n\tadd_chain_block(base, max(size, 2));\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_chain_block",
          "args": [
            "base",
            "max(size, 2)"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "add_chain_block",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3313-3355",
          "snippet": "static inline void add_chain_block(int offset, int size)\n{\n\tint bucket = size_to_bucket(size);\n\tint next = chain_block_buckets[bucket];\n\tint prev, curr;\n\n\tif (unlikely(size < 2)) {\n\t\t/*\n\t\t * We can't store single entries on the freelist. Leak them.\n\t\t *\n\t\t * One possible way out would be to uniquely mark them, other\n\t\t * than with CHAIN_BLK_FLAG, such that we can recover them when\n\t\t * the block before it is re-added.\n\t\t */\n\t\tif (size)\n\t\t\tnr_lost_chain_hlocks++;\n\t\treturn;\n\t}\n\n\tnr_free_chain_hlocks += size;\n\tif (!bucket) {\n\t\tnr_large_chain_blocks++;\n\n\t\t/*\n\t\t * Variable sized, sort large to small.\n\t\t */\n\t\tfor_each_chain_block(0, prev, curr) {\n\t\t\tif (size >= chain_block_size(curr))\n\t\t\t\tbreak;\n\t\t}\n\t\tinit_chain_block(offset, curr, 0, size);\n\t\tif (prev < 0)\n\t\t\tchain_block_buckets[0] = offset;\n\t\telse\n\t\t\tinit_chain_block(prev, offset, 0, 0);\n\t\treturn;\n\t}\n\t/*\n\t * Fixed size, add to head.\n\t */\n\tinit_chain_block(offset, next, bucket, size);\n\tchain_block_buckets[bucket] = offset;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CHAIN_BLK_FLAG\t\t(1U << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAIN_BLK_FLAG\t\t(1U << 15)\n\nstatic inline void add_chain_block(int offset, int size)\n{\n\tint bucket = size_to_bucket(size);\n\tint next = chain_block_buckets[bucket];\n\tint prev, curr;\n\n\tif (unlikely(size < 2)) {\n\t\t/*\n\t\t * We can't store single entries on the freelist. Leak them.\n\t\t *\n\t\t * One possible way out would be to uniquely mark them, other\n\t\t * than with CHAIN_BLK_FLAG, such that we can recover them when\n\t\t * the block before it is re-added.\n\t\t */\n\t\tif (size)\n\t\t\tnr_lost_chain_hlocks++;\n\t\treturn;\n\t}\n\n\tnr_free_chain_hlocks += size;\n\tif (!bucket) {\n\t\tnr_large_chain_blocks++;\n\n\t\t/*\n\t\t * Variable sized, sort large to small.\n\t\t */\n\t\tfor_each_chain_block(0, prev, curr) {\n\t\t\tif (size >= chain_block_size(curr))\n\t\t\t\tbreak;\n\t\t}\n\t\tinit_chain_block(offset, curr, 0, size);\n\t\tif (prev < 0)\n\t\t\tchain_block_buckets[0] = offset;\n\t\telse\n\t\t\tinit_chain_block(prev, offset, 0, 0);\n\t\treturn;\n\t}\n\t/*\n\t * Fixed size, add to head.\n\t */\n\tinit_chain_block(offset, next, bucket, size);\n\tchain_block_buckets[bucket] = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "size",
            "2"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void free_chain_hlocks(int base, int size)\n{\n\tadd_chain_block(base, max(size, 2));\n}"
  },
  {
    "function_name": "alloc_chain_hlocks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3393-3453",
    "snippet": "static int alloc_chain_hlocks(int req)\n{\n\tint bucket, curr, size;\n\n\t/*\n\t * We rely on the MSB to act as an escape bit to denote freelist\n\t * pointers. Make sure this bit isn't set in 'normal' class_idx usage.\n\t */\n\tBUILD_BUG_ON((MAX_LOCKDEP_KEYS-1) & CHAIN_BLK_FLAG);\n\n\tinit_data_structures_once();\n\n\tif (nr_free_chain_hlocks < req)\n\t\treturn -1;\n\n\t/*\n\t * We require a minimum of 2 (u16) entries to encode a freelist\n\t * 'pointer'.\n\t */\n\treq = max(req, 2);\n\tbucket = size_to_bucket(req);\n\tcurr = chain_block_buckets[bucket];\n\n\tif (bucket) {\n\t\tif (curr >= 0) {\n\t\t\tdel_chain_block(bucket, req, chain_block_next(curr));\n\t\t\treturn curr;\n\t\t}\n\t\t/* Try bucket 0 */\n\t\tcurr = chain_block_buckets[0];\n\t}\n\n\t/*\n\t * The variable sized freelist is sorted by size; the first entry is\n\t * the largest. Use it if it fits.\n\t */\n\tif (curr >= 0) {\n\t\tsize = chain_block_size(curr);\n\t\tif (likely(size >= req)) {\n\t\t\tdel_chain_block(0, size, chain_block_next(curr));\n\t\t\tadd_chain_block(curr + req, size - req);\n\t\t\treturn curr;\n\t\t}\n\t}\n\n\t/*\n\t * Last resort, split a block in a larger sized bucket.\n\t */\n\tfor (size = MAX_CHAIN_BUCKETS; size > req; size--) {\n\t\tbucket = size_to_bucket(size);\n\t\tcurr = chain_block_buckets[bucket];\n\t\tif (curr < 0)\n\t\t\tcontinue;\n\n\t\tdel_chain_block(bucket, size, chain_block_next(curr));\n\t\tadd_chain_block(curr + req, size - req);\n\t\treturn curr;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CHAIN_BLK_FLAG\t\t(1U << 15)",
      "#define MAX_CHAIN_BUCKETS\t16"
    ],
    "globals_used": [
      "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_chain_block",
          "args": [
            "curr + req",
            "size - req"
          ],
          "line": 3448
        },
        "resolved": true,
        "details": {
          "function_name": "add_chain_block",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3313-3355",
          "snippet": "static inline void add_chain_block(int offset, int size)\n{\n\tint bucket = size_to_bucket(size);\n\tint next = chain_block_buckets[bucket];\n\tint prev, curr;\n\n\tif (unlikely(size < 2)) {\n\t\t/*\n\t\t * We can't store single entries on the freelist. Leak them.\n\t\t *\n\t\t * One possible way out would be to uniquely mark them, other\n\t\t * than with CHAIN_BLK_FLAG, such that we can recover them when\n\t\t * the block before it is re-added.\n\t\t */\n\t\tif (size)\n\t\t\tnr_lost_chain_hlocks++;\n\t\treturn;\n\t}\n\n\tnr_free_chain_hlocks += size;\n\tif (!bucket) {\n\t\tnr_large_chain_blocks++;\n\n\t\t/*\n\t\t * Variable sized, sort large to small.\n\t\t */\n\t\tfor_each_chain_block(0, prev, curr) {\n\t\t\tif (size >= chain_block_size(curr))\n\t\t\t\tbreak;\n\t\t}\n\t\tinit_chain_block(offset, curr, 0, size);\n\t\tif (prev < 0)\n\t\t\tchain_block_buckets[0] = offset;\n\t\telse\n\t\t\tinit_chain_block(prev, offset, 0, 0);\n\t\treturn;\n\t}\n\t/*\n\t * Fixed size, add to head.\n\t */\n\tinit_chain_block(offset, next, bucket, size);\n\tchain_block_buckets[bucket] = offset;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CHAIN_BLK_FLAG\t\t(1U << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAIN_BLK_FLAG\t\t(1U << 15)\n\nstatic inline void add_chain_block(int offset, int size)\n{\n\tint bucket = size_to_bucket(size);\n\tint next = chain_block_buckets[bucket];\n\tint prev, curr;\n\n\tif (unlikely(size < 2)) {\n\t\t/*\n\t\t * We can't store single entries on the freelist. Leak them.\n\t\t *\n\t\t * One possible way out would be to uniquely mark them, other\n\t\t * than with CHAIN_BLK_FLAG, such that we can recover them when\n\t\t * the block before it is re-added.\n\t\t */\n\t\tif (size)\n\t\t\tnr_lost_chain_hlocks++;\n\t\treturn;\n\t}\n\n\tnr_free_chain_hlocks += size;\n\tif (!bucket) {\n\t\tnr_large_chain_blocks++;\n\n\t\t/*\n\t\t * Variable sized, sort large to small.\n\t\t */\n\t\tfor_each_chain_block(0, prev, curr) {\n\t\t\tif (size >= chain_block_size(curr))\n\t\t\t\tbreak;\n\t\t}\n\t\tinit_chain_block(offset, curr, 0, size);\n\t\tif (prev < 0)\n\t\t\tchain_block_buckets[0] = offset;\n\t\telse\n\t\t\tinit_chain_block(prev, offset, 0, 0);\n\t\treturn;\n\t}\n\t/*\n\t * Fixed size, add to head.\n\t */\n\tinit_chain_block(offset, next, bucket, size);\n\tchain_block_buckets[bucket] = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_chain_block",
          "args": [
            "bucket",
            "size",
            "chain_block_next(curr)"
          ],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "del_chain_block",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3368-3375",
          "snippet": "static inline void del_chain_block(int bucket, int size, int next)\n{\n\tnr_free_chain_hlocks -= size;\n\tchain_block_buckets[bucket] = next;\n\n\tif (!bucket)\n\t\tnr_large_chain_blocks--;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void del_chain_block(int bucket, int size, int next)\n{\n\tnr_free_chain_hlocks -= size;\n\tchain_block_buckets[bucket] = next;\n\n\tif (!bucket)\n\t\tnr_large_chain_blocks--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chain_block_next",
          "args": [
            "curr"
          ],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "chain_block_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3278-3292",
          "snippet": "static inline int chain_block_next(int offset)\n{\n\tint next = chain_hlocks[offset];\n\n\tWARN_ON_ONCE(!(next & CHAIN_BLK_FLAG));\n\n\tif (next == CHAIN_BLK_LIST_END)\n\t\treturn -1;\n\n\tnext &= ~CHAIN_BLK_FLAG;\n\tnext <<= 16;\n\tnext |= chain_hlocks[offset + 1];\n\n\treturn next;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CHAIN_BLK_LIST_END\t0xFFFFU",
            "#define CHAIN_BLK_FLAG\t\t(1U << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAIN_BLK_LIST_END\t0xFFFFU\n#define CHAIN_BLK_FLAG\t\t(1U << 15)\n\nstatic inline int chain_block_next(int offset)\n{\n\tint next = chain_hlocks[offset];\n\n\tWARN_ON_ONCE(!(next & CHAIN_BLK_FLAG));\n\n\tif (next == CHAIN_BLK_LIST_END)\n\t\treturn -1;\n\n\tnext &= ~CHAIN_BLK_FLAG;\n\tnext <<= 16;\n\tnext |= chain_hlocks[offset + 1];\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "size_to_bucket",
          "args": [
            "size"
          ],
          "line": 3442
        },
        "resolved": true,
        "details": {
          "function_name": "size_to_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3259-3265",
          "snippet": "static inline int size_to_bucket(int size)\n{\n\tif (size > MAX_CHAIN_BUCKETS)\n\t\treturn 0;\n\n\treturn size - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define MAX_CHAIN_BUCKETS\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define MAX_CHAIN_BUCKETS\t16\n\nstatic inline int size_to_bucket(int size)\n{\n\tif (size > MAX_CHAIN_BUCKETS)\n\t\treturn 0;\n\n\treturn size - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "size >= req"
          ],
          "line": 3431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chain_block_size",
          "args": [
            "curr"
          ],
          "line": 3430
        },
        "resolved": true,
        "details": {
          "function_name": "chain_block_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3297-3300",
          "snippet": "static inline int chain_block_size(int offset)\n{\n\treturn (chain_hlocks[offset + 2] << 16) | chain_hlocks[offset + 3];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int chain_block_size(int offset)\n{\n\treturn (chain_hlocks[offset + 2] << 16) | chain_hlocks[offset + 3];\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "req",
            "2"
          ],
          "line": 3412
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_data_structures_once",
          "args": [],
          "line": 3403
        },
        "resolved": true,
        "details": {
          "function_name": "init_data_structures_once",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1150-1177",
          "snippet": "static void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static LIST_HEAD(free_lock_classes);",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static void init_chain_block_buckets(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic LIST_HEAD(free_lock_classes);\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic void init_chain_block_buckets(void);\n\nstatic void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "(MAX_LOCKDEP_KEYS-1) & CHAIN_BLK_FLAG"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAIN_BLK_FLAG\t\t(1U << 15)\n#define MAX_CHAIN_BUCKETS\t16\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic int alloc_chain_hlocks(int req)\n{\n\tint bucket, curr, size;\n\n\t/*\n\t * We rely on the MSB to act as an escape bit to denote freelist\n\t * pointers. Make sure this bit isn't set in 'normal' class_idx usage.\n\t */\n\tBUILD_BUG_ON((MAX_LOCKDEP_KEYS-1) & CHAIN_BLK_FLAG);\n\n\tinit_data_structures_once();\n\n\tif (nr_free_chain_hlocks < req)\n\t\treturn -1;\n\n\t/*\n\t * We require a minimum of 2 (u16) entries to encode a freelist\n\t * 'pointer'.\n\t */\n\treq = max(req, 2);\n\tbucket = size_to_bucket(req);\n\tcurr = chain_block_buckets[bucket];\n\n\tif (bucket) {\n\t\tif (curr >= 0) {\n\t\t\tdel_chain_block(bucket, req, chain_block_next(curr));\n\t\t\treturn curr;\n\t\t}\n\t\t/* Try bucket 0 */\n\t\tcurr = chain_block_buckets[0];\n\t}\n\n\t/*\n\t * The variable sized freelist is sorted by size; the first entry is\n\t * the largest. Use it if it fits.\n\t */\n\tif (curr >= 0) {\n\t\tsize = chain_block_size(curr);\n\t\tif (likely(size >= req)) {\n\t\t\tdel_chain_block(0, size, chain_block_next(curr));\n\t\t\tadd_chain_block(curr + req, size - req);\n\t\t\treturn curr;\n\t\t}\n\t}\n\n\t/*\n\t * Last resort, split a block in a larger sized bucket.\n\t */\n\tfor (size = MAX_CHAIN_BUCKETS; size > req; size--) {\n\t\tbucket = size_to_bucket(size);\n\t\tcurr = chain_block_buckets[bucket];\n\t\tif (curr < 0)\n\t\t\tcontinue;\n\n\t\tdel_chain_block(bucket, size, chain_block_next(curr));\n\t\tadd_chain_block(curr + req, size - req);\n\t\treturn curr;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "init_chain_block_buckets",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3377-3385",
    "snippet": "static void init_chain_block_buckets(void)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_CHAIN_BUCKETS; i++)\n\t\tchain_block_buckets[i] = -1;\n\n\tadd_chain_block(0, ARRAY_SIZE(chain_hlocks));\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define MAX_CHAIN_BUCKETS\t16"
    ],
    "globals_used": [
      "static void init_chain_block_buckets(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_chain_block",
          "args": [
            "0",
            "ARRAY_SIZE(chain_hlocks)"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "add_chain_block",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3313-3355",
          "snippet": "static inline void add_chain_block(int offset, int size)\n{\n\tint bucket = size_to_bucket(size);\n\tint next = chain_block_buckets[bucket];\n\tint prev, curr;\n\n\tif (unlikely(size < 2)) {\n\t\t/*\n\t\t * We can't store single entries on the freelist. Leak them.\n\t\t *\n\t\t * One possible way out would be to uniquely mark them, other\n\t\t * than with CHAIN_BLK_FLAG, such that we can recover them when\n\t\t * the block before it is re-added.\n\t\t */\n\t\tif (size)\n\t\t\tnr_lost_chain_hlocks++;\n\t\treturn;\n\t}\n\n\tnr_free_chain_hlocks += size;\n\tif (!bucket) {\n\t\tnr_large_chain_blocks++;\n\n\t\t/*\n\t\t * Variable sized, sort large to small.\n\t\t */\n\t\tfor_each_chain_block(0, prev, curr) {\n\t\t\tif (size >= chain_block_size(curr))\n\t\t\t\tbreak;\n\t\t}\n\t\tinit_chain_block(offset, curr, 0, size);\n\t\tif (prev < 0)\n\t\t\tchain_block_buckets[0] = offset;\n\t\telse\n\t\t\tinit_chain_block(prev, offset, 0, 0);\n\t\treturn;\n\t}\n\t/*\n\t * Fixed size, add to head.\n\t */\n\tinit_chain_block(offset, next, bucket, size);\n\tchain_block_buckets[bucket] = offset;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CHAIN_BLK_FLAG\t\t(1U << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAIN_BLK_FLAG\t\t(1U << 15)\n\nstatic inline void add_chain_block(int offset, int size)\n{\n\tint bucket = size_to_bucket(size);\n\tint next = chain_block_buckets[bucket];\n\tint prev, curr;\n\n\tif (unlikely(size < 2)) {\n\t\t/*\n\t\t * We can't store single entries on the freelist. Leak them.\n\t\t *\n\t\t * One possible way out would be to uniquely mark them, other\n\t\t * than with CHAIN_BLK_FLAG, such that we can recover them when\n\t\t * the block before it is re-added.\n\t\t */\n\t\tif (size)\n\t\t\tnr_lost_chain_hlocks++;\n\t\treturn;\n\t}\n\n\tnr_free_chain_hlocks += size;\n\tif (!bucket) {\n\t\tnr_large_chain_blocks++;\n\n\t\t/*\n\t\t * Variable sized, sort large to small.\n\t\t */\n\t\tfor_each_chain_block(0, prev, curr) {\n\t\t\tif (size >= chain_block_size(curr))\n\t\t\t\tbreak;\n\t\t}\n\t\tinit_chain_block(offset, curr, 0, size);\n\t\tif (prev < 0)\n\t\t\tchain_block_buckets[0] = offset;\n\t\telse\n\t\t\tinit_chain_block(prev, offset, 0, 0);\n\t\treturn;\n\t}\n\t/*\n\t * Fixed size, add to head.\n\t */\n\tinit_chain_block(offset, next, bucket, size);\n\tchain_block_buckets[bucket] = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "chain_hlocks"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define MAX_CHAIN_BUCKETS\t16\n\nstatic void init_chain_block_buckets(void);\n\nstatic void init_chain_block_buckets(void)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_CHAIN_BUCKETS; i++)\n\t\tchain_block_buckets[i] = -1;\n\n\tadd_chain_block(0, ARRAY_SIZE(chain_hlocks));\n}"
  },
  {
    "function_name": "del_chain_block",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3368-3375",
    "snippet": "static inline void del_chain_block(int bucket, int size, int next)\n{\n\tnr_free_chain_hlocks -= size;\n\tchain_block_buckets[bucket] = next;\n\n\tif (!bucket)\n\t\tnr_large_chain_blocks--;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void del_chain_block(int bucket, int size, int next)\n{\n\tnr_free_chain_hlocks -= size;\n\tchain_block_buckets[bucket] = next;\n\n\tif (!bucket)\n\t\tnr_large_chain_blocks--;\n}"
  },
  {
    "function_name": "add_chain_block",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3313-3355",
    "snippet": "static inline void add_chain_block(int offset, int size)\n{\n\tint bucket = size_to_bucket(size);\n\tint next = chain_block_buckets[bucket];\n\tint prev, curr;\n\n\tif (unlikely(size < 2)) {\n\t\t/*\n\t\t * We can't store single entries on the freelist. Leak them.\n\t\t *\n\t\t * One possible way out would be to uniquely mark them, other\n\t\t * than with CHAIN_BLK_FLAG, such that we can recover them when\n\t\t * the block before it is re-added.\n\t\t */\n\t\tif (size)\n\t\t\tnr_lost_chain_hlocks++;\n\t\treturn;\n\t}\n\n\tnr_free_chain_hlocks += size;\n\tif (!bucket) {\n\t\tnr_large_chain_blocks++;\n\n\t\t/*\n\t\t * Variable sized, sort large to small.\n\t\t */\n\t\tfor_each_chain_block(0, prev, curr) {\n\t\t\tif (size >= chain_block_size(curr))\n\t\t\t\tbreak;\n\t\t}\n\t\tinit_chain_block(offset, curr, 0, size);\n\t\tif (prev < 0)\n\t\t\tchain_block_buckets[0] = offset;\n\t\telse\n\t\t\tinit_chain_block(prev, offset, 0, 0);\n\t\treturn;\n\t}\n\t/*\n\t * Fixed size, add to head.\n\t */\n\tinit_chain_block(offset, next, bucket, size);\n\tchain_block_buckets[bucket] = offset;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CHAIN_BLK_FLAG\t\t(1U << 15)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_chain_block",
          "args": [
            "offset",
            "next",
            "bucket",
            "size"
          ],
          "line": 3353
        },
        "resolved": true,
        "details": {
          "function_name": "init_chain_block",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3302-3311",
          "snippet": "static inline void init_chain_block(int offset, int next, int bucket, int size)\n{\n\tchain_hlocks[offset] = (next >> 16) | CHAIN_BLK_FLAG;\n\tchain_hlocks[offset + 1] = (u16)next;\n\n\tif (size && !bucket) {\n\t\tchain_hlocks[offset + 2] = size >> 16;\n\t\tchain_hlocks[offset + 3] = (u16)size;\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CHAIN_BLK_FLAG\t\t(1U << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAIN_BLK_FLAG\t\t(1U << 15)\n\nstatic inline void init_chain_block(int offset, int next, int bucket, int size)\n{\n\tchain_hlocks[offset] = (next >> 16) | CHAIN_BLK_FLAG;\n\tchain_hlocks[offset + 1] = (u16)next;\n\n\tif (size && !bucket) {\n\t\tchain_hlocks[offset + 2] = size >> 16;\n\t\tchain_hlocks[offset + 3] = (u16)size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chain_block_size",
          "args": [
            "curr"
          ],
          "line": 3340
        },
        "resolved": true,
        "details": {
          "function_name": "chain_block_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3297-3300",
          "snippet": "static inline int chain_block_size(int offset)\n{\n\treturn (chain_hlocks[offset + 2] << 16) | chain_hlocks[offset + 3];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int chain_block_size(int offset)\n{\n\treturn (chain_hlocks[offset + 2] << 16) | chain_hlocks[offset + 3];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_chain_block",
          "args": [
            "0",
            "prev",
            "curr"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size < 2"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_to_bucket",
          "args": [
            "size"
          ],
          "line": 3315
        },
        "resolved": true,
        "details": {
          "function_name": "size_to_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3259-3265",
          "snippet": "static inline int size_to_bucket(int size)\n{\n\tif (size > MAX_CHAIN_BUCKETS)\n\t\treturn 0;\n\n\treturn size - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define MAX_CHAIN_BUCKETS\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define MAX_CHAIN_BUCKETS\t16\n\nstatic inline int size_to_bucket(int size)\n{\n\tif (size > MAX_CHAIN_BUCKETS)\n\t\treturn 0;\n\n\treturn size - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAIN_BLK_FLAG\t\t(1U << 15)\n\nstatic inline void add_chain_block(int offset, int size)\n{\n\tint bucket = size_to_bucket(size);\n\tint next = chain_block_buckets[bucket];\n\tint prev, curr;\n\n\tif (unlikely(size < 2)) {\n\t\t/*\n\t\t * We can't store single entries on the freelist. Leak them.\n\t\t *\n\t\t * One possible way out would be to uniquely mark them, other\n\t\t * than with CHAIN_BLK_FLAG, such that we can recover them when\n\t\t * the block before it is re-added.\n\t\t */\n\t\tif (size)\n\t\t\tnr_lost_chain_hlocks++;\n\t\treturn;\n\t}\n\n\tnr_free_chain_hlocks += size;\n\tif (!bucket) {\n\t\tnr_large_chain_blocks++;\n\n\t\t/*\n\t\t * Variable sized, sort large to small.\n\t\t */\n\t\tfor_each_chain_block(0, prev, curr) {\n\t\t\tif (size >= chain_block_size(curr))\n\t\t\t\tbreak;\n\t\t}\n\t\tinit_chain_block(offset, curr, 0, size);\n\t\tif (prev < 0)\n\t\t\tchain_block_buckets[0] = offset;\n\t\telse\n\t\t\tinit_chain_block(prev, offset, 0, 0);\n\t\treturn;\n\t}\n\t/*\n\t * Fixed size, add to head.\n\t */\n\tinit_chain_block(offset, next, bucket, size);\n\tchain_block_buckets[bucket] = offset;\n}"
  },
  {
    "function_name": "init_chain_block",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3302-3311",
    "snippet": "static inline void init_chain_block(int offset, int next, int bucket, int size)\n{\n\tchain_hlocks[offset] = (next >> 16) | CHAIN_BLK_FLAG;\n\tchain_hlocks[offset + 1] = (u16)next;\n\n\tif (size && !bucket) {\n\t\tchain_hlocks[offset + 2] = size >> 16;\n\t\tchain_hlocks[offset + 3] = (u16)size;\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CHAIN_BLK_FLAG\t\t(1U << 15)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAIN_BLK_FLAG\t\t(1U << 15)\n\nstatic inline void init_chain_block(int offset, int next, int bucket, int size)\n{\n\tchain_hlocks[offset] = (next >> 16) | CHAIN_BLK_FLAG;\n\tchain_hlocks[offset + 1] = (u16)next;\n\n\tif (size && !bucket) {\n\t\tchain_hlocks[offset + 2] = size >> 16;\n\t\tchain_hlocks[offset + 3] = (u16)size;\n\t}\n}"
  },
  {
    "function_name": "chain_block_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3297-3300",
    "snippet": "static inline int chain_block_size(int offset)\n{\n\treturn (chain_hlocks[offset + 2] << 16) | chain_hlocks[offset + 3];\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int chain_block_size(int offset)\n{\n\treturn (chain_hlocks[offset + 2] << 16) | chain_hlocks[offset + 3];\n}"
  },
  {
    "function_name": "chain_block_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3278-3292",
    "snippet": "static inline int chain_block_next(int offset)\n{\n\tint next = chain_hlocks[offset];\n\n\tWARN_ON_ONCE(!(next & CHAIN_BLK_FLAG));\n\n\tif (next == CHAIN_BLK_LIST_END)\n\t\treturn -1;\n\n\tnext &= ~CHAIN_BLK_FLAG;\n\tnext <<= 16;\n\tnext |= chain_hlocks[offset + 1];\n\n\treturn next;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CHAIN_BLK_LIST_END\t0xFFFFU",
      "#define CHAIN_BLK_FLAG\t\t(1U << 15)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(next & CHAIN_BLK_FLAG)"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAIN_BLK_LIST_END\t0xFFFFU\n#define CHAIN_BLK_FLAG\t\t(1U << 15)\n\nstatic inline int chain_block_next(int offset)\n{\n\tint next = chain_hlocks[offset];\n\n\tWARN_ON_ONCE(!(next & CHAIN_BLK_FLAG));\n\n\tif (next == CHAIN_BLK_LIST_END)\n\t\treturn -1;\n\n\tnext &= ~CHAIN_BLK_FLAG;\n\tnext <<= 16;\n\tnext |= chain_hlocks[offset + 1];\n\n\treturn next;\n}"
  },
  {
    "function_name": "size_to_bucket",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3259-3265",
    "snippet": "static inline int size_to_bucket(int size)\n{\n\tif (size > MAX_CHAIN_BUCKETS)\n\t\treturn 0;\n\n\treturn size - 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define MAX_CHAIN_BUCKETS\t16"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define MAX_CHAIN_BUCKETS\t16\n\nstatic inline int size_to_bucket(int size)\n{\n\tif (size > MAX_CHAIN_BUCKETS)\n\t\treturn 0;\n\n\treturn size - 1;\n}"
  },
  {
    "function_name": "check_prevs_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3159-3226",
    "snippet": "static int\ncheck_prevs_add(struct task_struct *curr, struct held_lock *next)\n{\n\tstruct lock_trace *trace = NULL;\n\tint depth = curr->lockdep_depth;\n\tstruct held_lock *hlock;\n\n\t/*\n\t * Debugging checks.\n\t *\n\t * Depth must not be zero for a non-head lock:\n\t */\n\tif (!depth)\n\t\tgoto out_bug;\n\t/*\n\t * At least two relevant locks must exist for this\n\t * to be a head:\n\t */\n\tif (curr->held_locks[depth].irq_context !=\n\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\tgoto out_bug;\n\n\tfor (;;) {\n\t\tu16 distance = curr->lockdep_depth - depth + 1;\n\t\thlock = curr->held_locks + depth - 1;\n\n\t\tif (hlock->check) {\n\t\t\tint ret = check_prev_add(curr, hlock, next, distance, &trace);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Stop after the first non-trylock entry,\n\t\t\t * as non-trylock entries have added their\n\t\t\t * own direct dependencies already, so this\n\t\t\t * lock is connected to them indirectly:\n\t\t\t */\n\t\t\tif (!hlock->trylock)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdepth--;\n\t\t/*\n\t\t * End of lock-stack?\n\t\t */\n\t\tif (!depth)\n\t\t\tbreak;\n\t\t/*\n\t\t * Stop the search if we cross into another context:\n\t\t */\n\t\tif (curr->held_locks[depth].irq_context !=\n\t\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\t\tbreak;\n\t}\n\treturn 1;\nout_bug:\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Clearly we all shouldn't be here, but since we made it we\n\t * can reliable say we messed up our state. See the above two\n\t * gotos for reasons why we could possibly end up here.\n\t */\n\tWARN_ON(1);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 3223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_prev_add",
          "args": [
            "curr",
            "hlock",
            "next",
            "distance",
            "&trace"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "check_prev_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3027-3151",
          "snippet": "static int\ncheck_prev_add(struct task_struct *curr, struct held_lock *prev,\n\t       struct held_lock *next, u16 distance,\n\t       struct lock_trace **const trace)\n{\n\tstruct lock_list *entry;\n\tenum bfs_result ret;\n\n\tif (!hlock_class(prev)->key || !hlock_class(next)->key) {\n\t\t/*\n\t\t * The warning statements below may trigger a use-after-free\n\t\t * of the class name. It is better to trigger a use-after free\n\t\t * and to have the class name most of the time instead of not\n\t\t * having the class name available.\n\t\t */\n\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(prev)->key,\n\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",\n\t\t\t  hlock_class(prev),\n\t\t\t  hlock_class(prev)->name);\n\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(next)->key,\n\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",\n\t\t\t  hlock_class(next),\n\t\t\t  hlock_class(next)->name);\n\t\treturn 2;\n\t}\n\n\t/*\n\t * Prove that the new <prev> -> <next> dependency would not\n\t * create a circular dependency in the graph. (We do this by\n\t * a breadth-first search into the graph starting at <next>,\n\t * and check whether we can reach <prev>.)\n\t *\n\t * The search is limited by the size of the circular queue (i.e.,\n\t * MAX_CIRCULAR_QUEUE_SIZE) which keeps track of a breadth of nodes\n\t * in the graph whose neighbours are to be checked.\n\t */\n\tret = check_noncircular(next, prev, trace);\n\tif (unlikely(bfs_error(ret) || ret == BFS_RMATCH))\n\t\treturn 0;\n\n\tif (!check_irq_usage(curr, prev, next))\n\t\treturn 0;\n\n\t/*\n\t * Is the <prev> -> <next> dependency already present?\n\t *\n\t * (this may occur even though this is a new chain: consider\n\t *  e.g. the L1 -> L2 -> L3 -> L4 and the L5 -> L1 -> L2 -> L3\n\t *  chains - the second one will be new, but L1 already has\n\t *  L2 added to its dependency list, due to the first chain.)\n\t */\n\tlist_for_each_entry(entry, &hlock_class(prev)->locks_after, entry) {\n\t\tif (entry->class == hlock_class(next)) {\n\t\t\tif (distance == 1)\n\t\t\t\tentry->distance = 1;\n\t\t\tentry->dep |= calc_dep(prev, next);\n\n\t\t\t/*\n\t\t\t * Also, update the reverse dependency in @next's\n\t\t\t * ->locks_before list.\n\t\t\t *\n\t\t\t *  Here we reuse @entry as the cursor, which is fine\n\t\t\t *  because we won't go to the next iteration of the\n\t\t\t *  outer loop:\n\t\t\t *\n\t\t\t *  For normal cases, we return in the inner loop.\n\t\t\t *\n\t\t\t *  If we fail to return, we have inconsistency, i.e.\n\t\t\t *  <prev>::locks_after contains <next> while\n\t\t\t *  <next>::locks_before doesn't contain <prev>. In\n\t\t\t *  that case, we return after the inner and indicate\n\t\t\t *  something is wrong.\n\t\t\t */\n\t\t\tlist_for_each_entry(entry, &hlock_class(next)->locks_before, entry) {\n\t\t\t\tif (entry->class == hlock_class(prev)) {\n\t\t\t\t\tif (distance == 1)\n\t\t\t\t\t\tentry->distance = 1;\n\t\t\t\t\tentry->dep |= calc_depb(prev, next);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* <prev> is not found in <next>::locks_before */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Is the <prev> -> <next> link redundant?\n\t */\n\tret = check_redundant(prev, next);\n\tif (bfs_error(ret))\n\t\treturn 0;\n\telse if (ret == BFS_RMATCH)\n\t\treturn 2;\n\n\tif (!*trace) {\n\t\t*trace = save_trace();\n\t\tif (!*trace)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Ok, all validations passed, add the new lock\n\t * to the previous lock's dependency list:\n\t */\n\tret = add_lock_to_list(hlock_class(next), hlock_class(prev),\n\t\t\t       &hlock_class(prev)->locks_after,\n\t\t\t       next->acquire_ip, distance,\n\t\t\t       calc_dep(prev, next),\n\t\t\t       *trace);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = add_lock_to_list(hlock_class(prev), hlock_class(next),\n\t\t\t       &hlock_class(next)->locks_before,\n\t\t\t       next->acquire_ip, distance,\n\t\t\t       calc_depb(prev, next),\n\t\t\t       *trace);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn 2;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define MAX_CIRCULAR_QUEUE_SIZE\t\t(1UL << CONFIG_LOCKDEP_CIRCULAR_QUEUE_BITS)"
          ],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define MAX_CIRCULAR_QUEUE_SIZE\t\t(1UL << CONFIG_LOCKDEP_CIRCULAR_QUEUE_BITS)\n\nstatic noinstr struct;\n\nstatic int\ncheck_prev_add(struct task_struct *curr, struct held_lock *prev,\n\t       struct held_lock *next, u16 distance,\n\t       struct lock_trace **const trace)\n{\n\tstruct lock_list *entry;\n\tenum bfs_result ret;\n\n\tif (!hlock_class(prev)->key || !hlock_class(next)->key) {\n\t\t/*\n\t\t * The warning statements below may trigger a use-after-free\n\t\t * of the class name. It is better to trigger a use-after free\n\t\t * and to have the class name most of the time instead of not\n\t\t * having the class name available.\n\t\t */\n\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(prev)->key,\n\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",\n\t\t\t  hlock_class(prev),\n\t\t\t  hlock_class(prev)->name);\n\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(next)->key,\n\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",\n\t\t\t  hlock_class(next),\n\t\t\t  hlock_class(next)->name);\n\t\treturn 2;\n\t}\n\n\t/*\n\t * Prove that the new <prev> -> <next> dependency would not\n\t * create a circular dependency in the graph. (We do this by\n\t * a breadth-first search into the graph starting at <next>,\n\t * and check whether we can reach <prev>.)\n\t *\n\t * The search is limited by the size of the circular queue (i.e.,\n\t * MAX_CIRCULAR_QUEUE_SIZE) which keeps track of a breadth of nodes\n\t * in the graph whose neighbours are to be checked.\n\t */\n\tret = check_noncircular(next, prev, trace);\n\tif (unlikely(bfs_error(ret) || ret == BFS_RMATCH))\n\t\treturn 0;\n\n\tif (!check_irq_usage(curr, prev, next))\n\t\treturn 0;\n\n\t/*\n\t * Is the <prev> -> <next> dependency already present?\n\t *\n\t * (this may occur even though this is a new chain: consider\n\t *  e.g. the L1 -> L2 -> L3 -> L4 and the L5 -> L1 -> L2 -> L3\n\t *  chains - the second one will be new, but L1 already has\n\t *  L2 added to its dependency list, due to the first chain.)\n\t */\n\tlist_for_each_entry(entry, &hlock_class(prev)->locks_after, entry) {\n\t\tif (entry->class == hlock_class(next)) {\n\t\t\tif (distance == 1)\n\t\t\t\tentry->distance = 1;\n\t\t\tentry->dep |= calc_dep(prev, next);\n\n\t\t\t/*\n\t\t\t * Also, update the reverse dependency in @next's\n\t\t\t * ->locks_before list.\n\t\t\t *\n\t\t\t *  Here we reuse @entry as the cursor, which is fine\n\t\t\t *  because we won't go to the next iteration of the\n\t\t\t *  outer loop:\n\t\t\t *\n\t\t\t *  For normal cases, we return in the inner loop.\n\t\t\t *\n\t\t\t *  If we fail to return, we have inconsistency, i.e.\n\t\t\t *  <prev>::locks_after contains <next> while\n\t\t\t *  <next>::locks_before doesn't contain <prev>. In\n\t\t\t *  that case, we return after the inner and indicate\n\t\t\t *  something is wrong.\n\t\t\t */\n\t\t\tlist_for_each_entry(entry, &hlock_class(next)->locks_before, entry) {\n\t\t\t\tif (entry->class == hlock_class(prev)) {\n\t\t\t\t\tif (distance == 1)\n\t\t\t\t\t\tentry->distance = 1;\n\t\t\t\t\tentry->dep |= calc_depb(prev, next);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* <prev> is not found in <next>::locks_before */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Is the <prev> -> <next> link redundant?\n\t */\n\tret = check_redundant(prev, next);\n\tif (bfs_error(ret))\n\t\treturn 0;\n\telse if (ret == BFS_RMATCH)\n\t\treturn 2;\n\n\tif (!*trace) {\n\t\t*trace = save_trace();\n\t\tif (!*trace)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Ok, all validations passed, add the new lock\n\t * to the previous lock's dependency list:\n\t */\n\tret = add_lock_to_list(hlock_class(next), hlock_class(prev),\n\t\t\t       &hlock_class(prev)->locks_after,\n\t\t\t       next->acquire_ip, distance,\n\t\t\t       calc_dep(prev, next),\n\t\t\t       *trace);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = add_lock_to_list(hlock_class(prev), hlock_class(next),\n\t\t\t       &hlock_class(next)->locks_before,\n\t\t\t       next->acquire_ip, distance,\n\t\t\t       calc_depb(prev, next),\n\t\t\t       *trace);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int\ncheck_prevs_add(struct task_struct *curr, struct held_lock *next)\n{\n\tstruct lock_trace *trace = NULL;\n\tint depth = curr->lockdep_depth;\n\tstruct held_lock *hlock;\n\n\t/*\n\t * Debugging checks.\n\t *\n\t * Depth must not be zero for a non-head lock:\n\t */\n\tif (!depth)\n\t\tgoto out_bug;\n\t/*\n\t * At least two relevant locks must exist for this\n\t * to be a head:\n\t */\n\tif (curr->held_locks[depth].irq_context !=\n\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\tgoto out_bug;\n\n\tfor (;;) {\n\t\tu16 distance = curr->lockdep_depth - depth + 1;\n\t\thlock = curr->held_locks + depth - 1;\n\n\t\tif (hlock->check) {\n\t\t\tint ret = check_prev_add(curr, hlock, next, distance, &trace);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Stop after the first non-trylock entry,\n\t\t\t * as non-trylock entries have added their\n\t\t\t * own direct dependencies already, so this\n\t\t\t * lock is connected to them indirectly:\n\t\t\t */\n\t\t\tif (!hlock->trylock)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdepth--;\n\t\t/*\n\t\t * End of lock-stack?\n\t\t */\n\t\tif (!depth)\n\t\t\tbreak;\n\t\t/*\n\t\t * Stop the search if we cross into another context:\n\t\t */\n\t\tif (curr->held_locks[depth].irq_context !=\n\t\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\t\tbreak;\n\t}\n\treturn 1;\nout_bug:\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Clearly we all shouldn't be here, but since we made it we\n\t * can reliable say we messed up our state. See the above two\n\t * gotos for reasons why we could possibly end up here.\n\t */\n\tWARN_ON(1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_prev_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "3027-3151",
    "snippet": "static int\ncheck_prev_add(struct task_struct *curr, struct held_lock *prev,\n\t       struct held_lock *next, u16 distance,\n\t       struct lock_trace **const trace)\n{\n\tstruct lock_list *entry;\n\tenum bfs_result ret;\n\n\tif (!hlock_class(prev)->key || !hlock_class(next)->key) {\n\t\t/*\n\t\t * The warning statements below may trigger a use-after-free\n\t\t * of the class name. It is better to trigger a use-after free\n\t\t * and to have the class name most of the time instead of not\n\t\t * having the class name available.\n\t\t */\n\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(prev)->key,\n\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",\n\t\t\t  hlock_class(prev),\n\t\t\t  hlock_class(prev)->name);\n\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(next)->key,\n\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",\n\t\t\t  hlock_class(next),\n\t\t\t  hlock_class(next)->name);\n\t\treturn 2;\n\t}\n\n\t/*\n\t * Prove that the new <prev> -> <next> dependency would not\n\t * create a circular dependency in the graph. (We do this by\n\t * a breadth-first search into the graph starting at <next>,\n\t * and check whether we can reach <prev>.)\n\t *\n\t * The search is limited by the size of the circular queue (i.e.,\n\t * MAX_CIRCULAR_QUEUE_SIZE) which keeps track of a breadth of nodes\n\t * in the graph whose neighbours are to be checked.\n\t */\n\tret = check_noncircular(next, prev, trace);\n\tif (unlikely(bfs_error(ret) || ret == BFS_RMATCH))\n\t\treturn 0;\n\n\tif (!check_irq_usage(curr, prev, next))\n\t\treturn 0;\n\n\t/*\n\t * Is the <prev> -> <next> dependency already present?\n\t *\n\t * (this may occur even though this is a new chain: consider\n\t *  e.g. the L1 -> L2 -> L3 -> L4 and the L5 -> L1 -> L2 -> L3\n\t *  chains - the second one will be new, but L1 already has\n\t *  L2 added to its dependency list, due to the first chain.)\n\t */\n\tlist_for_each_entry(entry, &hlock_class(prev)->locks_after, entry) {\n\t\tif (entry->class == hlock_class(next)) {\n\t\t\tif (distance == 1)\n\t\t\t\tentry->distance = 1;\n\t\t\tentry->dep |= calc_dep(prev, next);\n\n\t\t\t/*\n\t\t\t * Also, update the reverse dependency in @next's\n\t\t\t * ->locks_before list.\n\t\t\t *\n\t\t\t *  Here we reuse @entry as the cursor, which is fine\n\t\t\t *  because we won't go to the next iteration of the\n\t\t\t *  outer loop:\n\t\t\t *\n\t\t\t *  For normal cases, we return in the inner loop.\n\t\t\t *\n\t\t\t *  If we fail to return, we have inconsistency, i.e.\n\t\t\t *  <prev>::locks_after contains <next> while\n\t\t\t *  <next>::locks_before doesn't contain <prev>. In\n\t\t\t *  that case, we return after the inner and indicate\n\t\t\t *  something is wrong.\n\t\t\t */\n\t\t\tlist_for_each_entry(entry, &hlock_class(next)->locks_before, entry) {\n\t\t\t\tif (entry->class == hlock_class(prev)) {\n\t\t\t\t\tif (distance == 1)\n\t\t\t\t\t\tentry->distance = 1;\n\t\t\t\t\tentry->dep |= calc_depb(prev, next);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* <prev> is not found in <next>::locks_before */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Is the <prev> -> <next> link redundant?\n\t */\n\tret = check_redundant(prev, next);\n\tif (bfs_error(ret))\n\t\treturn 0;\n\telse if (ret == BFS_RMATCH)\n\t\treturn 2;\n\n\tif (!*trace) {\n\t\t*trace = save_trace();\n\t\tif (!*trace)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Ok, all validations passed, add the new lock\n\t * to the previous lock's dependency list:\n\t */\n\tret = add_lock_to_list(hlock_class(next), hlock_class(prev),\n\t\t\t       &hlock_class(prev)->locks_after,\n\t\t\t       next->acquire_ip, distance,\n\t\t\t       calc_dep(prev, next),\n\t\t\t       *trace);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = add_lock_to_list(hlock_class(prev), hlock_class(next),\n\t\t\t       &hlock_class(next)->locks_before,\n\t\t\t       next->acquire_ip, distance,\n\t\t\t       calc_depb(prev, next),\n\t\t\t       *trace);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn 2;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define MAX_CIRCULAR_QUEUE_SIZE\t\t(1UL << CONFIG_LOCKDEP_CIRCULAR_QUEUE_BITS)"
    ],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_lock_to_list",
          "args": [
            "hlock_class(prev)",
            "hlock_class(next)",
            "&hlock_class(next)->locks_before",
            "next->acquire_ip",
            "distance",
            "calc_depb(prev, next)",
            "*trace"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "add_lock_to_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1379-1406",
          "snippet": "static int add_lock_to_list(struct lock_class *this,\n\t\t\t    struct lock_class *links_to, struct list_head *head,\n\t\t\t    unsigned long ip, u16 distance, u8 dep,\n\t\t\t    const struct lock_trace *trace)\n{\n\tstruct lock_list *entry;\n\t/*\n\t * Lock not present yet - get a new dependency struct and\n\t * add it to the list:\n\t */\n\tentry = alloc_list_entry();\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->class = this;\n\tentry->links_to = links_to;\n\tentry->dep = dep;\n\tentry->distance = distance;\n\tentry->trace = trace;\n\t/*\n\t * Both allocation and removal are done under the graph lock; but\n\t * iteration is under RCU-sched; see look_up_lock_class() and\n\t * lockdep_free_key_range().\n\t */\n\tlist_add_tail_rcu(&entry->entry, head);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int add_lock_to_list(struct lock_class *this,\n\t\t\t    struct lock_class *links_to, struct list_head *head,\n\t\t\t    unsigned long ip, u16 distance, u8 dep,\n\t\t\t    const struct lock_trace *trace)\n{\n\tstruct lock_list *entry;\n\t/*\n\t * Lock not present yet - get a new dependency struct and\n\t * add it to the list:\n\t */\n\tentry = alloc_list_entry();\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->class = this;\n\tentry->links_to = links_to;\n\tentry->dep = dep;\n\tentry->distance = distance;\n\tentry->trace = trace;\n\t/*\n\t * Both allocation and removal are done under the graph lock; but\n\t * iteration is under RCU-sched; see look_up_lock_class() and\n\t * lockdep_free_key_range().\n\t */\n\tlist_add_tail_rcu(&entry->entry, head);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_depb",
          "args": [
            "prev",
            "next"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "calc_depb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1606-1609",
          "snippet": "static inline u8 calc_depb(struct held_lock *prev, struct held_lock *next)\n{\n\treturn 1U << __calc_dep_bitb(prev, next);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline u8 calc_depb(struct held_lock *prev, struct held_lock *next)\n{\n\treturn 1U << __calc_dep_bitb(prev, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "next"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_trace",
          "args": [],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "save_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "530-567",
          "snippet": "static struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))"
          ],
          "globals_used": [
            "unsigned long nr_stack_trace_entries;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))\n\nunsigned long nr_stack_trace_entries;\nstatic noinstr struct;\n\nstatic struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_error",
          "args": [
            "ret"
          ],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1555-1558",
          "snippet": "static inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_redundant",
          "args": [
            "prev",
            "next"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "check_redundant",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2886-2890",
          "snippet": "static inline enum bfs_result\ncheck_redundant(struct held_lock *src, struct held_lock *target)\n{\n\treturn BFS_RNOMATCH;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline enum bfs_result\ncheck_redundant(struct held_lock *src, struct held_lock *target)\n{\n\treturn BFS_RNOMATCH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&hlock_class(next)->locks_before",
            "entry"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&hlock_class(prev)->locks_after",
            "entry"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_usage",
          "args": [
            "curr",
            "prev",
            "next"
          ],
          "line": 3067
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_usage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2827-2831",
          "snippet": "static inline int check_irq_usage(struct task_struct *curr,\n\t\t\t\t  struct held_lock *prev, struct held_lock *next)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int check_irq_usage(struct task_struct *curr,\n\t\t\t\t  struct held_lock *prev, struct held_lock *next)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bfs_error(ret) || ret == BFS_RMATCH"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_noncircular",
          "args": [
            "next",
            "prev",
            "trace"
          ],
          "line": 3063
        },
        "resolved": true,
        "details": {
          "function_name": "check_noncircular",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2119-2147",
          "snippet": "bfs_result\ncheck_noncircular(struct held_lock *src, struct held_lock *target,\n\t\t  struct lock_trace **const trace)\n{\n\tenum bfs_result ret;\n\tstruct lock_list *target_entry;\n\tstruct lock_list src_entry;\n\n\tbfs_init_root(&src_entry, src);\n\n\tdebug_atomic_inc(nr_cyclic_checks);\n\n\tret = check_path(target, &src_entry, hlock_conflict, NULL, &target_entry);\n\n\tif (unlikely(ret == BFS_RMATCH)) {\n\t\tif (!*trace) {\n\t\t\t/*\n\t\t\t * If save_trace fails here, the printing might\n\t\t\t * trigger a WARN but because of the !nr_entries it\n\t\t\t * should not do bad things.\n\t\t\t */\n\t\t\t*trace = save_trace();\n\t\t}\n\n\t\tprint_circular_bug(&src_entry, target_entry, src, target);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nbfs_result\ncheck_noncircular(struct held_lock *src, struct held_lock *target,\n\t\t  struct lock_trace **const trace)\n{\n\tenum bfs_result ret;\n\tstruct lock_list *target_entry;\n\tstruct lock_list src_entry;\n\n\tbfs_init_root(&src_entry, src);\n\n\tdebug_atomic_inc(nr_cyclic_checks);\n\n\tret = check_path(target, &src_entry, hlock_conflict, NULL, &target_entry);\n\n\tif (unlikely(ret == BFS_RMATCH)) {\n\t\tif (!*trace) {\n\t\t\t/*\n\t\t\t * If save_trace fails here, the printing might\n\t\t\t * trigger a WARN but because of the !nr_entries it\n\t\t\t * should not do bad things.\n\t\t\t */\n\t\t\t*trace = save_trace();\n\t\t}\n\n\t\tprint_circular_bug(&src_entry, target_entry, src, target);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!debug_locks_silent && !hlock_class(next)->key",
            "\"Detected use-after-free of lock class %px/%s\\n\"",
            "hlock_class(next)",
            "hlock_class(next)->name"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!debug_locks_silent && !hlock_class(prev)->key",
            "\"Detected use-after-free of lock class %px/%s\\n\"",
            "hlock_class(prev)",
            "hlock_class(prev)->name"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define MAX_CIRCULAR_QUEUE_SIZE\t\t(1UL << CONFIG_LOCKDEP_CIRCULAR_QUEUE_BITS)\n\nstatic noinstr struct;\n\nstatic int\ncheck_prev_add(struct task_struct *curr, struct held_lock *prev,\n\t       struct held_lock *next, u16 distance,\n\t       struct lock_trace **const trace)\n{\n\tstruct lock_list *entry;\n\tenum bfs_result ret;\n\n\tif (!hlock_class(prev)->key || !hlock_class(next)->key) {\n\t\t/*\n\t\t * The warning statements below may trigger a use-after-free\n\t\t * of the class name. It is better to trigger a use-after free\n\t\t * and to have the class name most of the time instead of not\n\t\t * having the class name available.\n\t\t */\n\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(prev)->key,\n\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",\n\t\t\t  hlock_class(prev),\n\t\t\t  hlock_class(prev)->name);\n\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(next)->key,\n\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",\n\t\t\t  hlock_class(next),\n\t\t\t  hlock_class(next)->name);\n\t\treturn 2;\n\t}\n\n\t/*\n\t * Prove that the new <prev> -> <next> dependency would not\n\t * create a circular dependency in the graph. (We do this by\n\t * a breadth-first search into the graph starting at <next>,\n\t * and check whether we can reach <prev>.)\n\t *\n\t * The search is limited by the size of the circular queue (i.e.,\n\t * MAX_CIRCULAR_QUEUE_SIZE) which keeps track of a breadth of nodes\n\t * in the graph whose neighbours are to be checked.\n\t */\n\tret = check_noncircular(next, prev, trace);\n\tif (unlikely(bfs_error(ret) || ret == BFS_RMATCH))\n\t\treturn 0;\n\n\tif (!check_irq_usage(curr, prev, next))\n\t\treturn 0;\n\n\t/*\n\t * Is the <prev> -> <next> dependency already present?\n\t *\n\t * (this may occur even though this is a new chain: consider\n\t *  e.g. the L1 -> L2 -> L3 -> L4 and the L5 -> L1 -> L2 -> L3\n\t *  chains - the second one will be new, but L1 already has\n\t *  L2 added to its dependency list, due to the first chain.)\n\t */\n\tlist_for_each_entry(entry, &hlock_class(prev)->locks_after, entry) {\n\t\tif (entry->class == hlock_class(next)) {\n\t\t\tif (distance == 1)\n\t\t\t\tentry->distance = 1;\n\t\t\tentry->dep |= calc_dep(prev, next);\n\n\t\t\t/*\n\t\t\t * Also, update the reverse dependency in @next's\n\t\t\t * ->locks_before list.\n\t\t\t *\n\t\t\t *  Here we reuse @entry as the cursor, which is fine\n\t\t\t *  because we won't go to the next iteration of the\n\t\t\t *  outer loop:\n\t\t\t *\n\t\t\t *  For normal cases, we return in the inner loop.\n\t\t\t *\n\t\t\t *  If we fail to return, we have inconsistency, i.e.\n\t\t\t *  <prev>::locks_after contains <next> while\n\t\t\t *  <next>::locks_before doesn't contain <prev>. In\n\t\t\t *  that case, we return after the inner and indicate\n\t\t\t *  something is wrong.\n\t\t\t */\n\t\t\tlist_for_each_entry(entry, &hlock_class(next)->locks_before, entry) {\n\t\t\t\tif (entry->class == hlock_class(prev)) {\n\t\t\t\t\tif (distance == 1)\n\t\t\t\t\t\tentry->distance = 1;\n\t\t\t\t\tentry->dep |= calc_depb(prev, next);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* <prev> is not found in <next>::locks_before */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Is the <prev> -> <next> link redundant?\n\t */\n\tret = check_redundant(prev, next);\n\tif (bfs_error(ret))\n\t\treturn 0;\n\telse if (ret == BFS_RMATCH)\n\t\treturn 2;\n\n\tif (!*trace) {\n\t\t*trace = save_trace();\n\t\tif (!*trace)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Ok, all validations passed, add the new lock\n\t * to the previous lock's dependency list:\n\t */\n\tret = add_lock_to_list(hlock_class(next), hlock_class(prev),\n\t\t\t       &hlock_class(prev)->locks_after,\n\t\t\t       next->acquire_ip, distance,\n\t\t\t       calc_dep(prev, next),\n\t\t\t       *trace);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = add_lock_to_list(hlock_class(prev), hlock_class(next),\n\t\t\t       &hlock_class(next)->locks_before,\n\t\t\t       next->acquire_ip, distance,\n\t\t\t       calc_depb(prev, next),\n\t\t\t       *trace);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn 2;\n}"
  },
  {
    "function_name": "check_deadlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2969-3003",
    "snippet": "static int\ncheck_deadlock(struct task_struct *curr, struct held_lock *next)\n{\n\tstruct held_lock *prev;\n\tstruct held_lock *nest = NULL;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tprev = curr->held_locks + i;\n\n\t\tif (prev->instance == next->nest_lock)\n\t\t\tnest = prev;\n\n\t\tif (hlock_class(prev) != hlock_class(next))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Allow read-after-read recursion of the same\n\t\t * lock class (i.e. read_lock(lock)+read_lock(lock)):\n\t\t */\n\t\tif ((next->read == 2) && prev->read)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We're holding the nest_lock, which serializes this lock's\n\t\t * nesting behaviour.\n\t\t */\n\t\tif (nest)\n\t\t\treturn 2;\n\n\t\tprint_deadlock_bug(curr, prev, next);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_deadlock_bug",
          "args": [
            "curr",
            "prev",
            "next"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "print_deadlock_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2933-2957",
          "snippet": "static void\nprint_deadlock_bug(struct task_struct *curr, struct held_lock *prev,\n\t\t   struct held_lock *next)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: possible recursive locking detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(next);\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\tprint_lock(prev);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_deadlock_scenario(next, prev);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_deadlock_bug(struct task_struct *curr, struct held_lock *prev,\n\t\t   struct held_lock *next)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: possible recursive locking detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(next);\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\tprint_lock(prev);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_deadlock_scenario(next, prev);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "next"
          ],
          "line": 2982
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_deadlock(struct task_struct *curr, struct held_lock *next)\n{\n\tstruct held_lock *prev;\n\tstruct held_lock *nest = NULL;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tprev = curr->held_locks + i;\n\n\t\tif (prev->instance == next->nest_lock)\n\t\t\tnest = prev;\n\n\t\tif (hlock_class(prev) != hlock_class(next))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Allow read-after-read recursion of the same\n\t\t * lock class (i.e. read_lock(lock)+read_lock(lock)):\n\t\t */\n\t\tif ((next->read == 2) && prev->read)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We're holding the nest_lock, which serializes this lock's\n\t\t * nesting behaviour.\n\t\t */\n\t\tif (nest)\n\t\t\treturn 2;\n\n\t\tprint_deadlock_bug(curr, prev, next);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "print_deadlock_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2933-2957",
    "snippet": "static void\nprint_deadlock_bug(struct task_struct *curr, struct held_lock *prev,\n\t\t   struct held_lock *next)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: possible recursive locking detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(next);\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\tprint_lock(prev);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_deadlock_scenario(next, prev);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_deadlock_scenario",
          "args": [
            "next",
            "prev"
          ],
          "line": 2952
        },
        "resolved": true,
        "details": {
          "function_name": "print_deadlock_scenario",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2914-2931",
          "snippet": "static void\nprint_deadlock_scenario(struct held_lock *nxt, struct held_lock *prv)\n{\n\tstruct lock_class *next = hlock_class(nxt);\n\tstruct lock_class *prev = hlock_class(prv);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(prev);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(next);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n\tprintk(\" May be due to missing lock nesting notation\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_deadlock_scenario(struct held_lock *nxt, struct held_lock *prv)\n{\n\tstruct lock_class *next = hlock_class(nxt);\n\tstruct lock_class *prev = hlock_class(prv);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(prev);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(next);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n\tprintk(\" May be due to missing lock nesting notation\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "prev"
          ],
          "line": 2949
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "726-748",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nbut task is already holding lock:\\n\""
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is trying to acquire lock:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"--------------------------------------------\\n\""
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: possible recursive locking detected\\n\""
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"============================================\\n\""
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_deadlock_bug(struct task_struct *curr, struct held_lock *prev,\n\t\t   struct held_lock *next)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: possible recursive locking detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(next);\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\tprint_lock(prev);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_deadlock_scenario(next, prev);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "print_deadlock_scenario",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2914-2931",
    "snippet": "static void\nprint_deadlock_scenario(struct held_lock *nxt, struct held_lock *prv)\n{\n\tstruct lock_class *next = hlock_class(nxt);\n\tstruct lock_class *prev = hlock_class(prv);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(prev);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(next);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n\tprintk(\" May be due to missing lock nesting notation\\n\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" May be due to missing lock nesting notation\\n\\n\""
          ],
          "line": 2930
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__print_lock_name",
          "args": [
            "next"
          ],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "__print_lock_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "683-699",
          "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "prv"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_deadlock_scenario(struct held_lock *nxt, struct held_lock *prv)\n{\n\tstruct lock_class *next = hlock_class(nxt);\n\tstruct lock_class *prev = hlock_class(prv);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(prev);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(next);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n\tprintk(\" May be due to missing lock nesting notation\\n\\n\");\n}"
  },
  {
    "function_name": "dec_chains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2904-2912",
    "snippet": "static void dec_chains(int irq_context)\n{\n\tif (irq_context & LOCK_CHAIN_HARDIRQ_CONTEXT)\n\t\tnr_hardirq_chains--;\n\telse if (irq_context & LOCK_CHAIN_SOFTIRQ_CONTEXT)\n\t\tnr_softirq_chains--;\n\telse\n\t\tnr_process_chains--;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_hardirq_chains;",
      "unsigned int nr_softirq_chains;",
      "unsigned int nr_process_chains;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned int nr_hardirq_chains;\nunsigned int nr_softirq_chains;\nunsigned int nr_process_chains;\n\nstatic void dec_chains(int irq_context)\n{\n\tif (irq_context & LOCK_CHAIN_HARDIRQ_CONTEXT)\n\t\tnr_hardirq_chains--;\n\telse if (irq_context & LOCK_CHAIN_SOFTIRQ_CONTEXT)\n\t\tnr_softirq_chains--;\n\telse\n\t\tnr_process_chains--;\n}"
  },
  {
    "function_name": "inc_chains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2894-2902",
    "snippet": "static void inc_chains(int irq_context)\n{\n\tif (irq_context & LOCK_CHAIN_HARDIRQ_CONTEXT)\n\t\tnr_hardirq_chains++;\n\telse if (irq_context & LOCK_CHAIN_SOFTIRQ_CONTEXT)\n\t\tnr_softirq_chains++;\n\telse\n\t\tnr_process_chains++;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_hardirq_chains;",
      "unsigned int nr_softirq_chains;",
      "unsigned int nr_process_chains;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned int nr_hardirq_chains;\nunsigned int nr_softirq_chains;\nunsigned int nr_process_chains;\n\nstatic void inc_chains(int irq_context)\n{\n\tif (irq_context & LOCK_CHAIN_HARDIRQ_CONTEXT)\n\t\tnr_hardirq_chains++;\n\telse if (irq_context & LOCK_CHAIN_SOFTIRQ_CONTEXT)\n\t\tnr_softirq_chains++;\n\telse\n\t\tnr_process_chains++;\n}"
  },
  {
    "function_name": "check_redundant",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2886-2890",
    "snippet": "static inline enum bfs_result\ncheck_redundant(struct held_lock *src, struct held_lock *target)\n{\n\treturn BFS_RNOMATCH;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline enum bfs_result\ncheck_redundant(struct held_lock *src, struct held_lock *target)\n{\n\treturn BFS_RNOMATCH;\n}"
  },
  {
    "function_name": "check_redundant",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2849-2882",
    "snippet": "bfs_result\ncheck_redundant(struct held_lock *src, struct held_lock *target)\n{\n\tenum bfs_result ret;\n\tstruct lock_list *target_entry;\n\tstruct lock_list src_entry;\n\n\tbfs_init_root(&src_entry, src);\n\t/*\n\t * Special setup for check_redundant().\n\t *\n\t * To report redundant, we need to find a strong dependency path that\n\t * is equal to or stronger than <src> -> <target>. So if <src> is E,\n\t * we need to let __bfs() only search for a path starting at a -(E*)->,\n\t * we achieve this by setting the initial node's ->only_xr to true in\n\t * that case. And if <prev> is S, we set initial ->only_xr to false\n\t * because both -(S*)-> (equal) and -(E*)-> (stronger) are redundant.\n\t */\n\tsrc_entry.only_xr = src->read == 0;\n\n\tdebug_atomic_inc(nr_redundant_checks);\n\n\t/*\n\t * Note: we skip local_lock() for redundant check, because as the\n\t * comment in usage_skip(), A -> local_lock() -> B and A -> B are not\n\t * the same.\n\t */\n\tret = check_path(target, &src_entry, hlock_equal, usage_skip, &target_entry);\n\n\tif (ret == BFS_RMATCH)\n\t\tdebug_atomic_inc(nr_redundant);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_redundant"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_path",
          "args": [
            "target",
            "&src_entry",
            "hlock_equal",
            "usage_skip",
            "&target_entry"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "check_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2096-2110",
          "snippet": "bfs_result\ncheck_path(struct held_lock *target, struct lock_list *src_entry,\n\t   bool (*match)(struct lock_list *entry, void *data),\n\t   bool (*skip)(struct lock_list *entry, void *data),\n\t   struct lock_list **target_entry)\n{\n\tenum bfs_result ret;\n\n\tret = __bfs_forwards(src_entry, target, match, skip, target_entry);\n\n\tif (unlikely(bfs_error(ret)))\n\t\tprint_bfs_bug(ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nbfs_result\ncheck_path(struct held_lock *target, struct lock_list *src_entry,\n\t   bool (*match)(struct lock_list *entry, void *data),\n\t   bool (*skip)(struct lock_list *entry, void *data),\n\t   struct lock_list **target_entry)\n{\n\tenum bfs_result ret;\n\n\tret = __bfs_forwards(src_entry, target, match, skip, target_entry);\n\n\tif (unlikely(bfs_error(ret)))\n\t\tprint_bfs_bug(ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_redundant_checks"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bfs_init_root",
          "args": [
            "&src_entry",
            "src"
          ],
          "line": 2856
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_init_rootb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1645-1650",
          "snippet": "static inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nbfs_result\ncheck_redundant(struct held_lock *src, struct held_lock *target)\n{\n\tenum bfs_result ret;\n\tstruct lock_list *target_entry;\n\tstruct lock_list src_entry;\n\n\tbfs_init_root(&src_entry, src);\n\t/*\n\t * Special setup for check_redundant().\n\t *\n\t * To report redundant, we need to find a strong dependency path that\n\t * is equal to or stronger than <src> -> <target>. So if <src> is E,\n\t * we need to let __bfs() only search for a path starting at a -(E*)->,\n\t * we achieve this by setting the initial node's ->only_xr to true in\n\t * that case. And if <prev> is S, we set initial ->only_xr to false\n\t * because both -(S*)-> (equal) and -(E*)-> (stronger) are redundant.\n\t */\n\tsrc_entry.only_xr = src->read == 0;\n\n\tdebug_atomic_inc(nr_redundant_checks);\n\n\t/*\n\t * Note: we skip local_lock() for redundant check, because as the\n\t * comment in usage_skip(), A -> local_lock() -> B and A -> B are not\n\t * the same.\n\t */\n\tret = check_path(target, &src_entry, hlock_equal, usage_skip, &target_entry);\n\n\tif (ret == BFS_RMATCH)\n\t\tdebug_atomic_inc(nr_redundant);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "usage_skip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2833-2836",
    "snippet": "static inline bool usage_skip(struct lock_list *entry, void *mask)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline bool usage_skip(struct lock_list *entry, void *mask)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "check_irq_usage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2827-2831",
    "snippet": "static inline int check_irq_usage(struct task_struct *curr,\n\t\t\t\t  struct held_lock *prev, struct held_lock *next)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int check_irq_usage(struct task_struct *curr,\n\t\t\t\t  struct held_lock *prev, struct held_lock *next)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "check_irq_usage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2739-2823",
    "snippet": "static int check_irq_usage(struct task_struct *curr, struct held_lock *prev,\n\t\t\t   struct held_lock *next)\n{\n\tunsigned long usage_mask = 0, forward_mask, backward_mask;\n\tenum lock_usage_bit forward_bit = 0, backward_bit = 0;\n\tstruct lock_list *target_entry1;\n\tstruct lock_list *target_entry;\n\tstruct lock_list this, that;\n\tenum bfs_result ret;\n\n\t/*\n\t * Step 1: gather all hard/soft IRQs usages backward in an\n\t * accumulated usage mask.\n\t */\n\tbfs_init_rootb(&this, prev);\n\n\tret = __bfs_backwards(&this, &usage_mask, usage_accumulate, usage_skip, NULL);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\n\tusage_mask &= LOCKF_USED_IN_IRQ_ALL;\n\tif (!usage_mask)\n\t\treturn 1;\n\n\t/*\n\t * Step 2: find exclusive uses forward that match the previous\n\t * backward accumulated mask.\n\t */\n\tforward_mask = exclusive_mask(usage_mask);\n\n\tbfs_init_root(&that, next);\n\n\tret = find_usage_forwards(&that, forward_mask, &target_entry1);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (ret == BFS_RNOMATCH)\n\t\treturn 1;\n\n\t/*\n\t * Step 3: we found a bad match! Now retrieve a lock from the backward\n\t * list whose usage mask matches the exclusive usage mask from the\n\t * lock found on the forward list.\n\t *\n\t * Note, we should only keep the LOCKF_ENABLED_IRQ_ALL bits, considering\n\t * the follow case:\n\t *\n\t * When trying to add A -> B to the graph, we find that there is a\n\t * hardirq-safe L, that L -> ... -> A, and another hardirq-unsafe M,\n\t * that B -> ... -> M. However M is **softirq-safe**, if we use exact\n\t * invert bits of M's usage_mask, we will find another lock N that is\n\t * **softirq-unsafe** and N -> ... -> A, however N -> .. -> M will not\n\t * cause a inversion deadlock.\n\t */\n\tbackward_mask = original_mask(target_entry1->class->usage_mask & LOCKF_ENABLED_IRQ_ALL);\n\n\tret = find_usage_backwards(&this, backward_mask, &target_entry);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (DEBUG_LOCKS_WARN_ON(ret == BFS_RNOMATCH))\n\t\treturn 1;\n\n\t/*\n\t * Step 4: narrow down to a pair of incompatible usage bits\n\t * and report it.\n\t */\n\tret = find_exclusive_match(target_entry->class->usage_mask,\n\t\t\t\t   target_entry1->class->usage_mask,\n\t\t\t\t   &backward_bit, &forward_bit);\n\tif (DEBUG_LOCKS_WARN_ON(ret == -1))\n\t\treturn 1;\n\n\tprint_bad_irq_dependency(curr, &this, &that,\n\t\t\t\t target_entry, target_entry1,\n\t\t\t\t prev, next,\n\t\t\t\t backward_bit, forward_bit,\n\t\t\t\t state_name(backward_bit));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_bad_irq_dependency",
          "args": [
            "curr",
            "&this",
            "&that",
            "target_entry",
            "target_entry1",
            "prev",
            "next",
            "backward_bit",
            "forward_bit",
            "state_name(backward_bit)"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "print_bad_irq_dependency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2509-2578",
          "snippet": "static void\nprint_bad_irq_dependency(struct task_struct *curr,\n\t\t\t struct lock_list *prev_root,\n\t\t\t struct lock_list *next_root,\n\t\t\t struct lock_list *backwards_entry,\n\t\t\t struct lock_list *forwards_entry,\n\t\t\t struct held_lock *prev,\n\t\t\t struct held_lock *next,\n\t\t\t enum lock_usage_bit bit1,\n\t\t\t enum lock_usage_bit bit2,\n\t\t\t const char *irqclass)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================================\\n\");\n\tpr_warn(\"WARNING: %s-safe -> %s-unsafe lock order detected\\n\",\n\t\tirqclass, irqclass);\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tlockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,\n\t\tcurr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,\n\t\tlockdep_hardirqs_enabled(),\n\t\tcurr->softirqs_enabled);\n\tprint_lock(next);\n\n\tpr_warn(\"\\nand this task is already holding:\\n\");\n\tprint_lock(prev);\n\tpr_warn(\"which would create a new lock dependency:\\n\");\n\tprint_lock_name(hlock_class(prev));\n\tpr_cont(\" ->\");\n\tprint_lock_name(hlock_class(next));\n\tpr_cont(\"\\n\");\n\n\tpr_warn(\"\\nbut this new dependency connects a %s-irq-safe lock:\\n\",\n\t\tirqclass);\n\tprint_lock_name(backwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-safe at:\\n\", irqclass);\n\n\tprint_lock_trace(backwards_entry->class->usage_traces[bit1], 1);\n\n\tpr_warn(\"\\nto a %s-irq-unsafe lock:\\n\", irqclass);\n\tprint_lock_name(forwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-unsafe at:\\n\", irqclass);\n\tpr_warn(\"...\");\n\n\tprint_lock_trace(forwards_entry->class->usage_traces[bit2], 1);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_irq_lock_scenario(backwards_entry, forwards_entry,\n\t\t\t\thlock_class(prev), hlock_class(next));\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe dependencies between %s-irq-safe lock and the holding lock:\\n\", irqclass);\n\tprint_shortest_lock_dependencies_backwards(backwards_entry, prev_root);\n\n\tpr_warn(\"\\nthe dependencies between the lock to be acquired\");\n\tpr_warn(\" and %s-irq-unsafe lock:\\n\", irqclass);\n\tnext_root->trace = save_trace();\n\tif (!next_root->trace)\n\t\treturn;\n\tprint_shortest_lock_dependencies(forwards_entry, next_root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_bad_irq_dependency(struct task_struct *curr,\n\t\t\t struct lock_list *prev_root,\n\t\t\t struct lock_list *next_root,\n\t\t\t struct lock_list *backwards_entry,\n\t\t\t struct lock_list *forwards_entry,\n\t\t\t struct held_lock *prev,\n\t\t\t struct held_lock *next,\n\t\t\t enum lock_usage_bit bit1,\n\t\t\t enum lock_usage_bit bit2,\n\t\t\t const char *irqclass)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================================\\n\");\n\tpr_warn(\"WARNING: %s-safe -> %s-unsafe lock order detected\\n\",\n\t\tirqclass, irqclass);\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tlockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,\n\t\tcurr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,\n\t\tlockdep_hardirqs_enabled(),\n\t\tcurr->softirqs_enabled);\n\tprint_lock(next);\n\n\tpr_warn(\"\\nand this task is already holding:\\n\");\n\tprint_lock(prev);\n\tpr_warn(\"which would create a new lock dependency:\\n\");\n\tprint_lock_name(hlock_class(prev));\n\tpr_cont(\" ->\");\n\tprint_lock_name(hlock_class(next));\n\tpr_cont(\"\\n\");\n\n\tpr_warn(\"\\nbut this new dependency connects a %s-irq-safe lock:\\n\",\n\t\tirqclass);\n\tprint_lock_name(backwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-safe at:\\n\", irqclass);\n\n\tprint_lock_trace(backwards_entry->class->usage_traces[bit1], 1);\n\n\tpr_warn(\"\\nto a %s-irq-unsafe lock:\\n\", irqclass);\n\tprint_lock_name(forwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-unsafe at:\\n\", irqclass);\n\tpr_warn(\"...\");\n\n\tprint_lock_trace(forwards_entry->class->usage_traces[bit2], 1);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_irq_lock_scenario(backwards_entry, forwards_entry,\n\t\t\t\thlock_class(prev), hlock_class(next));\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe dependencies between %s-irq-safe lock and the holding lock:\\n\", irqclass);\n\tprint_shortest_lock_dependencies_backwards(backwards_entry, prev_root);\n\n\tpr_warn(\"\\nthe dependencies between the lock to be acquired\");\n\tpr_warn(\" and %s-irq-unsafe lock:\\n\", irqclass);\n\tnext_root->trace = save_trace();\n\tif (!next_root->trace)\n\t\treturn;\n\tprint_shortest_lock_dependencies(forwards_entry, next_root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "state_name",
          "args": [
            "backward_bit"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "state_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2594-2600",
          "snippet": "static inline const char *state_name(enum lock_usage_bit bit)\n{\n\tif (bit & LOCK_USAGE_READ_MASK)\n\t\treturn state_rnames[bit >> LOCK_USAGE_DIR_MASK];\n\telse\n\t\treturn state_names[bit >> LOCK_USAGE_DIR_MASK];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline const char *state_name(enum lock_usage_bit bit)\n{\n\tif (bit & LOCK_USAGE_READ_MASK)\n\t\treturn state_rnames[bit >> LOCK_USAGE_DIR_MASK];\n\telse\n\t\treturn state_names[bit >> LOCK_USAGE_DIR_MASK];\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "ret == -1"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_exclusive_match",
          "args": [
            "target_entry->class->usage_mask",
            "target_entry1->class->usage_mask",
            "&backward_bit",
            "&forward_bit"
          ],
          "line": 2810
        },
        "resolved": true,
        "details": {
          "function_name": "find_exclusive_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2705-2731",
          "snippet": "static int find_exclusive_match(unsigned long mask,\n\t\t\t\tunsigned long excl_mask,\n\t\t\t\tenum lock_usage_bit *bitp,\n\t\t\t\tenum lock_usage_bit *excl_bitp)\n{\n\tint bit, excl, excl_read;\n\n\tfor_each_set_bit(bit, &mask, LOCK_USED) {\n\t\t/*\n\t\t * exclusive_bit() strips the read bit, however,\n\t\t * LOCK_ENABLED_IRQ_*_READ may cause deadlocks too, so we need\n\t\t * to search excl | LOCK_USAGE_READ_MASK as well.\n\t\t */\n\t\texcl = exclusive_bit(bit);\n\t\texcl_read = excl | LOCK_USAGE_READ_MASK;\n\t\tif (excl_mask & lock_flag(excl)) {\n\t\t\t*bitp = bit;\n\t\t\t*excl_bitp = excl;\n\t\t\treturn 0;\n\t\t} else if (excl_mask & lock_flag(excl_read)) {\n\t\t\t*bitp = bit;\n\t\t\t*excl_bitp = excl_read;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int find_exclusive_match(unsigned long mask,\n\t\t\t\tunsigned long excl_mask,\n\t\t\t\tenum lock_usage_bit *bitp,\n\t\t\t\tenum lock_usage_bit *excl_bitp)\n{\n\tint bit, excl, excl_read;\n\n\tfor_each_set_bit(bit, &mask, LOCK_USED) {\n\t\t/*\n\t\t * exclusive_bit() strips the read bit, however,\n\t\t * LOCK_ENABLED_IRQ_*_READ may cause deadlocks too, so we need\n\t\t * to search excl | LOCK_USAGE_READ_MASK as well.\n\t\t */\n\t\texcl = exclusive_bit(bit);\n\t\texcl_read = excl | LOCK_USAGE_READ_MASK;\n\t\tif (excl_mask & lock_flag(excl)) {\n\t\t\t*bitp = bit;\n\t\t\t*excl_bitp = excl;\n\t\t\treturn 0;\n\t\t} else if (excl_mask & lock_flag(excl_read)) {\n\t\t\t*bitp = bit;\n\t\t\t*excl_bitp = excl_read;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "ret == BFS_RNOMATCH"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_bfs_bug",
          "args": [
            "ret"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "print_bfs_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2024-2033",
          "snippet": "static noinline void print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline void print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_error",
          "args": [
            "ret"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1555-1558",
          "snippet": "static inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_usage_backwards",
          "args": [
            "&this",
            "backward_mask",
            "&target_entry"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "find_usage_backwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2281-2292",
          "snippet": "static enum bfs_result\nfind_usage_backwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic enum bfs_result\nfind_usage_backwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "original_mask",
          "args": [
            "target_entry1->class->usage_mask & LOCKF_ENABLED_IRQ_ALL"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "original_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2690-2699",
          "snippet": "static unsigned long original_mask(unsigned long mask)\n{\n\tunsigned long excl = invert_dir_mask(mask);\n\n\t/* Include read in existing usages */\n\texcl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;\n\texcl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;\n\n\treturn excl;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic unsigned long original_mask(unsigned long mask)\n{\n\tunsigned long excl = invert_dir_mask(mask);\n\n\t/* Include read in existing usages */\n\texcl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;\n\texcl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;\n\n\treturn excl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_usage_forwards",
          "args": [
            "&that",
            "forward_mask",
            "&target_entry1"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "find_usage_forwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2264-2275",
          "snippet": "static enum bfs_result\nfind_usage_forwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic enum bfs_result\nfind_usage_forwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_init_root",
          "args": [
            "&that",
            "next"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_init_rootb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1645-1650",
          "snippet": "static inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exclusive_mask",
          "args": [
            "usage_mask"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "exclusive_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2673-2681",
          "snippet": "static unsigned long exclusive_mask(unsigned long mask)\n{\n\tunsigned long excl = invert_dir_mask(mask);\n\n\texcl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;\n\texcl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;\n\n\treturn excl;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long exclusive_mask(unsigned long mask)\n{\n\tunsigned long excl = invert_dir_mask(mask);\n\n\texcl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;\n\texcl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;\n\n\treturn excl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bfs_backwards",
          "args": [
            "&this",
            "&usage_mask",
            "usage_accumulate",
            "usage_skip",
            "NULL"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_backwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1808-1818",
          "snippet": "static inline enum bfs_result\n__bfs_backwards(struct lock_list *src_entry,\n\t\tvoid *data,\n\t\tbool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_before));\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline enum bfs_result\n__bfs_backwards(struct lock_list *src_entry,\n\t\tvoid *data,\n\t\tbool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_before));\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int check_irq_usage(struct task_struct *curr, struct held_lock *prev,\n\t\t\t   struct held_lock *next)\n{\n\tunsigned long usage_mask = 0, forward_mask, backward_mask;\n\tenum lock_usage_bit forward_bit = 0, backward_bit = 0;\n\tstruct lock_list *target_entry1;\n\tstruct lock_list *target_entry;\n\tstruct lock_list this, that;\n\tenum bfs_result ret;\n\n\t/*\n\t * Step 1: gather all hard/soft IRQs usages backward in an\n\t * accumulated usage mask.\n\t */\n\tbfs_init_rootb(&this, prev);\n\n\tret = __bfs_backwards(&this, &usage_mask, usage_accumulate, usage_skip, NULL);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\n\tusage_mask &= LOCKF_USED_IN_IRQ_ALL;\n\tif (!usage_mask)\n\t\treturn 1;\n\n\t/*\n\t * Step 2: find exclusive uses forward that match the previous\n\t * backward accumulated mask.\n\t */\n\tforward_mask = exclusive_mask(usage_mask);\n\n\tbfs_init_root(&that, next);\n\n\tret = find_usage_forwards(&that, forward_mask, &target_entry1);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (ret == BFS_RNOMATCH)\n\t\treturn 1;\n\n\t/*\n\t * Step 3: we found a bad match! Now retrieve a lock from the backward\n\t * list whose usage mask matches the exclusive usage mask from the\n\t * lock found on the forward list.\n\t *\n\t * Note, we should only keep the LOCKF_ENABLED_IRQ_ALL bits, considering\n\t * the follow case:\n\t *\n\t * When trying to add A -> B to the graph, we find that there is a\n\t * hardirq-safe L, that L -> ... -> A, and another hardirq-unsafe M,\n\t * that B -> ... -> M. However M is **softirq-safe**, if we use exact\n\t * invert bits of M's usage_mask, we will find another lock N that is\n\t * **softirq-unsafe** and N -> ... -> A, however N -> .. -> M will not\n\t * cause a inversion deadlock.\n\t */\n\tbackward_mask = original_mask(target_entry1->class->usage_mask & LOCKF_ENABLED_IRQ_ALL);\n\n\tret = find_usage_backwards(&this, backward_mask, &target_entry);\n\tif (bfs_error(ret)) {\n\t\tprint_bfs_bug(ret);\n\t\treturn 0;\n\t}\n\tif (DEBUG_LOCKS_WARN_ON(ret == BFS_RNOMATCH))\n\t\treturn 1;\n\n\t/*\n\t * Step 4: narrow down to a pair of incompatible usage bits\n\t * and report it.\n\t */\n\tret = find_exclusive_match(target_entry->class->usage_mask,\n\t\t\t\t   target_entry1->class->usage_mask,\n\t\t\t\t   &backward_bit, &forward_bit);\n\tif (DEBUG_LOCKS_WARN_ON(ret == -1))\n\t\treturn 1;\n\n\tprint_bad_irq_dependency(curr, &this, &that,\n\t\t\t\t target_entry, target_entry1,\n\t\t\t\t prev, next,\n\t\t\t\t backward_bit, forward_bit,\n\t\t\t\t state_name(backward_bit));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_exclusive_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2705-2731",
    "snippet": "static int find_exclusive_match(unsigned long mask,\n\t\t\t\tunsigned long excl_mask,\n\t\t\t\tenum lock_usage_bit *bitp,\n\t\t\t\tenum lock_usage_bit *excl_bitp)\n{\n\tint bit, excl, excl_read;\n\n\tfor_each_set_bit(bit, &mask, LOCK_USED) {\n\t\t/*\n\t\t * exclusive_bit() strips the read bit, however,\n\t\t * LOCK_ENABLED_IRQ_*_READ may cause deadlocks too, so we need\n\t\t * to search excl | LOCK_USAGE_READ_MASK as well.\n\t\t */\n\t\texcl = exclusive_bit(bit);\n\t\texcl_read = excl | LOCK_USAGE_READ_MASK;\n\t\tif (excl_mask & lock_flag(excl)) {\n\t\t\t*bitp = bit;\n\t\t\t*excl_bitp = excl;\n\t\t\treturn 0;\n\t\t} else if (excl_mask & lock_flag(excl_read)) {\n\t\t\t*bitp = bit;\n\t\t\t*excl_bitp = excl_read;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_flag",
          "args": [
            "excl_read"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "lock_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "639-642",
          "snippet": "static inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exclusive_bit",
          "args": [
            "bit"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "exclusive_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2609-2618",
          "snippet": "static int exclusive_bit(int new_bit)\n{\n\tint state = new_bit & LOCK_USAGE_STATE_MASK;\n\tint dir = new_bit & LOCK_USAGE_DIR_MASK;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ LOCK_USAGE_DIR_MASK);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int exclusive_bit(int new_bit)\n{\n\tint state = new_bit & LOCK_USAGE_STATE_MASK;\n\tint dir = new_bit & LOCK_USAGE_DIR_MASK;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ LOCK_USAGE_DIR_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "bit",
            "&mask",
            "LOCK_USED"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int find_exclusive_match(unsigned long mask,\n\t\t\t\tunsigned long excl_mask,\n\t\t\t\tenum lock_usage_bit *bitp,\n\t\t\t\tenum lock_usage_bit *excl_bitp)\n{\n\tint bit, excl, excl_read;\n\n\tfor_each_set_bit(bit, &mask, LOCK_USED) {\n\t\t/*\n\t\t * exclusive_bit() strips the read bit, however,\n\t\t * LOCK_ENABLED_IRQ_*_READ may cause deadlocks too, so we need\n\t\t * to search excl | LOCK_USAGE_READ_MASK as well.\n\t\t */\n\t\texcl = exclusive_bit(bit);\n\t\texcl_read = excl | LOCK_USAGE_READ_MASK;\n\t\tif (excl_mask & lock_flag(excl)) {\n\t\t\t*bitp = bit;\n\t\t\t*excl_bitp = excl;\n\t\t\treturn 0;\n\t\t} else if (excl_mask & lock_flag(excl_read)) {\n\t\t\t*bitp = bit;\n\t\t\t*excl_bitp = excl_read;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "original_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2690-2699",
    "snippet": "static unsigned long original_mask(unsigned long mask)\n{\n\tunsigned long excl = invert_dir_mask(mask);\n\n\t/* Include read in existing usages */\n\texcl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;\n\texcl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;\n\n\treturn excl;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "invert_dir_mask",
          "args": [
            "mask"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "invert_dir_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2634-2643",
          "snippet": "static unsigned long invert_dir_mask(unsigned long mask)\n{\n\tunsigned long excl = 0;\n\n\t/* Invert dir */\n\texcl |= (mask & LOCKF_ENABLED_IRQ_ALL) >> LOCK_USAGE_DIR_MASK;\n\texcl |= (mask & LOCKF_USED_IN_IRQ_ALL) << LOCK_USAGE_DIR_MASK;\n\n\treturn excl;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long invert_dir_mask(unsigned long mask)\n{\n\tunsigned long excl = 0;\n\n\t/* Invert dir */\n\texcl |= (mask & LOCKF_ENABLED_IRQ_ALL) >> LOCK_USAGE_DIR_MASK;\n\texcl |= (mask & LOCKF_USED_IN_IRQ_ALL) << LOCK_USAGE_DIR_MASK;\n\n\treturn excl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic unsigned long original_mask(unsigned long mask)\n{\n\tunsigned long excl = invert_dir_mask(mask);\n\n\t/* Include read in existing usages */\n\texcl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;\n\texcl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;\n\n\treturn excl;\n}"
  },
  {
    "function_name": "exclusive_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2673-2681",
    "snippet": "static unsigned long exclusive_mask(unsigned long mask)\n{\n\tunsigned long excl = invert_dir_mask(mask);\n\n\texcl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;\n\texcl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;\n\n\treturn excl;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invert_dir_mask",
          "args": [
            "mask"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "invert_dir_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2634-2643",
          "snippet": "static unsigned long invert_dir_mask(unsigned long mask)\n{\n\tunsigned long excl = 0;\n\n\t/* Invert dir */\n\texcl |= (mask & LOCKF_ENABLED_IRQ_ALL) >> LOCK_USAGE_DIR_MASK;\n\texcl |= (mask & LOCKF_USED_IN_IRQ_ALL) << LOCK_USAGE_DIR_MASK;\n\n\treturn excl;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long invert_dir_mask(unsigned long mask)\n{\n\tunsigned long excl = 0;\n\n\t/* Invert dir */\n\texcl |= (mask & LOCKF_ENABLED_IRQ_ALL) >> LOCK_USAGE_DIR_MASK;\n\texcl |= (mask & LOCKF_USED_IN_IRQ_ALL) << LOCK_USAGE_DIR_MASK;\n\n\treturn excl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long exclusive_mask(unsigned long mask)\n{\n\tunsigned long excl = invert_dir_mask(mask);\n\n\texcl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;\n\texcl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;\n\n\treturn excl;\n}"
  },
  {
    "function_name": "invert_dir_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2634-2643",
    "snippet": "static unsigned long invert_dir_mask(unsigned long mask)\n{\n\tunsigned long excl = 0;\n\n\t/* Invert dir */\n\texcl |= (mask & LOCKF_ENABLED_IRQ_ALL) >> LOCK_USAGE_DIR_MASK;\n\texcl |= (mask & LOCKF_USED_IN_IRQ_ALL) << LOCK_USAGE_DIR_MASK;\n\n\treturn excl;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long invert_dir_mask(unsigned long mask)\n{\n\tunsigned long excl = 0;\n\n\t/* Invert dir */\n\texcl |= (mask & LOCKF_ENABLED_IRQ_ALL) >> LOCK_USAGE_DIR_MASK;\n\texcl |= (mask & LOCKF_USED_IN_IRQ_ALL) << LOCK_USAGE_DIR_MASK;\n\n\treturn excl;\n}"
  },
  {
    "function_name": "exclusive_bit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2609-2618",
    "snippet": "static int exclusive_bit(int new_bit)\n{\n\tint state = new_bit & LOCK_USAGE_STATE_MASK;\n\tint dir = new_bit & LOCK_USAGE_DIR_MASK;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ LOCK_USAGE_DIR_MASK);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int exclusive_bit(int new_bit)\n{\n\tint state = new_bit & LOCK_USAGE_STATE_MASK;\n\tint dir = new_bit & LOCK_USAGE_DIR_MASK;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ LOCK_USAGE_DIR_MASK);\n}"
  },
  {
    "function_name": "state_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2594-2600",
    "snippet": "static inline const char *state_name(enum lock_usage_bit bit)\n{\n\tif (bit & LOCK_USAGE_READ_MASK)\n\t\treturn state_rnames[bit >> LOCK_USAGE_DIR_MASK];\n\telse\n\t\treturn state_names[bit >> LOCK_USAGE_DIR_MASK];\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline const char *state_name(enum lock_usage_bit bit)\n{\n\tif (bit & LOCK_USAGE_READ_MASK)\n\t\treturn state_rnames[bit >> LOCK_USAGE_DIR_MASK];\n\telse\n\t\treturn state_names[bit >> LOCK_USAGE_DIR_MASK];\n}"
  },
  {
    "function_name": "print_bad_irq_dependency",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2509-2578",
    "snippet": "static void\nprint_bad_irq_dependency(struct task_struct *curr,\n\t\t\t struct lock_list *prev_root,\n\t\t\t struct lock_list *next_root,\n\t\t\t struct lock_list *backwards_entry,\n\t\t\t struct lock_list *forwards_entry,\n\t\t\t struct held_lock *prev,\n\t\t\t struct held_lock *next,\n\t\t\t enum lock_usage_bit bit1,\n\t\t\t enum lock_usage_bit bit2,\n\t\t\t const char *irqclass)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================================\\n\");\n\tpr_warn(\"WARNING: %s-safe -> %s-unsafe lock order detected\\n\",\n\t\tirqclass, irqclass);\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tlockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,\n\t\tcurr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,\n\t\tlockdep_hardirqs_enabled(),\n\t\tcurr->softirqs_enabled);\n\tprint_lock(next);\n\n\tpr_warn(\"\\nand this task is already holding:\\n\");\n\tprint_lock(prev);\n\tpr_warn(\"which would create a new lock dependency:\\n\");\n\tprint_lock_name(hlock_class(prev));\n\tpr_cont(\" ->\");\n\tprint_lock_name(hlock_class(next));\n\tpr_cont(\"\\n\");\n\n\tpr_warn(\"\\nbut this new dependency connects a %s-irq-safe lock:\\n\",\n\t\tirqclass);\n\tprint_lock_name(backwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-safe at:\\n\", irqclass);\n\n\tprint_lock_trace(backwards_entry->class->usage_traces[bit1], 1);\n\n\tpr_warn(\"\\nto a %s-irq-unsafe lock:\\n\", irqclass);\n\tprint_lock_name(forwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-unsafe at:\\n\", irqclass);\n\tpr_warn(\"...\");\n\n\tprint_lock_trace(forwards_entry->class->usage_traces[bit2], 1);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_irq_lock_scenario(backwards_entry, forwards_entry,\n\t\t\t\thlock_class(prev), hlock_class(next));\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe dependencies between %s-irq-safe lock and the holding lock:\\n\", irqclass);\n\tprint_shortest_lock_dependencies_backwards(backwards_entry, prev_root);\n\n\tpr_warn(\"\\nthe dependencies between the lock to be acquired\");\n\tpr_warn(\" and %s-irq-unsafe lock:\\n\", irqclass);\n\tnext_root->trace = save_trace();\n\tif (!next_root->trace)\n\t\treturn;\n\tprint_shortest_lock_dependencies(forwards_entry, next_root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_shortest_lock_dependencies",
          "args": [
            "forwards_entry",
            "next_root"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "print_shortest_lock_dependencies_backwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2418-2451",
          "snippet": "static void __used\nprint_shortest_lock_dependencies_backwards(struct lock_list *leaf,\n\t\t\t\t\t   struct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tconst struct lock_trace *trace = NULL;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tif (trace) {\n\t\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\t\tprint_lock_trace(trace, 2);\n\t\t\tprintk(\"\\n\");\n\t\t}\n\n\t\t/*\n\t\t * Record the pointer to the trace for the next lock_list\n\t\t * entry, see the comments for the function.\n\t\t */\n\t\ttrace = entry->trace;\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __used\nprint_shortest_lock_dependencies_backwards(struct lock_list *leaf,\n\t\t\t\t\t   struct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tconst struct lock_trace *trace = NULL;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tif (trace) {\n\t\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\t\tprint_lock_trace(trace, 2);\n\t\t\tprintk(\"\\n\");\n\t\t}\n\n\t\t/*\n\t\t * Record the pointer to the trace for the next lock_list\n\t\t * entry, see the comments for the function.\n\t\t */\n\t\ttrace = entry->trace;\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_trace",
          "args": [],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "save_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "530-567",
          "snippet": "static struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))"
          ],
          "globals_used": [
            "unsigned long nr_stack_trace_entries;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))\n\nunsigned long nr_stack_trace_entries;\nstatic noinstr struct;\n\nstatic struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\" and %s-irq-unsafe lock:\\n\"",
            "irqclass"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nthe dependencies between the lock to be acquired\""
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nthe dependencies between %s-irq-safe lock and the holding lock:\\n\"",
            "irqclass"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 2564
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_irq_lock_scenario",
          "args": [
            "backwards_entry",
            "forwards_entry",
            "hlock_class(prev)",
            "hlock_class(next)"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "print_irq_lock_scenario",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2453-2507",
          "snippet": "static void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "next"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\\n\""
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock_trace",
          "args": [
            "forwards_entry->class->usage_traces[bit2]",
            "1"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1820-1824",
          "snippet": "static void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"...\""
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n... which became %s-irq-unsafe at:\\n\"",
            "irqclass"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "forwards_entry->class"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "701-712",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nto a %s-irq-unsafe lock:\\n\"",
            "irqclass"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n... which became %s-irq-safe at:\\n\"",
            "irqclass"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nbut this new dependency connects a %s-irq-safe lock:\\n\"",
            "irqclass"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"which would create a new lock dependency:\\n\""
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "prev"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "726-748",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nand this task is already holding:\\n\""
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)",
            "lockdep_hardirq_context()",
            "hardirq_count() >> HARDIRQ_SHIFT",
            "curr->softirq_context",
            "softirq_count() >> SOFTIRQ_SHIFT",
            "lockdep_hardirqs_enabled()",
            "curr->softirqs_enabled"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_enabled",
          "args": [],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hardirq_count",
          "args": [],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirq_context",
          "args": [],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"-----------------------------------------------------\\n\""
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: %s-safe -> %s-unsafe lock order detected\\n\"",
            "irqclass",
            "irqclass"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=====================================================\\n\""
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_bad_irq_dependency(struct task_struct *curr,\n\t\t\t struct lock_list *prev_root,\n\t\t\t struct lock_list *next_root,\n\t\t\t struct lock_list *backwards_entry,\n\t\t\t struct lock_list *forwards_entry,\n\t\t\t struct held_lock *prev,\n\t\t\t struct held_lock *next,\n\t\t\t enum lock_usage_bit bit1,\n\t\t\t enum lock_usage_bit bit2,\n\t\t\t const char *irqclass)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================================\\n\");\n\tpr_warn(\"WARNING: %s-safe -> %s-unsafe lock order detected\\n\",\n\t\tirqclass, irqclass);\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tlockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,\n\t\tcurr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,\n\t\tlockdep_hardirqs_enabled(),\n\t\tcurr->softirqs_enabled);\n\tprint_lock(next);\n\n\tpr_warn(\"\\nand this task is already holding:\\n\");\n\tprint_lock(prev);\n\tpr_warn(\"which would create a new lock dependency:\\n\");\n\tprint_lock_name(hlock_class(prev));\n\tpr_cont(\" ->\");\n\tprint_lock_name(hlock_class(next));\n\tpr_cont(\"\\n\");\n\n\tpr_warn(\"\\nbut this new dependency connects a %s-irq-safe lock:\\n\",\n\t\tirqclass);\n\tprint_lock_name(backwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-safe at:\\n\", irqclass);\n\n\tprint_lock_trace(backwards_entry->class->usage_traces[bit1], 1);\n\n\tpr_warn(\"\\nto a %s-irq-unsafe lock:\\n\", irqclass);\n\tprint_lock_name(forwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-unsafe at:\\n\", irqclass);\n\tpr_warn(\"...\");\n\n\tprint_lock_trace(forwards_entry->class->usage_traces[bit2], 1);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_irq_lock_scenario(backwards_entry, forwards_entry,\n\t\t\t\thlock_class(prev), hlock_class(next));\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe dependencies between %s-irq-safe lock and the holding lock:\\n\", irqclass);\n\tprint_shortest_lock_dependencies_backwards(backwards_entry, prev_root);\n\n\tpr_warn(\"\\nthe dependencies between the lock to be acquired\");\n\tpr_warn(\" and %s-irq-unsafe lock:\\n\", irqclass);\n\tnext_root->trace = save_trace();\n\tif (!next_root->trace)\n\t\treturn;\n\tprint_shortest_lock_dependencies(forwards_entry, next_root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "print_irq_lock_scenario",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2453-2507",
    "snippet": "static void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n *** DEADLOCK ***\\n\\n\""
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__print_lock_name",
          "args": [
            "safe_class"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "__print_lock_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "683-699",
          "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
  },
  {
    "function_name": "print_shortest_lock_dependencies_backwards",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2418-2451",
    "snippet": "static void __used\nprint_shortest_lock_dependencies_backwards(struct lock_list *leaf,\n\t\t\t\t\t   struct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tconst struct lock_trace *trace = NULL;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tif (trace) {\n\t\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\t\tprint_lock_trace(trace, 2);\n\t\t\tprintk(\"\\n\");\n\t\t}\n\n\t\t/*\n\t\t * Record the pointer to the trace for the next lock_list\n\t\t * entry, see the comments for the function.\n\t\t */\n\t\ttrace = entry->trace;\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_lock_parent",
          "args": [
            "entry"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1499-1502",
          "snippet": "static inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"lockdep:%s bad path found in chain graph\\n\"",
            "__func__"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_trace",
          "args": [
            "trace",
            "2"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1820-1824",
          "snippet": "static void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_class_header",
          "args": [
            "entry->class",
            "depth"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_class_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2294-2318",
          "snippet": "static void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"%*s->\", depth, \"\");\n\tprint_lock_name(class);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tprintk(KERN_CONT \" ops: %lu\", debug_class_ops_read(class));\n#endif\n\tprintk(KERN_CONT \" {\\n\");\n\n\tfor (bit = 0; bit < LOCK_TRACE_STATES; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"%*s   %s\", depth, \"\", usage_str[bit]);\n\t\t\tlen += printk(KERN_CONT \" at:\\n\");\n\t\t\tprint_lock_trace(class->usage_traces[bit], len);\n\t\t}\n\t}\n\tprintk(\"%*s }\\n\", depth, \"\");\n\n\tprintk(\"%*s ... key      at: [<%px>] %pS\\n\",\n\t\tdepth, \"\", class->key, class->key);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"%*s->\", depth, \"\");\n\tprint_lock_name(class);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tprintk(KERN_CONT \" ops: %lu\", debug_class_ops_read(class));\n#endif\n\tprintk(KERN_CONT \" {\\n\");\n\n\tfor (bit = 0; bit < LOCK_TRACE_STATES; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"%*s   %s\", depth, \"\", usage_str[bit]);\n\t\t\tlen += printk(KERN_CONT \" at:\\n\");\n\t\t\tprint_lock_trace(class->usage_traces[bit], len);\n\t\t}\n\t}\n\tprintk(\"%*s }\\n\", depth, \"\");\n\n\tprintk(\"%*s ... key      at: [<%px>] %pS\\n\",\n\t\tdepth, \"\", class->key, class->key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_depth",
          "args": [
            "leaf"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_depth",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1504-1514",
          "snippet": "static inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __used\nprint_shortest_lock_dependencies_backwards(struct lock_list *leaf,\n\t\t\t\t\t   struct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tconst struct lock_trace *trace = NULL;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tif (trace) {\n\t\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\t\tprint_lock_trace(trace, 2);\n\t\t\tprintk(\"\\n\");\n\t\t}\n\n\t\t/*\n\t\t * Record the pointer to the trace for the next lock_list\n\t\t * entry, see the comments for the function.\n\t\t */\n\t\ttrace = entry->trace;\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n}"
  },
  {
    "function_name": "print_shortest_lock_dependencies",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2372-2396",
    "snippet": "static void __used\nprint_shortest_lock_dependencies(struct lock_list *leaf,\n\t\t\t\t struct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\tprint_lock_trace(entry->trace, 2);\n\t\tprintk(\"\\n\");\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_lock_parent",
          "args": [
            "entry"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1499-1502",
          "snippet": "static inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"lockdep:%s bad path found in chain graph\\n\"",
            "__func__"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_trace",
          "args": [
            "entry->trace",
            "2"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1820-1824",
          "snippet": "static void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_class_header",
          "args": [
            "entry->class",
            "depth"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_class_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2294-2318",
          "snippet": "static void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"%*s->\", depth, \"\");\n\tprint_lock_name(class);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tprintk(KERN_CONT \" ops: %lu\", debug_class_ops_read(class));\n#endif\n\tprintk(KERN_CONT \" {\\n\");\n\n\tfor (bit = 0; bit < LOCK_TRACE_STATES; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"%*s   %s\", depth, \"\", usage_str[bit]);\n\t\t\tlen += printk(KERN_CONT \" at:\\n\");\n\t\t\tprint_lock_trace(class->usage_traces[bit], len);\n\t\t}\n\t}\n\tprintk(\"%*s }\\n\", depth, \"\");\n\n\tprintk(\"%*s ... key      at: [<%px>] %pS\\n\",\n\t\tdepth, \"\", class->key, class->key);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"%*s->\", depth, \"\");\n\tprint_lock_name(class);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tprintk(KERN_CONT \" ops: %lu\", debug_class_ops_read(class));\n#endif\n\tprintk(KERN_CONT \" {\\n\");\n\n\tfor (bit = 0; bit < LOCK_TRACE_STATES; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"%*s   %s\", depth, \"\", usage_str[bit]);\n\t\t\tlen += printk(KERN_CONT \" at:\\n\");\n\t\t\tprint_lock_trace(class->usage_traces[bit], len);\n\t\t}\n\t}\n\tprintk(\"%*s }\\n\", depth, \"\");\n\n\tprintk(\"%*s ... key      at: [<%px>] %pS\\n\",\n\t\tdepth, \"\", class->key, class->key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_depth",
          "args": [
            "leaf"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_depth",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1504-1514",
          "snippet": "static inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __used\nprint_shortest_lock_dependencies(struct lock_list *leaf,\n\t\t\t\t struct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\tprint_lock_trace(entry->trace, 2);\n\t\tprintk(\"\\n\");\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n}"
  },
  {
    "function_name": "print_lock_class_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2294-2318",
    "snippet": "static void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"%*s->\", depth, \"\");\n\tprint_lock_name(class);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tprintk(KERN_CONT \" ops: %lu\", debug_class_ops_read(class));\n#endif\n\tprintk(KERN_CONT \" {\\n\");\n\n\tfor (bit = 0; bit < LOCK_TRACE_STATES; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"%*s   %s\", depth, \"\", usage_str[bit]);\n\t\t\tlen += printk(KERN_CONT \" at:\\n\");\n\t\t\tprint_lock_trace(class->usage_traces[bit], len);\n\t\t}\n\t}\n\tprintk(\"%*s }\\n\", depth, \"\");\n\n\tprintk(\"%*s ... key      at: [<%px>] %pS\\n\",\n\t\tdepth, \"\", class->key, class->key);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%*s ... key      at: [<%px>] %pS\\n\"",
            "depth",
            "\"\"",
            "class->key",
            "class->key"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_trace",
          "args": [
            "class->usage_traces[bit]",
            "len"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1820-1824",
          "snippet": "static void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \" at:\\n\""
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_class_ops_read",
          "args": [
            "class"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "debug_class_ops_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_internals.h",
          "lines": "242-251",
          "snippet": "static inline unsigned long debug_class_ops_read(struct lock_class *class)\n{\n\tint idx, cpu;\n\tunsigned long ops = 0;\n\n\tidx = class - lock_classes;\n\tfor_each_possible_cpu(cpu)\n\t\tops += per_cpu(lockdep_stats.lock_class_ops[idx], cpu);\n\treturn ops;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n\nstatic inline unsigned long debug_class_ops_read(struct lock_class *class)\n{\n\tint idx, cpu;\n\tunsigned long ops = 0;\n\n\tidx = class - lock_classes;\n\tfor_each_possible_cpu(cpu)\n\t\tops += per_cpu(lockdep_stats.lock_class_ops[idx], cpu);\n\treturn ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "class"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "701-712",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"%*s->\", depth, \"\");\n\tprint_lock_name(class);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tprintk(KERN_CONT \" ops: %lu\", debug_class_ops_read(class));\n#endif\n\tprintk(KERN_CONT \" {\\n\");\n\n\tfor (bit = 0; bit < LOCK_TRACE_STATES; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"%*s   %s\", depth, \"\", usage_str[bit]);\n\t\t\tlen += printk(KERN_CONT \" at:\\n\");\n\t\t\tprint_lock_trace(class->usage_traces[bit], len);\n\t\t}\n\t}\n\tprintk(\"%*s }\\n\", depth, \"\");\n\n\tprintk(\"%*s ... key      at: [<%px>] %pS\\n\",\n\t\tdepth, \"\", class->key, class->key);\n}"
  },
  {
    "function_name": "find_usage_backwards",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2281-2292",
    "snippet": "static enum bfs_result\nfind_usage_backwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_backwards",
          "args": [
            "root",
            "&usage_mask",
            "usage_match",
            "usage_skip",
            "target_entry"
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_backwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1808-1818",
          "snippet": "static inline enum bfs_result\n__bfs_backwards(struct lock_list *src_entry,\n\t\tvoid *data,\n\t\tbool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_before));\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline enum bfs_result\n__bfs_backwards(struct lock_list *src_entry,\n\t\tvoid *data,\n\t\tbool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_before));\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_find_usage_backwards_checks"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic enum bfs_result\nfind_usage_backwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}"
  },
  {
    "function_name": "find_usage_forwards",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2264-2275",
    "snippet": "static enum bfs_result\nfind_usage_forwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_forwards",
          "args": [
            "root",
            "&usage_mask",
            "usage_match",
            "usage_skip",
            "target_entry"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_forwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1796-1806",
          "snippet": "static inline enum bfs_result\n__bfs_forwards(struct lock_list *src_entry,\n\t       void *data,\n\t       bool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t       struct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_after));\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline enum bfs_result\n__bfs_forwards(struct lock_list *src_entry,\n\t       void *data,\n\t       bool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t       struct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_after));\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_find_usage_forwards_checks"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic enum bfs_result\nfind_usage_forwards(struct lock_list *root, unsigned long usage_mask,\n\t\t\tstruct lock_list **target_entry)\n{\n\tenum bfs_result result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, &usage_mask, usage_match, usage_skip, target_entry);\n\n\treturn result;\n}"
  },
  {
    "function_name": "usage_skip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2219-2255",
    "snippet": "static inline bool usage_skip(struct lock_list *entry, void *mask)\n{\n\t/*\n\t * Skip local_lock() for irq inversion detection.\n\t *\n\t * For !RT, local_lock() is not a real lock, so it won't carry any\n\t * dependency.\n\t *\n\t * For RT, an irq inversion happens when we have lock A and B, and on\n\t * some CPU we can have:\n\t *\n\t *\tlock(A);\n\t *\t<interrupted>\n\t *\t  lock(B);\n\t *\n\t * where lock(B) cannot sleep, and we have a dependency B -> ... -> A.\n\t *\n\t * Now we prove local_lock() cannot exist in that dependency. First we\n\t * have the observation for any lock chain L1 -> ... -> Ln, for any\n\t * 1 <= i <= n, Li.inner_wait_type <= L1.inner_wait_type, otherwise\n\t * wait context check will complain. And since B is not a sleep lock,\n\t * therefore B.inner_wait_type >= 2, and since the inner_wait_type of\n\t * local_lock() is 3, which is greater than 2, therefore there is no\n\t * way the local_lock() exists in the dependency B -> ... -> A.\n\t *\n\t * As a result, we will skip local_lock(), when we search for irq\n\t * inversion bugs.\n\t */\n\tif (entry->class->lock_type == LD_LOCK_PERCPU) {\n\t\tif (DEBUG_LOCKS_WARN_ON(entry->class->wait_type_inner < LD_WAIT_CONFIG))\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "entry->class->wait_type_inner < LD_WAIT_CONFIG"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline bool usage_skip(struct lock_list *entry, void *mask)\n{\n\t/*\n\t * Skip local_lock() for irq inversion detection.\n\t *\n\t * For !RT, local_lock() is not a real lock, so it won't carry any\n\t * dependency.\n\t *\n\t * For RT, an irq inversion happens when we have lock A and B, and on\n\t * some CPU we can have:\n\t *\n\t *\tlock(A);\n\t *\t<interrupted>\n\t *\t  lock(B);\n\t *\n\t * where lock(B) cannot sleep, and we have a dependency B -> ... -> A.\n\t *\n\t * Now we prove local_lock() cannot exist in that dependency. First we\n\t * have the observation for any lock chain L1 -> ... -> Ln, for any\n\t * 1 <= i <= n, Li.inner_wait_type <= L1.inner_wait_type, otherwise\n\t * wait context check will complain. And since B is not a sleep lock,\n\t * therefore B.inner_wait_type >= 2, and since the inner_wait_type of\n\t * local_lock() is 3, which is greater than 2, therefore there is no\n\t * way the local_lock() exists in the dependency B -> ... -> A.\n\t *\n\t * As a result, we will skip local_lock(), when we search for irq\n\t * inversion bugs.\n\t */\n\tif (entry->class->lock_type == LD_LOCK_PERCPU) {\n\t\tif (DEBUG_LOCKS_WARN_ON(entry->class->wait_type_inner < LD_WAIT_CONFIG))\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "usage_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2211-2217",
    "snippet": "static inline bool usage_match(struct lock_list *entry, void *mask)\n{\n\tif (!entry->only_xr)\n\t\treturn !!(entry->class->usage_mask & *(unsigned long *)mask);\n\telse /* Mask out _READ usage bits */\n\t\treturn !!((entry->class->usage_mask & LOCKF_IRQ) & *(unsigned long *)mask);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline bool usage_match(struct lock_list *entry, void *mask)\n{\n\tif (!entry->only_xr)\n\t\treturn !!(entry->class->usage_mask & *(unsigned long *)mask);\n\telse /* Mask out _READ usage bits */\n\t\treturn !!((entry->class->usage_mask & LOCKF_IRQ) & *(unsigned long *)mask);\n}"
  },
  {
    "function_name": "usage_accumulate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2192-2200",
    "snippet": "static inline bool usage_accumulate(struct lock_list *entry, void *mask)\n{\n\tif (!entry->only_xr)\n\t\t*(unsigned long *)mask |= entry->class->usage_mask;\n\telse /* Mask out _READ usage bits */\n\t\t*(unsigned long *)mask |= (entry->class->usage_mask & LOCKF_IRQ);\n\n\treturn false;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline bool usage_accumulate(struct lock_list *entry, void *mask)\n{\n\tif (!entry->only_xr)\n\t\t*(unsigned long *)mask |= entry->class->usage_mask;\n\telse /* Mask out _READ usage bits */\n\t\t*(unsigned long *)mask |= (entry->class->usage_mask & LOCKF_IRQ);\n\n\treturn false;\n}"
  },
  {
    "function_name": "check_noncircular",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2119-2147",
    "snippet": "bfs_result\ncheck_noncircular(struct held_lock *src, struct held_lock *target,\n\t\t  struct lock_trace **const trace)\n{\n\tenum bfs_result ret;\n\tstruct lock_list *target_entry;\n\tstruct lock_list src_entry;\n\n\tbfs_init_root(&src_entry, src);\n\n\tdebug_atomic_inc(nr_cyclic_checks);\n\n\tret = check_path(target, &src_entry, hlock_conflict, NULL, &target_entry);\n\n\tif (unlikely(ret == BFS_RMATCH)) {\n\t\tif (!*trace) {\n\t\t\t/*\n\t\t\t * If save_trace fails here, the printing might\n\t\t\t * trigger a WARN but because of the !nr_entries it\n\t\t\t * should not do bad things.\n\t\t\t */\n\t\t\t*trace = save_trace();\n\t\t}\n\n\t\tprint_circular_bug(&src_entry, target_entry, src, target);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_circular_bug",
          "args": [
            "&src_entry",
            "target_entry",
            "src",
            "target"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "print_circular_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1985-2022",
          "snippet": "static noinline void print_circular_bug(struct lock_list *this,\n\t\t\t\tstruct lock_list *target,\n\t\t\t\tstruct held_lock *check_src,\n\t\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_list *parent;\n\tstruct lock_list *first_parent;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tthis->trace = save_trace();\n\tif (!this->trace)\n\t\treturn;\n\n\tdepth = get_lock_depth(target);\n\n\tprint_circular_bug_header(target, depth, check_src, check_tgt);\n\n\tparent = get_lock_parent(target);\n\tfirst_parent = parent;\n\n\twhile (parent) {\n\t\tprint_circular_bug_entry(parent, --depth);\n\t\tparent = get_lock_parent(parent);\n\t}\n\n\tprintk(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_circular_lock_scenario(check_src, check_tgt,\n\t\t\t\t     first_parent);\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic noinline void print_circular_bug(struct lock_list *this,\n\t\t\t\tstruct lock_list *target,\n\t\t\t\tstruct held_lock *check_src,\n\t\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_list *parent;\n\tstruct lock_list *first_parent;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tthis->trace = save_trace();\n\tif (!this->trace)\n\t\treturn;\n\n\tdepth = get_lock_depth(target);\n\n\tprint_circular_bug_header(target, depth, check_src, check_tgt);\n\n\tparent = get_lock_parent(target);\n\tfirst_parent = parent;\n\n\twhile (parent) {\n\t\tprint_circular_bug_entry(parent, --depth);\n\t\tparent = get_lock_parent(parent);\n\t}\n\n\tprintk(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_circular_lock_scenario(check_src, check_tgt,\n\t\t\t\t     first_parent);\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_trace",
          "args": [],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "save_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "530-567",
          "snippet": "static struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))"
          ],
          "globals_used": [
            "unsigned long nr_stack_trace_entries;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))\n\nunsigned long nr_stack_trace_entries;\nstatic noinstr struct;\n\nstatic struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == BFS_RMATCH"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_path",
          "args": [
            "target",
            "&src_entry",
            "hlock_conflict",
            "NULL",
            "&target_entry"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "check_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2096-2110",
          "snippet": "bfs_result\ncheck_path(struct held_lock *target, struct lock_list *src_entry,\n\t   bool (*match)(struct lock_list *entry, void *data),\n\t   bool (*skip)(struct lock_list *entry, void *data),\n\t   struct lock_list **target_entry)\n{\n\tenum bfs_result ret;\n\n\tret = __bfs_forwards(src_entry, target, match, skip, target_entry);\n\n\tif (unlikely(bfs_error(ret)))\n\t\tprint_bfs_bug(ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nbfs_result\ncheck_path(struct held_lock *target, struct lock_list *src_entry,\n\t   bool (*match)(struct lock_list *entry, void *data),\n\t   bool (*skip)(struct lock_list *entry, void *data),\n\t   struct lock_list **target_entry)\n{\n\tenum bfs_result ret;\n\n\tret = __bfs_forwards(src_entry, target, match, skip, target_entry);\n\n\tif (unlikely(bfs_error(ret)))\n\t\tprint_bfs_bug(ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_cyclic_checks"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bfs_init_root",
          "args": [
            "&src_entry",
            "src"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_init_rootb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1645-1650",
          "snippet": "static inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nbfs_result\ncheck_noncircular(struct held_lock *src, struct held_lock *target,\n\t\t  struct lock_trace **const trace)\n{\n\tenum bfs_result ret;\n\tstruct lock_list *target_entry;\n\tstruct lock_list src_entry;\n\n\tbfs_init_root(&src_entry, src);\n\n\tdebug_atomic_inc(nr_cyclic_checks);\n\n\tret = check_path(target, &src_entry, hlock_conflict, NULL, &target_entry);\n\n\tif (unlikely(ret == BFS_RMATCH)) {\n\t\tif (!*trace) {\n\t\t\t/*\n\t\t\t * If save_trace fails here, the printing might\n\t\t\t * trigger a WARN but because of the !nr_entries it\n\t\t\t * should not do bad things.\n\t\t\t */\n\t\t\t*trace = save_trace();\n\t\t}\n\n\t\tprint_circular_bug(&src_entry, target_entry, src, target);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "check_path",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2096-2110",
    "snippet": "bfs_result\ncheck_path(struct held_lock *target, struct lock_list *src_entry,\n\t   bool (*match)(struct lock_list *entry, void *data),\n\t   bool (*skip)(struct lock_list *entry, void *data),\n\t   struct lock_list **target_entry)\n{\n\tenum bfs_result ret;\n\n\tret = __bfs_forwards(src_entry, target, match, skip, target_entry);\n\n\tif (unlikely(bfs_error(ret)))\n\t\tprint_bfs_bug(ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_bfs_bug",
          "args": [
            "ret"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "print_bfs_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2024-2033",
          "snippet": "static noinline void print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline void print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bfs_error(ret)"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bfs_error",
          "args": [
            "ret"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1555-1558",
          "snippet": "static inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bfs_forwards",
          "args": [
            "src_entry",
            "target",
            "match",
            "skip",
            "target_entry"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_forwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1796-1806",
          "snippet": "static inline enum bfs_result\n__bfs_forwards(struct lock_list *src_entry,\n\t       void *data,\n\t       bool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t       struct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_after));\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline enum bfs_result\n__bfs_forwards(struct lock_list *src_entry,\n\t       void *data,\n\t       bool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t       struct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_after));\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nbfs_result\ncheck_path(struct held_lock *target, struct lock_list *src_entry,\n\t   bool (*match)(struct lock_list *entry, void *data),\n\t   bool (*skip)(struct lock_list *entry, void *data),\n\t   struct lock_list **target_entry)\n{\n\tenum bfs_result ret;\n\n\tret = __bfs_forwards(src_entry, target, match, skip, target_entry);\n\n\tif (unlikely(bfs_error(ret)))\n\t\tprint_bfs_bug(ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lockdep_count_backward_deps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2076-2090",
    "snippet": "unsigned long lockdep_count_backward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\t__bfs_init_root(&this, class);\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\tret = __lockdep_count_backward_deps(&this);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_unlock",
          "args": [],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "117-127",
          "snippet": "static inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lockdep_count_backward_deps",
          "args": [
            "&this"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "__lockdep_count_backward_deps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2066-2074",
          "snippet": "static unsigned long __lockdep_count_backward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *target_entry;\n\n\t__bfs_backwards(this, (void *)&count, noop_count, NULL, &target_entry);\n\n\treturn count;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic unsigned long __lockdep_count_backward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *target_entry;\n\n\t__bfs_backwards(this, (void *)&count, noop_count, NULL, &target_entry);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_lock",
          "args": [],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "108-115",
          "snippet": "static inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bfs_init_root",
          "args": [
            "&this",
            "class"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_init_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1615-1621",
          "snippet": "static inline void __bfs_init_root(struct lock_list *lock,\n\t\t\t\t   struct lock_class *class)\n{\n\tlock->class = class;\n\tlock->parent = NULL;\n\tlock->only_xr = 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void __bfs_init_root(struct lock_list *lock,\n\t\t\t\t   struct lock_class *class)\n{\n\tlock->class = class;\n\tlock->parent = NULL;\n\tlock->only_xr = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nunsigned long lockdep_count_backward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\t__bfs_init_root(&this, class);\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\tret = __lockdep_count_backward_deps(&this);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__lockdep_count_backward_deps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2066-2074",
    "snippet": "static unsigned long __lockdep_count_backward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *target_entry;\n\n\t__bfs_backwards(this, (void *)&count, noop_count, NULL, &target_entry);\n\n\treturn count;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_backwards",
          "args": [
            "this",
            "(void *)&count",
            "noop_count",
            "NULL",
            "&target_entry"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_backwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1808-1818",
          "snippet": "static inline enum bfs_result\n__bfs_backwards(struct lock_list *src_entry,\n\t\tvoid *data,\n\t\tbool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_before));\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline enum bfs_result\n__bfs_backwards(struct lock_list *src_entry,\n\t\tvoid *data,\n\t\tbool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_before));\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic unsigned long __lockdep_count_backward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *target_entry;\n\n\t__bfs_backwards(this, (void *)&count, noop_count, NULL, &target_entry);\n\n\treturn count;\n}"
  },
  {
    "function_name": "lockdep_count_forward_deps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2050-2064",
    "snippet": "unsigned long lockdep_count_forward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\t__bfs_init_root(&this, class);\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\tret = __lockdep_count_forward_deps(&this);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_unlock",
          "args": [],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "117-127",
          "snippet": "static inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lockdep_count_forward_deps",
          "args": [
            "&this"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "__lockdep_count_forward_deps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2041-2049",
          "snippet": "static unsigned long __lockdep_count_forward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *target_entry;\n\n\t__bfs_forwards(this, (void *)&count, noop_count, NULL, &target_entry);\n\n\treturn count;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic unsigned long __lockdep_count_forward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *target_entry;\n\n\t__bfs_forwards(this, (void *)&count, noop_count, NULL, &target_entry);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_lock",
          "args": [],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "108-115",
          "snippet": "static inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bfs_init_root",
          "args": [
            "&this",
            "class"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_init_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1615-1621",
          "snippet": "static inline void __bfs_init_root(struct lock_list *lock,\n\t\t\t\t   struct lock_class *class)\n{\n\tlock->class = class;\n\tlock->parent = NULL;\n\tlock->only_xr = 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void __bfs_init_root(struct lock_list *lock,\n\t\t\t\t   struct lock_class *class)\n{\n\tlock->class = class;\n\tlock->parent = NULL;\n\tlock->only_xr = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nunsigned long lockdep_count_forward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\t__bfs_init_root(&this, class);\n\n\traw_local_irq_save(flags);\n\tlockdep_lock();\n\tret = __lockdep_count_forward_deps(&this);\n\tlockdep_unlock();\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__lockdep_count_forward_deps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2041-2049",
    "snippet": "static unsigned long __lockdep_count_forward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *target_entry;\n\n\t__bfs_forwards(this, (void *)&count, noop_count, NULL, &target_entry);\n\n\treturn count;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_forwards",
          "args": [
            "this",
            "(void *)&count",
            "noop_count",
            "NULL",
            "&target_entry"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_forwards",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1796-1806",
          "snippet": "static inline enum bfs_result\n__bfs_forwards(struct lock_list *src_entry,\n\t       void *data,\n\t       bool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t       struct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_after));\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline enum bfs_result\n__bfs_forwards(struct lock_list *src_entry,\n\t       void *data,\n\t       bool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t       struct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_after));\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic unsigned long __lockdep_count_forward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *target_entry;\n\n\t__bfs_forwards(this, (void *)&count, noop_count, NULL, &target_entry);\n\n\treturn count;\n}"
  },
  {
    "function_name": "noop_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2035-2039",
    "snippet": "static bool noop_count(struct lock_list *entry, void *data)\n{\n\t(*(unsigned long *)data)++;\n\treturn false;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic bool noop_count(struct lock_list *entry, void *data)\n{\n\t(*(unsigned long *)data)++;\n\treturn false;\n}"
  },
  {
    "function_name": "print_bfs_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "2024-2033",
    "snippet": "static noinline void print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"lockdep bfs error:%d\\n\"",
            "ret"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline void print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n}"
  },
  {
    "function_name": "print_circular_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1985-2022",
    "snippet": "static noinline void print_circular_bug(struct lock_list *this,\n\t\t\t\tstruct lock_list *target,\n\t\t\t\tstruct held_lock *check_src,\n\t\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_list *parent;\n\tstruct lock_list *first_parent;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tthis->trace = save_trace();\n\tif (!this->trace)\n\t\treturn;\n\n\tdepth = get_lock_depth(target);\n\n\tprint_circular_bug_header(target, depth, check_src, check_tgt);\n\n\tparent = get_lock_parent(target);\n\tfirst_parent = parent;\n\n\twhile (parent) {\n\t\tprint_circular_bug_entry(parent, --depth);\n\t\tparent = get_lock_parent(parent);\n\t}\n\n\tprintk(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_circular_lock_scenario(check_src, check_tgt,\n\t\t\t\t     first_parent);\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "750-769",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_circular_lock_scenario",
          "args": [
            "check_src",
            "check_tgt",
            "first_parent"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "print_circular_lock_scenario",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1841-1889",
          "snippet": "static void\nprint_circular_lock_scenario(struct held_lock *src,\n\t\t\t     struct held_lock *tgt,\n\t\t\t     struct lock_list *prt)\n{\n\tstruct lock_class *source = hlock_class(src);\n\tstruct lock_class *target = hlock_class(tgt);\n\tstruct lock_class *parent = prt->class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (parent != source) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(source);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(parent);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(target);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(parent);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(source);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_circular_lock_scenario(struct held_lock *src,\n\t\t\t     struct held_lock *tgt,\n\t\t\t     struct lock_list *prt)\n{\n\tstruct lock_class *source = hlock_class(src);\n\tstruct lock_class *target = hlock_class(tgt);\n\tstruct lock_class *parent = prt->class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (parent != source) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(source);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(parent);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(target);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(parent);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(source);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_parent",
          "args": [
            "parent"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1499-1502",
          "snippet": "static inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_circular_bug_entry",
          "args": [
            "parent",
            "--depth"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "print_circular_bug_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1830-1839",
          "snippet": "static noinline void\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_lock_trace(target->trace, 6);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic noinline void\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_lock_trace(target->trace, 6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_circular_bug_header",
          "args": [
            "target",
            "depth",
            "check_src",
            "check_tgt"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "print_circular_bug_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1895-1921",
          "snippet": "static noinline void\nprint_circular_bug_header(struct lock_list *entry, unsigned int depth,\n\t\t\tstruct held_lock *check_src,\n\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"======================================================\\n\");\n\tpr_warn(\"WARNING: possible circular locking dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(check_src);\n\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\n\tprint_lock(check_tgt);\n\tpr_warn(\"\\nwhich lock already depends on the new lock.\\n\\n\");\n\tpr_warn(\"\\nthe existing dependency chain (in reverse order) is:\\n\");\n\n\tprint_circular_bug_entry(entry, depth);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic noinline void\nprint_circular_bug_header(struct lock_list *entry, unsigned int depth,\n\t\t\tstruct held_lock *check_src,\n\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"======================================================\\n\");\n\tpr_warn(\"WARNING: possible circular locking dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(check_src);\n\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\n\tprint_lock(check_tgt);\n\tpr_warn(\"\\nwhich lock already depends on the new lock.\\n\\n\");\n\tpr_warn(\"\\nthe existing dependency chain (in reverse order) is:\\n\");\n\n\tprint_circular_bug_entry(entry, depth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_depth",
          "args": [
            "target"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_depth",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1504-1514",
          "snippet": "static inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_trace",
          "args": [],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "save_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "530-567",
          "snippet": "static struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))"
          ],
          "globals_used": [
            "unsigned long nr_stack_trace_entries;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))\n\nunsigned long nr_stack_trace_entries;\nstatic noinstr struct;\n\nstatic struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic noinline void print_circular_bug(struct lock_list *this,\n\t\t\t\tstruct lock_list *target,\n\t\t\t\tstruct held_lock *check_src,\n\t\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_list *parent;\n\tstruct lock_list *first_parent;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn;\n\n\tthis->trace = save_trace();\n\tif (!this->trace)\n\t\treturn;\n\n\tdepth = get_lock_depth(target);\n\n\tprint_circular_bug_header(target, depth, check_src, check_tgt);\n\n\tparent = get_lock_parent(target);\n\tfirst_parent = parent;\n\n\twhile (parent) {\n\t\tprint_circular_bug_entry(parent, --depth);\n\t\tparent = get_lock_parent(parent);\n\t}\n\n\tprintk(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_circular_lock_scenario(check_src, check_tgt,\n\t\t\t\t     first_parent);\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "hlock_conflict",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1976-1983",
    "snippet": "static inline bool hlock_conflict(struct lock_list *entry, void *data)\n{\n\tstruct held_lock *hlock = (struct held_lock *)data;\n\n\treturn hlock_class(hlock) == entry->class && /* Found A -> .. -> B */\n\t       (hlock->read == 0 || /* B -> A is -(E*)-> */\n\t\t!entry->only_xr); /* A -> .. -> B is -(*N)-> */\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline bool hlock_conflict(struct lock_list *entry, void *data)\n{\n\tstruct held_lock *hlock = (struct held_lock *)data;\n\n\treturn hlock_class(hlock) == entry->class && /* Found A -> .. -> B */\n\t       (hlock->read == 0 || /* B -> A is -(E*)-> */\n\t\t!entry->only_xr); /* A -> .. -> B is -(*N)-> */\n}"
  },
  {
    "function_name": "hlock_equal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1949-1956",
    "snippet": "static inline bool hlock_equal(struct lock_list *entry, void *data)\n{\n\tstruct held_lock *hlock = (struct held_lock *)data;\n\n\treturn hlock_class(hlock) == entry->class && /* Found A -> .. -> B */\n\t       (hlock->read == 2 ||  /* A -> B is -(*R)-> */\n\t\t!entry->only_xr); /* A -> .. -> B is -(*N)-> */\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline bool hlock_equal(struct lock_list *entry, void *data)\n{\n\tstruct held_lock *hlock = (struct held_lock *)data;\n\n\treturn hlock_class(hlock) == entry->class && /* Found A -> .. -> B */\n\t       (hlock->read == 2 ||  /* A -> B is -(*R)-> */\n\t\t!entry->only_xr); /* A -> .. -> B is -(*N)-> */\n}"
  },
  {
    "function_name": "print_circular_bug_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1895-1921",
    "snippet": "static noinline void\nprint_circular_bug_header(struct lock_list *entry, unsigned int depth,\n\t\t\tstruct held_lock *check_src,\n\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"======================================================\\n\");\n\tpr_warn(\"WARNING: possible circular locking dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(check_src);\n\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\n\tprint_lock(check_tgt);\n\tpr_warn(\"\\nwhich lock already depends on the new lock.\\n\\n\");\n\tpr_warn(\"\\nthe existing dependency chain (in reverse order) is:\\n\");\n\n\tprint_circular_bug_entry(entry, depth);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_circular_bug_entry",
          "args": [
            "entry",
            "depth"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "print_circular_bug_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1830-1839",
          "snippet": "static noinline void\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_lock_trace(target->trace, 6);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic noinline void\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_lock_trace(target->trace, 6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nthe existing dependency chain (in reverse order) is:\\n\""
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nwhich lock already depends on the new lock.\\n\\n\""
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "check_tgt"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "726-748",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nbut task is already holding lock:\\n\""
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is trying to acquire lock:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"------------------------------------------------------\\n\""
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "771-777",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: possible circular locking dependency detected\\n\""
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"======================================================\\n\""
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic noinline void\nprint_circular_bug_header(struct lock_list *entry, unsigned int depth,\n\t\t\tstruct held_lock *check_src,\n\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"======================================================\\n\");\n\tpr_warn(\"WARNING: possible circular locking dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(check_src);\n\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\n\tprint_lock(check_tgt);\n\tpr_warn(\"\\nwhich lock already depends on the new lock.\\n\\n\");\n\tpr_warn(\"\\nthe existing dependency chain (in reverse order) is:\\n\");\n\n\tprint_circular_bug_entry(entry, depth);\n}"
  },
  {
    "function_name": "print_circular_lock_scenario",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1841-1889",
    "snippet": "static void\nprint_circular_lock_scenario(struct held_lock *src,\n\t\t\t     struct held_lock *tgt,\n\t\t\t     struct lock_list *prt)\n{\n\tstruct lock_class *source = hlock_class(src);\n\tstruct lock_class *target = hlock_class(tgt);\n\tstruct lock_class *parent = prt->class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (parent != source) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(source);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(parent);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(target);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(parent);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(source);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n *** DEADLOCK ***\\n\\n\""
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__print_lock_name",
          "args": [
            "source"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "__print_lock_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "683-699",
          "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "tgt"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void\nprint_circular_lock_scenario(struct held_lock *src,\n\t\t\t     struct held_lock *tgt,\n\t\t\t     struct lock_list *prt)\n{\n\tstruct lock_class *source = hlock_class(src);\n\tstruct lock_class *target = hlock_class(tgt);\n\tstruct lock_class *parent = prt->class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (parent != source) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(source);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(parent);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(target);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(parent);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(source);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
  },
  {
    "function_name": "print_circular_bug_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1830-1839",
    "snippet": "static noinline void\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_lock_trace(target->trace, 6);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_lock_trace",
          "args": [
            "target->trace",
            "6"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1820-1824",
          "snippet": "static void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \":\\n\""
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "target->class"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "701-712",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n-> #%u\"",
            "depth"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic noinline void\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_lock_trace(target->trace, 6);\n}"
  },
  {
    "function_name": "print_lock_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1820-1824",
    "snippet": "static void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stack_trace_print",
          "args": [
            "trace->entries",
            "trace->nr_entries",
            "spaces"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stacktrace.c",
          "lines": "24-34",
          "snippet": "void stack_trace_print(const unsigned long *entries, unsigned int nr_entries,\n\t\t       int spaces)\n{\n\tunsigned int i;\n\n\tif (WARN_ON(!entries))\n\t\treturn;\n\n\tfor (i = 0; i < nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)entries[i]);\n}",
          "includes": [
            "#include <linux/interrupt.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\nvoid stack_trace_print(const unsigned long *entries, unsigned int nr_entries,\n\t\t       int spaces)\n{\n\tunsigned int i;\n\n\tif (WARN_ON(!entries))\n\t\treturn;\n\n\tfor (i = 0; i < nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)entries[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_trace(const struct lock_trace *trace,\n\t\t\t     unsigned int spaces)\n{\n\tstack_trace_print(trace->entries, trace->nr_entries, spaces);\n}"
  },
  {
    "function_name": "__bfs_backwards",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1808-1818",
    "snippet": "static inline enum bfs_result\n__bfs_backwards(struct lock_list *src_entry,\n\t\tvoid *data,\n\t\tbool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_before));\n\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs",
          "args": [
            "src_entry",
            "data",
            "match",
            "skip",
            "target_entry",
            "offsetof(struct lock_class, locks_before)"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1688-1794",
          "snippet": "static enum bfs_result __bfs(struct lock_list *source_entry,\n\t\t\t     void *data,\n\t\t\t     bool (*match)(struct lock_list *entry, void *data),\n\t\t\t     bool (*skip)(struct lock_list *entry, void *data),\n\t\t\t     struct lock_list **target_entry,\n\t\t\t     int offset)\n{\n\tstruct circular_queue *cq = &lock_cq;\n\tstruct lock_list *lock = NULL;\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tunsigned int cq_depth;\n\tbool first;\n\n\tlockdep_assert_locked();\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, source_entry);\n\n\twhile ((lock = __bfs_next(lock, offset)) || (lock = __cq_dequeue(cq))) {\n\t\tif (!lock->class)\n\t\t\treturn BFS_EINVALIDNODE;\n\n\t\t/*\n\t\t * Step 1: check whether we already finish on this one.\n\t\t *\n\t\t * If we have visited all the dependencies from this @lock to\n\t\t * others (iow, if we have visited all lock_list entries in\n\t\t * @lock->class->locks_{after,before}) we skip, otherwise go\n\t\t * and visit all the dependencies in the list and mark this\n\t\t * list accessed.\n\t\t */\n\t\tif (lock_accessed(lock))\n\t\t\tcontinue;\n\t\telse\n\t\t\tmark_lock_accessed(lock);\n\n\t\t/*\n\t\t * Step 2: check whether prev dependency and this form a strong\n\t\t *         dependency path.\n\t\t */\n\t\tif (lock->parent) { /* Parent exists, check prev dependency */\n\t\t\tu8 dep = lock->dep;\n\t\t\tbool prev_only_xr = lock->parent->only_xr;\n\n\t\t\t/*\n\t\t\t * Mask out all -(S*)-> if we only have *R in previous\n\t\t\t * step, because -(*R)-> -(S*)-> don't make up a strong\n\t\t\t * dependency.\n\t\t\t */\n\t\t\tif (prev_only_xr)\n\t\t\t\tdep &= ~(DEP_SR_MASK | DEP_SN_MASK);\n\n\t\t\t/* If nothing left, we skip */\n\t\t\tif (!dep)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are only -(*R)-> left, set that for the next step */\n\t\t\tlock->only_xr = !(dep & (DEP_SN_MASK | DEP_EN_MASK));\n\t\t}\n\n\t\t/*\n\t\t * Step 3: we haven't visited this and there is a strong\n\t\t *         dependency path to this, so check with @match.\n\t\t *         If @skip is provide and returns true, we skip this\n\t\t *         lock (and any path this lock is in).\n\t\t */\n\t\tif (skip && skip(lock, data))\n\t\t\tcontinue;\n\n\t\tif (match(lock, data)) {\n\t\t\t*target_entry = lock;\n\t\t\treturn BFS_RMATCH;\n\t\t}\n\n\t\t/*\n\t\t * Step 4: if not match, expand the path by adding the\n\t\t *         forward or backwards dependencies in the search\n\t\t *\n\t\t */\n\t\tfirst = true;\n\t\thead = get_dep_list(lock, offset);\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tvisit_lock_entry(entry, lock);\n\n\t\t\t/*\n\t\t\t * Note we only enqueue the first of the list into the\n\t\t\t * queue, because we can always find a sibling\n\t\t\t * dependency from one (see __bfs_next()), as a result\n\t\t\t * the space of queue is saved.\n\t\t\t */\n\t\t\tif (!first)\n\t\t\t\tcontinue;\n\n\t\t\tfirst = false;\n\n\t\t\tif (__cq_enqueue(cq, entry))\n\t\t\t\treturn BFS_EQUEUEFULL;\n\n\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t}\n\t}\n\n\treturn BFS_RNOMATCH;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define DEP_EN_MASK (1U << (DEP_EN_BIT))",
            "#define DEP_SN_MASK (1U << (DEP_SN_BIT))",
            "#define DEP_SR_MASK (1U << (DEP_SR_BIT))"
          ],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define DEP_EN_MASK (1U << (DEP_EN_BIT))\n#define DEP_SN_MASK (1U << (DEP_SN_BIT))\n#define DEP_SR_MASK (1U << (DEP_SR_BIT))\n\nstatic noinstr struct;\n\nstatic enum bfs_result __bfs(struct lock_list *source_entry,\n\t\t\t     void *data,\n\t\t\t     bool (*match)(struct lock_list *entry, void *data),\n\t\t\t     bool (*skip)(struct lock_list *entry, void *data),\n\t\t\t     struct lock_list **target_entry,\n\t\t\t     int offset)\n{\n\tstruct circular_queue *cq = &lock_cq;\n\tstruct lock_list *lock = NULL;\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tunsigned int cq_depth;\n\tbool first;\n\n\tlockdep_assert_locked();\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, source_entry);\n\n\twhile ((lock = __bfs_next(lock, offset)) || (lock = __cq_dequeue(cq))) {\n\t\tif (!lock->class)\n\t\t\treturn BFS_EINVALIDNODE;\n\n\t\t/*\n\t\t * Step 1: check whether we already finish on this one.\n\t\t *\n\t\t * If we have visited all the dependencies from this @lock to\n\t\t * others (iow, if we have visited all lock_list entries in\n\t\t * @lock->class->locks_{after,before}) we skip, otherwise go\n\t\t * and visit all the dependencies in the list and mark this\n\t\t * list accessed.\n\t\t */\n\t\tif (lock_accessed(lock))\n\t\t\tcontinue;\n\t\telse\n\t\t\tmark_lock_accessed(lock);\n\n\t\t/*\n\t\t * Step 2: check whether prev dependency and this form a strong\n\t\t *         dependency path.\n\t\t */\n\t\tif (lock->parent) { /* Parent exists, check prev dependency */\n\t\t\tu8 dep = lock->dep;\n\t\t\tbool prev_only_xr = lock->parent->only_xr;\n\n\t\t\t/*\n\t\t\t * Mask out all -(S*)-> if we only have *R in previous\n\t\t\t * step, because -(*R)-> -(S*)-> don't make up a strong\n\t\t\t * dependency.\n\t\t\t */\n\t\t\tif (prev_only_xr)\n\t\t\t\tdep &= ~(DEP_SR_MASK | DEP_SN_MASK);\n\n\t\t\t/* If nothing left, we skip */\n\t\t\tif (!dep)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are only -(*R)-> left, set that for the next step */\n\t\t\tlock->only_xr = !(dep & (DEP_SN_MASK | DEP_EN_MASK));\n\t\t}\n\n\t\t/*\n\t\t * Step 3: we haven't visited this and there is a strong\n\t\t *         dependency path to this, so check with @match.\n\t\t *         If @skip is provide and returns true, we skip this\n\t\t *         lock (and any path this lock is in).\n\t\t */\n\t\tif (skip && skip(lock, data))\n\t\t\tcontinue;\n\n\t\tif (match(lock, data)) {\n\t\t\t*target_entry = lock;\n\t\t\treturn BFS_RMATCH;\n\t\t}\n\n\t\t/*\n\t\t * Step 4: if not match, expand the path by adding the\n\t\t *         forward or backwards dependencies in the search\n\t\t *\n\t\t */\n\t\tfirst = true;\n\t\thead = get_dep_list(lock, offset);\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tvisit_lock_entry(entry, lock);\n\n\t\t\t/*\n\t\t\t * Note we only enqueue the first of the list into the\n\t\t\t * queue, because we can always find a sibling\n\t\t\t * dependency from one (see __bfs_next()), as a result\n\t\t\t * the space of queue is saved.\n\t\t\t */\n\t\t\tif (!first)\n\t\t\t\tcontinue;\n\n\t\t\tfirst = false;\n\n\t\t\tif (__cq_enqueue(cq, entry))\n\t\t\t\treturn BFS_EQUEUEFULL;\n\n\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t}\n\t}\n\n\treturn BFS_RNOMATCH;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline enum bfs_result\n__bfs_backwards(struct lock_list *src_entry,\n\t\tvoid *data,\n\t\tbool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_before));\n\n}"
  },
  {
    "function_name": "__bfs_forwards",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1796-1806",
    "snippet": "static inline enum bfs_result\n__bfs_forwards(struct lock_list *src_entry,\n\t       void *data,\n\t       bool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t       struct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_after));\n\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs",
          "args": [
            "src_entry",
            "data",
            "match",
            "skip",
            "target_entry",
            "offsetof(struct lock_class, locks_after)"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1688-1794",
          "snippet": "static enum bfs_result __bfs(struct lock_list *source_entry,\n\t\t\t     void *data,\n\t\t\t     bool (*match)(struct lock_list *entry, void *data),\n\t\t\t     bool (*skip)(struct lock_list *entry, void *data),\n\t\t\t     struct lock_list **target_entry,\n\t\t\t     int offset)\n{\n\tstruct circular_queue *cq = &lock_cq;\n\tstruct lock_list *lock = NULL;\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tunsigned int cq_depth;\n\tbool first;\n\n\tlockdep_assert_locked();\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, source_entry);\n\n\twhile ((lock = __bfs_next(lock, offset)) || (lock = __cq_dequeue(cq))) {\n\t\tif (!lock->class)\n\t\t\treturn BFS_EINVALIDNODE;\n\n\t\t/*\n\t\t * Step 1: check whether we already finish on this one.\n\t\t *\n\t\t * If we have visited all the dependencies from this @lock to\n\t\t * others (iow, if we have visited all lock_list entries in\n\t\t * @lock->class->locks_{after,before}) we skip, otherwise go\n\t\t * and visit all the dependencies in the list and mark this\n\t\t * list accessed.\n\t\t */\n\t\tif (lock_accessed(lock))\n\t\t\tcontinue;\n\t\telse\n\t\t\tmark_lock_accessed(lock);\n\n\t\t/*\n\t\t * Step 2: check whether prev dependency and this form a strong\n\t\t *         dependency path.\n\t\t */\n\t\tif (lock->parent) { /* Parent exists, check prev dependency */\n\t\t\tu8 dep = lock->dep;\n\t\t\tbool prev_only_xr = lock->parent->only_xr;\n\n\t\t\t/*\n\t\t\t * Mask out all -(S*)-> if we only have *R in previous\n\t\t\t * step, because -(*R)-> -(S*)-> don't make up a strong\n\t\t\t * dependency.\n\t\t\t */\n\t\t\tif (prev_only_xr)\n\t\t\t\tdep &= ~(DEP_SR_MASK | DEP_SN_MASK);\n\n\t\t\t/* If nothing left, we skip */\n\t\t\tif (!dep)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are only -(*R)-> left, set that for the next step */\n\t\t\tlock->only_xr = !(dep & (DEP_SN_MASK | DEP_EN_MASK));\n\t\t}\n\n\t\t/*\n\t\t * Step 3: we haven't visited this and there is a strong\n\t\t *         dependency path to this, so check with @match.\n\t\t *         If @skip is provide and returns true, we skip this\n\t\t *         lock (and any path this lock is in).\n\t\t */\n\t\tif (skip && skip(lock, data))\n\t\t\tcontinue;\n\n\t\tif (match(lock, data)) {\n\t\t\t*target_entry = lock;\n\t\t\treturn BFS_RMATCH;\n\t\t}\n\n\t\t/*\n\t\t * Step 4: if not match, expand the path by adding the\n\t\t *         forward or backwards dependencies in the search\n\t\t *\n\t\t */\n\t\tfirst = true;\n\t\thead = get_dep_list(lock, offset);\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tvisit_lock_entry(entry, lock);\n\n\t\t\t/*\n\t\t\t * Note we only enqueue the first of the list into the\n\t\t\t * queue, because we can always find a sibling\n\t\t\t * dependency from one (see __bfs_next()), as a result\n\t\t\t * the space of queue is saved.\n\t\t\t */\n\t\t\tif (!first)\n\t\t\t\tcontinue;\n\n\t\t\tfirst = false;\n\n\t\t\tif (__cq_enqueue(cq, entry))\n\t\t\t\treturn BFS_EQUEUEFULL;\n\n\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t}\n\t}\n\n\treturn BFS_RNOMATCH;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define DEP_EN_MASK (1U << (DEP_EN_BIT))",
            "#define DEP_SN_MASK (1U << (DEP_SN_BIT))",
            "#define DEP_SR_MASK (1U << (DEP_SR_BIT))"
          ],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define DEP_EN_MASK (1U << (DEP_EN_BIT))\n#define DEP_SN_MASK (1U << (DEP_SN_BIT))\n#define DEP_SR_MASK (1U << (DEP_SR_BIT))\n\nstatic noinstr struct;\n\nstatic enum bfs_result __bfs(struct lock_list *source_entry,\n\t\t\t     void *data,\n\t\t\t     bool (*match)(struct lock_list *entry, void *data),\n\t\t\t     bool (*skip)(struct lock_list *entry, void *data),\n\t\t\t     struct lock_list **target_entry,\n\t\t\t     int offset)\n{\n\tstruct circular_queue *cq = &lock_cq;\n\tstruct lock_list *lock = NULL;\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tunsigned int cq_depth;\n\tbool first;\n\n\tlockdep_assert_locked();\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, source_entry);\n\n\twhile ((lock = __bfs_next(lock, offset)) || (lock = __cq_dequeue(cq))) {\n\t\tif (!lock->class)\n\t\t\treturn BFS_EINVALIDNODE;\n\n\t\t/*\n\t\t * Step 1: check whether we already finish on this one.\n\t\t *\n\t\t * If we have visited all the dependencies from this @lock to\n\t\t * others (iow, if we have visited all lock_list entries in\n\t\t * @lock->class->locks_{after,before}) we skip, otherwise go\n\t\t * and visit all the dependencies in the list and mark this\n\t\t * list accessed.\n\t\t */\n\t\tif (lock_accessed(lock))\n\t\t\tcontinue;\n\t\telse\n\t\t\tmark_lock_accessed(lock);\n\n\t\t/*\n\t\t * Step 2: check whether prev dependency and this form a strong\n\t\t *         dependency path.\n\t\t */\n\t\tif (lock->parent) { /* Parent exists, check prev dependency */\n\t\t\tu8 dep = lock->dep;\n\t\t\tbool prev_only_xr = lock->parent->only_xr;\n\n\t\t\t/*\n\t\t\t * Mask out all -(S*)-> if we only have *R in previous\n\t\t\t * step, because -(*R)-> -(S*)-> don't make up a strong\n\t\t\t * dependency.\n\t\t\t */\n\t\t\tif (prev_only_xr)\n\t\t\t\tdep &= ~(DEP_SR_MASK | DEP_SN_MASK);\n\n\t\t\t/* If nothing left, we skip */\n\t\t\tif (!dep)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are only -(*R)-> left, set that for the next step */\n\t\t\tlock->only_xr = !(dep & (DEP_SN_MASK | DEP_EN_MASK));\n\t\t}\n\n\t\t/*\n\t\t * Step 3: we haven't visited this and there is a strong\n\t\t *         dependency path to this, so check with @match.\n\t\t *         If @skip is provide and returns true, we skip this\n\t\t *         lock (and any path this lock is in).\n\t\t */\n\t\tif (skip && skip(lock, data))\n\t\t\tcontinue;\n\n\t\tif (match(lock, data)) {\n\t\t\t*target_entry = lock;\n\t\t\treturn BFS_RMATCH;\n\t\t}\n\n\t\t/*\n\t\t * Step 4: if not match, expand the path by adding the\n\t\t *         forward or backwards dependencies in the search\n\t\t *\n\t\t */\n\t\tfirst = true;\n\t\thead = get_dep_list(lock, offset);\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tvisit_lock_entry(entry, lock);\n\n\t\t\t/*\n\t\t\t * Note we only enqueue the first of the list into the\n\t\t\t * queue, because we can always find a sibling\n\t\t\t * dependency from one (see __bfs_next()), as a result\n\t\t\t * the space of queue is saved.\n\t\t\t */\n\t\t\tif (!first)\n\t\t\t\tcontinue;\n\n\t\t\tfirst = false;\n\n\t\t\tif (__cq_enqueue(cq, entry))\n\t\t\t\treturn BFS_EQUEUEFULL;\n\n\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t}\n\t}\n\n\treturn BFS_RNOMATCH;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline enum bfs_result\n__bfs_forwards(struct lock_list *src_entry,\n\t       void *data,\n\t       bool (*match)(struct lock_list *entry, void *data),\n\t       bool (*skip)(struct lock_list *entry, void *data),\n\t       struct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, skip, target_entry,\n\t\t     offsetof(struct lock_class, locks_after));\n\n}"
  },
  {
    "function_name": "__bfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1688-1794",
    "snippet": "static enum bfs_result __bfs(struct lock_list *source_entry,\n\t\t\t     void *data,\n\t\t\t     bool (*match)(struct lock_list *entry, void *data),\n\t\t\t     bool (*skip)(struct lock_list *entry, void *data),\n\t\t\t     struct lock_list **target_entry,\n\t\t\t     int offset)\n{\n\tstruct circular_queue *cq = &lock_cq;\n\tstruct lock_list *lock = NULL;\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tunsigned int cq_depth;\n\tbool first;\n\n\tlockdep_assert_locked();\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, source_entry);\n\n\twhile ((lock = __bfs_next(lock, offset)) || (lock = __cq_dequeue(cq))) {\n\t\tif (!lock->class)\n\t\t\treturn BFS_EINVALIDNODE;\n\n\t\t/*\n\t\t * Step 1: check whether we already finish on this one.\n\t\t *\n\t\t * If we have visited all the dependencies from this @lock to\n\t\t * others (iow, if we have visited all lock_list entries in\n\t\t * @lock->class->locks_{after,before}) we skip, otherwise go\n\t\t * and visit all the dependencies in the list and mark this\n\t\t * list accessed.\n\t\t */\n\t\tif (lock_accessed(lock))\n\t\t\tcontinue;\n\t\telse\n\t\t\tmark_lock_accessed(lock);\n\n\t\t/*\n\t\t * Step 2: check whether prev dependency and this form a strong\n\t\t *         dependency path.\n\t\t */\n\t\tif (lock->parent) { /* Parent exists, check prev dependency */\n\t\t\tu8 dep = lock->dep;\n\t\t\tbool prev_only_xr = lock->parent->only_xr;\n\n\t\t\t/*\n\t\t\t * Mask out all -(S*)-> if we only have *R in previous\n\t\t\t * step, because -(*R)-> -(S*)-> don't make up a strong\n\t\t\t * dependency.\n\t\t\t */\n\t\t\tif (prev_only_xr)\n\t\t\t\tdep &= ~(DEP_SR_MASK | DEP_SN_MASK);\n\n\t\t\t/* If nothing left, we skip */\n\t\t\tif (!dep)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are only -(*R)-> left, set that for the next step */\n\t\t\tlock->only_xr = !(dep & (DEP_SN_MASK | DEP_EN_MASK));\n\t\t}\n\n\t\t/*\n\t\t * Step 3: we haven't visited this and there is a strong\n\t\t *         dependency path to this, so check with @match.\n\t\t *         If @skip is provide and returns true, we skip this\n\t\t *         lock (and any path this lock is in).\n\t\t */\n\t\tif (skip && skip(lock, data))\n\t\t\tcontinue;\n\n\t\tif (match(lock, data)) {\n\t\t\t*target_entry = lock;\n\t\t\treturn BFS_RMATCH;\n\t\t}\n\n\t\t/*\n\t\t * Step 4: if not match, expand the path by adding the\n\t\t *         forward or backwards dependencies in the search\n\t\t *\n\t\t */\n\t\tfirst = true;\n\t\thead = get_dep_list(lock, offset);\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tvisit_lock_entry(entry, lock);\n\n\t\t\t/*\n\t\t\t * Note we only enqueue the first of the list into the\n\t\t\t * queue, because we can always find a sibling\n\t\t\t * dependency from one (see __bfs_next()), as a result\n\t\t\t * the space of queue is saved.\n\t\t\t */\n\t\t\tif (!first)\n\t\t\t\tcontinue;\n\n\t\t\tfirst = false;\n\n\t\t\tif (__cq_enqueue(cq, entry))\n\t\t\t\treturn BFS_EQUEUEFULL;\n\n\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t}\n\t}\n\n\treturn BFS_RNOMATCH;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define DEP_EN_MASK (1U << (DEP_EN_BIT))",
      "#define DEP_SN_MASK (1U << (DEP_SN_BIT))",
      "#define DEP_SR_MASK (1U << (DEP_SR_BIT))"
    ],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cq_get_elem_count",
          "args": [
            "cq"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_get_elem_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1478-1481",
          "snippet": "static inline unsigned int  __cq_get_elem_count(struct circular_queue *cq)\n{\n\treturn (cq->rear - cq->front) & CQ_MASK;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
          ],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic noinstr struct;\n\nstatic inline unsigned int  __cq_get_elem_count(struct circular_queue *cq)\n{\n\treturn (cq->rear - cq->front) & CQ_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cq_enqueue",
          "args": [
            "cq",
            "entry"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1451-1459",
          "snippet": "static inline int __cq_enqueue(struct circular_queue *cq, struct lock_list *elem)\n{\n\tif (__cq_full(cq))\n\t\treturn -1;\n\n\tcq->element[cq->rear] = elem;\n\tcq->rear = (cq->rear + 1) & CQ_MASK;\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
          ],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic noinstr struct;\n\nstatic inline int __cq_enqueue(struct circular_queue *cq, struct lock_list *elem)\n{\n\tif (__cq_full(cq))\n\t\treturn -1;\n\n\tcq->element[cq->rear] = elem;\n\tcq->rear = (cq->rear + 1) & CQ_MASK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "visit_lock_entry",
          "args": [
            "entry",
            "lock"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "visit_lock_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1488-1492",
          "snippet": "static inline void visit_lock_entry(struct lock_list *lock,\n\t\t\t\t    struct lock_list *parent)\n{\n\tlock->parent = parent;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void visit_lock_entry(struct lock_list *lock,\n\t\t\t\t    struct lock_list *parent)\n{\n\tlock->parent = parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "entry",
            "head",
            "entry"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dep_list",
          "args": [
            "lock",
            "offset"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "get_dep_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1523-1528",
          "snippet": "static inline struct list_head *get_dep_list(struct lock_list *lock, int offset)\n{\n\tvoid *lock_class = lock->class;\n\n\treturn lock_class + offset;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct list_head *get_dep_list(struct lock_list *lock, int offset)\n{\n\tvoid *lock_class = lock->class;\n\n\treturn lock_class + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "lock",
            "data"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "5083-5117",
          "snippet": "static noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic noinstr int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t   const struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip",
          "args": [
            "lock",
            "data"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "usage_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "2833-2836",
          "snippet": "static inline bool usage_skip(struct lock_list *entry, void *mask)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline bool usage_skip(struct lock_list *entry, void *mask)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_lock_accessed",
          "args": [
            "lock"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lock_accessed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1483-1486",
          "snippet": "static inline void mark_lock_accessed(struct lock_list *lock)\n{\n\tlock->class->dep_gen_id = lockdep_dependency_gen_id;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void mark_lock_accessed(struct lock_list *lock)\n{\n\tlock->class->dep_gen_id = lockdep_dependency_gen_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_accessed",
          "args": [
            "lock"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "lock_accessed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1494-1497",
          "snippet": "static inline unsigned long lock_accessed(struct lock_list *lock)\n{\n\treturn lock->class->dep_gen_id == lockdep_dependency_gen_id;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline unsigned long lock_accessed(struct lock_list *lock)\n{\n\treturn lock->class->dep_gen_id == lockdep_dependency_gen_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cq_dequeue",
          "args": [
            "cq"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_dequeue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1465-1476",
          "snippet": "static inline struct lock_list * __cq_dequeue(struct circular_queue *cq)\n{\n\tstruct lock_list * lock;\n\n\tif (__cq_empty(cq))\n\t\treturn NULL;\n\n\tlock = cq->element[cq->front];\n\tcq->front = (cq->front + 1) & CQ_MASK;\n\n\treturn lock;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
          ],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic noinstr struct;\n\nstatic inline struct lock_list * __cq_dequeue(struct circular_queue *cq)\n{\n\tstruct lock_list * lock;\n\n\tif (__cq_empty(cq))\n\t\treturn NULL;\n\n\tlock = cq->element[cq->front];\n\tcq->front = (cq->front + 1) & CQ_MASK;\n\n\treturn lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bfs_next",
          "args": [
            "lock",
            "offset"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1652-1659",
          "snippet": "static inline struct lock_list *__bfs_next(struct lock_list *lock, int offset)\n{\n\tif (!lock || !lock->parent)\n\t\treturn NULL;\n\n\treturn list_next_or_null_rcu(get_dep_list(lock->parent, offset),\n\t\t\t\t     &lock->entry, struct lock_list, entry);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct lock_list *__bfs_next(struct lock_list *lock, int offset)\n{\n\tif (!lock || !lock->parent)\n\t\treturn NULL;\n\n\treturn list_next_or_null_rcu(get_dep_list(lock->parent, offset),\n\t\t\t\t     &lock->entry, struct lock_list, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cq_init",
          "args": [
            "cq"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1435-1439",
          "snippet": "static inline void __cq_init(struct circular_queue *cq)\n{\n\tcq->front = cq->rear = 0;\n\tlockdep_dependency_gen_id++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void __cq_init(struct circular_queue *cq)\n{\n\tcq->front = cq->rear = 0;\n\tlockdep_dependency_gen_id++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_locked",
          "args": [],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "129-132",
          "snippet": "static inline bool lockdep_assert_locked(void)\n{\n\treturn DEBUG_LOCKS_WARN_ON(__owner != current);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct task_struct *__owner;\n\nstatic inline bool lockdep_assert_locked(void)\n{\n\treturn DEBUG_LOCKS_WARN_ON(__owner != current);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define DEP_EN_MASK (1U << (DEP_EN_BIT))\n#define DEP_SN_MASK (1U << (DEP_SN_BIT))\n#define DEP_SR_MASK (1U << (DEP_SR_BIT))\n\nstatic noinstr struct;\n\nstatic enum bfs_result __bfs(struct lock_list *source_entry,\n\t\t\t     void *data,\n\t\t\t     bool (*match)(struct lock_list *entry, void *data),\n\t\t\t     bool (*skip)(struct lock_list *entry, void *data),\n\t\t\t     struct lock_list **target_entry,\n\t\t\t     int offset)\n{\n\tstruct circular_queue *cq = &lock_cq;\n\tstruct lock_list *lock = NULL;\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tunsigned int cq_depth;\n\tbool first;\n\n\tlockdep_assert_locked();\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, source_entry);\n\n\twhile ((lock = __bfs_next(lock, offset)) || (lock = __cq_dequeue(cq))) {\n\t\tif (!lock->class)\n\t\t\treturn BFS_EINVALIDNODE;\n\n\t\t/*\n\t\t * Step 1: check whether we already finish on this one.\n\t\t *\n\t\t * If we have visited all the dependencies from this @lock to\n\t\t * others (iow, if we have visited all lock_list entries in\n\t\t * @lock->class->locks_{after,before}) we skip, otherwise go\n\t\t * and visit all the dependencies in the list and mark this\n\t\t * list accessed.\n\t\t */\n\t\tif (lock_accessed(lock))\n\t\t\tcontinue;\n\t\telse\n\t\t\tmark_lock_accessed(lock);\n\n\t\t/*\n\t\t * Step 2: check whether prev dependency and this form a strong\n\t\t *         dependency path.\n\t\t */\n\t\tif (lock->parent) { /* Parent exists, check prev dependency */\n\t\t\tu8 dep = lock->dep;\n\t\t\tbool prev_only_xr = lock->parent->only_xr;\n\n\t\t\t/*\n\t\t\t * Mask out all -(S*)-> if we only have *R in previous\n\t\t\t * step, because -(*R)-> -(S*)-> don't make up a strong\n\t\t\t * dependency.\n\t\t\t */\n\t\t\tif (prev_only_xr)\n\t\t\t\tdep &= ~(DEP_SR_MASK | DEP_SN_MASK);\n\n\t\t\t/* If nothing left, we skip */\n\t\t\tif (!dep)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are only -(*R)-> left, set that for the next step */\n\t\t\tlock->only_xr = !(dep & (DEP_SN_MASK | DEP_EN_MASK));\n\t\t}\n\n\t\t/*\n\t\t * Step 3: we haven't visited this and there is a strong\n\t\t *         dependency path to this, so check with @match.\n\t\t *         If @skip is provide and returns true, we skip this\n\t\t *         lock (and any path this lock is in).\n\t\t */\n\t\tif (skip && skip(lock, data))\n\t\t\tcontinue;\n\n\t\tif (match(lock, data)) {\n\t\t\t*target_entry = lock;\n\t\t\treturn BFS_RMATCH;\n\t\t}\n\n\t\t/*\n\t\t * Step 4: if not match, expand the path by adding the\n\t\t *         forward or backwards dependencies in the search\n\t\t *\n\t\t */\n\t\tfirst = true;\n\t\thead = get_dep_list(lock, offset);\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tvisit_lock_entry(entry, lock);\n\n\t\t\t/*\n\t\t\t * Note we only enqueue the first of the list into the\n\t\t\t * queue, because we can always find a sibling\n\t\t\t * dependency from one (see __bfs_next()), as a result\n\t\t\t * the space of queue is saved.\n\t\t\t */\n\t\t\tif (!first)\n\t\t\t\tcontinue;\n\n\t\t\tfirst = false;\n\n\t\t\tif (__cq_enqueue(cq, entry))\n\t\t\t\treturn BFS_EQUEUEFULL;\n\n\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t}\n\t}\n\n\treturn BFS_RNOMATCH;\n}"
  },
  {
    "function_name": "__bfs_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1652-1659",
    "snippet": "static inline struct lock_list *__bfs_next(struct lock_list *lock, int offset)\n{\n\tif (!lock || !lock->parent)\n\t\treturn NULL;\n\n\treturn list_next_or_null_rcu(get_dep_list(lock->parent, offset),\n\t\t\t\t     &lock->entry, struct lock_list, entry);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_next_or_null_rcu",
          "args": [
            "get_dep_list(lock->parent, offset)",
            "&lock->entry",
            "structlock_list",
            "entry"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dep_list",
          "args": [
            "lock->parent",
            "offset"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "get_dep_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1523-1528",
          "snippet": "static inline struct list_head *get_dep_list(struct lock_list *lock, int offset)\n{\n\tvoid *lock_class = lock->class;\n\n\treturn lock_class + offset;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct list_head *get_dep_list(struct lock_list *lock, int offset)\n{\n\tvoid *lock_class = lock->class;\n\n\treturn lock_class + offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct lock_list *__bfs_next(struct lock_list *lock, int offset)\n{\n\tif (!lock || !lock->parent)\n\t\treturn NULL;\n\n\treturn list_next_or_null_rcu(get_dep_list(lock->parent, offset),\n\t\t\t\t     &lock->entry, struct lock_list, entry);\n}"
  },
  {
    "function_name": "bfs_init_rootb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1645-1650",
    "snippet": "static inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_init_root",
          "args": [
            "lock",
            "hlock_class(hlock)"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_init_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1615-1621",
          "snippet": "static inline void __bfs_init_root(struct lock_list *lock,\n\t\t\t\t   struct lock_class *class)\n{\n\tlock->class = class;\n\tlock->parent = NULL;\n\tlock->only_xr = 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void __bfs_init_root(struct lock_list *lock,\n\t\t\t\t   struct lock_class *class)\n{\n\tlock->class = class;\n\tlock->parent = NULL;\n\tlock->only_xr = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline void bfs_init_rootb(struct lock_list *lock,\n\t\t\t\t  struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read != 0);\n}"
  },
  {
    "function_name": "bfs_init_root",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1631-1636",
    "snippet": "static inline void bfs_init_root(struct lock_list *lock,\n\t\t\t\t struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read == 2);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_init_root",
          "args": [
            "lock",
            "hlock_class(hlock)"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_init_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1615-1621",
          "snippet": "static inline void __bfs_init_root(struct lock_list *lock,\n\t\t\t\t   struct lock_class *class)\n{\n\tlock->class = class;\n\tlock->parent = NULL;\n\tlock->only_xr = 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void __bfs_init_root(struct lock_list *lock,\n\t\t\t\t   struct lock_class *class)\n{\n\tlock->class = class;\n\tlock->parent = NULL;\n\tlock->only_xr = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline void bfs_init_root(struct lock_list *lock,\n\t\t\t\t struct held_lock *hlock)\n{\n\t__bfs_init_root(lock, hlock_class(hlock));\n\tlock->only_xr = (hlock->read == 2);\n}"
  },
  {
    "function_name": "__bfs_init_root",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1615-1621",
    "snippet": "static inline void __bfs_init_root(struct lock_list *lock,\n\t\t\t\t   struct lock_class *class)\n{\n\tlock->class = class;\n\tlock->parent = NULL;\n\tlock->only_xr = 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void __bfs_init_root(struct lock_list *lock,\n\t\t\t\t   struct lock_class *class)\n{\n\tlock->class = class;\n\tlock->parent = NULL;\n\tlock->only_xr = 0;\n}"
  },
  {
    "function_name": "calc_depb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1606-1609",
    "snippet": "static inline u8 calc_depb(struct held_lock *prev, struct held_lock *next)\n{\n\treturn 1U << __calc_dep_bitb(prev, next);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__calc_dep_bitb",
          "args": [
            "prev",
            "next"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "__calc_dep_bitb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1600-1604",
          "snippet": "static inline unsigned int\n__calc_dep_bitb(struct held_lock *prev, struct held_lock *next)\n{\n\treturn (next->read != 2) + ((prev->read == 0) << 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline unsigned int\n__calc_dep_bitb(struct held_lock *prev, struct held_lock *next)\n{\n\treturn (next->read != 2) + ((prev->read == 0) << 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline u8 calc_depb(struct held_lock *prev, struct held_lock *next)\n{\n\treturn 1U << __calc_dep_bitb(prev, next);\n}"
  },
  {
    "function_name": "__calc_dep_bitb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1600-1604",
    "snippet": "static inline unsigned int\n__calc_dep_bitb(struct held_lock *prev, struct held_lock *next)\n{\n\treturn (next->read != 2) + ((prev->read == 0) << 1);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline unsigned int\n__calc_dep_bitb(struct held_lock *prev, struct held_lock *next)\n{\n\treturn (next->read != 2) + ((prev->read == 0) << 1);\n}"
  },
  {
    "function_name": "calc_dep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1591-1594",
    "snippet": "static inline u8 calc_dep(struct held_lock *prev, struct held_lock *next)\n{\n\treturn 1U << __calc_dep_bit(prev, next);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__calc_dep_bit",
          "args": [
            "prev",
            "next"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "__calc_dep_bitb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1600-1604",
          "snippet": "static inline unsigned int\n__calc_dep_bitb(struct held_lock *prev, struct held_lock *next)\n{\n\treturn (next->read != 2) + ((prev->read == 0) << 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline unsigned int\n__calc_dep_bitb(struct held_lock *prev, struct held_lock *next)\n{\n\treturn (next->read != 2) + ((prev->read == 0) << 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline u8 calc_dep(struct held_lock *prev, struct held_lock *next)\n{\n\treturn 1U << __calc_dep_bit(prev, next);\n}"
  },
  {
    "function_name": "__calc_dep_bit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1585-1589",
    "snippet": "static inline unsigned int\n__calc_dep_bit(struct held_lock *prev, struct held_lock *next)\n{\n\treturn (prev->read == 0) + ((next->read != 2) << 1);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline unsigned int\n__calc_dep_bit(struct held_lock *prev, struct held_lock *next)\n{\n\treturn (prev->read == 0) + ((next->read != 2) << 1);\n}"
  },
  {
    "function_name": "bfs_error",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1555-1558",
    "snippet": "static inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline bool bfs_error(enum bfs_result res)\n{\n\treturn res < 0;\n}"
  },
  {
    "function_name": "get_dep_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1523-1528",
    "snippet": "static inline struct list_head *get_dep_list(struct lock_list *lock, int offset)\n{\n\tvoid *lock_class = lock->class;\n\n\treturn lock_class + offset;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct list_head *get_dep_list(struct lock_list *lock, int offset)\n{\n\tvoid *lock_class = lock->class;\n\n\treturn lock_class + offset;\n}"
  },
  {
    "function_name": "get_lock_depth",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1504-1514",
    "snippet": "static inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_lock_parent",
          "args": [
            "child"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1499-1502",
          "snippet": "static inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}"
  },
  {
    "function_name": "get_lock_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1499-1502",
    "snippet": "static inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}"
  },
  {
    "function_name": "lock_accessed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1494-1497",
    "snippet": "static inline unsigned long lock_accessed(struct lock_list *lock)\n{\n\treturn lock->class->dep_gen_id == lockdep_dependency_gen_id;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline unsigned long lock_accessed(struct lock_list *lock)\n{\n\treturn lock->class->dep_gen_id == lockdep_dependency_gen_id;\n}"
  },
  {
    "function_name": "visit_lock_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1488-1492",
    "snippet": "static inline void visit_lock_entry(struct lock_list *lock,\n\t\t\t\t    struct lock_list *parent)\n{\n\tlock->parent = parent;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void visit_lock_entry(struct lock_list *lock,\n\t\t\t\t    struct lock_list *parent)\n{\n\tlock->parent = parent;\n}"
  },
  {
    "function_name": "mark_lock_accessed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1483-1486",
    "snippet": "static inline void mark_lock_accessed(struct lock_list *lock)\n{\n\tlock->class->dep_gen_id = lockdep_dependency_gen_id;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void mark_lock_accessed(struct lock_list *lock)\n{\n\tlock->class->dep_gen_id = lockdep_dependency_gen_id;\n}"
  },
  {
    "function_name": "__cq_get_elem_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1478-1481",
    "snippet": "static inline unsigned int  __cq_get_elem_count(struct circular_queue *cq)\n{\n\treturn (cq->rear - cq->front) & CQ_MASK;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
    ],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic noinstr struct;\n\nstatic inline unsigned int  __cq_get_elem_count(struct circular_queue *cq)\n{\n\treturn (cq->rear - cq->front) & CQ_MASK;\n}"
  },
  {
    "function_name": "__cq_dequeue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1465-1476",
    "snippet": "static inline struct lock_list * __cq_dequeue(struct circular_queue *cq)\n{\n\tstruct lock_list * lock;\n\n\tif (__cq_empty(cq))\n\t\treturn NULL;\n\n\tlock = cq->element[cq->front];\n\tcq->front = (cq->front + 1) & CQ_MASK;\n\n\treturn lock;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
    ],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cq_empty",
          "args": [
            "cq"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1441-1444",
          "snippet": "static inline int __cq_empty(struct circular_queue *cq)\n{\n\treturn (cq->front == cq->rear);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int __cq_empty(struct circular_queue *cq)\n{\n\treturn (cq->front == cq->rear);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic noinstr struct;\n\nstatic inline struct lock_list * __cq_dequeue(struct circular_queue *cq)\n{\n\tstruct lock_list * lock;\n\n\tif (__cq_empty(cq))\n\t\treturn NULL;\n\n\tlock = cq->element[cq->front];\n\tcq->front = (cq->front + 1) & CQ_MASK;\n\n\treturn lock;\n}"
  },
  {
    "function_name": "__cq_enqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1451-1459",
    "snippet": "static inline int __cq_enqueue(struct circular_queue *cq, struct lock_list *elem)\n{\n\tif (__cq_full(cq))\n\t\treturn -1;\n\n\tcq->element[cq->rear] = elem;\n\tcq->rear = (cq->rear + 1) & CQ_MASK;\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
    ],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cq_full",
          "args": [
            "cq"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_full",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1446-1449",
          "snippet": "static inline int __cq_full(struct circular_queue *cq)\n{\n\treturn ((cq->rear + 1) & CQ_MASK) == cq->front;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
          ],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic noinstr struct;\n\nstatic inline int __cq_full(struct circular_queue *cq)\n{\n\treturn ((cq->rear + 1) & CQ_MASK) == cq->front;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic noinstr struct;\n\nstatic inline int __cq_enqueue(struct circular_queue *cq, struct lock_list *elem)\n{\n\tif (__cq_full(cq))\n\t\treturn -1;\n\n\tcq->element[cq->rear] = elem;\n\tcq->rear = (cq->rear + 1) & CQ_MASK;\n\treturn 0;\n}"
  },
  {
    "function_name": "__cq_full",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1446-1449",
    "snippet": "static inline int __cq_full(struct circular_queue *cq)\n{\n\treturn ((cq->rear + 1) & CQ_MASK) == cq->front;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
    ],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic noinstr struct;\n\nstatic inline int __cq_full(struct circular_queue *cq)\n{\n\treturn ((cq->rear + 1) & CQ_MASK) == cq->front;\n}"
  },
  {
    "function_name": "__cq_empty",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1441-1444",
    "snippet": "static inline int __cq_empty(struct circular_queue *cq)\n{\n\treturn (cq->front == cq->rear);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline int __cq_empty(struct circular_queue *cq)\n{\n\treturn (cq->front == cq->rear);\n}"
  },
  {
    "function_name": "__cq_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1435-1439",
    "snippet": "static inline void __cq_init(struct circular_queue *cq)\n{\n\tcq->front = cq->rear = 0;\n\tlockdep_dependency_gen_id++;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void __cq_init(struct circular_queue *cq)\n{\n\tcq->front = cq->rear = 0;\n\tlockdep_dependency_gen_id++;\n}"
  },
  {
    "function_name": "add_lock_to_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1379-1406",
    "snippet": "static int add_lock_to_list(struct lock_class *this,\n\t\t\t    struct lock_class *links_to, struct list_head *head,\n\t\t\t    unsigned long ip, u16 distance, u8 dep,\n\t\t\t    const struct lock_trace *trace)\n{\n\tstruct lock_list *entry;\n\t/*\n\t * Lock not present yet - get a new dependency struct and\n\t * add it to the list:\n\t */\n\tentry = alloc_list_entry();\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->class = this;\n\tentry->links_to = links_to;\n\tentry->dep = dep;\n\tentry->distance = distance;\n\tentry->trace = trace;\n\t/*\n\t * Both allocation and removal are done under the graph lock; but\n\t * iteration is under RCU-sched; see look_up_lock_class() and\n\t * lockdep_free_key_range().\n\t */\n\tlist_add_tail_rcu(&entry->entry, head);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&entry->entry",
            "head"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_list_entry",
          "args": [],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_list_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1358-1374",
          "snippet": "static struct lock_list *alloc_list_entry(void)\n{\n\tint idx = find_first_zero_bit(list_entries_in_use,\n\t\t\t\t      ARRAY_SIZE(list_entries));\n\n\tif (idx >= ARRAY_SIZE(list_entries)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_ENTRIES too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_list_entries++;\n\t__set_bit(idx, list_entries_in_use);\n\treturn list_entries + idx;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_list_entries;",
            "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];",
            "static DECLARE_BITMAP(list_entries_in_use, MAX_LOCKDEP_ENTRIES);",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\nstatic DECLARE_BITMAP(list_entries_in_use, MAX_LOCKDEP_ENTRIES);\nstatic noinstr struct;\n\nstatic struct lock_list *alloc_list_entry(void)\n{\n\tint idx = find_first_zero_bit(list_entries_in_use,\n\t\t\t\t      ARRAY_SIZE(list_entries));\n\n\tif (idx >= ARRAY_SIZE(list_entries)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_ENTRIES too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_list_entries++;\n\t__set_bit(idx, list_entries_in_use);\n\treturn list_entries + idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int add_lock_to_list(struct lock_class *this,\n\t\t\t    struct lock_class *links_to, struct list_head *head,\n\t\t\t    unsigned long ip, u16 distance, u8 dep,\n\t\t\t    const struct lock_trace *trace)\n{\n\tstruct lock_list *entry;\n\t/*\n\t * Lock not present yet - get a new dependency struct and\n\t * add it to the list:\n\t */\n\tentry = alloc_list_entry();\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->class = this;\n\tentry->links_to = links_to;\n\tentry->dep = dep;\n\tentry->distance = distance;\n\tentry->trace = trace;\n\t/*\n\t * Both allocation and removal are done under the graph lock; but\n\t * iteration is under RCU-sched; see look_up_lock_class() and\n\t * lockdep_free_key_range().\n\t */\n\tlist_add_tail_rcu(&entry->entry, head);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "alloc_list_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1358-1374",
    "snippet": "static struct lock_list *alloc_list_entry(void)\n{\n\tint idx = find_first_zero_bit(list_entries_in_use,\n\t\t\t\t      ARRAY_SIZE(list_entries));\n\n\tif (idx >= ARRAY_SIZE(list_entries)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_ENTRIES too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_list_entries++;\n\t__set_bit(idx, list_entries_in_use);\n\treturn list_entries + idx;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long nr_list_entries;",
      "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];",
      "static DECLARE_BITMAP(list_entries_in_use, MAX_LOCKDEP_ENTRIES);",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "idx",
            "list_entries_in_use"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lockdep_off",
          "args": [
            "\"BUG: MAX_LOCKDEP_ENTRIES too low!\""
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "490-497",
          "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define lock_stat 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "list_entries"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "list_entries_in_use",
            "ARRAY_SIZE(list_entries)"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "list_entries"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\nstatic DECLARE_BITMAP(list_entries_in_use, MAX_LOCKDEP_ENTRIES);\nstatic noinstr struct;\n\nstatic struct lock_list *alloc_list_entry(void)\n{\n\tint idx = find_first_zero_bit(list_entries_in_use,\n\t\t\t\t      ARRAY_SIZE(list_entries));\n\n\tif (idx >= ARRAY_SIZE(list_entries)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_ENTRIES too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_list_entries++;\n\t__set_bit(idx, list_entries_in_use);\n\treturn list_entries + idx;\n}"
  },
  {
    "function_name": "register_lock_class",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1249-1351",
    "snippet": "static struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key) && !is_dynamic_key(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\tinit_data_structures_once();\n\n\t/* Allocate a new lock class and add it to the hash. */\n\tclass = list_first_entry_or_null(&free_lock_classes, typeof(*class),\n\t\t\t\t\t lock_entry);\n\tif (!class) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_lock_classes++;\n\t__set_bit(class - lock_classes, lock_classes_in_use);\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tclass->name_version = count_matching_names(class);\n\tclass->wait_type_inner = lock->wait_type_inner;\n\tclass->wait_type_outer = lock->wait_type_outer;\n\tclass->lock_type = lock->lock_type;\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Remove the class from the free list and add it to the global list\n\t * of classes.\n\t */\n\tlist_move_tail(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long nr_lock_classes;",
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);",
      "static LIST_HEAD(free_lock_classes);",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "class->subclass != subclass"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_lock",
          "args": [],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "graph_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "137-151",
          "snippet": "static int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"\\n\""
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"#%d\"",
            "class->name_version"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "class"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "SOFTIRQ_verbose",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4112-4118",
          "snippet": "static int SOFTIRQ_verbose(struct lock_class *class)\n{\n#if SOFTIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int SOFTIRQ_verbose(struct lock_class *class)\n{\n#if SOFTIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&class->lock_entry",
            "&all_lock_classes"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&class->hash_entry",
            "hash_head"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_matching_names",
          "args": [
            "class"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "count_matching_names",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "839-855",
          "snippet": "static int count_matching_names(struct lock_class *new_class)\n{\n\tstruct lock_class *class;\n\tint count = 0;\n\n\tif (!new_class->name)\n\t\treturn 0;\n\n\tlist_for_each_entry(class, &all_lock_classes, lock_entry) {\n\t\tif (new_class->key - new_class->subclass == class->key)\n\t\t\treturn class->name_version;\n\t\tif (class->name && !strcmp(class->name, new_class->name))\n\t\t\tcount = max(count, class->name_version);\n\t}\n\n\treturn count + 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int count_matching_names(struct lock_class *new_class)\n{\n\tstruct lock_class *class;\n\tint count = 0;\n\n\tif (!new_class->name)\n\t\treturn 0;\n\n\tlist_for_each_entry(class, &all_lock_classes, lock_entry) {\n\t\tif (new_class->key - new_class->subclass == class->key)\n\t\t\treturn class->name_version;\n\t\tif (class->name && !strcmp(class->name, new_class->name))\n\t\t\tcount = max(count, class->name_version);\n\t}\n\n\treturn count + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&class->locks_after)"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&class->locks_after"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&class->locks_before)"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_unused_locks"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "class - lock_classes",
            "lock_classes_in_use"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lockdep_off",
          "args": [
            "\"BUG: MAX_LOCKDEP_KEYS too low!\""
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "490-497",
          "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define lock_stat 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&free_lock_classes",
            "typeof(*class)",
            "lock_entry"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*class"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_data_structures_once",
          "args": [],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "init_data_structures_once",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1150-1177",
          "snippet": "static void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static LIST_HEAD(free_lock_classes);",
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static void init_chain_block_buckets(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic LIST_HEAD(free_lock_classes);\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic void init_chain_block_buckets(void);\n\nstatic void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "class",
            "hash_head",
            "hash_entry"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "classhashentry",
          "args": [
            "key"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dynamic_key",
          "args": [
            "lock->key"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "is_dynamic_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1213-1242",
          "snippet": "static bool is_dynamic_key(const struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head;\n\tstruct lock_class_key *k;\n\tbool found = false;\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn false;\n\n\t/*\n\t * If lock debugging is disabled lock_keys_hash[] may contain\n\t * pointers to memory that has already been freed. Avoid triggering\n\t * a use-after-free in that case by returning early.\n\t */\n\tif (!debug_locks)\n\t\treturn true;\n\n\thash_head = keyhashentry(key);\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (k == key) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head lock_keys_hash[KEYHASH_SIZE];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct hlist_head lock_keys_hash[KEYHASH_SIZE];\nstatic noinstr struct;\n\nstatic bool is_dynamic_key(const struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head;\n\tstruct lock_class_key *k;\n\tbool found = false;\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn false;\n\n\t/*\n\t * If lock debugging is disabled lock_keys_hash[] may contain\n\t * pointers to memory that has already been freed. Avoid triggering\n\t * a use-after-free in that case by returning early.\n\t */\n\tif (!debug_locks)\n\t\treturn true;\n\n\thash_head = keyhashentry(key);\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (k == key) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_obj",
          "args": [
            "lock->key"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "static_obj",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "806-831",
          "snippet": "static int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assign_lock_key",
          "args": [
            "lock"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "assign_lock_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "923-956",
          "snippet": "static bool assign_lock_key(struct lockdep_map *lock)\n{\n\tunsigned long can_addr, addr = (unsigned long)lock;\n\n#ifdef __KERNEL__\n\t/*\n\t * lockdep_free_key_range() assumes that struct lock_class_key\n\t * objects do not overlap. Since we use the address of lock\n\t * objects as class key for static objects, check whether the\n\t * size of lock_class_key objects does not exceed the size of\n\t * the smallest lock object.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) > sizeof(raw_spinlock_t));\n#endif\n\n\tif (__is_kernel_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (__is_module_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (static_obj(lock))\n\t\tlock->key = (void *)lock;\n\telse {\n\t\t/* Debug-check: all keys must be persistent! */\n\t\tdebug_locks_off();\n\t\tpr_err(\"INFO: trying to register non-static key.\\n\");\n\t\tpr_err(\"The code is fine but needs lockdep annotation, or maybe\\n\");\n\t\tpr_err(\"you didn't initialize this object before use?\\n\");\n\t\tpr_err(\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic bool assign_lock_key(struct lockdep_map *lock)\n{\n\tunsigned long can_addr, addr = (unsigned long)lock;\n\n#ifdef __KERNEL__\n\t/*\n\t * lockdep_free_key_range() assumes that struct lock_class_key\n\t * objects do not overlap. Since we use the address of lock\n\t * objects as class key for static objects, check whether the\n\t * size of lock_class_key objects does not exceed the size of\n\t * the smallest lock object.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) > sizeof(raw_spinlock_t));\n#endif\n\n\tif (__is_kernel_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (__is_module_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (static_obj(lock))\n\t\tlock->key = (void *)lock;\n\telse {\n\t\t/* Debug-check: all keys must be persistent! */\n\t\tdebug_locks_off();\n\t\tpr_err(\"INFO: trying to register non-static key.\\n\");\n\t\tpr_err(\"The code is fine but needs lockdep annotation, or maybe\\n\");\n\t\tpr_err(\"you didn't initialize this object before use?\\n\");\n\t\tpr_err(\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "class"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "look_up_lock_class",
          "args": [
            "lock",
            "subclass"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "look_up_lock_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "858-916",
          "snippet": "lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tinstrumentation_begin();\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\tinstrumentation_end();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name &&\n\t\t\t\t     lock->key != &__lockdep_no_validate__);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct",
            "struct lock_class_key __lockdep_no_validate__;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstruct lock_class_key __lockdep_no_validate__;\n\nlock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tinstrumentation_begin();\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\tinstrumentation_end();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name &&\n\t\t\t\t     lock->key != &__lockdep_no_validate__);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_lock_classes;\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\nstatic LIST_HEAD(free_lock_classes);\nstatic noinstr struct;\n\nstatic struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key) && !is_dynamic_key(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\tinit_data_structures_once();\n\n\t/* Allocate a new lock class and add it to the hash. */\n\tclass = list_first_entry_or_null(&free_lock_classes, typeof(*class),\n\t\t\t\t\t lock_entry);\n\tif (!class) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tnr_lock_classes++;\n\t__set_bit(class - lock_classes, lock_classes_in_use);\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tWARN_ON_ONCE(!list_empty(&class->locks_before));\n\tWARN_ON_ONCE(!list_empty(&class->locks_after));\n\tclass->name_version = count_matching_names(class);\n\tclass->wait_type_inner = lock->wait_type_inner;\n\tclass->wait_type_outer = lock->wait_type_outer;\n\tclass->lock_type = lock->lock_type;\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Remove the class from the free list and add it to the global list\n\t * of classes.\n\t */\n\tlist_move_tail(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}"
  },
  {
    "function_name": "is_dynamic_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1213-1242",
    "snippet": "static bool is_dynamic_key(const struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head;\n\tstruct lock_class_key *k;\n\tbool found = false;\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn false;\n\n\t/*\n\t * If lock debugging is disabled lock_keys_hash[] may contain\n\t * pointers to memory that has already been freed. Avoid triggering\n\t * a use-after-free in that case by returning early.\n\t */\n\tif (!debug_locks)\n\t\treturn true;\n\n\thash_head = keyhashentry(key);\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (k == key) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head lock_keys_hash[KEYHASH_SIZE];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "k",
            "hash_head",
            "hash_entry"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyhashentry",
          "args": [
            "key"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "keyhashentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1179-1184",
          "snippet": "static inline struct hlist_head *keyhashentry(const struct lock_class_key *key)\n{\n\tunsigned long hash = hash_long((uintptr_t)key, KEYHASH_BITS);\n\n\treturn lock_keys_hash + hash;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define KEYHASH_BITS\t\t(MAX_LOCKDEP_KEYS_BITS - 1)"
          ],
          "globals_used": [
            "static struct hlist_head lock_keys_hash[KEYHASH_SIZE];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define KEYHASH_BITS\t\t(MAX_LOCKDEP_KEYS_BITS - 1)\n\nstatic struct hlist_head lock_keys_hash[KEYHASH_SIZE];\nstatic noinstr struct;\n\nstatic inline struct hlist_head *keyhashentry(const struct lock_class_key *key)\n{\n\tunsigned long hash = hash_long((uintptr_t)key, KEYHASH_BITS);\n\n\treturn lock_keys_hash + hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "static_obj(key)"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_obj",
          "args": [
            "key"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "static_obj",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "806-831",
          "snippet": "static int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct hlist_head lock_keys_hash[KEYHASH_SIZE];\nstatic noinstr struct;\n\nstatic bool is_dynamic_key(const struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head;\n\tstruct lock_class_key *k;\n\tbool found = false;\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn false;\n\n\t/*\n\t * If lock debugging is disabled lock_keys_hash[] may contain\n\t * pointers to memory that has already been freed. Avoid triggering\n\t * a use-after-free in that case by returning early.\n\t */\n\tif (!debug_locks)\n\t\treturn true;\n\n\thash_head = keyhashentry(key);\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (k == key) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}"
  },
  {
    "function_name": "lockdep_register_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1187-1209",
    "snippet": "void lockdep_register_key(struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head;\n\tstruct lock_class_key *k;\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn;\n\thash_head = keyhashentry(key);\n\n\traw_local_irq_save(flags);\n\tif (!graph_lock())\n\t\tgoto restore_irqs;\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (WARN_ON_ONCE(k == key))\n\t\t\tgoto out_unlock;\n\t}\n\thlist_add_head_rcu(&key->hash_entry, hash_head);\nout_unlock:\n\tgraph_unlock();\nrestore_irqs:\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&key->hash_entry",
            "hash_head"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "k == key"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "k",
            "hash_head",
            "hash_entry"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_lock",
          "args": [],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "graph_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "137-151",
          "snippet": "static int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyhashentry",
          "args": [
            "key"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "keyhashentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1179-1184",
          "snippet": "static inline struct hlist_head *keyhashentry(const struct lock_class_key *key)\n{\n\tunsigned long hash = hash_long((uintptr_t)key, KEYHASH_BITS);\n\n\treturn lock_keys_hash + hash;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define KEYHASH_BITS\t\t(MAX_LOCKDEP_KEYS_BITS - 1)"
          ],
          "globals_used": [
            "static struct hlist_head lock_keys_hash[KEYHASH_SIZE];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define KEYHASH_BITS\t\t(MAX_LOCKDEP_KEYS_BITS - 1)\n\nstatic struct hlist_head lock_keys_hash[KEYHASH_SIZE];\nstatic noinstr struct;\n\nstatic inline struct hlist_head *keyhashentry(const struct lock_class_key *key)\n{\n\tunsigned long hash = hash_long((uintptr_t)key, KEYHASH_BITS);\n\n\treturn lock_keys_hash + hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "static_obj(key)"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_obj",
          "args": [
            "key"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "static_obj",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "806-831",
          "snippet": "static int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_register_key(struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head;\n\tstruct lock_class_key *k;\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn;\n\thash_head = keyhashentry(key);\n\n\traw_local_irq_save(flags);\n\tif (!graph_lock())\n\t\tgoto restore_irqs;\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (WARN_ON_ONCE(k == key))\n\t\t\tgoto out_unlock;\n\t}\n\thlist_add_head_rcu(&key->hash_entry, hash_head);\nout_unlock:\n\tgraph_unlock();\nrestore_irqs:\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "keyhashentry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1179-1184",
    "snippet": "static inline struct hlist_head *keyhashentry(const struct lock_class_key *key)\n{\n\tunsigned long hash = hash_long((uintptr_t)key, KEYHASH_BITS);\n\n\treturn lock_keys_hash + hash;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define KEYHASH_BITS\t\t(MAX_LOCKDEP_KEYS_BITS - 1)"
    ],
    "globals_used": [
      "static struct hlist_head lock_keys_hash[KEYHASH_SIZE];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_long",
          "args": [
            "(uintptr_t)key",
            "KEYHASH_BITS"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define KEYHASH_BITS\t\t(MAX_LOCKDEP_KEYS_BITS - 1)\n\nstatic struct hlist_head lock_keys_hash[KEYHASH_SIZE];\nstatic noinstr struct;\n\nstatic inline struct hlist_head *keyhashentry(const struct lock_class_key *key)\n{\n\tunsigned long hash = hash_long((uintptr_t)key, KEYHASH_BITS);\n\n\treturn lock_keys_hash + hash;\n}"
  },
  {
    "function_name": "init_data_structures_once",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1150-1177",
    "snippet": "static void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static LIST_HEAD(free_lock_classes);",
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static void init_chain_block_buckets(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_chain_block_buckets",
          "args": [],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "init_chain_block_buckets",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3822-3822",
          "snippet": "static void init_chain_block_buckets(void)\t{ }",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_chain_block_buckets(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void init_chain_block_buckets(void);\n\nstatic void init_chain_block_buckets(void)\t{ }"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lock_classes[i].locks_before"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lock_classes[i].locks_after"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lock_classes[i].lock_entry",
            "&free_lock_classes"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_classes"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&delayed_free.pf[1].zapped"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&delayed_free.pf[0].zapped"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rcu_head",
          "args": [
            "&delayed_free.rcu_head"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "init_rcu_head_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "438-441",
          "snippet": "void init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rcu_head_initialized"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic LIST_HEAD(free_lock_classes);\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic void init_chain_block_buckets(void);\n\nstatic void init_data_structures_once(void)\n{\n\tstatic bool __read_mostly ds_initialized, rcu_head_initialized;\n\tint i;\n\n\tif (likely(rcu_head_initialized))\n\t\treturn;\n\n\tif (system_state >= SYSTEM_SCHEDULING) {\n\t\tinit_rcu_head(&delayed_free.rcu_head);\n\t\trcu_head_initialized = true;\n\t}\n\n\tif (ds_initialized)\n\t\treturn;\n\n\tds_initialized = true;\n\n\tINIT_LIST_HEAD(&delayed_free.pf[0].zapped);\n\tINIT_LIST_HEAD(&delayed_free.pf[1].zapped);\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tlist_add_tail(&lock_classes[i].lock_entry, &free_lock_classes);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_after);\n\t\tINIT_LIST_HEAD(&lock_classes[i].locks_before);\n\t}\n\tinit_chain_block_buckets();\n}"
  },
  {
    "function_name": "check_data_structures",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1140-1140",
    "snippet": "static inline void check_data_structures(void) { }",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void check_data_structures(void) { }"
  },
  {
    "function_name": "check_data_structures",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1126-1136",
    "snippet": "static void check_data_structures(void)\n{\n\tstatic bool once = false;\n\n\tif (check_consistency && !once) {\n\t\tif (!__check_data_structures()) {\n\t\t\tonce = true;\n\t\t\tWARN_ON(once);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "once"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__check_data_structures",
          "args": [],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "__check_data_structures",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1050-1121",
          "snippet": "static bool __check_data_structures(void)\n{\n\tstruct lock_class *class;\n\tstruct lock_chain *chain;\n\tstruct hlist_head *head;\n\tstruct lock_list *e;\n\tint i;\n\n\t/* Check whether all classes occur in a lock list. */\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (!in_list(&class->lock_entry, &all_lock_classes) &&\n\t\t    !in_list(&class->lock_entry, &free_lock_classes) &&\n\t\t    !in_any_zapped_class_list(class)) {\n\t\t\tprintk(KERN_INFO \"class %px/%s is not in any class list\\n\",\n\t\t\t       class, class->name ? : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* Check whether all classes have valid lock lists. */\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (!class_lock_list_valid(class, &class->locks_before))\n\t\t\treturn false;\n\t\tif (!class_lock_list_valid(class, &class->locks_after))\n\t\t\treturn false;\n\t}\n\n\t/* Check the chain_key of all lock chains. */\n\tfor (i = 0; i < ARRAY_SIZE(chainhash_table); i++) {\n\t\thead = chainhash_table + i;\n\t\thlist_for_each_entry_rcu(chain, head, entry) {\n\t\t\tif (!check_lock_chain_key(chain))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Check whether all list entries that are in use occur in a class\n\t * lock list.\n\t */\n\tfor_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\te = list_entries + i;\n\t\tif (!in_any_class_list(&e->entry)) {\n\t\t\tprintk(KERN_INFO \"list entry %d is not in any class list; class %s <> %s\\n\",\n\t\t\t       (unsigned int)(e - list_entries),\n\t\t\t       e->class->name ? : \"(?)\",\n\t\t\t       e->links_to->name ? : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Check whether all list entries that are not in use do not occur in\n\t * a class lock list.\n\t */\n\tfor_each_clear_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\te = list_entries + i;\n\t\tif (in_any_class_list(&e->entry)) {\n\t\t\tprintk(KERN_INFO \"list entry %d occurs in a class list; class %s <> %s\\n\",\n\t\t\t       (unsigned int)(e - list_entries),\n\t\t\t       e->class && e->class->name ? e->class->name :\n\t\t\t       \"(?)\",\n\t\t\t       e->links_to && e->links_to->name ?\n\t\t\t       e->links_to->name : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];",
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static LIST_HEAD(free_lock_classes);",
            "static struct hlist_head chainhash_table[CHAINHASH_SIZE];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic LIST_HEAD(free_lock_classes);\nstatic struct hlist_head chainhash_table[CHAINHASH_SIZE];\nstatic noinstr struct;\n\nstatic bool __check_data_structures(void)\n{\n\tstruct lock_class *class;\n\tstruct lock_chain *chain;\n\tstruct hlist_head *head;\n\tstruct lock_list *e;\n\tint i;\n\n\t/* Check whether all classes occur in a lock list. */\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (!in_list(&class->lock_entry, &all_lock_classes) &&\n\t\t    !in_list(&class->lock_entry, &free_lock_classes) &&\n\t\t    !in_any_zapped_class_list(class)) {\n\t\t\tprintk(KERN_INFO \"class %px/%s is not in any class list\\n\",\n\t\t\t       class, class->name ? : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* Check whether all classes have valid lock lists. */\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (!class_lock_list_valid(class, &class->locks_before))\n\t\t\treturn false;\n\t\tif (!class_lock_list_valid(class, &class->locks_after))\n\t\t\treturn false;\n\t}\n\n\t/* Check the chain_key of all lock chains. */\n\tfor (i = 0; i < ARRAY_SIZE(chainhash_table); i++) {\n\t\thead = chainhash_table + i;\n\t\thlist_for_each_entry_rcu(chain, head, entry) {\n\t\t\tif (!check_lock_chain_key(chain))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Check whether all list entries that are in use occur in a class\n\t * lock list.\n\t */\n\tfor_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\te = list_entries + i;\n\t\tif (!in_any_class_list(&e->entry)) {\n\t\t\tprintk(KERN_INFO \"list entry %d is not in any class list; class %s <> %s\\n\",\n\t\t\t       (unsigned int)(e - list_entries),\n\t\t\t       e->class->name ? : \"(?)\",\n\t\t\t       e->links_to->name ? : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Check whether all list entries that are not in use do not occur in\n\t * a class lock list.\n\t */\n\tfor_each_clear_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\te = list_entries + i;\n\t\tif (in_any_class_list(&e->entry)) {\n\t\t\tprintk(KERN_INFO \"list entry %d occurs in a class list; class %s <> %s\\n\",\n\t\t\t       (unsigned int)(e - list_entries),\n\t\t\t       e->class && e->class->name ? e->class->name :\n\t\t\t       \"(?)\",\n\t\t\t       e->links_to && e->links_to->name ?\n\t\t\t       e->links_to->name : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_data_structures(void)\n{\n\tstatic bool once = false;\n\n\tif (check_consistency && !once) {\n\t\tif (!__check_data_structures()) {\n\t\t\tonce = true;\n\t\t\tWARN_ON(once);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__check_data_structures",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1050-1121",
    "snippet": "static bool __check_data_structures(void)\n{\n\tstruct lock_class *class;\n\tstruct lock_chain *chain;\n\tstruct hlist_head *head;\n\tstruct lock_list *e;\n\tint i;\n\n\t/* Check whether all classes occur in a lock list. */\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (!in_list(&class->lock_entry, &all_lock_classes) &&\n\t\t    !in_list(&class->lock_entry, &free_lock_classes) &&\n\t\t    !in_any_zapped_class_list(class)) {\n\t\t\tprintk(KERN_INFO \"class %px/%s is not in any class list\\n\",\n\t\t\t       class, class->name ? : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* Check whether all classes have valid lock lists. */\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (!class_lock_list_valid(class, &class->locks_before))\n\t\t\treturn false;\n\t\tif (!class_lock_list_valid(class, &class->locks_after))\n\t\t\treturn false;\n\t}\n\n\t/* Check the chain_key of all lock chains. */\n\tfor (i = 0; i < ARRAY_SIZE(chainhash_table); i++) {\n\t\thead = chainhash_table + i;\n\t\thlist_for_each_entry_rcu(chain, head, entry) {\n\t\t\tif (!check_lock_chain_key(chain))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Check whether all list entries that are in use occur in a class\n\t * lock list.\n\t */\n\tfor_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\te = list_entries + i;\n\t\tif (!in_any_class_list(&e->entry)) {\n\t\t\tprintk(KERN_INFO \"list entry %d is not in any class list; class %s <> %s\\n\",\n\t\t\t       (unsigned int)(e - list_entries),\n\t\t\t       e->class->name ? : \"(?)\",\n\t\t\t       e->links_to->name ? : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Check whether all list entries that are not in use do not occur in\n\t * a class lock list.\n\t */\n\tfor_each_clear_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\te = list_entries + i;\n\t\tif (in_any_class_list(&e->entry)) {\n\t\t\tprintk(KERN_INFO \"list entry %d occurs in a class list; class %s <> %s\\n\",\n\t\t\t       (unsigned int)(e - list_entries),\n\t\t\t       e->class && e->class->name ? e->class->name :\n\t\t\t       \"(?)\",\n\t\t\t       e->links_to && e->links_to->name ?\n\t\t\t       e->links_to->name : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];",
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static LIST_HEAD(free_lock_classes);",
      "static struct hlist_head chainhash_table[CHAINHASH_SIZE];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"list entry %d occurs in a class list; class %s <> %s\\n\"",
            "(unsigned int)(e - list_entries)",
            "e->class && e->class->name ? e->class->name :\n\t\t\t       \"(?)\"",
            "e->links_to && e->links_to->name ?\n\t\t\t       e->links_to->name : \"(?)\""
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_any_class_list",
          "args": [
            "&e->entry"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "in_any_class_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "977-989",
          "snippet": "static bool in_any_class_list(struct list_head *e)\n{\n\tstruct lock_class *class;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (in_list(e, &class->locks_after) ||\n\t\t    in_list(e, &class->locks_before))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic bool in_any_class_list(struct list_head *e)\n{\n\tstruct lock_class *class;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (in_list(e, &class->locks_after) ||\n\t\t    in_list(e, &class->locks_before))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_clear_bit",
          "args": [
            "i",
            "list_entries_in_use",
            "ARRAY_SIZE(list_entries)"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "list_entries"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "list_entries_in_use",
            "ARRAY_SIZE(list_entries)"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "list_entries"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_lock_chain_key",
          "args": [
            "chain"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "check_lock_chain_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1014-1035",
          "snippet": "static bool check_lock_chain_key(struct lock_chain *chain)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tint i;\n\n\tfor (i = chain->base; i < chain->base + chain->depth; i++)\n\t\tchain_key = iterate_chain_key(chain_key, chain_hlocks[i]);\n\t/*\n\t * The 'unsigned long long' casts avoid that a compiler warning\n\t * is reported when building tools/lib/lockdep.\n\t */\n\tif (chain->chain_key != chain_key) {\n\t\tprintk(KERN_INFO \"chain %lld: key %#llx <> %#llx\\n\",\n\t\t       (unsigned long long)(chain - lock_chains),\n\t\t       (unsigned long long)chain->chain_key,\n\t\t       (unsigned long long)chain_key);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic bool check_lock_chain_key(struct lock_chain *chain)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tint i;\n\n\tfor (i = chain->base; i < chain->base + chain->depth; i++)\n\t\tchain_key = iterate_chain_key(chain_key, chain_hlocks[i]);\n\t/*\n\t * The 'unsigned long long' casts avoid that a compiler warning\n\t * is reported when building tools/lib/lockdep.\n\t */\n\tif (chain->chain_key != chain_key) {\n\t\tprintk(KERN_INFO \"chain %lld: key %#llx <> %#llx\\n\",\n\t\t       (unsigned long long)(chain - lock_chains),\n\t\t       (unsigned long long)chain->chain_key,\n\t\t       (unsigned long long)chain_key);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "chain",
            "head",
            "entry"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "chainhash_table"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "class_lock_list_valid",
          "args": [
            "class",
            "&class->locks_after"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "class_lock_list_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "991-1008",
          "snippet": "static bool class_lock_list_valid(struct lock_class *c, struct list_head *h)\n{\n\tstruct lock_list *e;\n\n\tlist_for_each_entry(e, h, entry) {\n\t\tif (e->links_to != c) {\n\t\t\tprintk(KERN_INFO \"class %s: mismatch for lock entry %ld; class %s <> %s\",\n\t\t\t       c->name ? : \"(?)\",\n\t\t\t       (unsigned long)(e - list_entries),\n\t\t\t       e->links_to && e->links_to->name ?\n\t\t\t       e->links_to->name : \"(?)\",\n\t\t\t       e->class && e->class->name ? e->class->name :\n\t\t\t       \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\nstatic noinstr struct;\n\nstatic bool class_lock_list_valid(struct lock_class *c, struct list_head *h)\n{\n\tstruct lock_list *e;\n\n\tlist_for_each_entry(e, h, entry) {\n\t\tif (e->links_to != c) {\n\t\t\tprintk(KERN_INFO \"class %s: mismatch for lock entry %ld; class %s <> %s\",\n\t\t\t       c->name ? : \"(?)\",\n\t\t\t       (unsigned long)(e - list_entries),\n\t\t\t       e->links_to && e->links_to->name ?\n\t\t\t       e->links_to->name : \"(?)\",\n\t\t\t       e->class && e->class->name ? e->class->name :\n\t\t\t       \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_classes"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_any_zapped_class_list",
          "args": [
            "class"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "in_any_zapped_class_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1037-1048",
          "snippet": "static bool in_any_zapped_class_list(struct lock_class *class)\n{\n\tstruct pending_free *pf;\n\tint i;\n\n\tfor (i = 0, pf = delayed_free.pf; i < ARRAY_SIZE(delayed_free.pf); i++, pf++) {\n\t\tif (in_list(&class->lock_entry, &pf->zapped))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic bool in_any_zapped_class_list(struct lock_class *class)\n{\n\tstruct pending_free *pf;\n\tint i;\n\n\tfor (i = 0, pf = delayed_free.pf; i < ARRAY_SIZE(delayed_free.pf); i++, pf++) {\n\t\tif (in_list(&class->lock_entry, &pf->zapped))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_list",
          "args": [
            "&class->lock_entry",
            "&free_lock_classes"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "in_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "961-971",
          "snippet": "static bool in_list(struct list_head *e, struct list_head *h)\n{\n\tstruct list_head *f;\n\n\tlist_for_each(f, h) {\n\t\tif (e == f)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic bool in_list(struct list_head *e, struct list_head *h)\n{\n\tstruct list_head *f;\n\n\tlist_for_each(f, h) {\n\t\tif (e == f)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_classes"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic LIST_HEAD(free_lock_classes);\nstatic struct hlist_head chainhash_table[CHAINHASH_SIZE];\nstatic noinstr struct;\n\nstatic bool __check_data_structures(void)\n{\n\tstruct lock_class *class;\n\tstruct lock_chain *chain;\n\tstruct hlist_head *head;\n\tstruct lock_list *e;\n\tint i;\n\n\t/* Check whether all classes occur in a lock list. */\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (!in_list(&class->lock_entry, &all_lock_classes) &&\n\t\t    !in_list(&class->lock_entry, &free_lock_classes) &&\n\t\t    !in_any_zapped_class_list(class)) {\n\t\t\tprintk(KERN_INFO \"class %px/%s is not in any class list\\n\",\n\t\t\t       class, class->name ? : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* Check whether all classes have valid lock lists. */\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (!class_lock_list_valid(class, &class->locks_before))\n\t\t\treturn false;\n\t\tif (!class_lock_list_valid(class, &class->locks_after))\n\t\t\treturn false;\n\t}\n\n\t/* Check the chain_key of all lock chains. */\n\tfor (i = 0; i < ARRAY_SIZE(chainhash_table); i++) {\n\t\thead = chainhash_table + i;\n\t\thlist_for_each_entry_rcu(chain, head, entry) {\n\t\t\tif (!check_lock_chain_key(chain))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Check whether all list entries that are in use occur in a class\n\t * lock list.\n\t */\n\tfor_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\te = list_entries + i;\n\t\tif (!in_any_class_list(&e->entry)) {\n\t\t\tprintk(KERN_INFO \"list entry %d is not in any class list; class %s <> %s\\n\",\n\t\t\t       (unsigned int)(e - list_entries),\n\t\t\t       e->class->name ? : \"(?)\",\n\t\t\t       e->links_to->name ? : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Check whether all list entries that are not in use do not occur in\n\t * a class lock list.\n\t */\n\tfor_each_clear_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {\n\t\te = list_entries + i;\n\t\tif (in_any_class_list(&e->entry)) {\n\t\t\tprintk(KERN_INFO \"list entry %d occurs in a class list; class %s <> %s\\n\",\n\t\t\t       (unsigned int)(e - list_entries),\n\t\t\t       e->class && e->class->name ? e->class->name :\n\t\t\t       \"(?)\",\n\t\t\t       e->links_to && e->links_to->name ?\n\t\t\t       e->links_to->name : \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "in_any_zapped_class_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1037-1048",
    "snippet": "static bool in_any_zapped_class_list(struct lock_class *class)\n{\n\tstruct pending_free *pf;\n\tint i;\n\n\tfor (i = 0, pf = delayed_free.pf; i < ARRAY_SIZE(delayed_free.pf); i++, pf++) {\n\t\tif (in_list(&class->lock_entry, &pf->zapped))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_list",
          "args": [
            "&class->lock_entry",
            "&pf->zapped"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "in_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "961-971",
          "snippet": "static bool in_list(struct list_head *e, struct list_head *h)\n{\n\tstruct list_head *f;\n\n\tlist_for_each(f, h) {\n\t\tif (e == f)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic bool in_list(struct list_head *e, struct list_head *h)\n{\n\tstruct list_head *f;\n\n\tlist_for_each(f, h) {\n\t\tif (e == f)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "delayed_free.pf"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nstatic bool in_any_zapped_class_list(struct lock_class *class)\n{\n\tstruct pending_free *pf;\n\tint i;\n\n\tfor (i = 0, pf = delayed_free.pf; i < ARRAY_SIZE(delayed_free.pf); i++, pf++) {\n\t\tif (in_list(&class->lock_entry, &pf->zapped))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "check_lock_chain_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "1014-1035",
    "snippet": "static bool check_lock_chain_key(struct lock_chain *chain)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tint i;\n\n\tfor (i = chain->base; i < chain->base + chain->depth; i++)\n\t\tchain_key = iterate_chain_key(chain_key, chain_hlocks[i]);\n\t/*\n\t * The 'unsigned long long' casts avoid that a compiler warning\n\t * is reported when building tools/lib/lockdep.\n\t */\n\tif (chain->chain_key != chain_key) {\n\t\tprintk(KERN_INFO \"chain %lld: key %#llx <> %#llx\\n\",\n\t\t       (unsigned long long)(chain - lock_chains),\n\t\t       (unsigned long long)chain->chain_key,\n\t\t       (unsigned long long)chain_key);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"chain %lld: key %#llx <> %#llx\\n\"",
            "(unsigned long long)(chain - lock_chains)",
            "(unsigned long long)chain->chain_key",
            "(unsigned long long)chain_key"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_chain_key",
          "args": [
            "chain_key",
            "chain_hlocks[i]"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_chain_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "415-422",
          "snippet": "static inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic bool check_lock_chain_key(struct lock_chain *chain)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tu64 chain_key = INITIAL_CHAIN_KEY;\n\tint i;\n\n\tfor (i = chain->base; i < chain->base + chain->depth; i++)\n\t\tchain_key = iterate_chain_key(chain_key, chain_hlocks[i]);\n\t/*\n\t * The 'unsigned long long' casts avoid that a compiler warning\n\t * is reported when building tools/lib/lockdep.\n\t */\n\tif (chain->chain_key != chain_key) {\n\t\tprintk(KERN_INFO \"chain %lld: key %#llx <> %#llx\\n\",\n\t\t       (unsigned long long)(chain - lock_chains),\n\t\t       (unsigned long long)chain->chain_key,\n\t\t       (unsigned long long)chain_key);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}"
  },
  {
    "function_name": "class_lock_list_valid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "991-1008",
    "snippet": "static bool class_lock_list_valid(struct lock_class *c, struct list_head *h)\n{\n\tstruct lock_list *e;\n\n\tlist_for_each_entry(e, h, entry) {\n\t\tif (e->links_to != c) {\n\t\t\tprintk(KERN_INFO \"class %s: mismatch for lock entry %ld; class %s <> %s\",\n\t\t\t       c->name ? : \"(?)\",\n\t\t\t       (unsigned long)(e - list_entries),\n\t\t\t       e->links_to && e->links_to->name ?\n\t\t\t       e->links_to->name : \"(?)\",\n\t\t\t       e->class && e->class->name ? e->class->name :\n\t\t\t       \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"class %s: mismatch for lock entry %ld; class %s <> %s\"",
            "c->name ? : \"(?)\"",
            "(unsigned long)(e - list_entries)",
            "e->links_to && e->links_to->name ?\n\t\t\t       e->links_to->name : \"(?)\"",
            "e->class && e->class->name ? e->class->name :\n\t\t\t       \"(?)\""
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "e",
            "h",
            "entry"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\nstatic noinstr struct;\n\nstatic bool class_lock_list_valid(struct lock_class *c, struct list_head *h)\n{\n\tstruct lock_list *e;\n\n\tlist_for_each_entry(e, h, entry) {\n\t\tif (e->links_to != c) {\n\t\t\tprintk(KERN_INFO \"class %s: mismatch for lock entry %ld; class %s <> %s\",\n\t\t\t       c->name ? : \"(?)\",\n\t\t\t       (unsigned long)(e - list_entries),\n\t\t\t       e->links_to && e->links_to->name ?\n\t\t\t       e->links_to->name : \"(?)\",\n\t\t\t       e->class && e->class->name ? e->class->name :\n\t\t\t       \"(?)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "in_any_class_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "977-989",
    "snippet": "static bool in_any_class_list(struct list_head *e)\n{\n\tstruct lock_class *class;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (in_list(e, &class->locks_after) ||\n\t\t    in_list(e, &class->locks_before))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_list",
          "args": [
            "e",
            "&class->locks_before"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "in_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "961-971",
          "snippet": "static bool in_list(struct list_head *e, struct list_head *h)\n{\n\tstruct list_head *f;\n\n\tlist_for_each(f, h) {\n\t\tif (e == f)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic bool in_list(struct list_head *e, struct list_head *h)\n{\n\tstruct list_head *f;\n\n\tlist_for_each(f, h) {\n\t\tif (e == f)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_classes"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic bool in_any_class_list(struct list_head *e)\n{\n\tstruct lock_class *class;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_classes); i++) {\n\t\tclass = &lock_classes[i];\n\t\tif (in_list(e, &class->locks_after) ||\n\t\t    in_list(e, &class->locks_before))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "in_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "961-971",
    "snippet": "static bool in_list(struct list_head *e, struct list_head *h)\n{\n\tstruct list_head *f;\n\n\tlist_for_each(f, h) {\n\t\tif (e == f)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "f",
            "h"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic bool in_list(struct list_head *e, struct list_head *h)\n{\n\tstruct list_head *f;\n\n\tlist_for_each(f, h) {\n\t\tif (e == f)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "assign_lock_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "923-956",
    "snippet": "static bool assign_lock_key(struct lockdep_map *lock)\n{\n\tunsigned long can_addr, addr = (unsigned long)lock;\n\n#ifdef __KERNEL__\n\t/*\n\t * lockdep_free_key_range() assumes that struct lock_class_key\n\t * objects do not overlap. Since we use the address of lock\n\t * objects as class key for static objects, check whether the\n\t * size of lock_class_key objects does not exceed the size of\n\t * the smallest lock object.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) > sizeof(raw_spinlock_t));\n#endif\n\n\tif (__is_kernel_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (__is_module_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (static_obj(lock))\n\t\tlock->key = (void *)lock;\n\telse {\n\t\t/* Debug-check: all keys must be persistent! */\n\t\tdebug_locks_off();\n\t\tpr_err(\"INFO: trying to register non-static key.\\n\");\n\t\tpr_err(\"The code is fine but needs lockdep annotation, or maybe\\n\");\n\t\tpr_err(\"you didn't initialize this object before use?\\n\");\n\t\tpr_err(\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"turning off the locking correctness validator.\\n\""
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"you didn't initialize this object before use?\\n\""
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"The code is fine but needs lockdep annotation, or maybe\\n\""
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: trying to register non-static key.\\n\""
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_obj",
          "args": [
            "lock"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "static_obj",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "806-831",
          "snippet": "static int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__is_module_percpu_address",
          "args": [
            "addr",
            "&can_addr"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "__is_module_percpu_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "710-713",
          "snippet": "bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)\n{\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__is_kernel_percpu_address",
          "args": [
            "addr",
            "&can_addr"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct lock_class_key) > sizeof(raw_spinlock_t)"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic bool assign_lock_key(struct lockdep_map *lock)\n{\n\tunsigned long can_addr, addr = (unsigned long)lock;\n\n#ifdef __KERNEL__\n\t/*\n\t * lockdep_free_key_range() assumes that struct lock_class_key\n\t * objects do not overlap. Since we use the address of lock\n\t * objects as class key for static objects, check whether the\n\t * size of lock_class_key objects does not exceed the size of\n\t * the smallest lock object.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) > sizeof(raw_spinlock_t));\n#endif\n\n\tif (__is_kernel_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (__is_module_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (static_obj(lock))\n\t\tlock->key = (void *)lock;\n\telse {\n\t\t/* Debug-check: all keys must be persistent! */\n\t\tdebug_locks_off();\n\t\tpr_err(\"INFO: trying to register non-static key.\\n\");\n\t\tpr_err(\"The code is fine but needs lockdep annotation, or maybe\\n\");\n\t\tpr_err(\"you didn't initialize this object before use?\\n\");\n\t\tpr_err(\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "look_up_lock_class",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "858-916",
    "snippet": "lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tinstrumentation_begin();\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\tinstrumentation_end();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name &&\n\t\t\t\t     lock->key != &__lockdep_no_validate__);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "struct lock_class_key __lockdep_no_validate__;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "class->name != lock->name &&\n\t\t\t\t     lock->key != &__lockdep_no_validate__"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu_notrace",
          "args": [
            "class",
            "hash_head",
            "hash_entry"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "classhashentry",
          "args": [
            "key"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lock->key"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\""
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\"",
            "subclass"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "subclass >= MAX_LOCKDEP_SUBCLASSES"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstruct lock_class_key __lockdep_no_validate__;\n\nlock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tinstrumentation_begin();\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\tinstrumentation_end();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name &&\n\t\t\t\t     lock->key != &__lockdep_no_validate__);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "count_matching_names",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "839-855",
    "snippet": "static int count_matching_names(struct lock_class *new_class)\n{\n\tstruct lock_class *class;\n\tint count = 0;\n\n\tif (!new_class->name)\n\t\treturn 0;\n\n\tlist_for_each_entry(class, &all_lock_classes, lock_entry) {\n\t\tif (new_class->key - new_class->subclass == class->key)\n\t\t\treturn class->name_version;\n\t\tif (class->name && !strcmp(class->name, new_class->name))\n\t\t\tcount = max(count, class->name_version);\n\t}\n\n\treturn count + 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "count",
            "class->name_version"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "class->name",
            "new_class->name"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "class",
            "&all_lock_classes",
            "lock_entry"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int count_matching_names(struct lock_class *new_class)\n{\n\tstruct lock_class *class;\n\tint count = 0;\n\n\tif (!new_class->name)\n\t\treturn 0;\n\n\tlist_for_each_entry(class, &all_lock_classes, lock_entry) {\n\t\tif (new_class->key - new_class->subclass == class->key)\n\t\t\treturn class->name_version;\n\t\tif (class->name && !strcmp(class->name, new_class->name))\n\t\t\tcount = max(count, class->name_version);\n\t}\n\n\treturn count + 1;\n}"
  },
  {
    "function_name": "static_obj",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "806-831",
    "snippet": "static int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_module_percpu_address",
          "args": [
            "addr"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "is_module_percpu_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "705-708",
          "snippet": "bool is_module_percpu_address(unsigned long addr)\n{\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool is_module_percpu_address(unsigned long addr)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_module_address",
          "args": [
            "addr"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "is_module_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4718-4727",
          "snippet": "bool is_module_address(unsigned long addr)\n{\n\tbool ret;\n\n\tpreempt_disable();\n\tret = __module_address(addr) != NULL;\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool is_module_address(unsigned long addr)\n{\n\tbool ret;\n\n\tpreempt_disable();\n\tret = __module_address(addr) != NULL;\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_kernel_percpu_address",
          "args": [
            "addr"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_is_kernel_initmem_freed",
          "args": [
            "addr"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "arch_is_kernel_initmem_freed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "797-803",
          "snippet": "static int arch_is_kernel_initmem_freed(unsigned long addr)\n{\n\tif (system_state < SYSTEM_FREEING_INITMEM)\n\t\treturn 0;\n\n\treturn init_section_contains((void *)addr, 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int arch_is_kernel_initmem_freed(unsigned long addr)\n{\n\tif (system_state < SYSTEM_FREEING_INITMEM)\n\t\treturn 0;\n\n\treturn init_section_contains((void *)addr, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int static_obj(const void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\tif (arch_is_kernel_initmem_freed(addr))\n\t\treturn 0;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}"
  },
  {
    "function_name": "arch_is_kernel_initmem_freed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "797-803",
    "snippet": "static int arch_is_kernel_initmem_freed(unsigned long addr)\n{\n\tif (system_state < SYSTEM_FREEING_INITMEM)\n\t\treturn 0;\n\n\treturn init_section_contains((void *)addr, 1);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_section_contains",
          "args": [
            "(void *)addr",
            "1"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int arch_is_kernel_initmem_freed(unsigned long addr)\n{\n\tif (system_state < SYSTEM_FREEING_INITMEM)\n\t\treturn 0;\n\n\treturn init_section_contains((void *)addr, 1);\n}"
  },
  {
    "function_name": "very_verbose",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "779-785",
    "snippet": "static int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define VERY_VERBOSE\t\t0"
    ],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_filter",
          "args": [
            "class"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "class_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "466-479",
          "snippet": "static int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define VERY_VERBOSE\t\t0\n\nstatic noinstr struct;\n\nstatic int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "print_kernel_ident",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "771-777",
    "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s %.*s %s\\n\"",
            "init_utsname()->release",
            "(int)strcspn(init_utsname()->version, \" \")",
            "init_utsname()->version",
            "print_tainted()"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_tainted",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "print_tainted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "398-419",
          "snippet": "const char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;",
            "const struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\nconst struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};\n\nconst char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "init_utsname()->version",
            "\" \""
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
  },
  {
    "function_name": "lockdep_print_held_locks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "750-769",
    "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "p->held_locks + i"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "726-748",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" #%d: \"",
            "i"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_is_running",
          "args": [
            "p"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "p"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "p"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->lockdep_depth"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p != current && task_is_running(p))\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
  },
  {
    "function_name": "print_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "726-748",
    "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \", at: %pS\\n\"",
            "(void *)hlock->acquire_ip"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "lock"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "701-712",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"<RELEASED>\\n\""
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t *\n\t * If this indeed happens, lets pretend it does not hurt to continue\n\t * to print the lock unless the hlock class_idx does not point to a\n\t * registered class. The rationale here is: since we don't attempt\n\t * to distinguish whether we are in this situation, if it just\n\t * happened we can't count on class_idx to tell either.\n\t */\n\tstruct lock_class *lock = hlock_class(hlock);\n\n\tif (!lock) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%px\", hlock->instance);\n\tprint_lock_name(lock);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
  },
  {
    "function_name": "print_lockdep_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "714-724",
    "snippet": "static void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%s\"",
            "name"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_key_name",
          "args": [
            "lock->key->subkeys",
            "str"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "__get_key_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "634-637",
          "snippet": "const char *__get_key_name(const struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nconst char *__get_key_name(const struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}"
  },
  {
    "function_name": "print_lock_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "701-712",
    "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"){%s}-{%d:%d}\"",
            "usage",
            "class->wait_type_outer ?: class->wait_type_inner",
            "class->wait_type_inner"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__print_lock_name",
          "args": [
            "class"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "__print_lock_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "683-699",
          "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \" (\""
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_usage_chars",
          "args": [
            "class",
            "usage"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "get_usage_chars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "670-681",
          "snippet": "void get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])\n{\n\tint i = 0;\n\n#define LOCKDEP_STATE(__STATE) \t\t\t\t\t\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\tusage[i] = '\\0';\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])\n{\n\tint i = 0;\n\n#define LOCKDEP_STATE(__STATE) \t\t\t\t\t\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\tusage[i] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}-{%d:%d}\", usage,\n\t\t\tclass->wait_type_outer ?: class->wait_type_inner,\n\t\t\tclass->wait_type_inner);\n}"
  },
  {
    "function_name": "__print_lock_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "683-699",
    "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"/%d\"",
            "class->subclass"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_key_name",
          "args": [
            "class->key",
            "str"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "__get_key_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "634-637",
          "snippet": "const char *__get_key_name(const struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nconst char *__get_key_name(const struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
  },
  {
    "function_name": "get_usage_chars",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "670-681",
    "snippet": "void get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])\n{\n\tint i = 0;\n\n#define LOCKDEP_STATE(__STATE) \t\t\t\t\t\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\tusage[i] = '\\0';\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])\n{\n\tint i = 0;\n\n#define LOCKDEP_STATE(__STATE) \t\t\t\t\t\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\tusage[i] = '\\0';\n}"
  },
  {
    "function_name": "get_usage_char",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "644-668",
    "snippet": "static char get_usage_char(struct lock_class *class, enum lock_usage_bit bit)\n{\n\t/*\n\t * The usage character defaults to '.' (i.e., irqs disabled and not in\n\t * irq context), which is the safest usage category.\n\t */\n\tchar c = '.';\n\n\t/*\n\t * The order of the following usage checks matters, which will\n\t * result in the outcome character as follows:\n\t *\n\t * - '+': irq is enabled and not in irq context\n\t * - '-': in irq context and irq is disabled\n\t * - '?': in irq context and irq is enabled\n\t */\n\tif (class->usage_mask & lock_flag(bit + LOCK_USAGE_DIR_MASK)) {\n\t\tc = '+';\n\t\tif (class->usage_mask & lock_flag(bit))\n\t\t\tc = '?';\n\t} else if (class->usage_mask & lock_flag(bit))\n\t\tc = '-';\n\n\treturn c;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_flag",
          "args": [
            "bit"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "lock_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "639-642",
          "snippet": "static inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic char get_usage_char(struct lock_class *class, enum lock_usage_bit bit)\n{\n\t/*\n\t * The usage character defaults to '.' (i.e., irqs disabled and not in\n\t * irq context), which is the safest usage category.\n\t */\n\tchar c = '.';\n\n\t/*\n\t * The order of the following usage checks matters, which will\n\t * result in the outcome character as follows:\n\t *\n\t * - '+': irq is enabled and not in irq context\n\t * - '-': in irq context and irq is disabled\n\t * - '?': in irq context and irq is enabled\n\t */\n\tif (class->usage_mask & lock_flag(bit + LOCK_USAGE_DIR_MASK)) {\n\t\tc = '+';\n\t\tif (class->usage_mask & lock_flag(bit))\n\t\t\tc = '?';\n\t} else if (class->usage_mask & lock_flag(bit))\n\t\tc = '-';\n\n\treturn c;\n}"
  },
  {
    "function_name": "lock_flag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "639-642",
    "snippet": "static inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}"
  },
  {
    "function_name": "__get_key_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "634-637",
    "snippet": "const char *__get_key_name(const struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "(unsigned long)key",
            "NULL",
            "NULL",
            "NULL",
            "str"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "377-384",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nconst char *__get_key_name(const struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}"
  },
  {
    "function_name": "lockdep_stack_hash_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "586-596",
    "snippet": "u64 lockdep_stack_hash_count(void)\n{\n\tu64 c = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stack_trace_hash); i++)\n\t\tif (!hlist_empty(&stack_trace_hash[i]))\n\t\t\tc++;\n\n\treturn c;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&stack_trace_hash[i]"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "stack_trace_hash"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nu64 lockdep_stack_hash_count(void)\n{\n\tu64 c = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stack_trace_hash); i++)\n\t\tif (!hlist_empty(&stack_trace_hash[i]))\n\t\t\tc++;\n\n\treturn c;\n}"
  },
  {
    "function_name": "lockdep_stack_trace_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "570-583",
    "snippet": "u64 lockdep_stack_trace_count(void)\n{\n\tstruct lock_trace *trace;\n\tu64 c = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stack_trace_hash); i++) {\n\t\thlist_for_each_entry(trace, &stack_trace_hash[i], hash_entry) {\n\t\t\tc++;\n\t\t}\n\t}\n\n\treturn c;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "trace",
            "&stack_trace_hash[i]",
            "hash_entry"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "stack_trace_hash"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nu64 lockdep_stack_trace_count(void)\n{\n\tstruct lock_trace *trace;\n\tu64 c = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stack_trace_hash); i++) {\n\t\thlist_for_each_entry(trace, &stack_trace_hash[i], hash_entry) {\n\t\t\tc++;\n\t\t}\n\t}\n\n\treturn c;\n}"
  },
  {
    "function_name": "save_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "530-567",
    "snippet": "static struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))"
    ],
    "globals_used": [
      "unsigned long nr_stack_trace_entries;",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&trace->hash_entry",
            "hash_head"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traces_identical",
          "args": [
            "trace",
            "t2"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "traces_identical",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "523-528",
          "snippet": "static bool traces_identical(struct lock_trace *t1, struct lock_trace *t2)\n{\n\treturn t1->hash == t2->hash && t1->nr_entries == t2->nr_entries &&\n\t\tmemcmp(t1->entries, t2->entries,\n\t\t       t1->nr_entries * sizeof(t1->entries[0])) == 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic bool traces_identical(struct lock_trace *t1, struct lock_trace *t2)\n{\n\treturn t1->hash == t2->hash && t1->nr_entries == t2->nr_entries &&\n\t\tmemcmp(t1->entries, t2->entries,\n\t\t       t1->nr_entries * sizeof(t1->entries[0])) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "t2",
            "hash_head",
            "hash_entry"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "trace->entries",
            "trace->nr_entries *\n\t\t     sizeof(trace->entries[0])",
            "0"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack_trace_save",
          "args": [
            "trace->entries",
            "max_entries",
            "3"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_save_tsk_reliable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stacktrace.c",
          "lines": "343-353",
          "snippet": "int stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}",
          "includes": [
            "#include <linux/interrupt.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\nint stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lockdep_off",
          "args": [
            "\"BUG: MAX_STACK_TRACE_ENTRIES too low!\""
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "490-497",
          "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define lock_stat 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_NOT_POWER_OF_2",
          "args": [
            "STACK_TRACE_HASH_SIZE"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define LOCK_TRACE_SIZE_IN_LONGS\t\t\t\t\\\n\t(sizeof(struct lock_trace) / sizeof(unsigned long))\n\nunsigned long nr_stack_trace_entries;\nstatic noinstr struct;\n\nstatic struct lock_trace *save_trace(void)\n{\n\tstruct lock_trace *trace, *t2;\n\tstruct hlist_head *hash_head;\n\tu32 hash;\n\tint max_entries;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);\n\tBUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);\n\n\ttrace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);\n\tmax_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -\n\t\tLOCK_TRACE_SIZE_IN_LONGS;\n\n\tif (max_entries <= 0) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn NULL;\n\t}\n\ttrace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);\n\n\thash = jhash(trace->entries, trace->nr_entries *\n\t\t     sizeof(trace->entries[0]), 0);\n\ttrace->hash = hash;\n\thash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));\n\thlist_for_each_entry(t2, hash_head, hash_entry) {\n\t\tif (traces_identical(trace, t2))\n\t\t\treturn t2;\n\t}\n\tnr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;\n\thlist_add_head(&trace->hash_entry, hash_head);\n\n\treturn trace;\n}"
  },
  {
    "function_name": "traces_identical",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "523-528",
    "snippet": "static bool traces_identical(struct lock_trace *t1, struct lock_trace *t2)\n{\n\treturn t1->hash == t2->hash && t1->nr_entries == t2->nr_entries &&\n\t\tmemcmp(t1->entries, t2->entries,\n\t\t       t1->nr_entries * sizeof(t1->entries[0])) == 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "t1->entries",
            "t2->entries",
            "t1->nr_entries * sizeof(t1->entries[0])"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic bool traces_identical(struct lock_trace *t1, struct lock_trace *t2)\n{\n\treturn t1->hash == t2->hash && t1->nr_entries == t2->nr_entries &&\n\t\tmemcmp(t1->entries, t2->entries,\n\t\t       t1->nr_entries * sizeof(t1->entries[0])) == 0;\n}"
  },
  {
    "function_name": "print_lockdep_off",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "490-497",
    "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define lock_stat 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\""
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s\\n\"",
            "bug_msg"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
  },
  {
    "function_name": "verbose",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "482-488",
    "snippet": "static int verbose(struct lock_class *class)\n{\n#if VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define VERBOSE\t\t\t0"
    ],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_filter",
          "args": [
            "class"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "class_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "466-479",
          "snippet": "static int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define VERBOSE\t\t\t0\n\nstatic noinstr struct;\n\nstatic int verbose(struct lock_class *class)\n{\n#if VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "class_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "466-479",
    "snippet": "static int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "class->name",
            "\"&struct->lockfield\""
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}"
  },
  {
    "function_name": "lockdep_set_selftest_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "442-445",
    "snippet": "void lockdep_set_selftest_task(struct task_struct *task)\n{\n\tlockdep_selftest_task_struct = task;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *lockdep_selftest_task_struct;",
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct task_struct *lockdep_selftest_task_struct;\nstatic noinstr struct;\n\nvoid lockdep_set_selftest_task(struct task_struct *task)\n{\n\tlockdep_selftest_task_struct = task;\n}"
  },
  {
    "function_name": "lockdep_recursion_finish",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "436-440",
    "snippet": "static __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "lockdep_recursion",
            "0"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "__this_cpu_dec_return(lockdep_recursion)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec_return",
          "args": [
            "lockdep_recursion"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_finish(void)\n{\n\tif (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))\n\t\t__this_cpu_write(lockdep_recursion, 0);\n}"
  },
  {
    "function_name": "lockdep_recursion_inc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "431-434",
    "snippet": "static __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "lockdep_recursion"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline void lockdep_recursion_inc(void)\n{\n\t__this_cpu_inc(lockdep_recursion);\n}"
  },
  {
    "function_name": "lockdep_init_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "424-429",
    "snippet": "void lockdep_init_task(struct task_struct *task)\n{\n\ttask->lockdep_depth = 0; /* no locks held yet */\n\ttask->curr_chain_key = INITIAL_CHAIN_KEY;\n\ttask->lockdep_recursion = 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_init_task(struct task_struct *task)\n{\n\ttask->lockdep_depth = 0; /* no locks held yet */\n\ttask->curr_chain_key = INITIAL_CHAIN_KEY;\n\ttask->lockdep_recursion = 0;\n}"
  },
  {
    "function_name": "iterate_chain_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "415-422",
    "snippet": "static inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jhash_mix",
          "args": [
            "idx",
            "k0",
            "k1"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}"
  },
  {
    "function_name": "chain_hlock_class_idx",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "404-407",
    "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
  },
  {
    "function_name": "hlock_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "397-402",
    "snippet": "static inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "MAX_LOCKDEP_KEYS_BITS + 2 > 16"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline u16 hlock_id(struct held_lock *hlock)\n{\n\tBUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);\n\n\treturn (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));\n}"
  },
  {
    "function_name": "lock_release_holdtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "330-332",
    "snippet": "static inline void lock_release_holdtime(struct held_lock *hlock)\n{\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void lock_release_holdtime(struct held_lock *hlock)\n{\n}"
  },
  {
    "function_name": "lock_release_holdtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "313-328",
    "snippet": "static void lock_release_holdtime(struct held_lock *hlock)\n{\n\tstruct lock_class_stats *stats;\n\tu64 holdtime;\n\n\tif (!lock_stat)\n\t\treturn;\n\n\tholdtime = lockstat_clock() - hlock->holdtime_stamp;\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (hlock->read)\n\t\tlock_time_inc(&stats->read_holdtime, holdtime);\n\telse\n\t\tlock_time_inc(&stats->write_holdtime, holdtime);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define lock_stat 0"
    ],
    "globals_used": [
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_time_inc",
          "args": [
            "&stats->write_holdtime",
            "holdtime"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "lock_time_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "238-248",
          "snippet": "static void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_stats",
          "args": [
            "hlock_class(hlock)"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "308-311",
          "snippet": "static struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "chain_hlock_class_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "404-407",
          "snippet": "static inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic DECLARE_BITMAP(lock_classes_in_use, MAX_LOCKDEP_KEYS);\n\nstatic inline unsigned int chain_hlock_class_idx(u16 hlock_id)\n{\n\treturn hlock_id & (MAX_LOCKDEP_KEYS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockstat_clock",
          "args": [],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "lockstat_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "217-220",
          "snippet": "static inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void lock_release_holdtime(struct held_lock *hlock)\n{\n\tstruct lock_class_stats *stats;\n\tu64 holdtime;\n\n\tif (!lock_stat)\n\t\treturn;\n\n\tholdtime = lockstat_clock() - hlock->holdtime_stamp;\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (hlock->read)\n\t\tlock_time_inc(&stats->read_holdtime, holdtime);\n\telse\n\t\tlock_time_inc(&stats->write_holdtime, holdtime);\n}"
  },
  {
    "function_name": "get_lock_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "308-311",
    "snippet": "static struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "cpu_lock_stats"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}"
  },
  {
    "function_name": "clear_lock_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "294-306",
    "snippet": "void clear_lock_stats(struct lock_class *class)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct lock_class_stats *cpu_stats =\n\t\t\t&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\n\n\t\tmemset(cpu_stats, 0, sizeof(struct lock_class_stats));\n\t}\n\tmemset(class->contention_point, 0, sizeof(class->contention_point));\n\tmemset(class->contending_point, 0, sizeof(class->contending_point));\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "class->contending_point",
            "0",
            "sizeof(class->contending_point)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "class->contention_point",
            "0",
            "sizeof(class->contention_point)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cpu_stats",
            "0",
            "sizeof(struct lock_class_stats)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_lock_stats",
            "cpu"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nvoid clear_lock_stats(struct lock_class *class)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct lock_class_stats *cpu_stats =\n\t\t\t&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\n\n\t\tmemset(cpu_stats, 0, sizeof(struct lock_class_stats));\n\t}\n\tmemset(class->contention_point, 0, sizeof(class->contention_point));\n\tmemset(class->contending_point, 0, sizeof(class->contending_point));\n}"
  },
  {
    "function_name": "lock_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "265-292",
    "snippet": "struct lock_class_stats lock_stats(struct lock_class *class)\n{\n\tstruct lock_class_stats stats;\n\tint cpu, i;\n\n\tmemset(&stats, 0, sizeof(struct lock_class_stats));\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct lock_class_stats *pcs =\n\t\t\t&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.contention_point); i++)\n\t\t\tstats.contention_point[i] += pcs->contention_point[i];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.contending_point); i++)\n\t\t\tstats.contending_point[i] += pcs->contending_point[i];\n\n\t\tlock_time_add(&pcs->read_waittime, &stats.read_waittime);\n\t\tlock_time_add(&pcs->write_waittime, &stats.write_waittime);\n\n\t\tlock_time_add(&pcs->read_holdtime, &stats.read_holdtime);\n\t\tlock_time_add(&pcs->write_holdtime, &stats.write_holdtime);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.bounces); i++)\n\t\t\tstats.bounces[i] += pcs->bounces[i];\n\t}\n\n\treturn stats;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static noinstr struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "stats.bounces"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_time_add",
          "args": [
            "&pcs->write_holdtime",
            "&stats.write_holdtime"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "lock_time_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "250-263",
          "snippet": "static inline void lock_time_add(struct lock_time *src, struct lock_time *dst)\n{\n\tif (!src->nr)\n\t\treturn;\n\n\tif (src->max > dst->max)\n\t\tdst->max = src->max;\n\n\tif (src->min < dst->min || !dst->nr)\n\t\tdst->min = src->min;\n\n\tdst->total += src->total;\n\tdst->nr += src->nr;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void lock_time_add(struct lock_time *src, struct lock_time *dst)\n{\n\tif (!src->nr)\n\t\treturn;\n\n\tif (src->max > dst->max)\n\t\tdst->max = src->max;\n\n\tif (src->min < dst->min || !dst->nr)\n\t\tdst->min = src->min;\n\n\tdst->total += src->total;\n\tdst->nr += src->nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "stats.contending_point"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "stats.contention_point"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_lock_stats",
            "cpu"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&stats",
            "0",
            "sizeof(struct lock_class_stats)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstruct lock_class_stats lock_stats(struct lock_class *class)\n{\n\tstruct lock_class_stats stats;\n\tint cpu, i;\n\n\tmemset(&stats, 0, sizeof(struct lock_class_stats));\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct lock_class_stats *pcs =\n\t\t\t&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.contention_point); i++)\n\t\t\tstats.contention_point[i] += pcs->contention_point[i];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.contending_point); i++)\n\t\t\tstats.contending_point[i] += pcs->contending_point[i];\n\n\t\tlock_time_add(&pcs->read_waittime, &stats.read_waittime);\n\t\tlock_time_add(&pcs->write_waittime, &stats.write_waittime);\n\n\t\tlock_time_add(&pcs->read_holdtime, &stats.read_holdtime);\n\t\tlock_time_add(&pcs->write_holdtime, &stats.write_holdtime);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.bounces); i++)\n\t\t\tstats.bounces[i] += pcs->bounces[i];\n\t}\n\n\treturn stats;\n}"
  },
  {
    "function_name": "lock_time_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "250-263",
    "snippet": "static inline void lock_time_add(struct lock_time *src, struct lock_time *dst)\n{\n\tif (!src->nr)\n\t\treturn;\n\n\tif (src->max > dst->max)\n\t\tdst->max = src->max;\n\n\tif (src->min < dst->min || !dst->nr)\n\t\tdst->min = src->min;\n\n\tdst->total += src->total;\n\tdst->nr += src->nr;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic inline void lock_time_add(struct lock_time *src, struct lock_time *dst)\n{\n\tif (!src->nr)\n\t\treturn;\n\n\tif (src->max > dst->max)\n\t\tdst->max = src->max;\n\n\tif (src->min < dst->min || !dst->nr)\n\t\tdst->min = src->min;\n\n\tdst->total += src->total;\n\tdst->nr += src->nr;\n}"
  },
  {
    "function_name": "lock_time_inc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "238-248",
    "snippet": "static void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinstr struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nstatic void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}"
  },
  {
    "function_name": "lock_point",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "222-236",
    "snippet": "static int lock_point(unsigned long points[], unsigned long ip)\n{\n\tint i;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tif (points[i] == 0) {\n\t\t\tpoints[i] = ip;\n\t\t\tbreak;\n\t\t}\n\t\tif (points[i] == ip)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int lock_point(unsigned long points[], unsigned long ip)\n{\n\tint i;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tif (points[i] == 0) {\n\t\t\tpoints[i] = ip;\n\t\t\tbreak;\n\t\t}\n\t\tif (points[i] == ip)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}"
  },
  {
    "function_name": "lockstat_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "217-220",
    "snippet": "static inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}"
  },
  {
    "function_name": "hlock_class",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "192-212",
    "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfield */\n\tbarrier();\n\n\tif (!test_bit(class_idx, lock_classes_in_use)) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * At this point, if the passed hlock->class_idx is still garbage,\n\t * we just have to live with it\n\t */\n\treturn lock_classes + class_idx;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static noinstr struct",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "1"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "class_idx",
            "lock_classes_in_use"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfield */\n\tbarrier();\n\n\tif (!test_bit(class_idx, lock_classes_in_use)) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * At this point, if the passed hlock->class_idx is still garbage,\n\t * we just have to live with it\n\t */\n\treturn lock_classes + class_idx;\n}"
  },
  {
    "function_name": "debug_locks_off_graph_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "162-169",
    "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_unlock",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "117-127",
          "snippet": "static inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "graph_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "153-156",
    "snippet": "static inline void graph_unlock(void)\n{\n\tlockdep_unlock();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_unlock",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "117-127",
          "snippet": "static inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void graph_unlock(void)\n{\n\tlockdep_unlock();\n}"
  },
  {
    "function_name": "graph_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "137-151",
    "snippet": "static int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_unlock",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "117-127",
          "snippet": "static inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_lock",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "108-115",
          "snippet": "static inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static struct task_struct *__owner;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int graph_lock(void)\n{\n\tlockdep_lock();\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tlockdep_unlock();\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "lockdep_assert_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "129-132",
    "snippet": "static inline bool lockdep_assert_locked(void)\n{\n\treturn DEBUG_LOCKS_WARN_ON(__owner != current);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *__owner;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "__owner != current"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct task_struct *__owner;\n\nstatic inline bool lockdep_assert_locked(void)\n{\n\treturn DEBUG_LOCKS_WARN_ON(__owner != current);\n}"
  },
  {
    "function_name": "lockdep_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "117-127",
    "snippet": "static inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
      "static struct task_struct *__owner;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "lockdep_recursion"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&__lock"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "__owner != current"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_unlock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tif (debug_locks && DEBUG_LOCKS_WARN_ON(__owner != current))\n\t\treturn;\n\n\t__owner = NULL;\n\tarch_spin_unlock(&__lock);\n\t__this_cpu_dec(lockdep_recursion);\n}"
  },
  {
    "function_name": "lockdep_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "108-115",
    "snippet": "static inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
      "static struct task_struct *__owner;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&__lock"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "lockdep_recursion"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t __lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic struct task_struct *__owner;\n\nstatic inline void lockdep_lock(void)\n{\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(lockdep_recursion);\n\tarch_spin_lock(&__lock);\n\t__owner = current;\n}"
  },
  {
    "function_name": "lockdep_enabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
    "lines": "83-95",
    "snippet": "static __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "lockdep_recursion"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic __always_inline bool lockdep_enabled(void)\n{\n\tif (!debug_locks)\n\t\treturn false;\n\n\tif (this_cpu_read(lockdep_recursion))\n\t\treturn false;\n\n\tif (current->lockdep_recursion)\n\t\treturn false;\n\n\treturn true;\n}"
  }
]