[
  {
    "function_name": "devm_irq_domain_create_sim",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "233-249",
    "snippet": "struct irq_domain *devm_irq_domain_create_sim(struct device *dev,\n\t\t\t\t\t      struct fwnode_handle *fwnode,\n\t\t\t\t\t      unsigned int num_irqs)\n{\n\tstruct irq_domain *domain;\n\tint ret;\n\n\tdomain = irq_domain_create_sim(fwnode, num_irqs);\n\tif (IS_ERR(domain))\n\t\treturn domain;\n\n\tret = devm_add_action_or_reset(dev, devm_irq_domain_remove_sim, domain);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn domain;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devm_add_action_or_reset",
          "args": [
            "dev",
            "devm_irq_domain_remove_sim",
            "domain"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "domain"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_create_sim",
          "args": [
            "fwnode",
            "num_irqs"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_create_sim",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
          "lines": "164-194",
          "snippet": "struct irq_domain *irq_domain_create_sim(struct fwnode_handle *fwnode,\n\t\t\t\t\t unsigned int num_irqs)\n{\n\tstruct irq_sim_work_ctx *work_ctx;\n\n\twork_ctx = kmalloc(sizeof(*work_ctx), GFP_KERNEL);\n\tif (!work_ctx)\n\t\tgoto err_out;\n\n\twork_ctx->pending = bitmap_zalloc(num_irqs, GFP_KERNEL);\n\tif (!work_ctx->pending)\n\t\tgoto err_free_work_ctx;\n\n\twork_ctx->domain = irq_domain_create_linear(fwnode, num_irqs,\n\t\t\t\t\t\t    &irq_sim_domain_ops,\n\t\t\t\t\t\t    work_ctx);\n\tif (!work_ctx->domain)\n\t\tgoto err_free_bitmap;\n\n\twork_ctx->irq_count = num_irqs;\n\tinit_irq_work(&work_ctx->work, irq_sim_handle_irq);\n\n\treturn work_ctx->domain;\n\nerr_free_bitmap:\n\tbitmap_free(work_ctx->pending);\nerr_free_work_ctx:\n\tkfree(work_ctx);\nerr_out:\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/irq_sim.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct irq_domain_ops irq_sim_domain_ops = {\n\t.map\t\t= irq_sim_domain_map,\n\t.unmap\t\t= irq_sim_domain_unmap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic const struct irq_domain_ops irq_sim_domain_ops = {\n\t.map\t\t= irq_sim_domain_map,\n\t.unmap\t\t= irq_sim_domain_unmap,\n};\n\nstruct irq_domain *irq_domain_create_sim(struct fwnode_handle *fwnode,\n\t\t\t\t\t unsigned int num_irqs)\n{\n\tstruct irq_sim_work_ctx *work_ctx;\n\n\twork_ctx = kmalloc(sizeof(*work_ctx), GFP_KERNEL);\n\tif (!work_ctx)\n\t\tgoto err_out;\n\n\twork_ctx->pending = bitmap_zalloc(num_irqs, GFP_KERNEL);\n\tif (!work_ctx->pending)\n\t\tgoto err_free_work_ctx;\n\n\twork_ctx->domain = irq_domain_create_linear(fwnode, num_irqs,\n\t\t\t\t\t\t    &irq_sim_domain_ops,\n\t\t\t\t\t\t    work_ctx);\n\tif (!work_ctx->domain)\n\t\tgoto err_free_bitmap;\n\n\twork_ctx->irq_count = num_irqs;\n\tinit_irq_work(&work_ctx->work, irq_sim_handle_irq);\n\n\treturn work_ctx->domain;\n\nerr_free_bitmap:\n\tbitmap_free(work_ctx->pending);\nerr_free_work_ctx:\n\tkfree(work_ctx);\nerr_out:\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstruct irq_domain *devm_irq_domain_create_sim(struct device *dev,\n\t\t\t\t\t      struct fwnode_handle *fwnode,\n\t\t\t\t\t      unsigned int num_irqs)\n{\n\tstruct irq_domain *domain;\n\tint ret;\n\n\tdomain = irq_domain_create_sim(fwnode, num_irqs);\n\tif (IS_ERR(domain))\n\t\treturn domain;\n\n\tret = devm_add_action_or_reset(dev, devm_irq_domain_remove_sim, domain);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn domain;\n}"
  },
  {
    "function_name": "devm_irq_domain_remove_sim",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "215-220",
    "snippet": "static void devm_irq_domain_remove_sim(void *data)\n{\n\tstruct irq_domain *domain = data;\n\n\tirq_domain_remove_sim(domain);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_remove_sim",
          "args": [
            "domain"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "devm_irq_domain_remove_sim",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
          "lines": "215-220",
          "snippet": "static void devm_irq_domain_remove_sim(void *data)\n{\n\tstruct irq_domain *domain = data;\n\n\tirq_domain_remove_sim(domain);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic void devm_irq_domain_remove_sim(void *data)\n{\n\tstruct irq_domain *domain = data;\n\n\tirq_domain_remove_sim(domain);\n}"
  },
  {
    "function_name": "irq_domain_remove_sim",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "203-212",
    "snippet": "void irq_domain_remove_sim(struct irq_domain *domain)\n{\n\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;\n\n\tirq_work_sync(&work_ctx->work);\n\tbitmap_free(work_ctx->pending);\n\tkfree(work_ctx);\n\n\tirq_domain_remove(domain);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_remove",
          "args": [
            "domain"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "devm_irq_domain_remove_sim",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
          "lines": "215-220",
          "snippet": "static void devm_irq_domain_remove_sim(void *data)\n{\n\tstruct irq_domain *domain = data;\n\n\tirq_domain_remove_sim(domain);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/irq_sim.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic void devm_irq_domain_remove_sim(void *data)\n{\n\tstruct irq_domain *domain = data;\n\n\tirq_domain_remove_sim(domain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "work_ctx"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "work_ctx->pending"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_sync",
          "args": [
            "&work_ctx->work"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "276-290",
          "snippet": "void irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\tmight_sleep();\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt()) {\n\t\trcuwait_wait_event(&work->irqwait, !irq_work_is_busy(work),\n\t\t\t\t   TASK_UNINTERRUPTIBLE);\n\t\treturn;\n\t}\n\n\twhile (irq_work_is_busy(work))\n\t\tcpu_relax();\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\tmight_sleep();\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt()) {\n\t\trcuwait_wait_event(&work->irqwait, !irq_work_is_busy(work),\n\t\t\t\t   TASK_UNINTERRUPTIBLE);\n\t\treturn;\n\t}\n\n\twhile (irq_work_is_busy(work))\n\t\tcpu_relax();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nvoid irq_domain_remove_sim(struct irq_domain *domain)\n{\n\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;\n\n\tirq_work_sync(&work_ctx->work);\n\tbitmap_free(work_ctx->pending);\n\tkfree(work_ctx);\n\n\tirq_domain_remove(domain);\n}"
  },
  {
    "function_name": "irq_domain_create_sim",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "164-194",
    "snippet": "struct irq_domain *irq_domain_create_sim(struct fwnode_handle *fwnode,\n\t\t\t\t\t unsigned int num_irqs)\n{\n\tstruct irq_sim_work_ctx *work_ctx;\n\n\twork_ctx = kmalloc(sizeof(*work_ctx), GFP_KERNEL);\n\tif (!work_ctx)\n\t\tgoto err_out;\n\n\twork_ctx->pending = bitmap_zalloc(num_irqs, GFP_KERNEL);\n\tif (!work_ctx->pending)\n\t\tgoto err_free_work_ctx;\n\n\twork_ctx->domain = irq_domain_create_linear(fwnode, num_irqs,\n\t\t\t\t\t\t    &irq_sim_domain_ops,\n\t\t\t\t\t\t    work_ctx);\n\tif (!work_ctx->domain)\n\t\tgoto err_free_bitmap;\n\n\twork_ctx->irq_count = num_irqs;\n\tinit_irq_work(&work_ctx->work, irq_sim_handle_irq);\n\n\treturn work_ctx->domain;\n\nerr_free_bitmap:\n\tbitmap_free(work_ctx->pending);\nerr_free_work_ctx:\n\tkfree(work_ctx);\nerr_out:\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct irq_domain_ops irq_sim_domain_ops = {\n\t.map\t\t= irq_sim_domain_map,\n\t.unmap\t\t= irq_sim_domain_unmap,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "work_ctx"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "work_ctx->pending"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&work_ctx->work",
            "irq_sim_handle_irq"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_create_linear",
          "args": [
            "fwnode",
            "num_irqs",
            "&irq_sim_domain_ops",
            "work_ctx"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zalloc",
          "args": [
            "num_irqs",
            "GFP_KERNEL"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*work_ctx)",
            "GFP_KERNEL"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic const struct irq_domain_ops irq_sim_domain_ops = {\n\t.map\t\t= irq_sim_domain_map,\n\t.unmap\t\t= irq_sim_domain_unmap,\n};\n\nstruct irq_domain *irq_domain_create_sim(struct fwnode_handle *fwnode,\n\t\t\t\t\t unsigned int num_irqs)\n{\n\tstruct irq_sim_work_ctx *work_ctx;\n\n\twork_ctx = kmalloc(sizeof(*work_ctx), GFP_KERNEL);\n\tif (!work_ctx)\n\t\tgoto err_out;\n\n\twork_ctx->pending = bitmap_zalloc(num_irqs, GFP_KERNEL);\n\tif (!work_ctx->pending)\n\t\tgoto err_free_work_ctx;\n\n\twork_ctx->domain = irq_domain_create_linear(fwnode, num_irqs,\n\t\t\t\t\t\t    &irq_sim_domain_ops,\n\t\t\t\t\t\t    work_ctx);\n\tif (!work_ctx->domain)\n\t\tgoto err_free_bitmap;\n\n\twork_ctx->irq_count = num_irqs;\n\tinit_irq_work(&work_ctx->work, irq_sim_handle_irq);\n\n\treturn work_ctx->domain;\n\nerr_free_bitmap:\n\tbitmap_free(work_ctx->pending);\nerr_free_work_ctx:\n\tkfree(work_ctx);\nerr_out:\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "irq_sim_domain_unmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "136-147",
    "snippet": "static void irq_sim_domain_unmap(struct irq_domain *domain, unsigned int virq)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx;\n\tstruct irq_data *irqd;\n\n\tirqd = irq_domain_get_irq_data(domain, virq);\n\tirq_ctx = irq_data_get_irq_chip_data(irqd);\n\n\tirq_set_handler(virq, NULL);\n\tirq_domain_reset_irq_data(irqd);\n\tkfree(irq_ctx);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "irq_ctx"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_reset_irq_data",
          "args": [
            "irqd"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_reset_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1069-1074",
          "snippet": "void irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_handler",
          "args": [
            "virq",
            "NULL"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_handler_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "90-100",
          "snippet": "int irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip_data",
          "args": [
            "irqd"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "virq"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdomain.c",
          "lines": "1835-1841",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic void irq_sim_domain_unmap(struct irq_domain *domain, unsigned int virq)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx;\n\tstruct irq_data *irqd;\n\n\tirqd = irq_domain_get_irq_data(domain, virq);\n\tirq_ctx = irq_data_get_irq_chip_data(irqd);\n\n\tirq_set_handler(virq, NULL);\n\tirq_domain_reset_irq_data(irqd);\n\tkfree(irq_ctx);\n}"
  },
  {
    "function_name": "irq_sim_domain_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "117-134",
    "snippet": "static int irq_sim_domain_map(struct irq_domain *domain,\n\t\t\t      unsigned int virq, irq_hw_number_t hw)\n{\n\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;\n\tstruct irq_sim_irq_ctx *irq_ctx;\n\n\tirq_ctx = kzalloc(sizeof(*irq_ctx), GFP_KERNEL);\n\tif (!irq_ctx)\n\t\treturn -ENOMEM;\n\n\tirq_set_chip(virq, &irq_sim_irqchip);\n\tirq_set_chip_data(virq, irq_ctx);\n\tirq_set_handler(virq, handle_simple_irq);\n\tirq_modify_status(virq, IRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);\n\tirq_ctx->work_ctx = work_ctx;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_chip irq_sim_irqchip = {\n\t.name\t\t\t= \"irq_sim\",\n\t.irq_mask\t\t= irq_sim_irqmask,\n\t.irq_unmask\t\t= irq_sim_irqunmask,\n\t.irq_set_type\t\t= irq_sim_set_type,\n\t.irq_get_irqchip_state\t= irq_sim_get_irqchip_state,\n\t.irq_set_irqchip_state\t= irq_sim_set_irqchip_state,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_modify_status",
          "args": [
            "virq",
            "IRQ_NOREQUEST | IRQ_NOAUTOEN",
            "IRQ_NOPROBE"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "irq_modify_status",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1084-1120",
          "snippet": "void irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set)\n{\n\tunsigned long flags, trigger, tmp;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t/*\n\t * Warn when a driver sets the no autoenable flag on an already\n\t * active interrupt.\n\t */\n\tWARN_ON_ONCE(!desc->depth && (set & _IRQ_NOAUTOEN));\n\n\tirq_settings_clr_and_set(desc, clr, set);\n\n\ttrigger = irqd_get_trigger_type(&desc->irq_data);\n\n\tirqd_clear(&desc->irq_data, IRQD_NO_BALANCING | IRQD_PER_CPU |\n\t\t   IRQD_TRIGGER_MASK | IRQD_LEVEL | IRQD_MOVE_PCNTXT);\n\tif (irq_settings_has_no_balance_set(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\tif (irq_settings_is_per_cpu(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\tif (irq_settings_can_move_pcntxt(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_MOVE_PCNTXT);\n\tif (irq_settings_is_level(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\n\ttmp = irq_settings_get_trigger_mask(desc);\n\tif (tmp != IRQ_TYPE_NONE)\n\t\ttrigger = tmp;\n\n\tirqd_set(&desc->irq_data, trigger);\n\n\tirq_put_desc_unlock(desc, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set)\n{\n\tunsigned long flags, trigger, tmp;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t/*\n\t * Warn when a driver sets the no autoenable flag on an already\n\t * active interrupt.\n\t */\n\tWARN_ON_ONCE(!desc->depth && (set & _IRQ_NOAUTOEN));\n\n\tirq_settings_clr_and_set(desc, clr, set);\n\n\ttrigger = irqd_get_trigger_type(&desc->irq_data);\n\n\tirqd_clear(&desc->irq_data, IRQD_NO_BALANCING | IRQD_PER_CPU |\n\t\t   IRQD_TRIGGER_MASK | IRQD_LEVEL | IRQD_MOVE_PCNTXT);\n\tif (irq_settings_has_no_balance_set(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\tif (irq_settings_is_per_cpu(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\tif (irq_settings_can_move_pcntxt(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_MOVE_PCNTXT);\n\tif (irq_settings_is_level(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\n\ttmp = irq_settings_get_trigger_mask(desc);\n\tif (tmp != IRQ_TYPE_NONE)\n\t\ttrigger = tmp;\n\n\tirqd_set(&desc->irq_data, trigger);\n\n\tirq_put_desc_unlock(desc, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_handler",
          "args": [
            "virq",
            "handle_simple_irq"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_handler_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "90-100",
          "snippet": "int irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_chip_data",
          "args": [
            "virq",
            "irq_ctx"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_chip_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "145-155",
          "snippet": "int irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*irq_ctx)",
            "GFP_KERNEL"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic struct irq_chip irq_sim_irqchip = {\n\t.name\t\t\t= \"irq_sim\",\n\t.irq_mask\t\t= irq_sim_irqmask,\n\t.irq_unmask\t\t= irq_sim_irqunmask,\n\t.irq_set_type\t\t= irq_sim_set_type,\n\t.irq_get_irqchip_state\t= irq_sim_get_irqchip_state,\n\t.irq_set_irqchip_state\t= irq_sim_set_irqchip_state,\n};\n\nstatic int irq_sim_domain_map(struct irq_domain *domain,\n\t\t\t      unsigned int virq, irq_hw_number_t hw)\n{\n\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;\n\tstruct irq_sim_irq_ctx *irq_ctx;\n\n\tirq_ctx = kzalloc(sizeof(*irq_ctx), GFP_KERNEL);\n\tif (!irq_ctx)\n\t\treturn -ENOMEM;\n\n\tirq_set_chip(virq, &irq_sim_irqchip);\n\tirq_set_chip_data(virq, irq_ctx);\n\tirq_set_handler(virq, handle_simple_irq);\n\tirq_modify_status(virq, IRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);\n\tirq_ctx->work_ctx = work_ctx;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_sim_handle_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "100-115",
    "snippet": "static void irq_sim_handle_irq(struct irq_work *work)\n{\n\tstruct irq_sim_work_ctx *work_ctx;\n\tunsigned int offset = 0;\n\tint irqnum;\n\n\twork_ctx = container_of(work, struct irq_sim_work_ctx, work);\n\n\twhile (!bitmap_empty(work_ctx->pending, work_ctx->irq_count)) {\n\t\toffset = find_next_bit(work_ctx->pending,\n\t\t\t\t       work_ctx->irq_count, offset);\n\t\tclear_bit(offset, work_ctx->pending);\n\t\tirqnum = irq_find_mapping(work_ctx->domain, offset);\n\t\thandle_simple_irq(irq_to_desc(irqnum));\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_simple_irq",
          "args": [
            "irq_to_desc(irqnum)"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "handle_simple_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "541-560",
          "snippet": "void handle_simple_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\thandle_irq_event(desc);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid handle_simple_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\thandle_irq_event(desc);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irqnum"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_find_mapping",
          "args": [
            "work_ctx->domain",
            "offset"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "offset",
            "work_ctx->pending"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "work_ctx->pending",
            "work_ctx->irq_count",
            "offset"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_empty",
          "args": [
            "work_ctx->pending",
            "work_ctx->irq_count"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structirq_sim_work_ctx",
            "work"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic void irq_sim_handle_irq(struct irq_work *work)\n{\n\tstruct irq_sim_work_ctx *work_ctx;\n\tunsigned int offset = 0;\n\tint irqnum;\n\n\twork_ctx = container_of(work, struct irq_sim_work_ctx, work);\n\n\twhile (!bitmap_empty(work_ctx->pending, work_ctx->irq_count)) {\n\t\toffset = find_next_bit(work_ctx->pending,\n\t\t\t\t       work_ctx->irq_count, offset);\n\t\tclear_bit(offset, work_ctx->pending);\n\t\tirqnum = irq_find_mapping(work_ctx->domain, offset);\n\t\thandle_simple_irq(irq_to_desc(irqnum));\n\t}\n}"
  },
  {
    "function_name": "irq_sim_set_irqchip_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "70-89",
    "snippet": "static int irq_sim_set_irqchip_state(struct irq_data *data,\n\t\t\t\t     enum irqchip_irq_state which, bool state)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tswitch (which) {\n\tcase IRQCHIP_STATE_PENDING:\n\t\tif (irq_ctx->enabled) {\n\t\t\tassign_bit(hwirq, irq_ctx->work_ctx->pending, state);\n\t\t\tif (state)\n\t\t\t\tirq_work_queue(&irq_ctx->work_ctx->work);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&irq_ctx->work_ctx->work"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "106-118",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assign_bit",
          "args": [
            "hwirq",
            "irq_ctx->work_ctx->pending",
            "state"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_to_hwirq",
          "args": [
            "data"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip_data",
          "args": [
            "data"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic int irq_sim_set_irqchip_state(struct irq_data *data,\n\t\t\t\t     enum irqchip_irq_state which, bool state)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tswitch (which) {\n\tcase IRQCHIP_STATE_PENDING:\n\t\tif (irq_ctx->enabled) {\n\t\t\tassign_bit(hwirq, irq_ctx->work_ctx->pending, state);\n\t\t\tif (state)\n\t\t\t\tirq_work_queue(&irq_ctx->work_ctx->work);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_sim_get_irqchip_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "52-68",
    "snippet": "static int irq_sim_get_irqchip_state(struct irq_data *data,\n\t\t\t\t     enum irqchip_irq_state which, bool *state)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tswitch (which) {\n\tcase IRQCHIP_STATE_PENDING:\n\t\tif (irq_ctx->enabled)\n\t\t\t*state = test_bit(hwirq, irq_ctx->work_ctx->pending);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "hwirq",
            "irq_ctx->work_ctx->pending"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_to_hwirq",
          "args": [
            "data"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip_data",
          "args": [
            "data"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic int irq_sim_get_irqchip_state(struct irq_data *data,\n\t\t\t\t     enum irqchip_irq_state which, bool *state)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tswitch (which) {\n\tcase IRQCHIP_STATE_PENDING:\n\t\tif (irq_ctx->enabled)\n\t\t\t*state = test_bit(hwirq, irq_ctx->work_ctx->pending);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_sim_set_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "41-50",
    "snippet": "static int irq_sim_set_type(struct irq_data *data, unsigned int type)\n{\n\t/* We only support rising and falling edge trigger types. */\n\tif (type & ~IRQ_TYPE_EDGE_BOTH)\n\t\treturn -EINVAL;\n\n\tirqd_set_trigger_type(data, type);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_set_trigger_type",
          "args": [
            "data",
            "type"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic int irq_sim_set_type(struct irq_data *data, unsigned int type)\n{\n\t/* We only support rising and falling edge trigger types. */\n\tif (type & ~IRQ_TYPE_EDGE_BOTH)\n\t\treturn -EINVAL;\n\n\tirqd_set_trigger_type(data, type);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_sim_irqunmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "34-39",
    "snippet": "static void irq_sim_irqunmask(struct irq_data *data)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\n\tirq_ctx->enabled = true;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip_data",
          "args": [
            "data"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic void irq_sim_irqunmask(struct irq_data *data)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\n\tirq_ctx->enabled = true;\n}"
  },
  {
    "function_name": "irq_sim_irqmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irq_sim.c",
    "lines": "27-32",
    "snippet": "static void irq_sim_irqmask(struct irq_data *data)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\n\tirq_ctx->enabled = false;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip_data",
          "args": [
            "data"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq_work.h>\n#include <linux/irq_sim.h>\n#include <linux/irq.h>\n\nstatic void irq_sim_irqmask(struct irq_data *data)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\n\tirq_ctx->enabled = false;\n}"
  }
]