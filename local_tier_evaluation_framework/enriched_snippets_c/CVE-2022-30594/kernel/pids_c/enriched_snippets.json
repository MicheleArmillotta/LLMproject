[
  {
    "function_name": "pids_events_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "314-320",
    "snippet": "static int pids_events_show(struct seq_file *sf, void *v)\n{\n\tstruct pids_cgroup *pids = css_pids(seq_css(sf));\n\n\tseq_printf(sf, \"max %lld\\n\", (s64)atomic64_read(&pids->events_limit));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"max %lld\\n\"",
            "(s64)atomic64_read(&pids->events_limit)"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&pids->events_limit"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "seq_css(sf)"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "58-61",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int pids_events_show(struct seq_file *sf, void *v)\n{\n\tstruct pids_cgroup *pids = css_pids(seq_css(sf));\n\n\tseq_printf(sf, \"max %lld\\n\", (s64)atomic64_read(&pids->events_limit));\n\treturn 0;\n}"
  },
  {
    "function_name": "pids_current_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "306-312",
    "snippet": "static s64 pids_current_read(struct cgroup_subsys_state *css,\n\t\t\t     struct cftype *cft)\n{\n\tstruct pids_cgroup *pids = css_pids(css);\n\n\treturn atomic64_read(&pids->counter);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&pids->counter"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "58-61",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic s64 pids_current_read(struct cgroup_subsys_state *css,\n\t\t\t     struct cftype *cft)\n{\n\tstruct pids_cgroup *pids = css_pids(css);\n\n\treturn atomic64_read(&pids->counter);\n}"
  },
  {
    "function_name": "pids_max_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "292-304",
    "snippet": "static int pids_max_show(struct seq_file *sf, void *v)\n{\n\tstruct cgroup_subsys_state *css = seq_css(sf);\n\tstruct pids_cgroup *pids = css_pids(css);\n\tint64_t limit = atomic64_read(&pids->limit);\n\n\tif (limit >= PIDS_MAX)\n\t\tseq_printf(sf, \"%s\\n\", PIDS_MAX_STR);\n\telse\n\t\tseq_printf(sf, \"%lld\\n\", limit);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PIDS_MAX_STR \"max\"",
      "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"%lld\\n\"",
            "limit"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&pids->limit"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "58-61",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PIDS_MAX_STR \"max\"\n#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)\n\nstatic int pids_max_show(struct seq_file *sf, void *v)\n{\n\tstruct cgroup_subsys_state *css = seq_css(sf);\n\tstruct pids_cgroup *pids = css_pids(css);\n\tint64_t limit = atomic64_read(&pids->limit);\n\n\tif (limit >= PIDS_MAX)\n\t\tseq_printf(sf, \"%s\\n\", PIDS_MAX_STR);\n\telse\n\t\tseq_printf(sf, \"%lld\\n\", limit);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pids_max_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "262-290",
    "snippet": "static ssize_t pids_max_write(struct kernfs_open_file *of, char *buf,\n\t\t\t      size_t nbytes, loff_t off)\n{\n\tstruct cgroup_subsys_state *css = of_css(of);\n\tstruct pids_cgroup *pids = css_pids(css);\n\tint64_t limit;\n\tint err;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, PIDS_MAX_STR)) {\n\t\tlimit = PIDS_MAX;\n\t\tgoto set_limit;\n\t}\n\n\terr = kstrtoll(buf, 0, &limit);\n\tif (err)\n\t\treturn err;\n\n\tif (limit < 0 || limit >= PIDS_MAX)\n\t\treturn -EINVAL;\n\nset_limit:\n\t/*\n\t * Limit updates don't need to be mutex'd, since it isn't\n\t * critical that any racing fork()s follow the new limit.\n\t */\n\tatomic64_set(&pids->limit, limit);\n\treturn nbytes;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PIDS_MAX_STR \"max\"",
      "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&pids->limit",
            "limit"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoll",
          "args": [
            "buf",
            "0",
            "&limit"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "PIDS_MAX_STR"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "58-61",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "of_css",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "652-669",
          "snippet": "struct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PIDS_MAX_STR \"max\"\n#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)\n\nstatic ssize_t pids_max_write(struct kernfs_open_file *of, char *buf,\n\t\t\t      size_t nbytes, loff_t off)\n{\n\tstruct cgroup_subsys_state *css = of_css(of);\n\tstruct pids_cgroup *pids = css_pids(css);\n\tint64_t limit;\n\tint err;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, PIDS_MAX_STR)) {\n\t\tlimit = PIDS_MAX;\n\t\tgoto set_limit;\n\t}\n\n\terr = kstrtoll(buf, 0, &limit);\n\tif (err)\n\t\treturn err;\n\n\tif (limit < 0 || limit >= PIDS_MAX)\n\t\treturn -EINVAL;\n\nset_limit:\n\t/*\n\t * Limit updates don't need to be mutex'd, since it isn't\n\t * critical that any racing fork()s follow the new limit.\n\t */\n\tatomic64_set(&pids->limit, limit);\n\treturn nbytes;\n}"
  },
  {
    "function_name": "pids_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "255-260",
    "snippet": "static void pids_release(struct task_struct *task)\n{\n\tstruct pids_cgroup *pids = css_pids(task_css(task, pids_cgrp_id));\n\n\tpids_uncharge(pids, 1);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_uncharge",
          "args": [
            "pids",
            "1"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "pids_uncharge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "110-116",
          "snippet": "static void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "task_css(task, pids_cgrp_id)"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "58-61",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "task",
            "pids_cgrp_id"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_release(struct task_struct *task)\n{\n\tstruct pids_cgroup *pids = css_pids(task_css(task, pids_cgrp_id));\n\n\tpids_uncharge(pids, 1);\n}"
  },
  {
    "function_name": "pids_cancel_fork",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "242-253",
    "snippet": "static void pids_cancel_fork(struct task_struct *task, struct css_set *cset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\n\tif (cset)\n\t\tcss = cset->subsys[pids_cgrp_id];\n\telse\n\t\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\tpids_uncharge(pids, 1);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_uncharge",
          "args": [
            "pids",
            "1"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "pids_uncharge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "110-116",
          "snippet": "static void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "58-61",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_check",
          "args": [
            "current",
            "pids_cgrp_id",
            "true"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_cancel_fork(struct task_struct *task, struct css_set *cset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\n\tif (cset)\n\t\tcss = cset->subsys[pids_cgrp_id];\n\telse\n\t\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\tpids_uncharge(pids, 1);\n}"
  },
  {
    "function_name": "pids_can_fork",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "218-240",
    "snippet": "static int pids_can_fork(struct task_struct *task, struct css_set *cset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\tint err;\n\n\tif (cset)\n\t\tcss = cset->subsys[pids_cgrp_id];\n\telse\n\t\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\terr = pids_try_charge(pids, 1);\n\tif (err) {\n\t\t/* Only log the first time events_limit is incremented. */\n\t\tif (atomic64_inc_return(&pids->events_limit) == 1) {\n\t\t\tpr_info(\"cgroup: fork rejected by pids controller in \");\n\t\t\tpr_cont_cgroup_path(css->cgroup);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tcgroup_file_notify(&pids->events_file);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&pids->events_file"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont_cgroup_path",
          "args": [
            "css->cgroup"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"cgroup: fork rejected by pids controller in \""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_inc_return",
          "args": [
            "&pids->events_limit"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pids_try_charge",
          "args": [
            "pids",
            "1"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "pids_try_charge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "144-169",
          "snippet": "static int pids_try_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p, *q;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {\n\t\tint64_t new = atomic64_add_return(num, &p->counter);\n\t\tint64_t limit = atomic64_read(&p->limit);\n\n\t\t/*\n\t\t * Since new is capped to the maximum number of pid_t, if\n\t\t * p->limit is %PIDS_MAX then we know that this test will never\n\t\t * fail.\n\t\t */\n\t\tif (new > limit)\n\t\t\tgoto revert;\n\t}\n\n\treturn 0;\n\nrevert:\n\tfor (q = pids; q != p; q = parent_pids(q))\n\t\tpids_cancel(q, num);\n\tpids_cancel(p, num);\n\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)\n\nstatic int pids_try_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p, *q;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {\n\t\tint64_t new = atomic64_add_return(num, &p->counter);\n\t\tint64_t limit = atomic64_read(&p->limit);\n\n\t\t/*\n\t\t * Since new is capped to the maximum number of pid_t, if\n\t\t * p->limit is %PIDS_MAX then we know that this test will never\n\t\t * fail.\n\t\t */\n\t\tif (new > limit)\n\t\t\tgoto revert;\n\t}\n\n\treturn 0;\n\nrevert:\n\tfor (q = pids; q != p; q = parent_pids(q))\n\t\tpids_cancel(q, num);\n\tpids_cancel(p, num);\n\n\treturn -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "58-61",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_check",
          "args": [
            "current",
            "pids_cgrp_id",
            "true"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int pids_can_fork(struct task_struct *task, struct css_set *cset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\tint err;\n\n\tif (cset)\n\t\tcss = cset->subsys[pids_cgrp_id];\n\telse\n\t\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\terr = pids_try_charge(pids, 1);\n\tif (err) {\n\t\t/* Only log the first time events_limit is incremented. */\n\t\tif (atomic64_inc_return(&pids->events_limit) == 1) {\n\t\t\tpr_info(\"cgroup: fork rejected by pids controller in \");\n\t\t\tpr_cont_cgroup_path(css->cgroup);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tcgroup_file_notify(&pids->events_file);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "pids_cancel_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "196-212",
    "snippet": "static void pids_cancel_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *dst_css;\n\n\tcgroup_taskset_for_each(task, dst_css, tset) {\n\t\tstruct pids_cgroup *pids = css_pids(dst_css);\n\t\tstruct cgroup_subsys_state *old_css;\n\t\tstruct pids_cgroup *old_pids;\n\n\t\told_css = task_css(task, pids_cgrp_id);\n\t\told_pids = css_pids(old_css);\n\n\t\tpids_charge(old_pids, 1);\n\t\tpids_uncharge(pids, 1);\n\t}\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_uncharge",
          "args": [
            "pids",
            "1"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "pids_uncharge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "110-116",
          "snippet": "static void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pids_charge",
          "args": [
            "old_pids",
            "1"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "pids_charge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "127-133",
          "snippet": "static void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "old_css"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "58-61",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "task",
            "pids_cgrp_id"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_for_each",
          "args": [
            "task",
            "dst_css",
            "tset"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_cancel_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *dst_css;\n\n\tcgroup_taskset_for_each(task, dst_css, tset) {\n\t\tstruct pids_cgroup *pids = css_pids(dst_css);\n\t\tstruct cgroup_subsys_state *old_css;\n\t\tstruct pids_cgroup *old_pids;\n\n\t\told_css = task_css(task, pids_cgrp_id);\n\t\told_pids = css_pids(old_css);\n\n\t\tpids_charge(old_pids, 1);\n\t\tpids_uncharge(pids, 1);\n\t}\n}"
  },
  {
    "function_name": "pids_can_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "171-194",
    "snippet": "static int pids_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *dst_css;\n\n\tcgroup_taskset_for_each(task, dst_css, tset) {\n\t\tstruct pids_cgroup *pids = css_pids(dst_css);\n\t\tstruct cgroup_subsys_state *old_css;\n\t\tstruct pids_cgroup *old_pids;\n\n\t\t/*\n\t\t * No need to pin @old_css between here and cancel_attach()\n\t\t * because cgroup core protects it from being freed before\n\t\t * the migration completes or fails.\n\t\t */\n\t\told_css = task_css(task, pids_cgrp_id);\n\t\told_pids = css_pids(old_css);\n\n\t\tpids_charge(pids, 1);\n\t\tpids_uncharge(old_pids, 1);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_uncharge",
          "args": [
            "old_pids",
            "1"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "pids_uncharge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "110-116",
          "snippet": "static void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pids_charge",
          "args": [
            "pids",
            "1"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "pids_charge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "127-133",
          "snippet": "static void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "old_css"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "58-61",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "task",
            "pids_cgrp_id"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_for_each",
          "args": [
            "task",
            "dst_css",
            "tset"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int pids_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *dst_css;\n\n\tcgroup_taskset_for_each(task, dst_css, tset) {\n\t\tstruct pids_cgroup *pids = css_pids(dst_css);\n\t\tstruct cgroup_subsys_state *old_css;\n\t\tstruct pids_cgroup *old_pids;\n\n\t\t/*\n\t\t * No need to pin @old_css between here and cancel_attach()\n\t\t * because cgroup core protects it from being freed before\n\t\t * the migration completes or fails.\n\t\t */\n\t\told_css = task_css(task, pids_cgrp_id);\n\t\told_pids = css_pids(old_css);\n\n\t\tpids_charge(pids, 1);\n\t\tpids_uncharge(old_pids, 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pids_try_charge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "144-169",
    "snippet": "static int pids_try_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p, *q;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {\n\t\tint64_t new = atomic64_add_return(num, &p->counter);\n\t\tint64_t limit = atomic64_read(&p->limit);\n\n\t\t/*\n\t\t * Since new is capped to the maximum number of pid_t, if\n\t\t * p->limit is %PIDS_MAX then we know that this test will never\n\t\t * fail.\n\t\t */\n\t\tif (new > limit)\n\t\t\tgoto revert;\n\t}\n\n\treturn 0;\n\nrevert:\n\tfor (q = pids; q != p; q = parent_pids(q))\n\t\tpids_cancel(q, num);\n\tpids_cancel(p, num);\n\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_cancel",
          "args": [
            "p",
            "num"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "pids_cancel_fork",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "242-253",
          "snippet": "static void pids_cancel_fork(struct task_struct *task, struct css_set *cset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\n\tif (cset)\n\t\tcss = cset->subsys[pids_cgrp_id];\n\telse\n\t\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\tpids_uncharge(pids, 1);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_cancel_fork(struct task_struct *task, struct css_set *cset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\n\tif (cset)\n\t\tcss = cset->subsys[pids_cgrp_id];\n\telse\n\t\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\tpids_uncharge(pids, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_pids",
          "args": [
            "q"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "parent_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "63-66",
          "snippet": "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&p->limit"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_add_return",
          "args": [
            "num",
            "&p->counter"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)\n\nstatic int pids_try_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p, *q;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {\n\t\tint64_t new = atomic64_add_return(num, &p->counter);\n\t\tint64_t limit = atomic64_read(&p->limit);\n\n\t\t/*\n\t\t * Since new is capped to the maximum number of pid_t, if\n\t\t * p->limit is %PIDS_MAX then we know that this test will never\n\t\t * fail.\n\t\t */\n\t\tif (new > limit)\n\t\t\tgoto revert;\n\t}\n\n\treturn 0;\n\nrevert:\n\tfor (q = pids; q != p; q = parent_pids(q))\n\t\tpids_cancel(q, num);\n\tpids_cancel(p, num);\n\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "pids_charge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "127-133",
    "snippet": "static void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "num",
            "&p->counter"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_pids",
          "args": [
            "p"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "parent_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "63-66",
          "snippet": "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}"
  },
  {
    "function_name": "pids_uncharge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "110-116",
    "snippet": "static void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_cancel",
          "args": [
            "p",
            "num"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "pids_cancel_fork",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "242-253",
          "snippet": "static void pids_cancel_fork(struct task_struct *task, struct css_set *cset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\n\tif (cset)\n\t\tcss = cset->subsys[pids_cgrp_id];\n\telse\n\t\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\tpids_uncharge(pids, 1);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_cancel_fork(struct task_struct *task, struct css_set *cset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\n\tif (cset)\n\t\tcss = cset->subsys[pids_cgrp_id];\n\telse\n\t\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\tpids_uncharge(pids, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_pids",
          "args": [
            "p"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "parent_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "63-66",
          "snippet": "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}"
  },
  {
    "function_name": "pids_cancel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "96-103",
    "snippet": "static void pids_cancel(struct pids_cgroup *pids, int num)\n{\n\t/*\n\t * A negative count (or overflow for that matter) is invalid,\n\t * and indicates a bug in the `pids` controller proper.\n\t */\n\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic64_add_negative(-num, &pids->counter)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_add_negative",
          "args": [
            "-num",
            "&pids->counter"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_cancel(struct pids_cgroup *pids, int num)\n{\n\t/*\n\t * A negative count (or overflow for that matter) is invalid,\n\t * and indicates a bug in the `pids` controller proper.\n\t */\n\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));\n}"
  },
  {
    "function_name": "pids_css_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "83-86",
    "snippet": "static void pids_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_pids(css));\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "css_pids(css)"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "58-61",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_pids(css));\n}"
  },
  {
    "function_name": "pids_css_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "68-81",
    "snippet": "static struct cgroup_subsys_state *\npids_css_alloc(struct cgroup_subsys_state *parent)\n{\n\tstruct pids_cgroup *pids;\n\n\tpids = kzalloc(sizeof(struct pids_cgroup), GFP_KERNEL);\n\tif (!pids)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic64_set(&pids->counter, 0);\n\tatomic64_set(&pids->limit, PIDS_MAX);\n\tatomic64_set(&pids->events_limit, 0);\n\treturn &pids->css;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&pids->events_limit",
            "0"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&pids->limit",
            "PIDS_MAX"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&pids->counter",
            "0"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct pids_cgroup)",
            "GFP_KERNEL"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)\n\nstatic struct cgroup_subsys_state *\npids_css_alloc(struct cgroup_subsys_state *parent)\n{\n\tstruct pids_cgroup *pids;\n\n\tpids = kzalloc(sizeof(struct pids_cgroup), GFP_KERNEL);\n\tif (!pids)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic64_set(&pids->counter, 0);\n\tatomic64_set(&pids->limit, PIDS_MAX);\n\tatomic64_set(&pids->events_limit, 0);\n\treturn &pids->css;\n}"
  },
  {
    "function_name": "parent_pids",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "63-66",
    "snippet": "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "pids->css.parent"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
          "lines": "58-61",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}"
  },
  {
    "function_name": "css_pids",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/pids.c",
    "lines": "58-61",
    "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structpids_cgroup",
            "css"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
  }
]