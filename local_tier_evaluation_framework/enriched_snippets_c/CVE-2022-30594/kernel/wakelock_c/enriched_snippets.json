[
  {
    "function_name": "pm_wake_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "254-288",
    "snippet": "int pm_wake_unlock(const char *buf)\n{\n\tstruct wakelock *wl;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\tlen = strlen(buf);\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, false);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\t__pm_relax(wl->ws);\n\n\twakelocks_lru_most_recent(wl);\n\twakelocks_gc();\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wakelocks_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakelocks_gc",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "wakelocks_gc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "147-147",
          "snippet": "static inline void wakelocks_gc(void) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_gc(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "wakelocks_lru_most_recent",
          "args": [
            "wl"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "wakelocks_lru_most_recent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "146-146",
          "snippet": "static inline void wakelocks_lru_most_recent(struct wakelock *wl) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl) {}"
        }
      },
      {
        "call_info": {
          "callee": "__pm_relax",
          "args": [
            "wl->ws"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "wl"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "wl"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelock_lookup_add",
          "args": [
            "buf",
            "len",
            "false"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "wakelock_lookup_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "150-204",
          "snippet": "static struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\twl->ws = wakeup_source_register(NULL, wl->name);\n\tif (!wl->ws) {\n\t\tkfree(wl->name);\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws->last_time = ktime_get();\n\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root wakelocks_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nstatic struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\twl->ws = wakeup_source_register(NULL, wl->name);\n\tif (!wl->ws) {\n\t\tkfree(wl->name);\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws->last_time = ktime_get();\n\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_BLOCK_SUSPEND"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\n\nint pm_wake_unlock(const char *buf)\n{\n\tstruct wakelock *wl;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\tlen = strlen(buf);\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, false);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\t__pm_relax(wl->ws);\n\n\twakelocks_lru_most_recent(wl);\n\twakelocks_gc();\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "pm_wake_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "206-252",
    "snippet": "int pm_wake_lock(const char *buf)\n{\n\tconst char *str = buf;\n\tstruct wakelock *wl;\n\tu64 timeout_ns = 0;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\twhile (*str && !isspace(*str))\n\t\tstr++;\n\n\tlen = str - buf;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (*str && *str != '\\n') {\n\t\t/* Find out if there's a valid timeout string appended. */\n\t\tret = kstrtou64(skip_spaces(str), 10, &timeout_ns);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, true);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\tif (timeout_ns) {\n\t\tu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;\n\n\t\tdo_div(timeout_ms, NSEC_PER_MSEC);\n\t\t__pm_wakeup_event(wl->ws, timeout_ms);\n\t} else {\n\t\t__pm_stay_awake(wl->ws);\n\t}\n\n\twakelocks_lru_most_recent(wl);\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wakelocks_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakelocks_lru_most_recent",
          "args": [
            "wl"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "wakelocks_lru_most_recent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "146-146",
          "snippet": "static inline void wakelocks_lru_most_recent(struct wakelock *wl) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl) {}"
        }
      },
      {
        "call_info": {
          "callee": "__pm_stay_awake",
          "args": [
            "wl->ws"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_wakeup_event",
          "args": [
            "wl->ws",
            "timeout_ms"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "timeout_ms",
            "NSEC_PER_MSEC"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "wl"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "wl"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelock_lookup_add",
          "args": [
            "buf",
            "len",
            "true"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "wakelock_lookup_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "150-204",
          "snippet": "static struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\twl->ws = wakeup_source_register(NULL, wl->name);\n\tif (!wl->ws) {\n\t\tkfree(wl->name);\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws->last_time = ktime_get();\n\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root wakelocks_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nstatic struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\twl->ws = wakeup_source_register(NULL, wl->name);\n\tif (!wl->ws) {\n\t\tkfree(wl->name);\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws->last_time = ktime_get();\n\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtou64",
          "args": [
            "skip_spaces(str)",
            "10",
            "&timeout_ns"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "str"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "proc_skip_spaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "333-340",
          "snippet": "static size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*str"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_BLOCK_SUSPEND"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\n\nint pm_wake_lock(const char *buf)\n{\n\tconst char *str = buf;\n\tstruct wakelock *wl;\n\tu64 timeout_ns = 0;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\twhile (*str && !isspace(*str))\n\t\tstr++;\n\n\tlen = str - buf;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (*str && *str != '\\n') {\n\t\t/* Find out if there's a valid timeout string appended. */\n\t\tret = kstrtou64(skip_spaces(str), 10, &timeout_ns);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, true);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\tif (timeout_ns) {\n\t\tu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;\n\n\t\tdo_div(timeout_ms, NSEC_PER_MSEC);\n\t\t__pm_wakeup_event(wl->ws, timeout_ms);\n\t} else {\n\t\t__pm_stay_awake(wl->ws);\n\t}\n\n\twakelocks_lru_most_recent(wl);\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "wakelock_lookup_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "150-204",
    "snippet": "static struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\twl->ws = wakeup_source_register(NULL, wl->name);\n\tif (!wl->ws) {\n\t\tkfree(wl->name);\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws->last_time = ktime_get();\n\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root wakelocks_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "increment_wakelocks_number",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "increment_wakelocks_number",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "80-80",
          "snippet": "static inline void increment_wakelocks_number(void) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void increment_wakelocks_number(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "wakelocks_lru_add",
          "args": [
            "wl"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "wakelocks_lru_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "145-145",
          "snippet": "static inline void wakelocks_lru_add(struct wakelock *wl) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_add(struct wakelock *wl) {}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&wl->node",
            "&wakelocks_tree"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&wl->node",
            "parent",
            "node"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wl"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_source_register",
          "args": [
            "NULL",
            "wl->name"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "name",
            "len",
            "GFP_KERNEL"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*wl)",
            "GFP_KERNEL"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelocks_limit_exceeded",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "wakelocks_limit_exceeded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "79-79",
          "snippet": "static inline bool wakelocks_limit_exceeded(void) { return false; }",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline bool wakelocks_limit_exceeded(void) { return false; }"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "wl->name",
            "len"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*node",
            "structwakelock",
            "node"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nstatic struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\twl->ws = wakeup_source_register(NULL, wl->name);\n\tif (!wl->ws) {\n\t\tkfree(wl->name);\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws->last_time = ktime_get();\n\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}"
  },
  {
    "function_name": "wakelocks_gc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "147-147",
    "snippet": "static inline void wakelocks_gc(void) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_gc(void) {}"
  },
  {
    "function_name": "wakelocks_lru_most_recent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "146-146",
    "snippet": "static inline void wakelocks_lru_most_recent(struct wakelock *wl) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl) {}"
  },
  {
    "function_name": "wakelocks_lru_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "145-145",
    "snippet": "static inline void wakelocks_lru_add(struct wakelock *wl) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_add(struct wakelock *wl) {}"
  },
  {
    "function_name": "wakelocks_gc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "137-143",
    "snippet": "static void wakelocks_gc(void)\n{\n\tif (++wakelocks_gc_count <= WL_GC_COUNT_MAX)\n\t\treturn;\n\n\tschedule_work(&wakelock_work);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define WL_GC_COUNT_MAX\t100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&wakelock_work"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\n#define WL_GC_COUNT_MAX\t100\n\nstatic void wakelocks_gc(void)\n{\n\tif (++wakelocks_gc_count <= WL_GC_COUNT_MAX)\n\t\treturn;\n\n\tschedule_work(&wakelock_work);\n}"
  },
  {
    "function_name": "__wakelocks_gc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "103-135",
    "snippet": "static void __wakelocks_gc(struct work_struct *work)\n{\n\tstruct wakelock *wl, *aux;\n\tktime_t now;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tnow = ktime_get();\n\tlist_for_each_entry_safe_reverse(wl, aux, &wakelocks_lru_list, lru) {\n\t\tu64 idle_time_ns;\n\t\tbool active;\n\n\t\tspin_lock_irq(&wl->ws->lock);\n\t\tidle_time_ns = ktime_to_ns(ktime_sub(now, wl->ws->last_time));\n\t\tactive = wl->ws->active;\n\t\tspin_unlock_irq(&wl->ws->lock);\n\n\t\tif (idle_time_ns < ((u64)WL_GC_TIME_SEC * NSEC_PER_SEC))\n\t\t\tbreak;\n\n\t\tif (!active) {\n\t\t\twakeup_source_unregister(wl->ws);\n\t\t\trb_erase(&wl->node, &wakelocks_tree);\n\t\t\tlist_del(&wl->lru);\n\t\t\tkfree(wl->name);\n\t\t\tkfree(wl);\n\t\t\tdecrement_wakelocks_number();\n\t\t}\n\t}\n\twakelocks_gc_count = 0;\n\n\tmutex_unlock(&wakelocks_lock);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define WL_GC_TIME_SEC\t300"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(wakelocks_lock);",
      "static struct rb_root wakelocks_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decrement_wakelocks_number",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "decrement_wakelocks_number",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "81-81",
          "snippet": "static inline void decrement_wakelocks_number(void) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void decrement_wakelocks_number(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wl"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&wl->lru"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&wl->node",
            "&wakelocks_tree"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_unregister",
          "args": [
            "wl->ws"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&wl->ws->lock"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(now, wl->ws->last_time)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "wl->ws->last_time"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&wl->ws->lock"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "wl",
            "aux",
            "&wakelocks_lru_list",
            "lru"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\n#define WL_GC_TIME_SEC\t300\n\nstatic DEFINE_MUTEX(wakelocks_lock);\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nstatic void __wakelocks_gc(struct work_struct *work)\n{\n\tstruct wakelock *wl, *aux;\n\tktime_t now;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tnow = ktime_get();\n\tlist_for_each_entry_safe_reverse(wl, aux, &wakelocks_lru_list, lru) {\n\t\tu64 idle_time_ns;\n\t\tbool active;\n\n\t\tspin_lock_irq(&wl->ws->lock);\n\t\tidle_time_ns = ktime_to_ns(ktime_sub(now, wl->ws->last_time));\n\t\tactive = wl->ws->active;\n\t\tspin_unlock_irq(&wl->ws->lock);\n\n\t\tif (idle_time_ns < ((u64)WL_GC_TIME_SEC * NSEC_PER_SEC))\n\t\t\tbreak;\n\n\t\tif (!active) {\n\t\t\twakeup_source_unregister(wl->ws);\n\t\t\trb_erase(&wl->node, &wakelocks_tree);\n\t\t\tlist_del(&wl->lru);\n\t\t\tkfree(wl->name);\n\t\t\tkfree(wl);\n\t\t\tdecrement_wakelocks_number();\n\t\t}\n\t}\n\twakelocks_gc_count = 0;\n\n\tmutex_unlock(&wakelocks_lock);\n}"
  },
  {
    "function_name": "wakelocks_lru_most_recent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "98-101",
    "snippet": "static inline void wakelocks_lru_most_recent(struct wakelock *wl)\n{\n\tlist_move(&wl->lru, &wakelocks_lru_list);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&wl->lru",
            "&wakelocks_lru_list"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl)\n{\n\tlist_move(&wl->lru, &wakelocks_lru_list);\n}"
  },
  {
    "function_name": "wakelocks_lru_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "93-96",
    "snippet": "static inline void wakelocks_lru_add(struct wakelock *wl)\n{\n\tlist_add(&wl->lru, &wakelocks_lru_list);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&wl->lru",
            "&wakelocks_lru_list"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_add(struct wakelock *wl)\n{\n\tlist_add(&wl->lru, &wakelocks_lru_list);\n}"
  },
  {
    "function_name": "decrement_wakelocks_number",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "81-81",
    "snippet": "static inline void decrement_wakelocks_number(void) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void decrement_wakelocks_number(void) {}"
  },
  {
    "function_name": "increment_wakelocks_number",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "80-80",
    "snippet": "static inline void increment_wakelocks_number(void) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void increment_wakelocks_number(void) {}"
  },
  {
    "function_name": "wakelocks_limit_exceeded",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "79-79",
    "snippet": "static inline bool wakelocks_limit_exceeded(void) { return false; }",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline bool wakelocks_limit_exceeded(void) { return false; }"
  },
  {
    "function_name": "decrement_wakelocks_number",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "74-77",
    "snippet": "static inline void decrement_wakelocks_number(void)\n{\n\tnumber_of_wakelocks--;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void decrement_wakelocks_number(void)\n{\n\tnumber_of_wakelocks--;\n}"
  },
  {
    "function_name": "increment_wakelocks_number",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "69-72",
    "snippet": "static inline void increment_wakelocks_number(void)\n{\n\tnumber_of_wakelocks++;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void increment_wakelocks_number(void)\n{\n\tnumber_of_wakelocks++;\n}"
  },
  {
    "function_name": "wakelocks_limit_exceeded",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "64-67",
    "snippet": "static inline bool wakelocks_limit_exceeded(void)\n{\n\treturn number_of_wakelocks > CONFIG_PM_WAKELOCKS_LIMIT;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline bool wakelocks_limit_exceeded(void)\n{\n\treturn number_of_wakelocks > CONFIG_PM_WAKELOCKS_LIMIT;\n}"
  },
  {
    "function_name": "pm_show_wakelocks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
    "lines": "38-59",
    "snippet": "ssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws->active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wakelocks_lock);",
      "static struct rb_root wakelocks_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "str",
            "end - str",
            "\"\\n\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "str",
            "end - str",
            "\"%s \"",
            "wl->name"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structwakelock",
            "node"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "prb_next_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_ringbuffer.c",
          "lines": "2006-2015",
          "snippet": "u64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}",
          "includes": [
            "#include \"printk_ringbuffer.h\"",
            "#include <linux/bug.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"printk_ringbuffer.h\"\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/irqflags.h>\n#include <linux/kernel.h>\n\nu64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&wakelocks_tree"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "prb_first_valid_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_ringbuffer.c",
          "lines": "1981-1989",
          "snippet": "u64 prb_first_valid_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\tif (!_prb_read_valid(rb, &seq, NULL, NULL))\n\t\treturn 0;\n\n\treturn seq;\n}",
          "includes": [
            "#include \"printk_ringbuffer.h\"",
            "#include <linux/bug.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"printk_ringbuffer.h\"\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/irqflags.h>\n#include <linux/kernel.h>\n\nu64 prb_first_valid_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\tif (!_prb_read_valid(rb, &seq, NULL, NULL))\n\t\treturn 0;\n\n\treturn seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws->active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}"
  }
]