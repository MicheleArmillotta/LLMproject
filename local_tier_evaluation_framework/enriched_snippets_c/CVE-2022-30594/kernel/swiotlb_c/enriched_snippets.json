[
  {
    "function_name": "rmem_swiotlb_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "882-901",
    "snippet": "static int __init rmem_swiotlb_setup(struct reserved_mem *rmem)\n{\n\tunsigned long node = rmem->fdt_node;\n\n\tif (of_get_flat_dt_prop(node, \"reusable\", NULL) ||\n\t    of_get_flat_dt_prop(node, \"linux,cma-default\", NULL) ||\n\t    of_get_flat_dt_prop(node, \"linux,dma-default\", NULL) ||\n\t    of_get_flat_dt_prop(node, \"no-map\", NULL))\n\t\treturn -EINVAL;\n\n\tif (PageHighMem(pfn_to_page(PHYS_PFN(rmem->base)))) {\n\t\tpr_err(\"Restricted DMA pool must be accessible within the linear mapping.\");\n\t\treturn -EINVAL;\n\t}\n\n\trmem->ops = &rmem_swiotlb_ops;\n\tpr_info(\"Reserved memory: created restricted DMA pool at %pa, size %ld MiB\\n\",\n\t\t&rmem->base, (unsigned long)rmem->size / SZ_1M);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Reserved memory: created restricted DMA pool at %pa, size %ld MiB\\n\"",
            "&rmem->base",
            "(unsigned long)rmem->size / SZ_1M"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Restricted DMA pool must be accessible within the linear mapping.\""
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "pfn_to_page(PHYS_PFN(rmem->base))"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "PHYS_PFN(rmem->base)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "rmem->base"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"no-map\"",
            "NULL"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,dma-default\"",
            "NULL"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,cma-default\"",
            "NULL"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"reusable\"",
            "NULL"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic int __init rmem_swiotlb_setup(struct reserved_mem *rmem)\n{\n\tunsigned long node = rmem->fdt_node;\n\n\tif (of_get_flat_dt_prop(node, \"reusable\", NULL) ||\n\t    of_get_flat_dt_prop(node, \"linux,cma-default\", NULL) ||\n\t    of_get_flat_dt_prop(node, \"linux,dma-default\", NULL) ||\n\t    of_get_flat_dt_prop(node, \"no-map\", NULL))\n\t\treturn -EINVAL;\n\n\tif (PageHighMem(pfn_to_page(PHYS_PFN(rmem->base)))) {\n\t\tpr_err(\"Restricted DMA pool must be accessible within the linear mapping.\");\n\t\treturn -EINVAL;\n\t}\n\n\trmem->ops = &rmem_swiotlb_ops;\n\tpr_info(\"Reserved memory: created restricted DMA pool at %pa, size %ld MiB\\n\",\n\t\t&rmem->base, (unsigned long)rmem->size / SZ_1M);\n\treturn 0;\n}"
  },
  {
    "function_name": "rmem_swiotlb_device_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "871-875",
    "snippet": "static void rmem_swiotlb_device_release(struct reserved_mem *rmem,\n\t\t\t\t\tstruct device *dev)\n{\n\tdev->dma_io_tlb_mem = &io_tlb_default_mem;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct io_tlb_mem io_tlb_default_mem;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstruct io_tlb_mem io_tlb_default_mem;\n\nstatic void rmem_swiotlb_device_release(struct reserved_mem *rmem,\n\t\t\t\t\tstruct device *dev)\n{\n\tdev->dma_io_tlb_mem = &io_tlb_default_mem;\n}"
  },
  {
    "function_name": "rmem_swiotlb_device_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "832-869",
    "snippet": "static int rmem_swiotlb_device_init(struct reserved_mem *rmem,\n\t\t\t\t    struct device *dev)\n{\n\tstruct io_tlb_mem *mem = rmem->priv;\n\tunsigned long nslabs = rmem->size >> IO_TLB_SHIFT;\n\n\t/*\n\t * Since multiple devices can share the same pool, the private data,\n\t * io_tlb_mem struct, will be initialized by the first device attached\n\t * to it.\n\t */\n\tif (!mem) {\n\t\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\t\tif (!mem)\n\t\t\treturn -ENOMEM;\n\n\t\tmem->slots = kzalloc(array_size(sizeof(*mem->slots), nslabs),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!mem->slots) {\n\t\t\tkfree(mem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tset_memory_decrypted((unsigned long)phys_to_virt(rmem->base),\n\t\t\t\t     rmem->size >> PAGE_SHIFT);\n\t\tswiotlb_init_io_tlb_mem(mem, rmem->base, nslabs, false);\n\t\tmem->force_bounce = true;\n\t\tmem->for_alloc = true;\n\n\t\trmem->priv = mem;\n\n\t\trmem_swiotlb_debugfs_init(rmem);\n\t}\n\n\tdev->dma_io_tlb_mem = mem;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmem_swiotlb_debugfs_init",
          "args": [
            "rmem"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "rmem_swiotlb_debugfs_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "797-799",
          "snippet": "static void rmem_swiotlb_debugfs_init(struct reserved_mem *rmem)\n{\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void rmem_swiotlb_debugfs_init(struct reserved_mem *rmem)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_init_io_tlb_mem",
          "args": [
            "mem",
            "rmem->base",
            "nslabs",
            "false"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_init_io_tlb_mem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "214-246",
          "snippet": "static void swiotlb_init_io_tlb_mem(struct io_tlb_mem *mem, phys_addr_t start,\n\t\t\t\t    unsigned long nslabs, bool late_alloc)\n{\n\tvoid *vaddr = phys_to_virt(start);\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT, i;\n\n\tmem->nslabs = nslabs;\n\tmem->start = start;\n\tmem->end = mem->start + bytes;\n\tmem->index = 0;\n\tmem->late_alloc = late_alloc;\n\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmem->force_bounce = true;\n\n\tspin_lock_init(&mem->lock);\n\tfor (i = 0; i < mem->nslabs; i++) {\n\t\tmem->slots[i].list = IO_TLB_SEGSIZE - io_tlb_offset(i);\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * If swiotlb_unencrypted_base is set, the bounce buffer memory will\n\t * be remapped and cleared in swiotlb_update_mem_attributes.\n\t */\n\tif (swiotlb_unencrypted_base)\n\t\treturn;\n\n\tmemset(vaddr, 0, bytes);\n\tmem->vaddr = vaddr;\n\treturn;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;",
            "phys_addr_t swiotlb_unencrypted_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nenum swiotlb_force swiotlb_force;\nphys_addr_t swiotlb_unencrypted_base;\n\nstatic void swiotlb_init_io_tlb_mem(struct io_tlb_mem *mem, phys_addr_t start,\n\t\t\t\t    unsigned long nslabs, bool late_alloc)\n{\n\tvoid *vaddr = phys_to_virt(start);\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT, i;\n\n\tmem->nslabs = nslabs;\n\tmem->start = start;\n\tmem->end = mem->start + bytes;\n\tmem->index = 0;\n\tmem->late_alloc = late_alloc;\n\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmem->force_bounce = true;\n\n\tspin_lock_init(&mem->lock);\n\tfor (i = 0; i < mem->nslabs; i++) {\n\t\tmem->slots[i].list = IO_TLB_SEGSIZE - io_tlb_offset(i);\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * If swiotlb_unencrypted_base is set, the bounce buffer memory will\n\t * be remapped and cleared in swiotlb_update_mem_attributes.\n\t */\n\tif (swiotlb_unencrypted_base)\n\t\treturn;\n\n\tmemset(vaddr, 0, bytes);\n\tmem->vaddr = vaddr;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_memory_decrypted",
          "args": [
            "(unsigned long)phys_to_virt(rmem->base)",
            "rmem->size >> PAGE_SHIFT"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "rmem->base"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mem"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "array_size(sizeof(*mem->slots), nslabs)",
            "GFP_KERNEL"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "sizeof(*mem->slots)",
            "nslabs"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*mem)",
            "GFP_KERNEL"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic int rmem_swiotlb_device_init(struct reserved_mem *rmem,\n\t\t\t\t    struct device *dev)\n{\n\tstruct io_tlb_mem *mem = rmem->priv;\n\tunsigned long nslabs = rmem->size >> IO_TLB_SHIFT;\n\n\t/*\n\t * Since multiple devices can share the same pool, the private data,\n\t * io_tlb_mem struct, will be initialized by the first device attached\n\t * to it.\n\t */\n\tif (!mem) {\n\t\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\t\tif (!mem)\n\t\t\treturn -ENOMEM;\n\n\t\tmem->slots = kzalloc(array_size(sizeof(*mem->slots), nslabs),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!mem->slots) {\n\t\t\tkfree(mem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tset_memory_decrypted((unsigned long)phys_to_virt(rmem->base),\n\t\t\t\t     rmem->size >> PAGE_SHIFT);\n\t\tswiotlb_init_io_tlb_mem(mem, rmem->base, nslabs, false);\n\t\tmem->force_bounce = true;\n\t\tmem->for_alloc = true;\n\n\t\trmem->priv = mem;\n\n\t\trmem_swiotlb_debugfs_init(rmem);\n\t}\n\n\tdev->dma_io_tlb_mem = mem;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "swiotlb_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "820-830",
    "snippet": "bool swiotlb_free(struct device *dev, struct page *page, size_t size)\n{\n\tphys_addr_t tlb_addr = page_to_phys(page);\n\n\tif (!is_swiotlb_buffer(dev, tlb_addr))\n\t\treturn false;\n\n\tswiotlb_release_slots(dev, tlb_addr);\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_release_slots",
          "args": [
            "dev",
            "tlb_addr"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_release_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "636-677",
          "snippet": "static void swiotlb_release_slots(struct device *dev, phys_addr_t tlb_addr)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long flags;\n\tunsigned int offset = swiotlb_align_offset(dev, tlb_addr);\n\tint index = (tlb_addr - offset - mem->start) >> IO_TLB_SHIFT;\n\tint nslots = nr_slots(mem->slots[index].alloc_size + offset);\n\tint count, i;\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (index + nslots < ALIGN(index + 1, IO_TLB_SEGSIZE))\n\t\tcount = mem->slots[index + nslots].list;\n\telse\n\t\tcount = 0;\n\n\t/*\n\t * Step 1: return the slots to the free list, merging the slots with\n\t * superceeding slots\n\t */\n\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\tmem->slots[i].list = ++count;\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * Step 2: merge the returned slots with the preceding slots, if\n\t * available (non zero)\n\t */\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 && mem->slots[i].list;\n\t     i--)\n\t\tmem->slots[i].list = ++count;\n\tmem->used -= nslots;\n\tspin_unlock_irqrestore(&mem->lock, flags);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic void swiotlb_release_slots(struct device *dev, phys_addr_t tlb_addr)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long flags;\n\tunsigned int offset = swiotlb_align_offset(dev, tlb_addr);\n\tint index = (tlb_addr - offset - mem->start) >> IO_TLB_SHIFT;\n\tint nslots = nr_slots(mem->slots[index].alloc_size + offset);\n\tint count, i;\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (index + nslots < ALIGN(index + 1, IO_TLB_SEGSIZE))\n\t\tcount = mem->slots[index + nslots].list;\n\telse\n\t\tcount = 0;\n\n\t/*\n\t * Step 1: return the slots to the free list, merging the slots with\n\t * superceeding slots\n\t */\n\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\tmem->slots[i].list = ++count;\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * Step 2: merge the returned slots with the preceding slots, if\n\t * available (non zero)\n\t */\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 && mem->slots[i].list;\n\t     i--)\n\t\tmem->slots[i].list = ++count;\n\tmem->used -= nslots;\n\tspin_unlock_irqrestore(&mem->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_swiotlb_buffer",
          "args": [
            "dev",
            "tlb_addr"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nbool swiotlb_free(struct device *dev, struct page *page, size_t size)\n{\n\tphys_addr_t tlb_addr = page_to_phys(page);\n\n\tif (!is_swiotlb_buffer(dev, tlb_addr))\n\t\treturn false;\n\n\tswiotlb_release_slots(dev, tlb_addr);\n\n\treturn true;\n}"
  },
  {
    "function_name": "swiotlb_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "802-818",
    "snippet": "struct page *swiotlb_alloc(struct device *dev, size_t size)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tphys_addr_t tlb_addr;\n\tint index;\n\n\tif (!mem)\n\t\treturn NULL;\n\n\tindex = swiotlb_find_slots(dev, 0, size, 0);\n\tif (index == -1)\n\t\treturn NULL;\n\n\ttlb_addr = slot_addr(mem->start, index);\n\n\treturn pfn_to_page(PFN_DOWN(tlb_addr));\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "PFN_DOWN(tlb_addr)"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "tlb_addr"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_addr",
          "args": [
            "mem->start",
            "index"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "__is_insn_slot_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "296-312",
          "snippet": "bool __is_insn_slot_addr(struct kprobe_insn_cache *c, unsigned long addr)\n{\n\tstruct kprobe_insn_page *kip;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (addr >= (unsigned long)kip->insns &&\n\t\t    addr < (unsigned long)kip->insns + PAGE_SIZE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __is_insn_slot_addr(struct kprobe_insn_cache *c, unsigned long addr)\n{\n\tstruct kprobe_insn_page *kip;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (addr >= (unsigned long)kip->insns &&\n\t\t    addr < (unsigned long)kip->insns + PAGE_SIZE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_find_slots",
          "args": [
            "dev",
            "0",
            "size",
            "0"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_find_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "507-587",
          "snippet": "static int swiotlb_find_slots(struct device *dev, phys_addr_t orig_addr,\n\t\t\t      size_t alloc_size, unsigned int alloc_align_mask)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long boundary_mask = dma_get_seg_boundary(dev);\n\tdma_addr_t tbl_dma_addr =\n\t\tphys_to_dma_unencrypted(dev, mem->start) & boundary_mask;\n\tunsigned long max_slots = get_max_slots(boundary_mask);\n\tunsigned int iotlb_align_mask =\n\t\tdma_get_min_align_mask(dev) & ~(IO_TLB_SIZE - 1);\n\tunsigned int nslots = nr_slots(alloc_size), stride;\n\tunsigned int index, wrap, count = 0, i;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned long flags;\n\n\tBUG_ON(!nslots);\n\n\t/*\n\t * For mappings with an alignment requirement don't bother looping to\n\t * unaligned slots once we found an aligned one.  For allocations of\n\t * PAGE_SIZE or larger only look for page aligned allocations.\n\t */\n\tstride = (iotlb_align_mask >> IO_TLB_SHIFT) + 1;\n\tif (alloc_size >= PAGE_SIZE)\n\t\tstride = max(stride, stride << (PAGE_SHIFT - IO_TLB_SHIFT));\n\tstride = max(stride, (alloc_align_mask >> IO_TLB_SHIFT) + 1);\n\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (unlikely(nslots > mem->nslabs - mem->used))\n\t\tgoto not_found;\n\n\tindex = wrap = wrap_index(mem, ALIGN(mem->index, stride));\n\tdo {\n\t\tif (orig_addr &&\n\t\t    (slot_addr(tbl_dma_addr, index) & iotlb_align_mask) !=\n\t\t\t    (orig_addr & iotlb_align_mask)) {\n\t\t\tindex = wrap_index(mem, index + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we find a slot that indicates we have 'nslots' number of\n\t\t * contiguous buffers, we allocate the buffers from that slot\n\t\t * and mark the entries as '0' indicating unavailable.\n\t\t */\n\t\tif (!iommu_is_span_boundary(index, nslots,\n\t\t\t\t\t    nr_slots(tbl_dma_addr),\n\t\t\t\t\t    max_slots)) {\n\t\t\tif (mem->slots[index].list >= nslots)\n\t\t\t\tgoto found;\n\t\t}\n\t\tindex = wrap_index(mem, index + stride);\n\t} while (index != wrap);\n\nnot_found:\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn -1;\n\nfound:\n\tfor (i = index; i < index + nslots; i++) {\n\t\tmem->slots[i].list = 0;\n\t\tmem->slots[i].alloc_size =\n\t\t\talloc_size - (offset + ((i - index) << IO_TLB_SHIFT));\n\t}\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 &&\n\t     mem->slots[i].list; i--)\n\t\tmem->slots[i].list = ++count;\n\n\t/*\n\t * Update the indices to avoid searching in the next round.\n\t */\n\tif (index + nslots < mem->nslabs)\n\t\tmem->index = index + nslots;\n\telse\n\t\tmem->index = 0;\n\tmem->used += nslots;\n\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn index;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic int swiotlb_find_slots(struct device *dev, phys_addr_t orig_addr,\n\t\t\t      size_t alloc_size, unsigned int alloc_align_mask)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long boundary_mask = dma_get_seg_boundary(dev);\n\tdma_addr_t tbl_dma_addr =\n\t\tphys_to_dma_unencrypted(dev, mem->start) & boundary_mask;\n\tunsigned long max_slots = get_max_slots(boundary_mask);\n\tunsigned int iotlb_align_mask =\n\t\tdma_get_min_align_mask(dev) & ~(IO_TLB_SIZE - 1);\n\tunsigned int nslots = nr_slots(alloc_size), stride;\n\tunsigned int index, wrap, count = 0, i;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned long flags;\n\n\tBUG_ON(!nslots);\n\n\t/*\n\t * For mappings with an alignment requirement don't bother looping to\n\t * unaligned slots once we found an aligned one.  For allocations of\n\t * PAGE_SIZE or larger only look for page aligned allocations.\n\t */\n\tstride = (iotlb_align_mask >> IO_TLB_SHIFT) + 1;\n\tif (alloc_size >= PAGE_SIZE)\n\t\tstride = max(stride, stride << (PAGE_SHIFT - IO_TLB_SHIFT));\n\tstride = max(stride, (alloc_align_mask >> IO_TLB_SHIFT) + 1);\n\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (unlikely(nslots > mem->nslabs - mem->used))\n\t\tgoto not_found;\n\n\tindex = wrap = wrap_index(mem, ALIGN(mem->index, stride));\n\tdo {\n\t\tif (orig_addr &&\n\t\t    (slot_addr(tbl_dma_addr, index) & iotlb_align_mask) !=\n\t\t\t    (orig_addr & iotlb_align_mask)) {\n\t\t\tindex = wrap_index(mem, index + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we find a slot that indicates we have 'nslots' number of\n\t\t * contiguous buffers, we allocate the buffers from that slot\n\t\t * and mark the entries as '0' indicating unavailable.\n\t\t */\n\t\tif (!iommu_is_span_boundary(index, nslots,\n\t\t\t\t\t    nr_slots(tbl_dma_addr),\n\t\t\t\t\t    max_slots)) {\n\t\t\tif (mem->slots[index].list >= nslots)\n\t\t\t\tgoto found;\n\t\t}\n\t\tindex = wrap_index(mem, index + stride);\n\t} while (index != wrap);\n\nnot_found:\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn -1;\n\nfound:\n\tfor (i = index; i < index + nslots; i++) {\n\t\tmem->slots[i].list = 0;\n\t\tmem->slots[i].alloc_size =\n\t\t\talloc_size - (offset + ((i - index) << IO_TLB_SHIFT));\n\t}\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 &&\n\t     mem->slots[i].list; i--)\n\t\tmem->slots[i].list = ++count;\n\n\t/*\n\t * Update the indices to avoid searching in the next round.\n\t */\n\tif (index + nslots < mem->nslabs)\n\t\tmem->index = index + nslots;\n\telse\n\t\tmem->index = 0;\n\tmem->used += nslots;\n\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn index;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstruct page *swiotlb_alloc(struct device *dev, size_t size)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tphys_addr_t tlb_addr;\n\tint index;\n\n\tif (!mem)\n\t\treturn NULL;\n\n\tindex = swiotlb_find_slots(dev, 0, size, 0);\n\tif (index == -1)\n\t\treturn NULL;\n\n\ttlb_addr = slot_addr(mem->start, index);\n\n\treturn pfn_to_page(PFN_DOWN(tlb_addr));\n}"
  },
  {
    "function_name": "rmem_swiotlb_debugfs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "797-799",
    "snippet": "static void rmem_swiotlb_debugfs_init(struct reserved_mem *rmem)\n{\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void rmem_swiotlb_debugfs_init(struct reserved_mem *rmem)\n{\n}"
  },
  {
    "function_name": "rmem_swiotlb_debugfs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "789-795",
    "snippet": "static void rmem_swiotlb_debugfs_init(struct reserved_mem *rmem)\n{\n\tstruct io_tlb_mem *mem = rmem->priv;\n\n\tmem->debugfs = debugfs_create_dir(rmem->name, debugfs_dir);\n\tswiotlb_create_debugfs_files(mem);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_create_debugfs_files",
          "args": [
            "mem"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_create_debugfs_files",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "764-768",
          "snippet": "static void swiotlb_create_debugfs_files(struct io_tlb_mem *mem)\n{\n\tdebugfs_create_ulong(\"io_tlb_nslabs\", 0400, mem->debugfs, &mem->nslabs);\n\tdebugfs_create_ulong(\"io_tlb_used\", 0400, mem->debugfs, &mem->used);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void swiotlb_create_debugfs_files(struct io_tlb_mem *mem)\n{\n\tdebugfs_create_ulong(\"io_tlb_nslabs\", 0400, mem->debugfs, &mem->nslabs);\n\tdebugfs_create_ulong(\"io_tlb_used\", 0400, mem->debugfs, &mem->used);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "rmem->name",
            "debugfs_dir"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void rmem_swiotlb_debugfs_init(struct reserved_mem *rmem)\n{\n\tstruct io_tlb_mem *mem = rmem->priv;\n\n\tmem->debugfs = debugfs_create_dir(rmem->name, debugfs_dir);\n\tswiotlb_create_debugfs_files(mem);\n}"
  },
  {
    "function_name": "swiotlb_create_default_debugfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "770-780",
    "snippet": "static int __init swiotlb_create_default_debugfs(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\n\tdebugfs_dir = debugfs_create_dir(\"swiotlb\", NULL);\n\tif (mem->nslabs) {\n\t\tmem->debugfs = debugfs_dir;\n\t\tswiotlb_create_debugfs_files(mem);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct io_tlb_mem io_tlb_default_mem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_create_debugfs_files",
          "args": [
            "mem"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_create_debugfs_files",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "764-768",
          "snippet": "static void swiotlb_create_debugfs_files(struct io_tlb_mem *mem)\n{\n\tdebugfs_create_ulong(\"io_tlb_nslabs\", 0400, mem->debugfs, &mem->nslabs);\n\tdebugfs_create_ulong(\"io_tlb_used\", 0400, mem->debugfs, &mem->used);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void swiotlb_create_debugfs_files(struct io_tlb_mem *mem)\n{\n\tdebugfs_create_ulong(\"io_tlb_nslabs\", 0400, mem->debugfs, &mem->nslabs);\n\tdebugfs_create_ulong(\"io_tlb_used\", 0400, mem->debugfs, &mem->used);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"swiotlb\"",
            "NULL"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstruct io_tlb_mem io_tlb_default_mem;\n\nstatic int __init swiotlb_create_default_debugfs(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\n\tdebugfs_dir = debugfs_create_dir(\"swiotlb\", NULL);\n\tif (mem->nslabs) {\n\t\tmem->debugfs = debugfs_dir;\n\t\tswiotlb_create_debugfs_files(mem);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "swiotlb_create_debugfs_files",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "764-768",
    "snippet": "static void swiotlb_create_debugfs_files(struct io_tlb_mem *mem)\n{\n\tdebugfs_create_ulong(\"io_tlb_nslabs\", 0400, mem->debugfs, &mem->nslabs);\n\tdebugfs_create_ulong(\"io_tlb_used\", 0400, mem->debugfs, &mem->used);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_ulong",
          "args": [
            "\"io_tlb_used\"",
            "0400",
            "mem->debugfs",
            "&mem->used"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_ulong",
          "args": [
            "\"io_tlb_nslabs\"",
            "0400",
            "mem->debugfs",
            "&mem->nslabs"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void swiotlb_create_debugfs_files(struct io_tlb_mem *mem)\n{\n\tdebugfs_create_ulong(\"io_tlb_nslabs\", 0400, mem->debugfs, &mem->nslabs);\n\tdebugfs_create_ulong(\"io_tlb_used\", 0400, mem->debugfs, &mem->used);\n}"
  },
  {
    "function_name": "is_swiotlb_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "753-758",
    "snippet": "bool is_swiotlb_active(struct device *dev)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\n\treturn mem && mem->nslabs;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nbool is_swiotlb_active(struct device *dev)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\n\treturn mem && mem->nslabs;\n}"
  },
  {
    "function_name": "swiotlb_max_mapping_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "748-751",
    "snippet": "size_t swiotlb_max_mapping_size(struct device *dev)\n{\n\treturn ((size_t)IO_TLB_SIZE) * IO_TLB_SEGSIZE;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nsize_t swiotlb_max_mapping_size(struct device *dev)\n{\n\treturn ((size_t)IO_TLB_SIZE) * IO_TLB_SEGSIZE;\n}"
  },
  {
    "function_name": "swiotlb_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "718-746",
    "snippet": "dma_addr_t swiotlb_map(struct device *dev, phys_addr_t paddr, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t swiotlb_addr;\n\tdma_addr_t dma_addr;\n\n\ttrace_swiotlb_bounced(dev, phys_to_dma(dev, paddr), size,\n\t\t\t      swiotlb_force);\n\n\tswiotlb_addr = swiotlb_tbl_map_single(dev, paddr, size, size, 0, dir,\n\t\t\tattrs);\n\tif (swiotlb_addr == (phys_addr_t)DMA_MAPPING_ERROR)\n\t\treturn DMA_MAPPING_ERROR;\n\n\t/* Ensure that the address returned is DMA'ble */\n\tdma_addr = phys_to_dma_unencrypted(dev, swiotlb_addr);\n\tif (unlikely(!dma_capable(dev, dma_addr, size, true))) {\n\t\tswiotlb_tbl_unmap_single(dev, swiotlb_addr, size, dir,\n\t\t\tattrs | DMA_ATTR_SKIP_CPU_SYNC);\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"swiotlb addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t&dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tarch_sync_dma_for_device(swiotlb_addr, size, dir);\n\treturn dma_addr;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_sync_dma_for_device",
          "args": [
            "swiotlb_addr",
            "size",
            "dir"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_WARN_ONCE",
          "args": [
            "dev",
            "1",
            "\"swiotlb addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\"",
            "&dma_addr",
            "size",
            "*dev->dma_mask",
            "dev->bus_dma_limit"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_tbl_unmap_single",
          "args": [
            "dev",
            "swiotlb_addr",
            "size",
            "dir",
            "attrs | DMA_ATTR_SKIP_CPU_SYNC"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_tbl_unmap_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "682-694",
          "snippet": "void swiotlb_tbl_unmap_single(struct device *dev, phys_addr_t tlb_addr,\n\t\t\t      size_t mapping_size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_FROM_DEVICE);\n\n\tswiotlb_release_slots(dev, tlb_addr);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid swiotlb_tbl_unmap_single(struct device *dev, phys_addr_t tlb_addr,\n\t\t\t      size_t mapping_size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_FROM_DEVICE);\n\n\tswiotlb_release_slots(dev, tlb_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dma_capable(dev, dma_addr, size, true)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_capable",
          "args": [
            "dev",
            "dma_addr",
            "size",
            "true"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_dma_unencrypted",
          "args": [
            "dev",
            "swiotlb_addr"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_tbl_map_single",
          "args": [
            "dev",
            "paddr",
            "size",
            "size",
            "0",
            "dir",
            "attrs"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_tbl_map_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "589-634",
          "snippet": "phys_addr_t swiotlb_tbl_map_single(struct device *dev, phys_addr_t orig_addr,\n\t\tsize_t mapping_size, size_t alloc_size,\n\t\tunsigned int alloc_align_mask, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned int i;\n\tint index;\n\tphys_addr_t tlb_addr;\n\n\tif (!mem)\n\t\tpanic(\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\");\n\n\tif (cc_platform_has(CC_ATTR_MEM_ENCRYPT))\n\t\tpr_warn_once(\"Memory encryption is active and system is using DMA bounce buffers\\n\");\n\n\tif (mapping_size > alloc_size) {\n\t\tdev_warn_once(dev, \"Invalid sizes (mapping: %zd bytes, alloc: %zd bytes)\",\n\t\t\t      mapping_size, alloc_size);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\tindex = swiotlb_find_slots(dev, orig_addr,\n\t\t\t\t   alloc_size + offset, alloc_align_mask);\n\tif (index == -1) {\n\t\tif (!(attrs & DMA_ATTR_NO_WARN))\n\t\t\tdev_warn_ratelimited(dev,\n\t\"swiotlb buffer is full (sz: %zd bytes), total %lu (slots), used %lu (slots)\\n\",\n\t\t\t\t alloc_size, mem->nslabs, mem->used);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\t/*\n\t * Save away the mapping from the original address to the DMA address.\n\t * This is needed when we sync the memory.  Then we sync the buffer if\n\t * needed.\n\t */\n\tfor (i = 0; i < nr_slots(alloc_size + offset); i++)\n\t\tmem->slots[index + i].orig_addr = slot_addr(orig_addr, i);\n\ttlb_addr = slot_addr(mem->start, index) + offset;\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_TO_DEVICE);\n\treturn tlb_addr;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nphys_addr_t swiotlb_tbl_map_single(struct device *dev, phys_addr_t orig_addr,\n\t\tsize_t mapping_size, size_t alloc_size,\n\t\tunsigned int alloc_align_mask, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned int i;\n\tint index;\n\tphys_addr_t tlb_addr;\n\n\tif (!mem)\n\t\tpanic(\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\");\n\n\tif (cc_platform_has(CC_ATTR_MEM_ENCRYPT))\n\t\tpr_warn_once(\"Memory encryption is active and system is using DMA bounce buffers\\n\");\n\n\tif (mapping_size > alloc_size) {\n\t\tdev_warn_once(dev, \"Invalid sizes (mapping: %zd bytes, alloc: %zd bytes)\",\n\t\t\t      mapping_size, alloc_size);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\tindex = swiotlb_find_slots(dev, orig_addr,\n\t\t\t\t   alloc_size + offset, alloc_align_mask);\n\tif (index == -1) {\n\t\tif (!(attrs & DMA_ATTR_NO_WARN))\n\t\t\tdev_warn_ratelimited(dev,\n\t\"swiotlb buffer is full (sz: %zd bytes), total %lu (slots), used %lu (slots)\\n\",\n\t\t\t\t alloc_size, mem->nslabs, mem->used);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\t/*\n\t * Save away the mapping from the original address to the DMA address.\n\t * This is needed when we sync the memory.  Then we sync the buffer if\n\t * needed.\n\t */\n\tfor (i = 0; i < nr_slots(alloc_size + offset); i++)\n\t\tmem->slots[index + i].orig_addr = slot_addr(orig_addr, i);\n\ttlb_addr = slot_addr(mem->start, index) + offset;\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_TO_DEVICE);\n\treturn tlb_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_swiotlb_bounced",
          "args": [
            "dev",
            "phys_to_dma(dev, paddr)",
            "size",
            "swiotlb_force"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_dma",
          "args": [
            "dev",
            "paddr"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "25-31",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\n\ndma_addr_t swiotlb_map(struct device *dev, phys_addr_t paddr, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t swiotlb_addr;\n\tdma_addr_t dma_addr;\n\n\ttrace_swiotlb_bounced(dev, phys_to_dma(dev, paddr), size,\n\t\t\t      swiotlb_force);\n\n\tswiotlb_addr = swiotlb_tbl_map_single(dev, paddr, size, size, 0, dir,\n\t\t\tattrs);\n\tif (swiotlb_addr == (phys_addr_t)DMA_MAPPING_ERROR)\n\t\treturn DMA_MAPPING_ERROR;\n\n\t/* Ensure that the address returned is DMA'ble */\n\tdma_addr = phys_to_dma_unencrypted(dev, swiotlb_addr);\n\tif (unlikely(!dma_capable(dev, dma_addr, size, true))) {\n\t\tswiotlb_tbl_unmap_single(dev, swiotlb_addr, size, dir,\n\t\t\tattrs | DMA_ATTR_SKIP_CPU_SYNC);\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"swiotlb addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t&dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tarch_sync_dma_for_device(swiotlb_addr, size, dir);\n\treturn dma_addr;\n}"
  },
  {
    "function_name": "swiotlb_sync_single_for_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "705-712",
    "snippet": "void swiotlb_sync_single_for_cpu(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_FROM_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_TO_DEVICE);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dir != DMA_TO_DEVICE"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_bounce",
          "args": [
            "dev",
            "tlb_addr",
            "size",
            "DMA_FROM_DEVICE"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_bounce",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "412-482",
          "snippet": "static void swiotlb_bounce(struct device *dev, phys_addr_t tlb_addr, size_t size,\n\t\t\t   enum dma_data_direction dir)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tint index = (tlb_addr - mem->start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = mem->slots[index].orig_addr;\n\tsize_t alloc_size = mem->slots[index].alloc_size;\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = mem->vaddr + tlb_addr - mem->start;\n\tunsigned int tlb_offset, orig_addr_offset;\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\n\ttlb_offset = tlb_addr & (IO_TLB_SIZE - 1);\n\torig_addr_offset = swiotlb_align_offset(dev, orig_addr);\n\tif (tlb_offset < orig_addr_offset) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Access before mapping start detected. orig offset %u, requested offset %u.\\n\",\n\t\t\torig_addr_offset, tlb_offset);\n\t\treturn;\n\t}\n\n\ttlb_offset -= orig_addr_offset;\n\tif (tlb_offset > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu+%u.\\n\",\n\t\t\talloc_size, size, tlb_offset);\n\t\treturn;\n\t}\n\n\torig_addr += tlb_offset;\n\talloc_size -= tlb_offset;\n\n\tif (size > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\\n\",\n\t\t\talloc_size, size);\n\t\tsize = alloc_size;\n\t}\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic void swiotlb_bounce(struct device *dev, phys_addr_t tlb_addr, size_t size,\n\t\t\t   enum dma_data_direction dir)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tint index = (tlb_addr - mem->start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = mem->slots[index].orig_addr;\n\tsize_t alloc_size = mem->slots[index].alloc_size;\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = mem->vaddr + tlb_addr - mem->start;\n\tunsigned int tlb_offset, orig_addr_offset;\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\n\ttlb_offset = tlb_addr & (IO_TLB_SIZE - 1);\n\torig_addr_offset = swiotlb_align_offset(dev, orig_addr);\n\tif (tlb_offset < orig_addr_offset) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Access before mapping start detected. orig offset %u, requested offset %u.\\n\",\n\t\t\torig_addr_offset, tlb_offset);\n\t\treturn;\n\t}\n\n\ttlb_offset -= orig_addr_offset;\n\tif (tlb_offset > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu+%u.\\n\",\n\t\t\talloc_size, size, tlb_offset);\n\t\treturn;\n\t}\n\n\torig_addr += tlb_offset;\n\talloc_size -= tlb_offset;\n\n\tif (size > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\\n\",\n\t\t\talloc_size, size);\n\t\tsize = alloc_size;\n\t}\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid swiotlb_sync_single_for_cpu(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_FROM_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_TO_DEVICE);\n}"
  },
  {
    "function_name": "swiotlb_sync_single_for_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "696-703",
    "snippet": "void swiotlb_sync_single_for_device(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dir != DMA_FROM_DEVICE"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_bounce",
          "args": [
            "dev",
            "tlb_addr",
            "size",
            "DMA_TO_DEVICE"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_bounce",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "412-482",
          "snippet": "static void swiotlb_bounce(struct device *dev, phys_addr_t tlb_addr, size_t size,\n\t\t\t   enum dma_data_direction dir)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tint index = (tlb_addr - mem->start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = mem->slots[index].orig_addr;\n\tsize_t alloc_size = mem->slots[index].alloc_size;\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = mem->vaddr + tlb_addr - mem->start;\n\tunsigned int tlb_offset, orig_addr_offset;\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\n\ttlb_offset = tlb_addr & (IO_TLB_SIZE - 1);\n\torig_addr_offset = swiotlb_align_offset(dev, orig_addr);\n\tif (tlb_offset < orig_addr_offset) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Access before mapping start detected. orig offset %u, requested offset %u.\\n\",\n\t\t\torig_addr_offset, tlb_offset);\n\t\treturn;\n\t}\n\n\ttlb_offset -= orig_addr_offset;\n\tif (tlb_offset > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu+%u.\\n\",\n\t\t\talloc_size, size, tlb_offset);\n\t\treturn;\n\t}\n\n\torig_addr += tlb_offset;\n\talloc_size -= tlb_offset;\n\n\tif (size > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\\n\",\n\t\t\talloc_size, size);\n\t\tsize = alloc_size;\n\t}\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic void swiotlb_bounce(struct device *dev, phys_addr_t tlb_addr, size_t size,\n\t\t\t   enum dma_data_direction dir)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tint index = (tlb_addr - mem->start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = mem->slots[index].orig_addr;\n\tsize_t alloc_size = mem->slots[index].alloc_size;\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = mem->vaddr + tlb_addr - mem->start;\n\tunsigned int tlb_offset, orig_addr_offset;\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\n\ttlb_offset = tlb_addr & (IO_TLB_SIZE - 1);\n\torig_addr_offset = swiotlb_align_offset(dev, orig_addr);\n\tif (tlb_offset < orig_addr_offset) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Access before mapping start detected. orig offset %u, requested offset %u.\\n\",\n\t\t\torig_addr_offset, tlb_offset);\n\t\treturn;\n\t}\n\n\ttlb_offset -= orig_addr_offset;\n\tif (tlb_offset > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu+%u.\\n\",\n\t\t\talloc_size, size, tlb_offset);\n\t\treturn;\n\t}\n\n\torig_addr += tlb_offset;\n\talloc_size -= tlb_offset;\n\n\tif (size > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\\n\",\n\t\t\talloc_size, size);\n\t\tsize = alloc_size;\n\t}\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid swiotlb_sync_single_for_device(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n}"
  },
  {
    "function_name": "swiotlb_tbl_unmap_single",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "682-694",
    "snippet": "void swiotlb_tbl_unmap_single(struct device *dev, phys_addr_t tlb_addr,\n\t\t\t      size_t mapping_size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_FROM_DEVICE);\n\n\tswiotlb_release_slots(dev, tlb_addr);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_release_slots",
          "args": [
            "dev",
            "tlb_addr"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_release_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "636-677",
          "snippet": "static void swiotlb_release_slots(struct device *dev, phys_addr_t tlb_addr)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long flags;\n\tunsigned int offset = swiotlb_align_offset(dev, tlb_addr);\n\tint index = (tlb_addr - offset - mem->start) >> IO_TLB_SHIFT;\n\tint nslots = nr_slots(mem->slots[index].alloc_size + offset);\n\tint count, i;\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (index + nslots < ALIGN(index + 1, IO_TLB_SEGSIZE))\n\t\tcount = mem->slots[index + nslots].list;\n\telse\n\t\tcount = 0;\n\n\t/*\n\t * Step 1: return the slots to the free list, merging the slots with\n\t * superceeding slots\n\t */\n\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\tmem->slots[i].list = ++count;\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * Step 2: merge the returned slots with the preceding slots, if\n\t * available (non zero)\n\t */\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 && mem->slots[i].list;\n\t     i--)\n\t\tmem->slots[i].list = ++count;\n\tmem->used -= nslots;\n\tspin_unlock_irqrestore(&mem->lock, flags);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic void swiotlb_release_slots(struct device *dev, phys_addr_t tlb_addr)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long flags;\n\tunsigned int offset = swiotlb_align_offset(dev, tlb_addr);\n\tint index = (tlb_addr - offset - mem->start) >> IO_TLB_SHIFT;\n\tint nslots = nr_slots(mem->slots[index].alloc_size + offset);\n\tint count, i;\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (index + nslots < ALIGN(index + 1, IO_TLB_SEGSIZE))\n\t\tcount = mem->slots[index + nslots].list;\n\telse\n\t\tcount = 0;\n\n\t/*\n\t * Step 1: return the slots to the free list, merging the slots with\n\t * superceeding slots\n\t */\n\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\tmem->slots[i].list = ++count;\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * Step 2: merge the returned slots with the preceding slots, if\n\t * available (non zero)\n\t */\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 && mem->slots[i].list;\n\t     i--)\n\t\tmem->slots[i].list = ++count;\n\tmem->used -= nslots;\n\tspin_unlock_irqrestore(&mem->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_bounce",
          "args": [
            "dev",
            "tlb_addr",
            "mapping_size",
            "DMA_FROM_DEVICE"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_bounce",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "412-482",
          "snippet": "static void swiotlb_bounce(struct device *dev, phys_addr_t tlb_addr, size_t size,\n\t\t\t   enum dma_data_direction dir)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tint index = (tlb_addr - mem->start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = mem->slots[index].orig_addr;\n\tsize_t alloc_size = mem->slots[index].alloc_size;\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = mem->vaddr + tlb_addr - mem->start;\n\tunsigned int tlb_offset, orig_addr_offset;\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\n\ttlb_offset = tlb_addr & (IO_TLB_SIZE - 1);\n\torig_addr_offset = swiotlb_align_offset(dev, orig_addr);\n\tif (tlb_offset < orig_addr_offset) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Access before mapping start detected. orig offset %u, requested offset %u.\\n\",\n\t\t\torig_addr_offset, tlb_offset);\n\t\treturn;\n\t}\n\n\ttlb_offset -= orig_addr_offset;\n\tif (tlb_offset > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu+%u.\\n\",\n\t\t\talloc_size, size, tlb_offset);\n\t\treturn;\n\t}\n\n\torig_addr += tlb_offset;\n\talloc_size -= tlb_offset;\n\n\tif (size > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\\n\",\n\t\t\talloc_size, size);\n\t\tsize = alloc_size;\n\t}\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic void swiotlb_bounce(struct device *dev, phys_addr_t tlb_addr, size_t size,\n\t\t\t   enum dma_data_direction dir)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tint index = (tlb_addr - mem->start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = mem->slots[index].orig_addr;\n\tsize_t alloc_size = mem->slots[index].alloc_size;\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = mem->vaddr + tlb_addr - mem->start;\n\tunsigned int tlb_offset, orig_addr_offset;\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\n\ttlb_offset = tlb_addr & (IO_TLB_SIZE - 1);\n\torig_addr_offset = swiotlb_align_offset(dev, orig_addr);\n\tif (tlb_offset < orig_addr_offset) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Access before mapping start detected. orig offset %u, requested offset %u.\\n\",\n\t\t\torig_addr_offset, tlb_offset);\n\t\treturn;\n\t}\n\n\ttlb_offset -= orig_addr_offset;\n\tif (tlb_offset > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu+%u.\\n\",\n\t\t\talloc_size, size, tlb_offset);\n\t\treturn;\n\t}\n\n\torig_addr += tlb_offset;\n\talloc_size -= tlb_offset;\n\n\tif (size > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\\n\",\n\t\t\talloc_size, size);\n\t\tsize = alloc_size;\n\t}\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid swiotlb_tbl_unmap_single(struct device *dev, phys_addr_t tlb_addr,\n\t\t\t      size_t mapping_size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_FROM_DEVICE);\n\n\tswiotlb_release_slots(dev, tlb_addr);\n}"
  },
  {
    "function_name": "swiotlb_release_slots",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "636-677",
    "snippet": "static void swiotlb_release_slots(struct device *dev, phys_addr_t tlb_addr)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long flags;\n\tunsigned int offset = swiotlb_align_offset(dev, tlb_addr);\n\tint index = (tlb_addr - offset - mem->start) >> IO_TLB_SHIFT;\n\tint nslots = nr_slots(mem->slots[index].alloc_size + offset);\n\tint count, i;\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (index + nslots < ALIGN(index + 1, IO_TLB_SEGSIZE))\n\t\tcount = mem->slots[index + nslots].list;\n\telse\n\t\tcount = 0;\n\n\t/*\n\t * Step 1: return the slots to the free list, merging the slots with\n\t * superceeding slots\n\t */\n\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\tmem->slots[i].list = ++count;\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * Step 2: merge the returned slots with the preceding slots, if\n\t * available (non zero)\n\t */\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 && mem->slots[i].list;\n\t     i--)\n\t\tmem->slots[i].list = ++count;\n\tmem->used -= nslots;\n\tspin_unlock_irqrestore(&mem->lock, flags);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [
      "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&mem->lock",
            "flags"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_tlb_offset",
          "args": [
            "i"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "io_tlb_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "151-154",
          "snippet": "static inline unsigned long io_tlb_offset(unsigned long val)\n{\n\treturn val & (IO_TLB_SEGSIZE - 1);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic inline unsigned long io_tlb_offset(unsigned long val)\n{\n\treturn val & (IO_TLB_SEGSIZE - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "index + 1",
            "IO_TLB_SEGSIZE"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&mem->lock",
            "flags"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_slots",
          "args": [
            "mem->slots[index].alloc_size + offset"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "nr_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "156-159",
          "snippet": "static inline unsigned long nr_slots(u64 val)\n{\n\treturn DIV_ROUND_UP(val, IO_TLB_SIZE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic inline unsigned long nr_slots(u64 val)\n{\n\treturn DIV_ROUND_UP(val, IO_TLB_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_align_offset",
          "args": [
            "dev",
            "tlb_addr"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_align_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "404-407",
          "snippet": "static unsigned int swiotlb_align_offset(struct device *dev, u64 addr)\n{\n\treturn addr & dma_get_min_align_mask(dev) & (IO_TLB_SIZE - 1);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned int swiotlb_align_offset(struct device *dev, u64 addr)\n{\n\treturn addr & dma_get_min_align_mask(dev) & (IO_TLB_SIZE - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic void swiotlb_release_slots(struct device *dev, phys_addr_t tlb_addr)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long flags;\n\tunsigned int offset = swiotlb_align_offset(dev, tlb_addr);\n\tint index = (tlb_addr - offset - mem->start) >> IO_TLB_SHIFT;\n\tint nslots = nr_slots(mem->slots[index].alloc_size + offset);\n\tint count, i;\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (index + nslots < ALIGN(index + 1, IO_TLB_SEGSIZE))\n\t\tcount = mem->slots[index + nslots].list;\n\telse\n\t\tcount = 0;\n\n\t/*\n\t * Step 1: return the slots to the free list, merging the slots with\n\t * superceeding slots\n\t */\n\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\tmem->slots[i].list = ++count;\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * Step 2: merge the returned slots with the preceding slots, if\n\t * available (non zero)\n\t */\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 && mem->slots[i].list;\n\t     i--)\n\t\tmem->slots[i].list = ++count;\n\tmem->used -= nslots;\n\tspin_unlock_irqrestore(&mem->lock, flags);\n}"
  },
  {
    "function_name": "swiotlb_tbl_map_single",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "589-634",
    "snippet": "phys_addr_t swiotlb_tbl_map_single(struct device *dev, phys_addr_t orig_addr,\n\t\tsize_t mapping_size, size_t alloc_size,\n\t\tunsigned int alloc_align_mask, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned int i;\n\tint index;\n\tphys_addr_t tlb_addr;\n\n\tif (!mem)\n\t\tpanic(\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\");\n\n\tif (cc_platform_has(CC_ATTR_MEM_ENCRYPT))\n\t\tpr_warn_once(\"Memory encryption is active and system is using DMA bounce buffers\\n\");\n\n\tif (mapping_size > alloc_size) {\n\t\tdev_warn_once(dev, \"Invalid sizes (mapping: %zd bytes, alloc: %zd bytes)\",\n\t\t\t      mapping_size, alloc_size);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\tindex = swiotlb_find_slots(dev, orig_addr,\n\t\t\t\t   alloc_size + offset, alloc_align_mask);\n\tif (index == -1) {\n\t\tif (!(attrs & DMA_ATTR_NO_WARN))\n\t\t\tdev_warn_ratelimited(dev,\n\t\"swiotlb buffer is full (sz: %zd bytes), total %lu (slots), used %lu (slots)\\n\",\n\t\t\t\t alloc_size, mem->nslabs, mem->used);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\t/*\n\t * Save away the mapping from the original address to the DMA address.\n\t * This is needed when we sync the memory.  Then we sync the buffer if\n\t * needed.\n\t */\n\tfor (i = 0; i < nr_slots(alloc_size + offset); i++)\n\t\tmem->slots[index + i].orig_addr = slot_addr(orig_addr, i);\n\ttlb_addr = slot_addr(mem->start, index) + offset;\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_TO_DEVICE);\n\treturn tlb_addr;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_bounce",
          "args": [
            "dev",
            "tlb_addr",
            "mapping_size",
            "DMA_TO_DEVICE"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_bounce",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "412-482",
          "snippet": "static void swiotlb_bounce(struct device *dev, phys_addr_t tlb_addr, size_t size,\n\t\t\t   enum dma_data_direction dir)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tint index = (tlb_addr - mem->start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = mem->slots[index].orig_addr;\n\tsize_t alloc_size = mem->slots[index].alloc_size;\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = mem->vaddr + tlb_addr - mem->start;\n\tunsigned int tlb_offset, orig_addr_offset;\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\n\ttlb_offset = tlb_addr & (IO_TLB_SIZE - 1);\n\torig_addr_offset = swiotlb_align_offset(dev, orig_addr);\n\tif (tlb_offset < orig_addr_offset) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Access before mapping start detected. orig offset %u, requested offset %u.\\n\",\n\t\t\torig_addr_offset, tlb_offset);\n\t\treturn;\n\t}\n\n\ttlb_offset -= orig_addr_offset;\n\tif (tlb_offset > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu+%u.\\n\",\n\t\t\talloc_size, size, tlb_offset);\n\t\treturn;\n\t}\n\n\torig_addr += tlb_offset;\n\talloc_size -= tlb_offset;\n\n\tif (size > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\\n\",\n\t\t\talloc_size, size);\n\t\tsize = alloc_size;\n\t}\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic void swiotlb_bounce(struct device *dev, phys_addr_t tlb_addr, size_t size,\n\t\t\t   enum dma_data_direction dir)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tint index = (tlb_addr - mem->start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = mem->slots[index].orig_addr;\n\tsize_t alloc_size = mem->slots[index].alloc_size;\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = mem->vaddr + tlb_addr - mem->start;\n\tunsigned int tlb_offset, orig_addr_offset;\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\n\ttlb_offset = tlb_addr & (IO_TLB_SIZE - 1);\n\torig_addr_offset = swiotlb_align_offset(dev, orig_addr);\n\tif (tlb_offset < orig_addr_offset) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Access before mapping start detected. orig offset %u, requested offset %u.\\n\",\n\t\t\torig_addr_offset, tlb_offset);\n\t\treturn;\n\t}\n\n\ttlb_offset -= orig_addr_offset;\n\tif (tlb_offset > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu+%u.\\n\",\n\t\t\talloc_size, size, tlb_offset);\n\t\treturn;\n\t}\n\n\torig_addr += tlb_offset;\n\talloc_size -= tlb_offset;\n\n\tif (size > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\\n\",\n\t\t\talloc_size, size);\n\t\tsize = alloc_size;\n\t}\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot_addr",
          "args": [
            "mem->start",
            "index"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "__is_insn_slot_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "296-312",
          "snippet": "bool __is_insn_slot_addr(struct kprobe_insn_cache *c, unsigned long addr)\n{\n\tstruct kprobe_insn_page *kip;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (addr >= (unsigned long)kip->insns &&\n\t\t    addr < (unsigned long)kip->insns + PAGE_SIZE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __is_insn_slot_addr(struct kprobe_insn_cache *c, unsigned long addr)\n{\n\tstruct kprobe_insn_page *kip;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (addr >= (unsigned long)kip->insns &&\n\t\t    addr < (unsigned long)kip->insns + PAGE_SIZE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_slots",
          "args": [
            "alloc_size + offset"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "nr_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "156-159",
          "snippet": "static inline unsigned long nr_slots(u64 val)\n{\n\treturn DIV_ROUND_UP(val, IO_TLB_SIZE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic inline unsigned long nr_slots(u64 val)\n{\n\treturn DIV_ROUND_UP(val, IO_TLB_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_warn_ratelimited",
          "args": [
            "dev",
            "\"swiotlb buffer is full (sz: %zd bytes), total %lu (slots), used %lu (slots)\\n\"",
            "alloc_size",
            "mem->nslabs",
            "mem->used"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_find_slots",
          "args": [
            "dev",
            "orig_addr",
            "alloc_size + offset",
            "alloc_align_mask"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_find_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "507-587",
          "snippet": "static int swiotlb_find_slots(struct device *dev, phys_addr_t orig_addr,\n\t\t\t      size_t alloc_size, unsigned int alloc_align_mask)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long boundary_mask = dma_get_seg_boundary(dev);\n\tdma_addr_t tbl_dma_addr =\n\t\tphys_to_dma_unencrypted(dev, mem->start) & boundary_mask;\n\tunsigned long max_slots = get_max_slots(boundary_mask);\n\tunsigned int iotlb_align_mask =\n\t\tdma_get_min_align_mask(dev) & ~(IO_TLB_SIZE - 1);\n\tunsigned int nslots = nr_slots(alloc_size), stride;\n\tunsigned int index, wrap, count = 0, i;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned long flags;\n\n\tBUG_ON(!nslots);\n\n\t/*\n\t * For mappings with an alignment requirement don't bother looping to\n\t * unaligned slots once we found an aligned one.  For allocations of\n\t * PAGE_SIZE or larger only look for page aligned allocations.\n\t */\n\tstride = (iotlb_align_mask >> IO_TLB_SHIFT) + 1;\n\tif (alloc_size >= PAGE_SIZE)\n\t\tstride = max(stride, stride << (PAGE_SHIFT - IO_TLB_SHIFT));\n\tstride = max(stride, (alloc_align_mask >> IO_TLB_SHIFT) + 1);\n\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (unlikely(nslots > mem->nslabs - mem->used))\n\t\tgoto not_found;\n\n\tindex = wrap = wrap_index(mem, ALIGN(mem->index, stride));\n\tdo {\n\t\tif (orig_addr &&\n\t\t    (slot_addr(tbl_dma_addr, index) & iotlb_align_mask) !=\n\t\t\t    (orig_addr & iotlb_align_mask)) {\n\t\t\tindex = wrap_index(mem, index + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we find a slot that indicates we have 'nslots' number of\n\t\t * contiguous buffers, we allocate the buffers from that slot\n\t\t * and mark the entries as '0' indicating unavailable.\n\t\t */\n\t\tif (!iommu_is_span_boundary(index, nslots,\n\t\t\t\t\t    nr_slots(tbl_dma_addr),\n\t\t\t\t\t    max_slots)) {\n\t\t\tif (mem->slots[index].list >= nslots)\n\t\t\t\tgoto found;\n\t\t}\n\t\tindex = wrap_index(mem, index + stride);\n\t} while (index != wrap);\n\nnot_found:\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn -1;\n\nfound:\n\tfor (i = index; i < index + nslots; i++) {\n\t\tmem->slots[i].list = 0;\n\t\tmem->slots[i].alloc_size =\n\t\t\talloc_size - (offset + ((i - index) << IO_TLB_SHIFT));\n\t}\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 &&\n\t     mem->slots[i].list; i--)\n\t\tmem->slots[i].list = ++count;\n\n\t/*\n\t * Update the indices to avoid searching in the next round.\n\t */\n\tif (index + nslots < mem->nslabs)\n\t\tmem->index = index + nslots;\n\telse\n\t\tmem->index = 0;\n\tmem->used += nslots;\n\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn index;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic int swiotlb_find_slots(struct device *dev, phys_addr_t orig_addr,\n\t\t\t      size_t alloc_size, unsigned int alloc_align_mask)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long boundary_mask = dma_get_seg_boundary(dev);\n\tdma_addr_t tbl_dma_addr =\n\t\tphys_to_dma_unencrypted(dev, mem->start) & boundary_mask;\n\tunsigned long max_slots = get_max_slots(boundary_mask);\n\tunsigned int iotlb_align_mask =\n\t\tdma_get_min_align_mask(dev) & ~(IO_TLB_SIZE - 1);\n\tunsigned int nslots = nr_slots(alloc_size), stride;\n\tunsigned int index, wrap, count = 0, i;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned long flags;\n\n\tBUG_ON(!nslots);\n\n\t/*\n\t * For mappings with an alignment requirement don't bother looping to\n\t * unaligned slots once we found an aligned one.  For allocations of\n\t * PAGE_SIZE or larger only look for page aligned allocations.\n\t */\n\tstride = (iotlb_align_mask >> IO_TLB_SHIFT) + 1;\n\tif (alloc_size >= PAGE_SIZE)\n\t\tstride = max(stride, stride << (PAGE_SHIFT - IO_TLB_SHIFT));\n\tstride = max(stride, (alloc_align_mask >> IO_TLB_SHIFT) + 1);\n\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (unlikely(nslots > mem->nslabs - mem->used))\n\t\tgoto not_found;\n\n\tindex = wrap = wrap_index(mem, ALIGN(mem->index, stride));\n\tdo {\n\t\tif (orig_addr &&\n\t\t    (slot_addr(tbl_dma_addr, index) & iotlb_align_mask) !=\n\t\t\t    (orig_addr & iotlb_align_mask)) {\n\t\t\tindex = wrap_index(mem, index + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we find a slot that indicates we have 'nslots' number of\n\t\t * contiguous buffers, we allocate the buffers from that slot\n\t\t * and mark the entries as '0' indicating unavailable.\n\t\t */\n\t\tif (!iommu_is_span_boundary(index, nslots,\n\t\t\t\t\t    nr_slots(tbl_dma_addr),\n\t\t\t\t\t    max_slots)) {\n\t\t\tif (mem->slots[index].list >= nslots)\n\t\t\t\tgoto found;\n\t\t}\n\t\tindex = wrap_index(mem, index + stride);\n\t} while (index != wrap);\n\nnot_found:\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn -1;\n\nfound:\n\tfor (i = index; i < index + nslots; i++) {\n\t\tmem->slots[i].list = 0;\n\t\tmem->slots[i].alloc_size =\n\t\t\talloc_size - (offset + ((i - index) << IO_TLB_SHIFT));\n\t}\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 &&\n\t     mem->slots[i].list; i--)\n\t\tmem->slots[i].list = ++count;\n\n\t/*\n\t * Update the indices to avoid searching in the next round.\n\t */\n\tif (index + nslots < mem->nslabs)\n\t\tmem->index = index + nslots;\n\telse\n\t\tmem->index = 0;\n\tmem->used += nslots;\n\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_warn_once",
          "args": [
            "dev",
            "\"Invalid sizes (mapping: %zd bytes, alloc: %zd bytes)\"",
            "mapping_size",
            "alloc_size"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"Memory encryption is active and system is using DMA bounce buffers\\n\""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cc_platform_has",
          "args": [
            "CC_ATTR_MEM_ENCRYPT"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\""
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_panic_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "74-85",
          "snippet": "static int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_align_offset",
          "args": [
            "dev",
            "orig_addr"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_align_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "404-407",
          "snippet": "static unsigned int swiotlb_align_offset(struct device *dev, u64 addr)\n{\n\treturn addr & dma_get_min_align_mask(dev) & (IO_TLB_SIZE - 1);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned int swiotlb_align_offset(struct device *dev, u64 addr)\n{\n\treturn addr & dma_get_min_align_mask(dev) & (IO_TLB_SIZE - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nphys_addr_t swiotlb_tbl_map_single(struct device *dev, phys_addr_t orig_addr,\n\t\tsize_t mapping_size, size_t alloc_size,\n\t\tunsigned int alloc_align_mask, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned int i;\n\tint index;\n\tphys_addr_t tlb_addr;\n\n\tif (!mem)\n\t\tpanic(\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\");\n\n\tif (cc_platform_has(CC_ATTR_MEM_ENCRYPT))\n\t\tpr_warn_once(\"Memory encryption is active and system is using DMA bounce buffers\\n\");\n\n\tif (mapping_size > alloc_size) {\n\t\tdev_warn_once(dev, \"Invalid sizes (mapping: %zd bytes, alloc: %zd bytes)\",\n\t\t\t      mapping_size, alloc_size);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\tindex = swiotlb_find_slots(dev, orig_addr,\n\t\t\t\t   alloc_size + offset, alloc_align_mask);\n\tif (index == -1) {\n\t\tif (!(attrs & DMA_ATTR_NO_WARN))\n\t\t\tdev_warn_ratelimited(dev,\n\t\"swiotlb buffer is full (sz: %zd bytes), total %lu (slots), used %lu (slots)\\n\",\n\t\t\t\t alloc_size, mem->nslabs, mem->used);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\t/*\n\t * Save away the mapping from the original address to the DMA address.\n\t * This is needed when we sync the memory.  Then we sync the buffer if\n\t * needed.\n\t */\n\tfor (i = 0; i < nr_slots(alloc_size + offset); i++)\n\t\tmem->slots[index + i].orig_addr = slot_addr(orig_addr, i);\n\ttlb_addr = slot_addr(mem->start, index) + offset;\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_TO_DEVICE);\n\treturn tlb_addr;\n}"
  },
  {
    "function_name": "swiotlb_find_slots",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "507-587",
    "snippet": "static int swiotlb_find_slots(struct device *dev, phys_addr_t orig_addr,\n\t\t\t      size_t alloc_size, unsigned int alloc_align_mask)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long boundary_mask = dma_get_seg_boundary(dev);\n\tdma_addr_t tbl_dma_addr =\n\t\tphys_to_dma_unencrypted(dev, mem->start) & boundary_mask;\n\tunsigned long max_slots = get_max_slots(boundary_mask);\n\tunsigned int iotlb_align_mask =\n\t\tdma_get_min_align_mask(dev) & ~(IO_TLB_SIZE - 1);\n\tunsigned int nslots = nr_slots(alloc_size), stride;\n\tunsigned int index, wrap, count = 0, i;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned long flags;\n\n\tBUG_ON(!nslots);\n\n\t/*\n\t * For mappings with an alignment requirement don't bother looping to\n\t * unaligned slots once we found an aligned one.  For allocations of\n\t * PAGE_SIZE or larger only look for page aligned allocations.\n\t */\n\tstride = (iotlb_align_mask >> IO_TLB_SHIFT) + 1;\n\tif (alloc_size >= PAGE_SIZE)\n\t\tstride = max(stride, stride << (PAGE_SHIFT - IO_TLB_SHIFT));\n\tstride = max(stride, (alloc_align_mask >> IO_TLB_SHIFT) + 1);\n\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (unlikely(nslots > mem->nslabs - mem->used))\n\t\tgoto not_found;\n\n\tindex = wrap = wrap_index(mem, ALIGN(mem->index, stride));\n\tdo {\n\t\tif (orig_addr &&\n\t\t    (slot_addr(tbl_dma_addr, index) & iotlb_align_mask) !=\n\t\t\t    (orig_addr & iotlb_align_mask)) {\n\t\t\tindex = wrap_index(mem, index + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we find a slot that indicates we have 'nslots' number of\n\t\t * contiguous buffers, we allocate the buffers from that slot\n\t\t * and mark the entries as '0' indicating unavailable.\n\t\t */\n\t\tif (!iommu_is_span_boundary(index, nslots,\n\t\t\t\t\t    nr_slots(tbl_dma_addr),\n\t\t\t\t\t    max_slots)) {\n\t\t\tif (mem->slots[index].list >= nslots)\n\t\t\t\tgoto found;\n\t\t}\n\t\tindex = wrap_index(mem, index + stride);\n\t} while (index != wrap);\n\nnot_found:\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn -1;\n\nfound:\n\tfor (i = index; i < index + nslots; i++) {\n\t\tmem->slots[i].list = 0;\n\t\tmem->slots[i].alloc_size =\n\t\t\talloc_size - (offset + ((i - index) << IO_TLB_SHIFT));\n\t}\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 &&\n\t     mem->slots[i].list; i--)\n\t\tmem->slots[i].list = ++count;\n\n\t/*\n\t * Update the indices to avoid searching in the next round.\n\t */\n\tif (index + nslots < mem->nslabs)\n\t\tmem->index = index + nslots;\n\telse\n\t\tmem->index = 0;\n\tmem->used += nslots;\n\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn index;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&mem->lock",
            "flags"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_tlb_offset",
          "args": [
            "i"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "io_tlb_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "151-154",
          "snippet": "static inline unsigned long io_tlb_offset(unsigned long val)\n{\n\treturn val & (IO_TLB_SEGSIZE - 1);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic inline unsigned long io_tlb_offset(unsigned long val)\n{\n\treturn val & (IO_TLB_SEGSIZE - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrap_index",
          "args": [
            "mem",
            "index + stride"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "496-501",
          "snippet": "static unsigned int wrap_index(struct io_tlb_mem *mem, unsigned int index)\n{\n\tif (index >= mem->nslabs)\n\t\treturn 0;\n\treturn index;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned int wrap_index(struct io_tlb_mem *mem, unsigned int index)\n{\n\tif (index >= mem->nslabs)\n\t\treturn 0;\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_is_span_boundary",
          "args": [
            "index",
            "nslots",
            "nr_slots(tbl_dma_addr)",
            "max_slots"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_slots",
          "args": [
            "tbl_dma_addr"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "nr_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "156-159",
          "snippet": "static inline unsigned long nr_slots(u64 val)\n{\n\treturn DIV_ROUND_UP(val, IO_TLB_SIZE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic inline unsigned long nr_slots(u64 val)\n{\n\treturn DIV_ROUND_UP(val, IO_TLB_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot_addr",
          "args": [
            "tbl_dma_addr",
            "index"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "__is_insn_slot_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "296-312",
          "snippet": "bool __is_insn_slot_addr(struct kprobe_insn_cache *c, unsigned long addr)\n{\n\tstruct kprobe_insn_page *kip;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (addr >= (unsigned long)kip->insns &&\n\t\t    addr < (unsigned long)kip->insns + PAGE_SIZE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __is_insn_slot_addr(struct kprobe_insn_cache *c, unsigned long addr)\n{\n\tstruct kprobe_insn_page *kip;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (addr >= (unsigned long)kip->insns &&\n\t\t    addr < (unsigned long)kip->insns + PAGE_SIZE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "mem->index",
            "stride"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nslots > mem->nslabs - mem->used"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&mem->lock",
            "flags"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "stride",
            "(alloc_align_mask >> IO_TLB_SHIFT) + 1"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!nslots"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_align_offset",
          "args": [
            "dev",
            "orig_addr"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_align_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "404-407",
          "snippet": "static unsigned int swiotlb_align_offset(struct device *dev, u64 addr)\n{\n\treturn addr & dma_get_min_align_mask(dev) & (IO_TLB_SIZE - 1);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned int swiotlb_align_offset(struct device *dev, u64 addr)\n{\n\treturn addr & dma_get_min_align_mask(dev) & (IO_TLB_SIZE - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_get_min_align_mask",
          "args": [
            "dev"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_max_slots",
          "args": [
            "boundary_mask"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "get_max_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "489-494",
          "snippet": "static inline unsigned long get_max_slots(unsigned long boundary_mask)\n{\n\tif (boundary_mask == ~0UL)\n\t\treturn 1UL << (BITS_PER_LONG - IO_TLB_SHIFT);\n\treturn nr_slots(boundary_mask + 1);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic inline unsigned long get_max_slots(unsigned long boundary_mask)\n{\n\tif (boundary_mask == ~0UL)\n\t\treturn 1UL << (BITS_PER_LONG - IO_TLB_SHIFT);\n\treturn nr_slots(boundary_mask + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "phys_to_dma_unencrypted",
          "args": [
            "dev",
            "mem->start"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_get_seg_boundary",
          "args": [
            "dev"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic int swiotlb_find_slots(struct device *dev, phys_addr_t orig_addr,\n\t\t\t      size_t alloc_size, unsigned int alloc_align_mask)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned long boundary_mask = dma_get_seg_boundary(dev);\n\tdma_addr_t tbl_dma_addr =\n\t\tphys_to_dma_unencrypted(dev, mem->start) & boundary_mask;\n\tunsigned long max_slots = get_max_slots(boundary_mask);\n\tunsigned int iotlb_align_mask =\n\t\tdma_get_min_align_mask(dev) & ~(IO_TLB_SIZE - 1);\n\tunsigned int nslots = nr_slots(alloc_size), stride;\n\tunsigned int index, wrap, count = 0, i;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned long flags;\n\n\tBUG_ON(!nslots);\n\n\t/*\n\t * For mappings with an alignment requirement don't bother looping to\n\t * unaligned slots once we found an aligned one.  For allocations of\n\t * PAGE_SIZE or larger only look for page aligned allocations.\n\t */\n\tstride = (iotlb_align_mask >> IO_TLB_SHIFT) + 1;\n\tif (alloc_size >= PAGE_SIZE)\n\t\tstride = max(stride, stride << (PAGE_SHIFT - IO_TLB_SHIFT));\n\tstride = max(stride, (alloc_align_mask >> IO_TLB_SHIFT) + 1);\n\n\tspin_lock_irqsave(&mem->lock, flags);\n\tif (unlikely(nslots > mem->nslabs - mem->used))\n\t\tgoto not_found;\n\n\tindex = wrap = wrap_index(mem, ALIGN(mem->index, stride));\n\tdo {\n\t\tif (orig_addr &&\n\t\t    (slot_addr(tbl_dma_addr, index) & iotlb_align_mask) !=\n\t\t\t    (orig_addr & iotlb_align_mask)) {\n\t\t\tindex = wrap_index(mem, index + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we find a slot that indicates we have 'nslots' number of\n\t\t * contiguous buffers, we allocate the buffers from that slot\n\t\t * and mark the entries as '0' indicating unavailable.\n\t\t */\n\t\tif (!iommu_is_span_boundary(index, nslots,\n\t\t\t\t\t    nr_slots(tbl_dma_addr),\n\t\t\t\t\t    max_slots)) {\n\t\t\tif (mem->slots[index].list >= nslots)\n\t\t\t\tgoto found;\n\t\t}\n\t\tindex = wrap_index(mem, index + stride);\n\t} while (index != wrap);\n\nnot_found:\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn -1;\n\nfound:\n\tfor (i = index; i < index + nslots; i++) {\n\t\tmem->slots[i].list = 0;\n\t\tmem->slots[i].alloc_size =\n\t\t\talloc_size - (offset + ((i - index) << IO_TLB_SHIFT));\n\t}\n\tfor (i = index - 1;\n\t     io_tlb_offset(i) != IO_TLB_SEGSIZE - 1 &&\n\t     mem->slots[i].list; i--)\n\t\tmem->slots[i].list = ++count;\n\n\t/*\n\t * Update the indices to avoid searching in the next round.\n\t */\n\tif (index + nslots < mem->nslabs)\n\t\tmem->index = index + nslots;\n\telse\n\t\tmem->index = 0;\n\tmem->used += nslots;\n\n\tspin_unlock_irqrestore(&mem->lock, flags);\n\treturn index;\n}"
  },
  {
    "function_name": "wrap_index",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "496-501",
    "snippet": "static unsigned int wrap_index(struct io_tlb_mem *mem, unsigned int index)\n{\n\tif (index >= mem->nslabs)\n\t\treturn 0;\n\treturn index;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned int wrap_index(struct io_tlb_mem *mem, unsigned int index)\n{\n\tif (index >= mem->nslabs)\n\t\treturn 0;\n\treturn index;\n}"
  },
  {
    "function_name": "get_max_slots",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "489-494",
    "snippet": "static inline unsigned long get_max_slots(unsigned long boundary_mask)\n{\n\tif (boundary_mask == ~0UL)\n\t\treturn 1UL << (BITS_PER_LONG - IO_TLB_SHIFT);\n\treturn nr_slots(boundary_mask + 1);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_slots",
          "args": [
            "boundary_mask + 1"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "nr_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "156-159",
          "snippet": "static inline unsigned long nr_slots(u64 val)\n{\n\treturn DIV_ROUND_UP(val, IO_TLB_SIZE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic inline unsigned long nr_slots(u64 val)\n{\n\treturn DIV_ROUND_UP(val, IO_TLB_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic inline unsigned long get_max_slots(unsigned long boundary_mask)\n{\n\tif (boundary_mask == ~0UL)\n\t\treturn 1UL << (BITS_PER_LONG - IO_TLB_SHIFT);\n\treturn nr_slots(boundary_mask + 1);\n}"
  },
  {
    "function_name": "swiotlb_bounce",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "412-482",
    "snippet": "static void swiotlb_bounce(struct device *dev, phys_addr_t tlb_addr, size_t size,\n\t\t\t   enum dma_data_direction dir)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tint index = (tlb_addr - mem->start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = mem->slots[index].orig_addr;\n\tsize_t alloc_size = mem->slots[index].alloc_size;\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = mem->vaddr + tlb_addr - mem->start;\n\tunsigned int tlb_offset, orig_addr_offset;\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\n\ttlb_offset = tlb_addr & (IO_TLB_SIZE - 1);\n\torig_addr_offset = swiotlb_align_offset(dev, orig_addr);\n\tif (tlb_offset < orig_addr_offset) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Access before mapping start detected. orig offset %u, requested offset %u.\\n\",\n\t\t\torig_addr_offset, tlb_offset);\n\t\treturn;\n\t}\n\n\ttlb_offset -= orig_addr_offset;\n\tif (tlb_offset > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu+%u.\\n\",\n\t\t\talloc_size, size, tlb_offset);\n\t\treturn;\n\t}\n\n\torig_addr += tlb_offset;\n\talloc_size -= tlb_offset;\n\n\tif (size > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\\n\",\n\t\t\talloc_size, size);\n\t\tsize = alloc_size;\n\t}\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [
      "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "phys_to_virt(orig_addr)",
            "vaddr",
            "size"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "orig_addr"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "orig_addr"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "buffer"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_SIZE - offset",
            "size"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_WARN_ONCE",
          "args": [
            "dev",
            "1",
            "\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\\n\"",
            "alloc_size",
            "size"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_WARN_ONCE",
          "args": [
            "dev",
            "1",
            "\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu+%u.\\n\"",
            "alloc_size",
            "size",
            "tlb_offset"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_WARN_ONCE",
          "args": [
            "dev",
            "1",
            "\"Access before mapping start detected. orig offset %u, requested offset %u.\\n\"",
            "orig_addr_offset",
            "tlb_offset"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_align_offset",
          "args": [
            "dev",
            "orig_addr"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_align_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "404-407",
          "snippet": "static unsigned int swiotlb_align_offset(struct device *dev, u64 addr)\n{\n\treturn addr & dma_get_min_align_mask(dev) & (IO_TLB_SIZE - 1);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned int swiotlb_align_offset(struct device *dev, u64 addr)\n{\n\treturn addr & dma_get_min_align_mask(dev) & (IO_TLB_SIZE - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "orig_addr"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic void swiotlb_bounce(struct device *dev, phys_addr_t tlb_addr, size_t size,\n\t\t\t   enum dma_data_direction dir)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tint index = (tlb_addr - mem->start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = mem->slots[index].orig_addr;\n\tsize_t alloc_size = mem->slots[index].alloc_size;\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = mem->vaddr + tlb_addr - mem->start;\n\tunsigned int tlb_offset, orig_addr_offset;\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\n\ttlb_offset = tlb_addr & (IO_TLB_SIZE - 1);\n\torig_addr_offset = swiotlb_align_offset(dev, orig_addr);\n\tif (tlb_offset < orig_addr_offset) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Access before mapping start detected. orig offset %u, requested offset %u.\\n\",\n\t\t\torig_addr_offset, tlb_offset);\n\t\treturn;\n\t}\n\n\ttlb_offset -= orig_addr_offset;\n\tif (tlb_offset > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu+%u.\\n\",\n\t\t\talloc_size, size, tlb_offset);\n\t\treturn;\n\t}\n\n\torig_addr += tlb_offset;\n\talloc_size -= tlb_offset;\n\n\tif (size > alloc_size) {\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\\n\",\n\t\t\talloc_size, size);\n\t\tsize = alloc_size;\n\t}\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}"
  },
  {
    "function_name": "swiotlb_align_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "404-407",
    "snippet": "static unsigned int swiotlb_align_offset(struct device *dev, u64 addr)\n{\n\treturn addr & dma_get_min_align_mask(dev) & (IO_TLB_SIZE - 1);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_get_min_align_mask",
          "args": [
            "dev"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned int swiotlb_align_offset(struct device *dev, u64 addr)\n{\n\treturn addr & dma_get_min_align_mask(dev) & (IO_TLB_SIZE - 1);\n}"
  },
  {
    "function_name": "swiotlb_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "375-399",
    "snippet": "void __init swiotlb_exit(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tunsigned long tbl_vaddr;\n\tsize_t tbl_size, slots_size;\n\n\tif (!mem->nslabs)\n\t\treturn;\n\n\tpr_info(\"tearing down default memory pool\\n\");\n\ttbl_vaddr = (unsigned long)phys_to_virt(mem->start);\n\ttbl_size = PAGE_ALIGN(mem->end - mem->start);\n\tslots_size = PAGE_ALIGN(array_size(sizeof(*mem->slots), mem->nslabs));\n\n\tset_memory_encrypted(tbl_vaddr, tbl_size >> PAGE_SHIFT);\n\tif (mem->late_alloc) {\n\t\tfree_pages(tbl_vaddr, get_order(tbl_size));\n\t\tfree_pages((unsigned long)mem->slots, get_order(slots_size));\n\t} else {\n\t\tmemblock_free_late(mem->start, tbl_size);\n\t\tmemblock_free_late(__pa(mem->slots), slots_size);\n\t}\n\n\tmemset(mem, 0, sizeof(*mem));\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct io_tlb_mem io_tlb_default_mem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mem",
            "0",
            "sizeof(*mem)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_free_late",
          "args": [
            "__pa(mem->slots)",
            "slots_size"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "mem->slots"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "820-835",
          "snippet": "static void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(CPUHP_PADATA_DEAD,\n\t\t\t\t\t    &pinst->cpu_dead_node);\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->cpu_online_node);\n#endif\n\n\tWARN_ON(!list_empty(&pinst->pslist));\n\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tdestroy_workqueue(pinst->serial_wq);\n\tdestroy_workqueue(pinst->parallel_wq);\n\tkfree(pinst);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(CPUHP_PADATA_DEAD,\n\t\t\t\t\t    &pinst->cpu_dead_node);\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->cpu_online_node);\n#endif\n\n\tWARN_ON(!list_empty(&pinst->pslist));\n\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tdestroy_workqueue(pinst->serial_wq);\n\tdestroy_workqueue(pinst->parallel_wq);\n\tkfree(pinst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_free_late",
          "args": [
            "mem->start",
            "tbl_size"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)mem->slots",
            "get_order(slots_size)"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "slots_size"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "tbl_vaddr",
            "get_order(tbl_size)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "tbl_size"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_encrypted",
          "args": [
            "tbl_vaddr",
            "tbl_size >> PAGE_SHIFT"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "array_size(sizeof(*mem->slots), mem->nslabs)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "sizeof(*mem->slots)",
            "mem->nslabs"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "mem->end - mem->start"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "mem->start"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"tearing down default memory pool\\n\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstruct io_tlb_mem io_tlb_default_mem;\n\nvoid __init swiotlb_exit(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tunsigned long tbl_vaddr;\n\tsize_t tbl_size, slots_size;\n\n\tif (!mem->nslabs)\n\t\treturn;\n\n\tpr_info(\"tearing down default memory pool\\n\");\n\ttbl_vaddr = (unsigned long)phys_to_virt(mem->start);\n\ttbl_size = PAGE_ALIGN(mem->end - mem->start);\n\tslots_size = PAGE_ALIGN(array_size(sizeof(*mem->slots), mem->nslabs));\n\n\tset_memory_encrypted(tbl_vaddr, tbl_size >> PAGE_SHIFT);\n\tif (mem->late_alloc) {\n\t\tfree_pages(tbl_vaddr, get_order(tbl_size));\n\t\tfree_pages((unsigned long)mem->slots, get_order(slots_size));\n\t} else {\n\t\tmemblock_free_late(mem->start, tbl_size);\n\t\tmemblock_free_late(__pa(mem->slots), slots_size);\n\t}\n\n\tmemset(mem, 0, sizeof(*mem));\n}"
  },
  {
    "function_name": "swiotlb_late_init_with_tbl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "349-373",
    "snippet": "int\nswiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn 0;\n\n\t/* protect against double initialization */\n\tif (WARN_ON_ONCE(mem->nslabs))\n\t\treturn -ENOMEM;\n\n\tmem->slots = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\tget_order(array_size(sizeof(*mem->slots), nslabs)));\n\tif (!mem->slots)\n\t\treturn -ENOMEM;\n\n\tset_memory_decrypted((unsigned long)tlb, bytes >> PAGE_SHIFT);\n\tswiotlb_init_io_tlb_mem(mem, virt_to_phys(tlb), nslabs, true);\n\n\tswiotlb_print_info();\n\tswiotlb_set_max_segment(mem->nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;",
      "struct io_tlb_mem io_tlb_default_mem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_set_max_segment",
          "args": [
            "mem->nslabs << IO_TLB_SHIFT"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_set_max_segment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "111-117",
          "snippet": "void swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;",
            "static unsigned int max_segment;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nstatic unsigned int max_segment;\n\nvoid swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_print_info",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_print_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "138-149",
          "snippet": "void swiotlb_print_info(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\n\tif (!mem->nslabs) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %pa-%pa] (%luMB)\\n\", &mem->start, &mem->end,\n\t       (mem->nslabs << IO_TLB_SHIFT) >> 20);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct io_tlb_mem io_tlb_default_mem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstruct io_tlb_mem io_tlb_default_mem;\n\nvoid swiotlb_print_info(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\n\tif (!mem->nslabs) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %pa-%pa] (%luMB)\\n\", &mem->start, &mem->end,\n\t       (mem->nslabs << IO_TLB_SHIFT) >> 20);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_init_io_tlb_mem",
          "args": [
            "mem",
            "virt_to_phys(tlb)",
            "nslabs",
            "true"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_init_io_tlb_mem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "214-246",
          "snippet": "static void swiotlb_init_io_tlb_mem(struct io_tlb_mem *mem, phys_addr_t start,\n\t\t\t\t    unsigned long nslabs, bool late_alloc)\n{\n\tvoid *vaddr = phys_to_virt(start);\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT, i;\n\n\tmem->nslabs = nslabs;\n\tmem->start = start;\n\tmem->end = mem->start + bytes;\n\tmem->index = 0;\n\tmem->late_alloc = late_alloc;\n\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmem->force_bounce = true;\n\n\tspin_lock_init(&mem->lock);\n\tfor (i = 0; i < mem->nslabs; i++) {\n\t\tmem->slots[i].list = IO_TLB_SEGSIZE - io_tlb_offset(i);\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * If swiotlb_unencrypted_base is set, the bounce buffer memory will\n\t * be remapped and cleared in swiotlb_update_mem_attributes.\n\t */\n\tif (swiotlb_unencrypted_base)\n\t\treturn;\n\n\tmemset(vaddr, 0, bytes);\n\tmem->vaddr = vaddr;\n\treturn;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;",
            "phys_addr_t swiotlb_unencrypted_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nenum swiotlb_force swiotlb_force;\nphys_addr_t swiotlb_unencrypted_base;\n\nstatic void swiotlb_init_io_tlb_mem(struct io_tlb_mem *mem, phys_addr_t start,\n\t\t\t\t    unsigned long nslabs, bool late_alloc)\n{\n\tvoid *vaddr = phys_to_virt(start);\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT, i;\n\n\tmem->nslabs = nslabs;\n\tmem->start = start;\n\tmem->end = mem->start + bytes;\n\tmem->index = 0;\n\tmem->late_alloc = late_alloc;\n\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmem->force_bounce = true;\n\n\tspin_lock_init(&mem->lock);\n\tfor (i = 0; i < mem->nslabs; i++) {\n\t\tmem->slots[i].list = IO_TLB_SEGSIZE - io_tlb_offset(i);\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * If swiotlb_unencrypted_base is set, the bounce buffer memory will\n\t * be remapped and cleared in swiotlb_update_mem_attributes.\n\t */\n\tif (swiotlb_unencrypted_base)\n\t\treturn;\n\n\tmemset(vaddr, 0, bytes);\n\tmem->vaddr = vaddr;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_phys",
          "args": [
            "tlb"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "perf_virt_to_phys",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "7175-7208",
          "snippet": "static u64 perf_virt_to_phys(u64 virt)\n{\n\tu64 phys_addr = 0;\n\n\tif (!virt)\n\t\treturn 0;\n\n\tif (virt >= TASK_SIZE) {\n\t\t/* If it's vmalloc()d memory, leave phys_addr as 0 */\n\t\tif (virt_addr_valid((void *)(uintptr_t)virt) &&\n\t\t    !(virt >= VMALLOC_START && virt < VMALLOC_END))\n\t\t\tphys_addr = (u64)virt_to_phys((void *)(uintptr_t)virt);\n\t} else {\n\t\t/*\n\t\t * Walking the pages tables for user address.\n\t\t * Interrupts are disabled, so it prevents any tear down\n\t\t * of the page tables.\n\t\t * Try IRQ-safe get_user_page_fast_only first.\n\t\t * If failed, leave phys_addr as 0.\n\t\t */\n\t\tif (current->mm != NULL) {\n\t\t\tstruct page *p;\n\n\t\t\tpagefault_disable();\n\t\t\tif (get_user_page_fast_only(virt, 0, &p)) {\n\t\t\t\tphys_addr = page_to_phys(p) + virt % PAGE_SIZE;\n\t\t\t\tput_page(p);\n\t\t\t}\n\t\t\tpagefault_enable();\n\t\t}\n\t}\n\n\treturn phys_addr;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\n\nstatic u64 perf_virt_to_phys(u64 virt)\n{\n\tu64 phys_addr = 0;\n\n\tif (!virt)\n\t\treturn 0;\n\n\tif (virt >= TASK_SIZE) {\n\t\t/* If it's vmalloc()d memory, leave phys_addr as 0 */\n\t\tif (virt_addr_valid((void *)(uintptr_t)virt) &&\n\t\t    !(virt >= VMALLOC_START && virt < VMALLOC_END))\n\t\t\tphys_addr = (u64)virt_to_phys((void *)(uintptr_t)virt);\n\t} else {\n\t\t/*\n\t\t * Walking the pages tables for user address.\n\t\t * Interrupts are disabled, so it prevents any tear down\n\t\t * of the page tables.\n\t\t * Try IRQ-safe get_user_page_fast_only first.\n\t\t * If failed, leave phys_addr as 0.\n\t\t */\n\t\tif (current->mm != NULL) {\n\t\t\tstruct page *p;\n\n\t\t\tpagefault_disable();\n\t\t\tif (get_user_page_fast_only(virt, 0, &p)) {\n\t\t\t\tphys_addr = page_to_phys(p) + virt % PAGE_SIZE;\n\t\t\t\tput_page(p);\n\t\t\t}\n\t\t\tpagefault_enable();\n\t\t}\n\t}\n\n\treturn phys_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_memory_decrypted",
          "args": [
            "(unsigned long)tlb",
            "bytes >> PAGE_SHIFT"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_KERNEL | __GFP_ZERO",
            "get_order(array_size(sizeof(*mem->slots), nslabs))"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "array_size(sizeof(*mem->slots), nslabs)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "sizeof(*mem->slots)",
            "nslabs"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "mem->nslabs"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nstruct io_tlb_mem io_tlb_default_mem;\n\nint\nswiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn 0;\n\n\t/* protect against double initialization */\n\tif (WARN_ON_ONCE(mem->nslabs))\n\t\treturn -ENOMEM;\n\n\tmem->slots = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\tget_order(array_size(sizeof(*mem->slots), nslabs)));\n\tif (!mem->slots)\n\t\treturn -ENOMEM;\n\n\tset_memory_decrypted((unsigned long)tlb, bytes >> PAGE_SHIFT);\n\tswiotlb_init_io_tlb_mem(mem, virt_to_phys(tlb), nslabs, true);\n\n\tswiotlb_print_info();\n\tswiotlb_set_max_segment(mem->nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}"
  },
  {
    "function_name": "swiotlb_late_init_with_default_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "306-347",
    "snippet": "int\nswiotlb_late_init_with_default_size(size_t default_size)\n{\n\tunsigned long nslabs =\n\t\tALIGN(default_size >> IO_TLB_SHIFT, IO_TLB_SEGSIZE);\n\tunsigned long bytes;\n\tunsigned char *vstart = NULL;\n\tunsigned int order;\n\tint rc = 0;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn 0;\n\n\t/*\n\t * Get IO TLB memory from the low pages\n\t */\n\torder = get_order(nslabs << IO_TLB_SHIFT);\n\tnslabs = SLABS_PER_PAGE << order;\n\tbytes = nslabs << IO_TLB_SHIFT;\n\n\twhile ((SLABS_PER_PAGE << order) > IO_TLB_MIN_SLABS) {\n\t\tvstart = (void *)__get_free_pages(GFP_DMA | __GFP_NOWARN,\n\t\t\t\t\t\t  order);\n\t\tif (vstart)\n\t\t\tbreak;\n\t\torder--;\n\t}\n\n\tif (!vstart)\n\t\treturn -ENOMEM;\n\n\tif (order != get_order(bytes)) {\n\t\tpr_warn(\"only able to allocate %ld MB\\n\",\n\t\t\t(PAGE_SIZE << order) >> 20);\n\t\tnslabs = SLABS_PER_PAGE << order;\n\t}\n\trc = swiotlb_late_init_with_tbl(vstart, nslabs);\n\tif (rc)\n\t\tfree_pages((unsigned long)vstart, order);\n\n\treturn rc;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [
      "#define IO_TLB_MIN_SLABS ((1<<20) >> IO_TLB_SHIFT)",
      "#define SLABS_PER_PAGE (1 << (PAGE_SHIFT - IO_TLB_SHIFT))"
    ],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)vstart",
            "order"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_late_init_with_tbl",
          "args": [
            "vstart",
            "nslabs"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_late_init_with_tbl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "349-373",
          "snippet": "int\nswiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn 0;\n\n\t/* protect against double initialization */\n\tif (WARN_ON_ONCE(mem->nslabs))\n\t\treturn -ENOMEM;\n\n\tmem->slots = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\tget_order(array_size(sizeof(*mem->slots), nslabs)));\n\tif (!mem->slots)\n\t\treturn -ENOMEM;\n\n\tset_memory_decrypted((unsigned long)tlb, bytes >> PAGE_SHIFT);\n\tswiotlb_init_io_tlb_mem(mem, virt_to_phys(tlb), nslabs, true);\n\n\tswiotlb_print_info();\n\tswiotlb_set_max_segment(mem->nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;",
            "struct io_tlb_mem io_tlb_default_mem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nstruct io_tlb_mem io_tlb_default_mem;\n\nint\nswiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn 0;\n\n\t/* protect against double initialization */\n\tif (WARN_ON_ONCE(mem->nslabs))\n\t\treturn -ENOMEM;\n\n\tmem->slots = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\tget_order(array_size(sizeof(*mem->slots), nslabs)));\n\tif (!mem->slots)\n\t\treturn -ENOMEM;\n\n\tset_memory_decrypted((unsigned long)tlb, bytes >> PAGE_SHIFT);\n\tswiotlb_init_io_tlb_mem(mem, virt_to_phys(tlb), nslabs, true);\n\n\tswiotlb_print_info();\n\tswiotlb_set_max_segment(mem->nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"only able to allocate %ld MB\\n\"",
            "(PAGE_SIZE << order) >> 20"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "bytes"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_DMA | __GFP_NOWARN",
            "order"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "nslabs << IO_TLB_SHIFT"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "default_size >> IO_TLB_SHIFT",
            "IO_TLB_SEGSIZE"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define IO_TLB_MIN_SLABS ((1<<20) >> IO_TLB_SHIFT)\n#define SLABS_PER_PAGE (1 << (PAGE_SHIFT - IO_TLB_SHIFT))\n\nenum swiotlb_force swiotlb_force;\n\nint\nswiotlb_late_init_with_default_size(size_t default_size)\n{\n\tunsigned long nslabs =\n\t\tALIGN(default_size >> IO_TLB_SHIFT, IO_TLB_SEGSIZE);\n\tunsigned long bytes;\n\tunsigned char *vstart = NULL;\n\tunsigned int order;\n\tint rc = 0;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn 0;\n\n\t/*\n\t * Get IO TLB memory from the low pages\n\t */\n\torder = get_order(nslabs << IO_TLB_SHIFT);\n\tnslabs = SLABS_PER_PAGE << order;\n\tbytes = nslabs << IO_TLB_SHIFT;\n\n\twhile ((SLABS_PER_PAGE << order) > IO_TLB_MIN_SLABS) {\n\t\tvstart = (void *)__get_free_pages(GFP_DMA | __GFP_NOWARN,\n\t\t\t\t\t\t  order);\n\t\tif (vstart)\n\t\t\tbreak;\n\t\torder--;\n\t}\n\n\tif (!vstart)\n\t\treturn -ENOMEM;\n\n\tif (order != get_order(bytes)) {\n\t\tpr_warn(\"only able to allocate %ld MB\\n\",\n\t\t\t(PAGE_SIZE << order) >> 20);\n\t\tnslabs = SLABS_PER_PAGE << order;\n\t}\n\trc = swiotlb_late_init_with_tbl(vstart, nslabs);\n\tif (rc)\n\t\tfree_pages((unsigned long)vstart, order);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "swiotlb_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "278-299",
    "snippet": "void  __init\nswiotlb_init(int verbose)\n{\n\tsize_t bytes = PAGE_ALIGN(default_nslabs << IO_TLB_SHIFT);\n\tvoid *tlb;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn;\n\n\t/* Get IO TLB memory from the low pages */\n\ttlb = memblock_alloc_low(bytes, PAGE_SIZE);\n\tif (!tlb)\n\t\tgoto fail;\n\tif (swiotlb_init_with_tbl(tlb, default_nslabs, verbose))\n\t\tgoto fail_free_mem;\n\treturn;\n\nfail_free_mem:\n\tmemblock_free(tlb, bytes);\nfail:\n\tpr_warn(\"Cannot allocate buffer\");\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;",
      "static unsigned long default_nslabs = IO_TLB_DEFAULT_SIZE >> IO_TLB_SHIFT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Cannot allocate buffer\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_free",
          "args": [
            "tlb",
            "bytes"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_init_with_tbl",
          "args": [
            "tlb",
            "default_nslabs",
            "verbose"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_init_with_tbl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "248-272",
          "snippet": "int __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tsize_t alloc_size;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn 0;\n\n\t/* protect against double initialization */\n\tif (WARN_ON_ONCE(mem->nslabs))\n\t\treturn -ENOMEM;\n\n\talloc_size = PAGE_ALIGN(array_size(sizeof(*mem->slots), nslabs));\n\tmem->slots = memblock_alloc(alloc_size, PAGE_SIZE);\n\tif (!mem->slots)\n\t\tpanic(\"%s: Failed to allocate %zu bytes align=0x%lx\\n\",\n\t\t      __func__, alloc_size, PAGE_SIZE);\n\n\tswiotlb_init_io_tlb_mem(mem, __pa(tlb), nslabs, false);\n\n\tif (verbose)\n\t\tswiotlb_print_info();\n\tswiotlb_set_max_segment(mem->nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;",
            "struct io_tlb_mem io_tlb_default_mem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nstruct io_tlb_mem io_tlb_default_mem;\n\nint __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tsize_t alloc_size;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn 0;\n\n\t/* protect against double initialization */\n\tif (WARN_ON_ONCE(mem->nslabs))\n\t\treturn -ENOMEM;\n\n\talloc_size = PAGE_ALIGN(array_size(sizeof(*mem->slots), nslabs));\n\tmem->slots = memblock_alloc(alloc_size, PAGE_SIZE);\n\tif (!mem->slots)\n\t\tpanic(\"%s: Failed to allocate %zu bytes align=0x%lx\\n\",\n\t\t      __func__, alloc_size, PAGE_SIZE);\n\n\tswiotlb_init_io_tlb_mem(mem, __pa(tlb), nslabs, false);\n\n\tif (verbose)\n\t\tswiotlb_print_info();\n\tswiotlb_set_max_segment(mem->nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc_low",
          "args": [
            "bytes",
            "PAGE_SIZE"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "default_nslabs << IO_TLB_SHIFT"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nstatic unsigned long default_nslabs = IO_TLB_DEFAULT_SIZE >> IO_TLB_SHIFT;\n\nvoid  __init\nswiotlb_init(int verbose)\n{\n\tsize_t bytes = PAGE_ALIGN(default_nslabs << IO_TLB_SHIFT);\n\tvoid *tlb;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn;\n\n\t/* Get IO TLB memory from the low pages */\n\ttlb = memblock_alloc_low(bytes, PAGE_SIZE);\n\tif (!tlb)\n\t\tgoto fail;\n\tif (swiotlb_init_with_tbl(tlb, default_nslabs, verbose))\n\t\tgoto fail_free_mem;\n\treturn;\n\nfail_free_mem:\n\tmemblock_free(tlb, bytes);\nfail:\n\tpr_warn(\"Cannot allocate buffer\");\n}"
  },
  {
    "function_name": "swiotlb_init_with_tbl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "248-272",
    "snippet": "int __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tsize_t alloc_size;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn 0;\n\n\t/* protect against double initialization */\n\tif (WARN_ON_ONCE(mem->nslabs))\n\t\treturn -ENOMEM;\n\n\talloc_size = PAGE_ALIGN(array_size(sizeof(*mem->slots), nslabs));\n\tmem->slots = memblock_alloc(alloc_size, PAGE_SIZE);\n\tif (!mem->slots)\n\t\tpanic(\"%s: Failed to allocate %zu bytes align=0x%lx\\n\",\n\t\t      __func__, alloc_size, PAGE_SIZE);\n\n\tswiotlb_init_io_tlb_mem(mem, __pa(tlb), nslabs, false);\n\n\tif (verbose)\n\t\tswiotlb_print_info();\n\tswiotlb_set_max_segment(mem->nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;",
      "struct io_tlb_mem io_tlb_default_mem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_set_max_segment",
          "args": [
            "mem->nslabs << IO_TLB_SHIFT"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_set_max_segment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "111-117",
          "snippet": "void swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;",
            "static unsigned int max_segment;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nstatic unsigned int max_segment;\n\nvoid swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_print_info",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_print_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "138-149",
          "snippet": "void swiotlb_print_info(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\n\tif (!mem->nslabs) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %pa-%pa] (%luMB)\\n\", &mem->start, &mem->end,\n\t       (mem->nslabs << IO_TLB_SHIFT) >> 20);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct io_tlb_mem io_tlb_default_mem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstruct io_tlb_mem io_tlb_default_mem;\n\nvoid swiotlb_print_info(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\n\tif (!mem->nslabs) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %pa-%pa] (%luMB)\\n\", &mem->start, &mem->end,\n\t       (mem->nslabs << IO_TLB_SHIFT) >> 20);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_init_io_tlb_mem",
          "args": [
            "mem",
            "__pa(tlb)",
            "nslabs",
            "false"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_init_io_tlb_mem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "214-246",
          "snippet": "static void swiotlb_init_io_tlb_mem(struct io_tlb_mem *mem, phys_addr_t start,\n\t\t\t\t    unsigned long nslabs, bool late_alloc)\n{\n\tvoid *vaddr = phys_to_virt(start);\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT, i;\n\n\tmem->nslabs = nslabs;\n\tmem->start = start;\n\tmem->end = mem->start + bytes;\n\tmem->index = 0;\n\tmem->late_alloc = late_alloc;\n\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmem->force_bounce = true;\n\n\tspin_lock_init(&mem->lock);\n\tfor (i = 0; i < mem->nslabs; i++) {\n\t\tmem->slots[i].list = IO_TLB_SEGSIZE - io_tlb_offset(i);\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * If swiotlb_unencrypted_base is set, the bounce buffer memory will\n\t * be remapped and cleared in swiotlb_update_mem_attributes.\n\t */\n\tif (swiotlb_unencrypted_base)\n\t\treturn;\n\n\tmemset(vaddr, 0, bytes);\n\tmem->vaddr = vaddr;\n\treturn;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;",
            "phys_addr_t swiotlb_unencrypted_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nenum swiotlb_force swiotlb_force;\nphys_addr_t swiotlb_unencrypted_base;\n\nstatic void swiotlb_init_io_tlb_mem(struct io_tlb_mem *mem, phys_addr_t start,\n\t\t\t\t    unsigned long nslabs, bool late_alloc)\n{\n\tvoid *vaddr = phys_to_virt(start);\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT, i;\n\n\tmem->nslabs = nslabs;\n\tmem->start = start;\n\tmem->end = mem->start + bytes;\n\tmem->index = 0;\n\tmem->late_alloc = late_alloc;\n\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmem->force_bounce = true;\n\n\tspin_lock_init(&mem->lock);\n\tfor (i = 0; i < mem->nslabs; i++) {\n\t\tmem->slots[i].list = IO_TLB_SEGSIZE - io_tlb_offset(i);\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * If swiotlb_unencrypted_base is set, the bounce buffer memory will\n\t * be remapped and cleared in swiotlb_update_mem_attributes.\n\t */\n\tif (swiotlb_unencrypted_base)\n\t\treturn;\n\n\tmemset(vaddr, 0, bytes);\n\tmem->vaddr = vaddr;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "tlb"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "820-835",
          "snippet": "static void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(CPUHP_PADATA_DEAD,\n\t\t\t\t\t    &pinst->cpu_dead_node);\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->cpu_online_node);\n#endif\n\n\tWARN_ON(!list_empty(&pinst->pslist));\n\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tdestroy_workqueue(pinst->serial_wq);\n\tdestroy_workqueue(pinst->parallel_wq);\n\tkfree(pinst);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(CPUHP_PADATA_DEAD,\n\t\t\t\t\t    &pinst->cpu_dead_node);\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->cpu_online_node);\n#endif\n\n\tWARN_ON(!list_empty(&pinst->pslist));\n\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tdestroy_workqueue(pinst->serial_wq);\n\tdestroy_workqueue(pinst->parallel_wq);\n\tkfree(pinst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: Failed to allocate %zu bytes align=0x%lx\\n\"",
            "__func__",
            "alloc_size",
            "PAGE_SIZE"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "179-361",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "alloc_size",
            "PAGE_SIZE"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "array_size(sizeof(*mem->slots), nslabs)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "sizeof(*mem->slots)",
            "nslabs"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "mem->nslabs"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nstruct io_tlb_mem io_tlb_default_mem;\n\nint __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tsize_t alloc_size;\n\n\tif (swiotlb_force == SWIOTLB_NO_FORCE)\n\t\treturn 0;\n\n\t/* protect against double initialization */\n\tif (WARN_ON_ONCE(mem->nslabs))\n\t\treturn -ENOMEM;\n\n\talloc_size = PAGE_ALIGN(array_size(sizeof(*mem->slots), nslabs));\n\tmem->slots = memblock_alloc(alloc_size, PAGE_SIZE);\n\tif (!mem->slots)\n\t\tpanic(\"%s: Failed to allocate %zu bytes align=0x%lx\\n\",\n\t\t      __func__, alloc_size, PAGE_SIZE);\n\n\tswiotlb_init_io_tlb_mem(mem, __pa(tlb), nslabs, false);\n\n\tif (verbose)\n\t\tswiotlb_print_info();\n\tswiotlb_set_max_segment(mem->nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}"
  },
  {
    "function_name": "swiotlb_init_io_tlb_mem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "214-246",
    "snippet": "static void swiotlb_init_io_tlb_mem(struct io_tlb_mem *mem, phys_addr_t start,\n\t\t\t\t    unsigned long nslabs, bool late_alloc)\n{\n\tvoid *vaddr = phys_to_virt(start);\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT, i;\n\n\tmem->nslabs = nslabs;\n\tmem->start = start;\n\tmem->end = mem->start + bytes;\n\tmem->index = 0;\n\tmem->late_alloc = late_alloc;\n\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmem->force_bounce = true;\n\n\tspin_lock_init(&mem->lock);\n\tfor (i = 0; i < mem->nslabs; i++) {\n\t\tmem->slots[i].list = IO_TLB_SEGSIZE - io_tlb_offset(i);\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * If swiotlb_unencrypted_base is set, the bounce buffer memory will\n\t * be remapped and cleared in swiotlb_update_mem_attributes.\n\t */\n\tif (swiotlb_unencrypted_base)\n\t\treturn;\n\n\tmemset(vaddr, 0, bytes);\n\tmem->vaddr = vaddr;\n\treturn;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [
      "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
    ],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;",
      "phys_addr_t swiotlb_unencrypted_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vaddr",
            "0",
            "bytes"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_tlb_offset",
          "args": [
            "i"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "io_tlb_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "151-154",
          "snippet": "static inline unsigned long io_tlb_offset(unsigned long val)\n{\n\treturn val & (IO_TLB_SEGSIZE - 1);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic inline unsigned long io_tlb_offset(unsigned long val)\n{\n\treturn val & (IO_TLB_SEGSIZE - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mem->lock"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "start"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nenum swiotlb_force swiotlb_force;\nphys_addr_t swiotlb_unencrypted_base;\n\nstatic void swiotlb_init_io_tlb_mem(struct io_tlb_mem *mem, phys_addr_t start,\n\t\t\t\t    unsigned long nslabs, bool late_alloc)\n{\n\tvoid *vaddr = phys_to_virt(start);\n\tunsigned long bytes = nslabs << IO_TLB_SHIFT, i;\n\n\tmem->nslabs = nslabs;\n\tmem->start = start;\n\tmem->end = mem->start + bytes;\n\tmem->index = 0;\n\tmem->late_alloc = late_alloc;\n\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmem->force_bounce = true;\n\n\tspin_lock_init(&mem->lock);\n\tfor (i = 0; i < mem->nslabs; i++) {\n\t\tmem->slots[i].list = IO_TLB_SEGSIZE - io_tlb_offset(i);\n\t\tmem->slots[i].orig_addr = INVALID_PHYS_ADDR;\n\t\tmem->slots[i].alloc_size = 0;\n\t}\n\n\t/*\n\t * If swiotlb_unencrypted_base is set, the bounce buffer memory will\n\t * be remapped and cleared in swiotlb_update_mem_attributes.\n\t */\n\tif (swiotlb_unencrypted_base)\n\t\treturn;\n\n\tmemset(vaddr, 0, bytes);\n\tmem->vaddr = vaddr;\n\treturn;\n}"
  },
  {
    "function_name": "swiotlb_update_mem_attributes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "195-212",
    "snippet": "void __init swiotlb_update_mem_attributes(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tvoid *vaddr;\n\tunsigned long bytes;\n\n\tif (!mem->nslabs || mem->late_alloc)\n\t\treturn;\n\tvaddr = phys_to_virt(mem->start);\n\tbytes = PAGE_ALIGN(mem->nslabs << IO_TLB_SHIFT);\n\tset_memory_decrypted((unsigned long)vaddr, bytes >> PAGE_SHIFT);\n\n\tmem->vaddr = swiotlb_mem_remap(mem, bytes);\n\tif (!mem->vaddr)\n\t\tmem->vaddr = vaddr;\n\n\tmemset(mem->vaddr, 0, bytes);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct io_tlb_mem io_tlb_default_mem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mem->vaddr",
            "0",
            "bytes"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_mem_remap",
          "args": [
            "mem",
            "bytes"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_mem_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "183-186",
          "snippet": "static void *swiotlb_mem_remap(struct io_tlb_mem *mem, unsigned long bytes)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void *swiotlb_mem_remap(struct io_tlb_mem *mem, unsigned long bytes)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_memory_decrypted",
          "args": [
            "(unsigned long)vaddr",
            "bytes >> PAGE_SHIFT"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "mem->nslabs << IO_TLB_SHIFT"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "mem->start"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstruct io_tlb_mem io_tlb_default_mem;\n\nvoid __init swiotlb_update_mem_attributes(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\tvoid *vaddr;\n\tunsigned long bytes;\n\n\tif (!mem->nslabs || mem->late_alloc)\n\t\treturn;\n\tvaddr = phys_to_virt(mem->start);\n\tbytes = PAGE_ALIGN(mem->nslabs << IO_TLB_SHIFT);\n\tset_memory_decrypted((unsigned long)vaddr, bytes >> PAGE_SHIFT);\n\n\tmem->vaddr = swiotlb_mem_remap(mem, bytes);\n\tif (!mem->vaddr)\n\t\tmem->vaddr = vaddr;\n\n\tmemset(mem->vaddr, 0, bytes);\n}"
  },
  {
    "function_name": "swiotlb_mem_remap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "183-186",
    "snippet": "static void *swiotlb_mem_remap(struct io_tlb_mem *mem, unsigned long bytes)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void *swiotlb_mem_remap(struct io_tlb_mem *mem, unsigned long bytes)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "swiotlb_mem_remap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "167-181",
    "snippet": "static void *swiotlb_mem_remap(struct io_tlb_mem *mem, unsigned long bytes)\n{\n\tvoid *vaddr = NULL;\n\n\tif (swiotlb_unencrypted_base) {\n\t\tphys_addr_t paddr = mem->start + swiotlb_unencrypted_base;\n\n\t\tvaddr = memremap(paddr, bytes, MEMREMAP_WB);\n\t\tif (!vaddr)\n\t\t\tpr_err(\"Failed to map the unencrypted memory %pa size %lx.\\n\",\n\t\t\t       &paddr, bytes);\n\t}\n\n\treturn vaddr;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "phys_addr_t swiotlb_unencrypted_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to map the unencrypted memory %pa size %lx.\\n\"",
            "&paddr",
            "bytes"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memremap",
          "args": [
            "paddr",
            "bytes",
            "MEMREMAP_WB"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "devm_memremap_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
          "lines": "134-137",
          "snippet": "static int devm_memremap_match(struct device *dev, void *res, void *match_data)\n{\n\treturn *(void **)res == match_data;\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/io.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nstatic int devm_memremap_match(struct device *dev, void *res, void *match_data)\n{\n\treturn *(void **)res == match_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nphys_addr_t swiotlb_unencrypted_base;\n\nstatic void *swiotlb_mem_remap(struct io_tlb_mem *mem, unsigned long bytes)\n{\n\tvoid *vaddr = NULL;\n\n\tif (swiotlb_unencrypted_base) {\n\t\tphys_addr_t paddr = mem->start + swiotlb_unencrypted_base;\n\n\t\tvaddr = memremap(paddr, bytes, MEMREMAP_WB);\n\t\tif (!vaddr)\n\t\t\tpr_err(\"Failed to map the unencrypted memory %pa size %lx.\\n\",\n\t\t\t       &paddr, bytes);\n\t}\n\n\treturn vaddr;\n}"
  },
  {
    "function_name": "nr_slots",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "156-159",
    "snippet": "static inline unsigned long nr_slots(u64 val)\n{\n\treturn DIV_ROUND_UP(val, IO_TLB_SIZE);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "val",
            "IO_TLB_SIZE"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic inline unsigned long nr_slots(u64 val)\n{\n\treturn DIV_ROUND_UP(val, IO_TLB_SIZE);\n}"
  },
  {
    "function_name": "io_tlb_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "151-154",
    "snippet": "static inline unsigned long io_tlb_offset(unsigned long val)\n{\n\treturn val & (IO_TLB_SEGSIZE - 1);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic inline unsigned long io_tlb_offset(unsigned long val)\n{\n\treturn val & (IO_TLB_SEGSIZE - 1);\n}"
  },
  {
    "function_name": "swiotlb_print_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "138-149",
    "snippet": "void swiotlb_print_info(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\n\tif (!mem->nslabs) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %pa-%pa] (%luMB)\\n\", &mem->start, &mem->end,\n\t       (mem->nslabs << IO_TLB_SHIFT) >> 20);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct io_tlb_mem io_tlb_default_mem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mapped [mem %pa-%pa] (%luMB)\\n\"",
            "&mem->start",
            "&mem->end",
            "(mem->nslabs << IO_TLB_SHIFT) >> 20"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"No low mem\\n\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstruct io_tlb_mem io_tlb_default_mem;\n\nvoid swiotlb_print_info(void)\n{\n\tstruct io_tlb_mem *mem = &io_tlb_default_mem;\n\n\tif (!mem->nslabs) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %pa-%pa] (%luMB)\\n\", &mem->start, &mem->end,\n\t       (mem->nslabs << IO_TLB_SHIFT) >> 20);\n}"
  },
  {
    "function_name": "swiotlb_adjust_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "124-136",
    "snippet": "void __init swiotlb_adjust_size(unsigned long size)\n{\n\t/*\n\t * If swiotlb parameter has not been specified, give a chance to\n\t * architectures such as those supporting memory encryption to\n\t * adjust/expand SWIOTLB size for their use.\n\t */\n\tif (default_nslabs != IO_TLB_DEFAULT_SIZE >> IO_TLB_SHIFT)\n\t\treturn;\n\tsize = ALIGN(size, IO_TLB_SIZE);\n\tdefault_nslabs = ALIGN(size >> IO_TLB_SHIFT, IO_TLB_SEGSIZE);\n\tpr_info(\"SWIOTLB bounce buffer size adjusted to %luMB\", size >> 20);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long default_nslabs = IO_TLB_DEFAULT_SIZE >> IO_TLB_SHIFT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"SWIOTLB bounce buffer size adjusted to %luMB\"",
            "size >> 20"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size >> IO_TLB_SHIFT",
            "IO_TLB_SEGSIZE"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "IO_TLB_SIZE"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned long default_nslabs = IO_TLB_DEFAULT_SIZE >> IO_TLB_SHIFT;\n\nvoid __init swiotlb_adjust_size(unsigned long size)\n{\n\t/*\n\t * If swiotlb parameter has not been specified, give a chance to\n\t * architectures such as those supporting memory encryption to\n\t * adjust/expand SWIOTLB size for their use.\n\t */\n\tif (default_nslabs != IO_TLB_DEFAULT_SIZE >> IO_TLB_SHIFT)\n\t\treturn;\n\tsize = ALIGN(size, IO_TLB_SIZE);\n\tdefault_nslabs = ALIGN(size >> IO_TLB_SHIFT, IO_TLB_SEGSIZE);\n\tpr_info(\"SWIOTLB bounce buffer size adjusted to %luMB\", size >> 20);\n}"
  },
  {
    "function_name": "swiotlb_size_or_default",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "119-122",
    "snippet": "unsigned long swiotlb_size_or_default(void)\n{\n\treturn default_nslabs << IO_TLB_SHIFT;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long default_nslabs = IO_TLB_DEFAULT_SIZE >> IO_TLB_SHIFT;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned long default_nslabs = IO_TLB_DEFAULT_SIZE >> IO_TLB_SHIFT;\n\nunsigned long swiotlb_size_or_default(void)\n{\n\treturn default_nslabs << IO_TLB_SHIFT;\n}"
  },
  {
    "function_name": "swiotlb_set_max_segment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "111-117",
    "snippet": "void swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;",
      "static unsigned int max_segment;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "val",
            "PAGE_SIZE"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nstatic unsigned int max_segment;\n\nvoid swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}"
  },
  {
    "function_name": "swiotlb_max_segment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "105-108",
    "snippet": "unsigned int swiotlb_max_segment(void)\n{\n\treturn io_tlb_default_mem.nslabs ? max_segment : 0;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct io_tlb_mem io_tlb_default_mem;",
      "static unsigned int max_segment;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstruct io_tlb_mem io_tlb_default_mem;\nstatic unsigned int max_segment;\n\nunsigned int swiotlb_max_segment(void)\n{\n\treturn io_tlb_default_mem.nslabs ? max_segment : 0;\n}"
  },
  {
    "function_name": "setup_io_tlb_npages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
    "lines": "86-102",
    "snippet": "static int __init\nsetup_io_tlb_npages(char *str)\n{\n\tif (isdigit(*str)) {\n\t\t/* avoid tail segment of size < IO_TLB_SEGSIZE */\n\t\tdefault_nslabs =\n\t\t\tALIGN(simple_strtoul(str, &str, 0), IO_TLB_SEGSIZE);\n\t}\n\tif (*str == ',')\n\t\t++str;\n\tif (!strcmp(str, \"force\"))\n\t\tswiotlb_force = SWIOTLB_FORCE;\n\telse if (!strcmp(str, \"noforce\"))\n\t\tswiotlb_force = SWIOTLB_NO_FORCE;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/io.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/io.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/cc_platform.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;",
      "static unsigned long default_nslabs = IO_TLB_DEFAULT_SIZE >> IO_TLB_SHIFT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"noforce\""
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "simple_strtoul(str, &str, 0)",
            "IO_TLB_SEGSIZE"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "&str",
            "0"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*str"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nstatic unsigned long default_nslabs = IO_TLB_DEFAULT_SIZE >> IO_TLB_SHIFT;\n\nstatic int __init\nsetup_io_tlb_npages(char *str)\n{\n\tif (isdigit(*str)) {\n\t\t/* avoid tail segment of size < IO_TLB_SEGSIZE */\n\t\tdefault_nslabs =\n\t\t\tALIGN(simple_strtoul(str, &str, 0), IO_TLB_SEGSIZE);\n\t}\n\tif (*str == ',')\n\t\t++str;\n\tif (!strcmp(str, \"force\"))\n\t\tswiotlb_force = SWIOTLB_FORCE;\n\telse if (!strcmp(str, \"noforce\"))\n\t\tswiotlb_force = SWIOTLB_NO_FORCE;\n\n\treturn 0;\n}"
  }
]