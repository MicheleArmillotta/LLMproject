[
  {
    "function_name": "dev_map_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "1120-1132",
    "snippet": "static int __init dev_map_init(void)\n{\n\tint cpu;\n\n\t/* Assure tracepoint shadow struct _bpf_dtab_netdev is in sync */\n\tBUILD_BUG_ON(offsetof(struct bpf_dtab_netdev, dev) !=\n\t\t     offsetof(struct _bpf_dtab_netdev, dev));\n\tregister_netdevice_notifier(&dev_map_notifier);\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_LIST_HEAD(&per_cpu(dev_flush_list, cpu));\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct list_head, dev_flush_list);",
      "static struct notifier_block dev_map_notifier = {\n\t.notifier_call = dev_map_notification,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_netdevice_notifier",
          "args": [
            "&dev_map_notifier"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct bpf_dtab_netdev, dev) !=\n\t\t     offsetof(struct _bpf_dtab_netdev, dev)"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct list_head, dev_flush_list);\nstatic struct notifier_block dev_map_notifier = {\n\t.notifier_call = dev_map_notification,\n};\n\nstatic int __init dev_map_init(void)\n{\n\tint cpu;\n\n\t/* Assure tracepoint shadow struct _bpf_dtab_netdev is in sync */\n\tBUILD_BUG_ON(offsetof(struct bpf_dtab_netdev, dev) !=\n\t\t     offsetof(struct _bpf_dtab_netdev, dev));\n\tregister_netdevice_notifier(&dev_map_notifier);\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_LIST_HEAD(&per_cpu(dev_flush_list, cpu));\n\treturn 0;\n}"
  },
  {
    "function_name": "dev_map_notification",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "1063-1114",
    "snippet": "static int dev_map_notification(struct notifier_block *notifier,\n\t\t\t\tulong event, void *ptr)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\tstruct bpf_dtab *dtab;\n\tint i, cpu;\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\tif (!netdev->netdev_ops->ndo_xdp_xmit || netdev->xdp_bulkq)\n\t\t\tbreak;\n\n\t\t/* will be freed in free_netdev() */\n\t\tnetdev->xdp_bulkq = alloc_percpu(struct xdp_dev_bulk_queue);\n\t\tif (!netdev->xdp_bulkq)\n\t\t\treturn NOTIFY_BAD;\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(netdev->xdp_bulkq, cpu)->dev = netdev;\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\t/* This rcu_read_lock/unlock pair is needed because\n\t\t * dev_map_list is an RCU list AND to ensure a delete\n\t\t * operation does not free a netdev_map entry while we\n\t\t * are comparing it against the netdev being unregistered.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(dtab, &dev_map_list, list) {\n\t\t\tif (dtab->map.map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\t\t\tdev_map_hash_remove_netdev(dtab, netdev);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < dtab->map.max_entries; i++) {\n\t\t\t\tstruct bpf_dtab_netdev *dev, *odev;\n\n\t\t\t\tdev = rcu_dereference(dtab->netdev_map[i]);\n\t\t\t\tif (!dev || netdev != dev->dev)\n\t\t\t\t\tcontinue;\n\t\t\t\todev = unrcu_pointer(cmpxchg(&dtab->netdev_map[i], RCU_INITIALIZER(dev), NULL));\n\t\t\t\tif (dev == odev)\n\t\t\t\t\tcall_rcu(&dev->rcu,\n\t\t\t\t\t\t __dev_map_entry_free);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(dev_map_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&dev->rcu",
            "__dev_map_entry_free"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unrcu_pointer",
          "args": [
            "cmpxchg(&dtab->netdev_map[i], RCU_INITIALIZER(dev), NULL)"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&dtab->netdev_map[i]",
            "RCU_INITIALIZER(dev)",
            "NULL"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INITIALIZER",
          "args": [
            "dev"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "dtab->netdev_map[i]"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_map_hash_remove_netdev",
          "args": [
            "dtab",
            "netdev"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_hash_remove_netdev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "1037-1061",
          "snippet": "static void dev_map_hash_remove_netdev(struct bpf_dtab *dtab,\n\t\t\t\t       struct net_device *netdev)\n{\n\tunsigned long flags;\n\tu32 i;\n\n\tspin_lock_irqsave(&dtab->index_lock, flags);\n\tfor (i = 0; i < dtab->n_buckets; i++) {\n\t\tstruct bpf_dtab_netdev *dev;\n\t\tstruct hlist_head *head;\n\t\tstruct hlist_node *next;\n\n\t\thead = dev_map_index_hash(dtab, i);\n\n\t\thlist_for_each_entry_safe(dev, next, head, index_hlist) {\n\t\t\tif (netdev != dev->dev)\n\t\t\t\tcontinue;\n\n\t\t\tdtab->items--;\n\t\t\thlist_del_rcu(&dev->index_hlist);\n\t\t\tcall_rcu(&dev->rcu, __dev_map_entry_free);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void dev_map_hash_remove_netdev(struct bpf_dtab *dtab,\n\t\t\t\t       struct net_device *netdev)\n{\n\tunsigned long flags;\n\tu32 i;\n\n\tspin_lock_irqsave(&dtab->index_lock, flags);\n\tfor (i = 0; i < dtab->n_buckets; i++) {\n\t\tstruct bpf_dtab_netdev *dev;\n\t\tstruct hlist_head *head;\n\t\tstruct hlist_node *next;\n\n\t\thead = dev_map_index_hash(dtab, i);\n\n\t\thlist_for_each_entry_safe(dev, next, head, index_hlist) {\n\t\t\tif (netdev != dev->dev)\n\t\t\t\tcontinue;\n\n\t\t\tdtab->items--;\n\t\t\thlist_del_rcu(&dev->index_hlist);\n\t\t\tcall_rcu(&dev->rcu, __dev_map_entry_free);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "dtab",
            "&dev_map_list",
            "list"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structxdp_dev_bulk_queue"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netdev_notifier_info_to_dev",
          "args": [
            "ptr"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic LIST_HEAD(dev_map_list);\n\nstatic int dev_map_notification(struct notifier_block *notifier,\n\t\t\t\tulong event, void *ptr)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\tstruct bpf_dtab *dtab;\n\tint i, cpu;\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\tif (!netdev->netdev_ops->ndo_xdp_xmit || netdev->xdp_bulkq)\n\t\t\tbreak;\n\n\t\t/* will be freed in free_netdev() */\n\t\tnetdev->xdp_bulkq = alloc_percpu(struct xdp_dev_bulk_queue);\n\t\tif (!netdev->xdp_bulkq)\n\t\t\treturn NOTIFY_BAD;\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(netdev->xdp_bulkq, cpu)->dev = netdev;\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\t/* This rcu_read_lock/unlock pair is needed because\n\t\t * dev_map_list is an RCU list AND to ensure a delete\n\t\t * operation does not free a netdev_map entry while we\n\t\t * are comparing it against the netdev being unregistered.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(dtab, &dev_map_list, list) {\n\t\t\tif (dtab->map.map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\t\t\tdev_map_hash_remove_netdev(dtab, netdev);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < dtab->map.max_entries; i++) {\n\t\t\t\tstruct bpf_dtab_netdev *dev, *odev;\n\n\t\t\t\tdev = rcu_dereference(dtab->netdev_map[i]);\n\t\t\t\tif (!dev || netdev != dev->dev)\n\t\t\t\t\tcontinue;\n\t\t\t\todev = unrcu_pointer(cmpxchg(&dtab->netdev_map[i], RCU_INITIALIZER(dev), NULL));\n\t\t\t\tif (dev == odev)\n\t\t\t\t\tcall_rcu(&dev->rcu,\n\t\t\t\t\t\t __dev_map_entry_free);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "dev_map_hash_remove_netdev",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "1037-1061",
    "snippet": "static void dev_map_hash_remove_netdev(struct bpf_dtab *dtab,\n\t\t\t\t       struct net_device *netdev)\n{\n\tunsigned long flags;\n\tu32 i;\n\n\tspin_lock_irqsave(&dtab->index_lock, flags);\n\tfor (i = 0; i < dtab->n_buckets; i++) {\n\t\tstruct bpf_dtab_netdev *dev;\n\t\tstruct hlist_head *head;\n\t\tstruct hlist_node *next;\n\n\t\thead = dev_map_index_hash(dtab, i);\n\n\t\thlist_for_each_entry_safe(dev, next, head, index_hlist) {\n\t\t\tif (netdev != dev->dev)\n\t\t\t\tcontinue;\n\n\t\t\tdtab->items--;\n\t\t\thlist_del_rcu(&dev->index_hlist);\n\t\t\tcall_rcu(&dev->rcu, __dev_map_entry_free);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&dtab->index_lock",
            "flags"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&dev->rcu",
            "__dev_map_entry_free"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&dev->index_hlist"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "dev",
            "next",
            "head",
            "index_hlist"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_map_index_hash",
          "args": [
            "dtab",
            "i"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_index_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "104-108",
          "snippet": "static inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&dtab->index_lock",
            "flags"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void dev_map_hash_remove_netdev(struct bpf_dtab *dtab,\n\t\t\t\t       struct net_device *netdev)\n{\n\tunsigned long flags;\n\tu32 i;\n\n\tspin_lock_irqsave(&dtab->index_lock, flags);\n\tfor (i = 0; i < dtab->n_buckets; i++) {\n\t\tstruct bpf_dtab_netdev *dev;\n\t\tstruct hlist_head *head;\n\t\tstruct hlist_node *next;\n\n\t\thead = dev_map_index_hash(dtab, i);\n\n\t\thlist_for_each_entry_safe(dev, next, head, index_hlist) {\n\t\t\tif (netdev != dev->dev)\n\t\t\t\tcontinue;\n\n\t\t\tdtab->items--;\n\t\t\thlist_del_rcu(&dev->index_hlist);\n\t\t\tcall_rcu(&dev->rcu, __dev_map_entry_free);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n}"
  },
  {
    "function_name": "dev_hash_map_redirect",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "1000-1005",
    "snippet": "static int dev_hash_map_redirect(struct bpf_map *map, u32 ifindex, u64 flags)\n{\n\treturn __bpf_xdp_redirect_map(map, ifindex, flags,\n\t\t\t\t      BPF_F_BROADCAST | BPF_F_EXCLUDE_INGRESS,\n\t\t\t\t      __dev_map_hash_lookup_elem);\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_xdp_redirect_map",
          "args": [
            "map",
            "ifindex",
            "flags",
            "BPF_F_BROADCAST | BPF_F_EXCLUDE_INGRESS",
            "__dev_map_hash_lookup_elem"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_hash_map_redirect(struct bpf_map *map, u32 ifindex, u64 flags)\n{\n\treturn __bpf_xdp_redirect_map(map, ifindex, flags,\n\t\t\t\t      BPF_F_BROADCAST | BPF_F_EXCLUDE_INGRESS,\n\t\t\t\t      __dev_map_hash_lookup_elem);\n}"
  },
  {
    "function_name": "dev_map_redirect",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "993-998",
    "snippet": "static int dev_map_redirect(struct bpf_map *map, u32 ifindex, u64 flags)\n{\n\treturn __bpf_xdp_redirect_map(map, ifindex, flags,\n\t\t\t\t      BPF_F_BROADCAST | BPF_F_EXCLUDE_INGRESS,\n\t\t\t\t      __dev_map_lookup_elem);\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_xdp_redirect_map",
          "args": [
            "map",
            "ifindex",
            "flags",
            "BPF_F_BROADCAST | BPF_F_EXCLUDE_INGRESS",
            "__dev_map_lookup_elem"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_redirect(struct bpf_map *map, u32 ifindex, u64 flags)\n{\n\treturn __bpf_xdp_redirect_map(map, ifindex, flags,\n\t\t\t\t      BPF_F_BROADCAST | BPF_F_EXCLUDE_INGRESS,\n\t\t\t\t      __dev_map_lookup_elem);\n}"
  },
  {
    "function_name": "dev_map_hash_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "986-991",
    "snippet": "static int dev_map_hash_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\t   u64 map_flags)\n{\n\treturn __dev_map_hash_update_elem(current->nsproxy->net_ns,\n\t\t\t\t\t map, key, value, map_flags);\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dev_map_hash_update_elem",
          "args": [
            "current->nsproxy->net_ns",
            "map",
            "key",
            "value",
            "map_flags"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "__dev_map_hash_update_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "933-984",
          "snippet": "static int __dev_map_hash_update_elem(struct net *net, struct bpf_map *map,\n\t\t\t\t     void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dev, *old_dev;\n\tstruct bpf_devmap_val val = {};\n\tu32 idx = *(u32 *)key;\n\tunsigned long flags;\n\tint err = -EEXIST;\n\n\t/* already verified value_size <= sizeof val */\n\tmemcpy(&val, value, map->value_size);\n\n\tif (unlikely(map_flags > BPF_EXIST || !val.ifindex))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dtab->index_lock, flags);\n\n\told_dev = __dev_map_hash_lookup_elem(map, idx);\n\tif (old_dev && (map_flags & BPF_NOEXIST))\n\t\tgoto out_err;\n\n\tdev = __dev_map_alloc_node(net, dtab, &val, idx);\n\tif (IS_ERR(dev)) {\n\t\terr = PTR_ERR(dev);\n\t\tgoto out_err;\n\t}\n\n\tif (old_dev) {\n\t\thlist_del_rcu(&old_dev->index_hlist);\n\t} else {\n\t\tif (dtab->items >= dtab->map.max_entries) {\n\t\t\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\t\t\tcall_rcu(&dev->rcu, __dev_map_entry_free);\n\t\t\treturn -E2BIG;\n\t\t}\n\t\tdtab->items++;\n\t}\n\n\thlist_add_head_rcu(&dev->index_hlist,\n\t\t\t   dev_map_index_hash(dtab, idx));\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\n\tif (old_dev)\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\n\treturn 0;\n\nout_err:\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int __dev_map_hash_update_elem(struct net *net, struct bpf_map *map,\n\t\t\t\t     void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dev, *old_dev;\n\tstruct bpf_devmap_val val = {};\n\tu32 idx = *(u32 *)key;\n\tunsigned long flags;\n\tint err = -EEXIST;\n\n\t/* already verified value_size <= sizeof val */\n\tmemcpy(&val, value, map->value_size);\n\n\tif (unlikely(map_flags > BPF_EXIST || !val.ifindex))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dtab->index_lock, flags);\n\n\told_dev = __dev_map_hash_lookup_elem(map, idx);\n\tif (old_dev && (map_flags & BPF_NOEXIST))\n\t\tgoto out_err;\n\n\tdev = __dev_map_alloc_node(net, dtab, &val, idx);\n\tif (IS_ERR(dev)) {\n\t\terr = PTR_ERR(dev);\n\t\tgoto out_err;\n\t}\n\n\tif (old_dev) {\n\t\thlist_del_rcu(&old_dev->index_hlist);\n\t} else {\n\t\tif (dtab->items >= dtab->map.max_entries) {\n\t\t\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\t\t\tcall_rcu(&dev->rcu, __dev_map_entry_free);\n\t\t\treturn -E2BIG;\n\t\t}\n\t\tdtab->items++;\n\t}\n\n\thlist_add_head_rcu(&dev->index_hlist,\n\t\t\t   dev_map_index_hash(dtab, idx));\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\n\tif (old_dev)\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\n\treturn 0;\n\nout_err:\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_hash_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\t   u64 map_flags)\n{\n\treturn __dev_map_hash_update_elem(current->nsproxy->net_ns,\n\t\t\t\t\t map, key, value, map_flags);\n}"
  },
  {
    "function_name": "__dev_map_hash_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "933-984",
    "snippet": "static int __dev_map_hash_update_elem(struct net *net, struct bpf_map *map,\n\t\t\t\t     void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dev, *old_dev;\n\tstruct bpf_devmap_val val = {};\n\tu32 idx = *(u32 *)key;\n\tunsigned long flags;\n\tint err = -EEXIST;\n\n\t/* already verified value_size <= sizeof val */\n\tmemcpy(&val, value, map->value_size);\n\n\tif (unlikely(map_flags > BPF_EXIST || !val.ifindex))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dtab->index_lock, flags);\n\n\told_dev = __dev_map_hash_lookup_elem(map, idx);\n\tif (old_dev && (map_flags & BPF_NOEXIST))\n\t\tgoto out_err;\n\n\tdev = __dev_map_alloc_node(net, dtab, &val, idx);\n\tif (IS_ERR(dev)) {\n\t\terr = PTR_ERR(dev);\n\t\tgoto out_err;\n\t}\n\n\tif (old_dev) {\n\t\thlist_del_rcu(&old_dev->index_hlist);\n\t} else {\n\t\tif (dtab->items >= dtab->map.max_entries) {\n\t\t\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\t\t\tcall_rcu(&dev->rcu, __dev_map_entry_free);\n\t\t\treturn -E2BIG;\n\t\t}\n\t\tdtab->items++;\n\t}\n\n\thlist_add_head_rcu(&dev->index_hlist,\n\t\t\t   dev_map_index_hash(dtab, idx));\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\n\tif (old_dev)\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\n\treturn 0;\n\nout_err:\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&dtab->index_lock",
            "flags"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&old_dev->rcu",
            "__dev_map_entry_free"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&dev->index_hlist",
            "dev_map_index_hash(dtab, idx)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_map_index_hash",
          "args": [
            "dtab",
            "idx"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_index_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "104-108",
          "snippet": "static inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&old_dev->index_hlist"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dev"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dev"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dev_map_alloc_node",
          "args": [
            "net",
            "dtab",
            "&val",
            "idx"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "__dev_map_alloc_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "838-884",
          "snippet": "static struct bpf_dtab_netdev *__dev_map_alloc_node(struct net *net,\n\t\t\t\t\t\t    struct bpf_dtab *dtab,\n\t\t\t\t\t\t    struct bpf_devmap_val *val,\n\t\t\t\t\t\t    unsigned int idx)\n{\n\tstruct bpf_prog *prog = NULL;\n\tstruct bpf_dtab_netdev *dev;\n\n\tdev = bpf_map_kmalloc_node(&dtab->map, sizeof(*dev),\n\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t   dtab->map.numa_node);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev->dev = dev_get_by_index(net, val->ifindex);\n\tif (!dev->dev)\n\t\tgoto err_out;\n\n\tif (val->bpf_prog.fd > 0) {\n\t\tprog = bpf_prog_get_type_dev(val->bpf_prog.fd,\n\t\t\t\t\t     BPF_PROG_TYPE_XDP, false);\n\t\tif (IS_ERR(prog))\n\t\t\tgoto err_put_dev;\n\t\tif (prog->expected_attach_type != BPF_XDP_DEVMAP)\n\t\t\tgoto err_put_prog;\n\t}\n\n\tdev->idx = idx;\n\tdev->dtab = dtab;\n\tif (prog) {\n\t\tdev->xdp_prog = prog;\n\t\tdev->val.bpf_prog.id = prog->aux->id;\n\t} else {\n\t\tdev->xdp_prog = NULL;\n\t\tdev->val.bpf_prog.id = 0;\n\t}\n\tdev->val.ifindex = val->ifindex;\n\n\treturn dev;\nerr_put_prog:\n\tbpf_prog_put(prog);\nerr_put_dev:\n\tdev_put(dev->dev);\nerr_out:\n\tkfree(dev);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_dtab_netdev *__dev_map_alloc_node(struct net *net,\n\t\t\t\t\t\t    struct bpf_dtab *dtab,\n\t\t\t\t\t\t    struct bpf_devmap_val *val,\n\t\t\t\t\t\t    unsigned int idx)\n{\n\tstruct bpf_prog *prog = NULL;\n\tstruct bpf_dtab_netdev *dev;\n\n\tdev = bpf_map_kmalloc_node(&dtab->map, sizeof(*dev),\n\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t   dtab->map.numa_node);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev->dev = dev_get_by_index(net, val->ifindex);\n\tif (!dev->dev)\n\t\tgoto err_out;\n\n\tif (val->bpf_prog.fd > 0) {\n\t\tprog = bpf_prog_get_type_dev(val->bpf_prog.fd,\n\t\t\t\t\t     BPF_PROG_TYPE_XDP, false);\n\t\tif (IS_ERR(prog))\n\t\t\tgoto err_put_dev;\n\t\tif (prog->expected_attach_type != BPF_XDP_DEVMAP)\n\t\t\tgoto err_put_prog;\n\t}\n\n\tdev->idx = idx;\n\tdev->dtab = dtab;\n\tif (prog) {\n\t\tdev->xdp_prog = prog;\n\t\tdev->val.bpf_prog.id = prog->aux->id;\n\t} else {\n\t\tdev->xdp_prog = NULL;\n\t\tdev->val.bpf_prog.id = 0;\n\t}\n\tdev->val.ifindex = val->ifindex;\n\n\treturn dev;\nerr_put_prog:\n\tbpf_prog_put(prog);\nerr_put_dev:\n\tdev_put(dev->dev);\nerr_out:\n\tkfree(dev);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dev_map_hash_lookup_elem",
          "args": [
            "map",
            "idx"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "__dev_map_hash_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "266-278",
          "snippet": "static void *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct hlist_head *head = dev_map_index_hash(dtab, key);\n\tstruct bpf_dtab_netdev *dev;\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist,\n\t\t\t\t lockdep_is_held(&dtab->index_lock))\n\t\tif (dev->idx == key)\n\t\t\treturn dev;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct hlist_head *head = dev_map_index_hash(dtab, key);\n\tstruct bpf_dtab_netdev *dev;\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist,\n\t\t\t\t lockdep_is_held(&dtab->index_lock))\n\t\tif (dev->idx == key)\n\t\t\treturn dev;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&dtab->index_lock",
            "flags"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_flags > BPF_EXIST || !val.ifindex"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&val",
            "value",
            "map->value_size"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_dtab",
            "map"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int __dev_map_hash_update_elem(struct net *net, struct bpf_map *map,\n\t\t\t\t     void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dev, *old_dev;\n\tstruct bpf_devmap_val val = {};\n\tu32 idx = *(u32 *)key;\n\tunsigned long flags;\n\tint err = -EEXIST;\n\n\t/* already verified value_size <= sizeof val */\n\tmemcpy(&val, value, map->value_size);\n\n\tif (unlikely(map_flags > BPF_EXIST || !val.ifindex))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dtab->index_lock, flags);\n\n\told_dev = __dev_map_hash_lookup_elem(map, idx);\n\tif (old_dev && (map_flags & BPF_NOEXIST))\n\t\tgoto out_err;\n\n\tdev = __dev_map_alloc_node(net, dtab, &val, idx);\n\tif (IS_ERR(dev)) {\n\t\terr = PTR_ERR(dev);\n\t\tgoto out_err;\n\t}\n\n\tif (old_dev) {\n\t\thlist_del_rcu(&old_dev->index_hlist);\n\t} else {\n\t\tif (dtab->items >= dtab->map.max_entries) {\n\t\t\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\t\t\tcall_rcu(&dev->rcu, __dev_map_entry_free);\n\t\t\treturn -E2BIG;\n\t\t}\n\t\tdtab->items++;\n\t}\n\n\thlist_add_head_rcu(&dev->index_hlist,\n\t\t\t   dev_map_index_hash(dtab, idx));\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\n\tif (old_dev)\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\n\treturn 0;\n\nout_err:\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\treturn err;\n}"
  },
  {
    "function_name": "dev_map_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "926-931",
    "snippet": "static int dev_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t       u64 map_flags)\n{\n\treturn __dev_map_update_elem(current->nsproxy->net_ns,\n\t\t\t\t     map, key, value, map_flags);\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dev_map_update_elem",
          "args": [
            "current->nsproxy->net_ns",
            "map",
            "key",
            "value",
            "map_flags"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "__dev_map_update_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "886-924",
          "snippet": "static int __dev_map_update_elem(struct net *net, struct bpf_map *map,\n\t\t\t\t void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dev, *old_dev;\n\tstruct bpf_devmap_val val = {};\n\tu32 i = *(u32 *)key;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\tif (unlikely(i >= dtab->map.max_entries))\n\t\treturn -E2BIG;\n\tif (unlikely(map_flags == BPF_NOEXIST))\n\t\treturn -EEXIST;\n\n\t/* already verified value_size <= sizeof val */\n\tmemcpy(&val, value, map->value_size);\n\n\tif (!val.ifindex) {\n\t\tdev = NULL;\n\t\t/* can not specify fd if ifindex is 0 */\n\t\tif (val.bpf_prog.fd > 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdev = __dev_map_alloc_node(net, dtab, &val, i);\n\t\tif (IS_ERR(dev))\n\t\t\treturn PTR_ERR(dev);\n\t}\n\n\t/* Use call_rcu() here to ensure rcu critical sections have completed\n\t * Remembering the driver side flush operation will happen before the\n\t * net device is removed.\n\t */\n\told_dev = unrcu_pointer(xchg(&dtab->netdev_map[i], RCU_INITIALIZER(dev)));\n\tif (old_dev)\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int __dev_map_update_elem(struct net *net, struct bpf_map *map,\n\t\t\t\t void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dev, *old_dev;\n\tstruct bpf_devmap_val val = {};\n\tu32 i = *(u32 *)key;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\tif (unlikely(i >= dtab->map.max_entries))\n\t\treturn -E2BIG;\n\tif (unlikely(map_flags == BPF_NOEXIST))\n\t\treturn -EEXIST;\n\n\t/* already verified value_size <= sizeof val */\n\tmemcpy(&val, value, map->value_size);\n\n\tif (!val.ifindex) {\n\t\tdev = NULL;\n\t\t/* can not specify fd if ifindex is 0 */\n\t\tif (val.bpf_prog.fd > 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdev = __dev_map_alloc_node(net, dtab, &val, i);\n\t\tif (IS_ERR(dev))\n\t\t\treturn PTR_ERR(dev);\n\t}\n\n\t/* Use call_rcu() here to ensure rcu critical sections have completed\n\t * Remembering the driver side flush operation will happen before the\n\t * net device is removed.\n\t */\n\told_dev = unrcu_pointer(xchg(&dtab->netdev_map[i], RCU_INITIALIZER(dev)));\n\tif (old_dev)\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t       u64 map_flags)\n{\n\treturn __dev_map_update_elem(current->nsproxy->net_ns,\n\t\t\t\t     map, key, value, map_flags);\n}"
  },
  {
    "function_name": "__dev_map_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "886-924",
    "snippet": "static int __dev_map_update_elem(struct net *net, struct bpf_map *map,\n\t\t\t\t void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dev, *old_dev;\n\tstruct bpf_devmap_val val = {};\n\tu32 i = *(u32 *)key;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\tif (unlikely(i >= dtab->map.max_entries))\n\t\treturn -E2BIG;\n\tif (unlikely(map_flags == BPF_NOEXIST))\n\t\treturn -EEXIST;\n\n\t/* already verified value_size <= sizeof val */\n\tmemcpy(&val, value, map->value_size);\n\n\tif (!val.ifindex) {\n\t\tdev = NULL;\n\t\t/* can not specify fd if ifindex is 0 */\n\t\tif (val.bpf_prog.fd > 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdev = __dev_map_alloc_node(net, dtab, &val, i);\n\t\tif (IS_ERR(dev))\n\t\t\treturn PTR_ERR(dev);\n\t}\n\n\t/* Use call_rcu() here to ensure rcu critical sections have completed\n\t * Remembering the driver side flush operation will happen before the\n\t * net device is removed.\n\t */\n\told_dev = unrcu_pointer(xchg(&dtab->netdev_map[i], RCU_INITIALIZER(dev)));\n\tif (old_dev)\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&old_dev->rcu",
            "__dev_map_entry_free"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unrcu_pointer",
          "args": [
            "xchg(&dtab->netdev_map[i], RCU_INITIALIZER(dev))"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&dtab->netdev_map[i]",
            "RCU_INITIALIZER(dev)"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INITIALIZER",
          "args": [
            "dev"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dev"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dev"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dev_map_alloc_node",
          "args": [
            "net",
            "dtab",
            "&val",
            "i"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "__dev_map_alloc_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "838-884",
          "snippet": "static struct bpf_dtab_netdev *__dev_map_alloc_node(struct net *net,\n\t\t\t\t\t\t    struct bpf_dtab *dtab,\n\t\t\t\t\t\t    struct bpf_devmap_val *val,\n\t\t\t\t\t\t    unsigned int idx)\n{\n\tstruct bpf_prog *prog = NULL;\n\tstruct bpf_dtab_netdev *dev;\n\n\tdev = bpf_map_kmalloc_node(&dtab->map, sizeof(*dev),\n\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t   dtab->map.numa_node);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev->dev = dev_get_by_index(net, val->ifindex);\n\tif (!dev->dev)\n\t\tgoto err_out;\n\n\tif (val->bpf_prog.fd > 0) {\n\t\tprog = bpf_prog_get_type_dev(val->bpf_prog.fd,\n\t\t\t\t\t     BPF_PROG_TYPE_XDP, false);\n\t\tif (IS_ERR(prog))\n\t\t\tgoto err_put_dev;\n\t\tif (prog->expected_attach_type != BPF_XDP_DEVMAP)\n\t\t\tgoto err_put_prog;\n\t}\n\n\tdev->idx = idx;\n\tdev->dtab = dtab;\n\tif (prog) {\n\t\tdev->xdp_prog = prog;\n\t\tdev->val.bpf_prog.id = prog->aux->id;\n\t} else {\n\t\tdev->xdp_prog = NULL;\n\t\tdev->val.bpf_prog.id = 0;\n\t}\n\tdev->val.ifindex = val->ifindex;\n\n\treturn dev;\nerr_put_prog:\n\tbpf_prog_put(prog);\nerr_put_dev:\n\tdev_put(dev->dev);\nerr_out:\n\tkfree(dev);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_dtab_netdev *__dev_map_alloc_node(struct net *net,\n\t\t\t\t\t\t    struct bpf_dtab *dtab,\n\t\t\t\t\t\t    struct bpf_devmap_val *val,\n\t\t\t\t\t\t    unsigned int idx)\n{\n\tstruct bpf_prog *prog = NULL;\n\tstruct bpf_dtab_netdev *dev;\n\n\tdev = bpf_map_kmalloc_node(&dtab->map, sizeof(*dev),\n\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t   dtab->map.numa_node);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev->dev = dev_get_by_index(net, val->ifindex);\n\tif (!dev->dev)\n\t\tgoto err_out;\n\n\tif (val->bpf_prog.fd > 0) {\n\t\tprog = bpf_prog_get_type_dev(val->bpf_prog.fd,\n\t\t\t\t\t     BPF_PROG_TYPE_XDP, false);\n\t\tif (IS_ERR(prog))\n\t\t\tgoto err_put_dev;\n\t\tif (prog->expected_attach_type != BPF_XDP_DEVMAP)\n\t\t\tgoto err_put_prog;\n\t}\n\n\tdev->idx = idx;\n\tdev->dtab = dtab;\n\tif (prog) {\n\t\tdev->xdp_prog = prog;\n\t\tdev->val.bpf_prog.id = prog->aux->id;\n\t} else {\n\t\tdev->xdp_prog = NULL;\n\t\tdev->val.bpf_prog.id = 0;\n\t}\n\tdev->val.ifindex = val->ifindex;\n\n\treturn dev;\nerr_put_prog:\n\tbpf_prog_put(prog);\nerr_put_dev:\n\tdev_put(dev->dev);\nerr_out:\n\tkfree(dev);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&val",
            "value",
            "map->value_size"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_flags == BPF_NOEXIST"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "i >= dtab->map.max_entries"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_flags > BPF_EXIST"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_dtab",
            "map"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int __dev_map_update_elem(struct net *net, struct bpf_map *map,\n\t\t\t\t void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dev, *old_dev;\n\tstruct bpf_devmap_val val = {};\n\tu32 i = *(u32 *)key;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\tif (unlikely(i >= dtab->map.max_entries))\n\t\treturn -E2BIG;\n\tif (unlikely(map_flags == BPF_NOEXIST))\n\t\treturn -EEXIST;\n\n\t/* already verified value_size <= sizeof val */\n\tmemcpy(&val, value, map->value_size);\n\n\tif (!val.ifindex) {\n\t\tdev = NULL;\n\t\t/* can not specify fd if ifindex is 0 */\n\t\tif (val.bpf_prog.fd > 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdev = __dev_map_alloc_node(net, dtab, &val, i);\n\t\tif (IS_ERR(dev))\n\t\t\treturn PTR_ERR(dev);\n\t}\n\n\t/* Use call_rcu() here to ensure rcu critical sections have completed\n\t * Remembering the driver side flush operation will happen before the\n\t * net device is removed.\n\t */\n\told_dev = unrcu_pointer(xchg(&dtab->netdev_map[i], RCU_INITIALIZER(dev)));\n\tif (old_dev)\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__dev_map_alloc_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "838-884",
    "snippet": "static struct bpf_dtab_netdev *__dev_map_alloc_node(struct net *net,\n\t\t\t\t\t\t    struct bpf_dtab *dtab,\n\t\t\t\t\t\t    struct bpf_devmap_val *val,\n\t\t\t\t\t\t    unsigned int idx)\n{\n\tstruct bpf_prog *prog = NULL;\n\tstruct bpf_dtab_netdev *dev;\n\n\tdev = bpf_map_kmalloc_node(&dtab->map, sizeof(*dev),\n\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t   dtab->map.numa_node);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev->dev = dev_get_by_index(net, val->ifindex);\n\tif (!dev->dev)\n\t\tgoto err_out;\n\n\tif (val->bpf_prog.fd > 0) {\n\t\tprog = bpf_prog_get_type_dev(val->bpf_prog.fd,\n\t\t\t\t\t     BPF_PROG_TYPE_XDP, false);\n\t\tif (IS_ERR(prog))\n\t\t\tgoto err_put_dev;\n\t\tif (prog->expected_attach_type != BPF_XDP_DEVMAP)\n\t\t\tgoto err_put_prog;\n\t}\n\n\tdev->idx = idx;\n\tdev->dtab = dtab;\n\tif (prog) {\n\t\tdev->xdp_prog = prog;\n\t\tdev->val.bpf_prog.id = prog->aux->id;\n\t} else {\n\t\tdev->xdp_prog = NULL;\n\t\tdev->val.bpf_prog.id = 0;\n\t}\n\tdev->val.ifindex = val->ifindex;\n\n\treturn dev;\nerr_put_prog:\n\tbpf_prog_put(prog);\nerr_put_dev:\n\tdev_put(dev->dev);\nerr_out:\n\tkfree(dev);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dev"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_put",
          "args": [
            "dev->dev"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_type_dev",
          "args": [
            "val->bpf_prog.fd",
            "BPF_PROG_TYPE_XDP",
            "false"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_type_dev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2016-2020",
          "snippet": "struct bpf_prog *bpf_prog_get_type_dev(u32 ufd, enum bpf_prog_type type,\n\t\t\t\t       bool attach_drv)\n{\n\treturn __bpf_prog_get(ufd, &type, attach_drv);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_get_type_dev(u32 ufd, enum bpf_prog_type type,\n\t\t\t\t       bool attach_drv)\n{\n\treturn __bpf_prog_get(ufd, &type, attach_drv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_get_by_index",
          "args": [
            "net",
            "val->ifindex"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_kmalloc_node",
          "args": [
            "&dtab->map",
            "sizeof(*dev)",
            "GFP_ATOMIC | __GFP_NOWARN",
            "dtab->map.numa_node"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_kmalloc_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "427-438",
          "snippet": "void *bpf_map_kmalloc_node(const struct bpf_map *map, size_t size, gfp_t flags,\n\t\t\t   int node)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kmalloc_node(size, flags | __GFP_ACCOUNT, node);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_kmalloc_node(const struct bpf_map *map, size_t size, gfp_t flags,\n\t\t\t   int node)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kmalloc_node(size, flags | __GFP_ACCOUNT, node);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_dtab_netdev *__dev_map_alloc_node(struct net *net,\n\t\t\t\t\t\t    struct bpf_dtab *dtab,\n\t\t\t\t\t\t    struct bpf_devmap_val *val,\n\t\t\t\t\t\t    unsigned int idx)\n{\n\tstruct bpf_prog *prog = NULL;\n\tstruct bpf_dtab_netdev *dev;\n\n\tdev = bpf_map_kmalloc_node(&dtab->map, sizeof(*dev),\n\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t   dtab->map.numa_node);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev->dev = dev_get_by_index(net, val->ifindex);\n\tif (!dev->dev)\n\t\tgoto err_out;\n\n\tif (val->bpf_prog.fd > 0) {\n\t\tprog = bpf_prog_get_type_dev(val->bpf_prog.fd,\n\t\t\t\t\t     BPF_PROG_TYPE_XDP, false);\n\t\tif (IS_ERR(prog))\n\t\t\tgoto err_put_dev;\n\t\tif (prog->expected_attach_type != BPF_XDP_DEVMAP)\n\t\t\tgoto err_put_prog;\n\t}\n\n\tdev->idx = idx;\n\tdev->dtab = dtab;\n\tif (prog) {\n\t\tdev->xdp_prog = prog;\n\t\tdev->val.bpf_prog.id = prog->aux->id;\n\t} else {\n\t\tdev->xdp_prog = NULL;\n\t\tdev->val.bpf_prog.id = 0;\n\t}\n\tdev->val.ifindex = val->ifindex;\n\n\treturn dev;\nerr_put_prog:\n\tbpf_prog_put(prog);\nerr_put_dev:\n\tdev_put(dev->dev);\nerr_out:\n\tkfree(dev);\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "dev_map_hash_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "816-836",
    "snippet": "static int dev_map_hash_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *old_dev;\n\tint k = *(u32 *)key;\n\tunsigned long flags;\n\tint ret = -ENOENT;\n\n\tspin_lock_irqsave(&dtab->index_lock, flags);\n\n\told_dev = __dev_map_hash_lookup_elem(map, k);\n\tif (old_dev) {\n\t\tdtab->items--;\n\t\thlist_del_init_rcu(&old_dev->index_hlist);\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&dtab->index_lock",
            "flags"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&old_dev->rcu",
            "__dev_map_entry_free"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&old_dev->index_hlist"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dev_map_hash_lookup_elem",
          "args": [
            "map",
            "k"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "__dev_map_hash_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "266-278",
          "snippet": "static void *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct hlist_head *head = dev_map_index_hash(dtab, key);\n\tstruct bpf_dtab_netdev *dev;\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist,\n\t\t\t\t lockdep_is_held(&dtab->index_lock))\n\t\tif (dev->idx == key)\n\t\t\treturn dev;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct hlist_head *head = dev_map_index_hash(dtab, key);\n\tstruct bpf_dtab_netdev *dev;\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist,\n\t\t\t\t lockdep_is_held(&dtab->index_lock))\n\t\tif (dev->idx == key)\n\t\t\treturn dev;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&dtab->index_lock",
            "flags"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_dtab",
            "map"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_hash_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *old_dev;\n\tint k = *(u32 *)key;\n\tunsigned long flags;\n\tint ret = -ENOENT;\n\n\tspin_lock_irqsave(&dtab->index_lock, flags);\n\n\told_dev = __dev_map_hash_lookup_elem(map, k);\n\tif (old_dev) {\n\t\tdtab->items--;\n\t\thlist_del_init_rcu(&old_dev->index_hlist);\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&dtab->index_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dev_map_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "801-814",
    "snippet": "static int dev_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *old_dev;\n\tint k = *(u32 *)key;\n\n\tif (k >= map->max_entries)\n\t\treturn -EINVAL;\n\n\told_dev = unrcu_pointer(xchg(&dtab->netdev_map[k], NULL));\n\tif (old_dev)\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&old_dev->rcu",
            "__dev_map_entry_free"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unrcu_pointer",
          "args": [
            "xchg(&dtab->netdev_map[k], NULL)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&dtab->netdev_map[k]",
            "NULL"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_dtab",
            "map"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *old_dev;\n\tint k = *(u32 *)key;\n\n\tif (k >= map->max_entries)\n\t\treturn -EINVAL;\n\n\told_dev = unrcu_pointer(xchg(&dtab->netdev_map[k], NULL));\n\tif (old_dev)\n\t\tcall_rcu(&old_dev->rcu, __dev_map_entry_free);\n\treturn 0;\n}"
  },
  {
    "function_name": "__dev_map_entry_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "790-799",
    "snippet": "static void __dev_map_entry_free(struct rcu_head *rcu)\n{\n\tstruct bpf_dtab_netdev *dev;\n\n\tdev = container_of(rcu, struct bpf_dtab_netdev, rcu);\n\tif (dev->xdp_prog)\n\t\tbpf_prog_put(dev->xdp_prog);\n\tdev_put(dev->dev);\n\tkfree(dev);\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dev"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_put",
          "args": [
            "dev->dev"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "dev->xdp_prog"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_dtab_netdev",
            "rcu"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void __dev_map_entry_free(struct rcu_head *rcu)\n{\n\tstruct bpf_dtab_netdev *dev;\n\n\tdev = container_of(rcu, struct bpf_dtab_netdev, rcu);\n\tif (dev->xdp_prog)\n\t\tbpf_prog_put(dev->xdp_prog);\n\tdev_put(dev->dev);\n\tkfree(dev);\n}"
  },
  {
    "function_name": "dev_map_hash_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "783-788",
    "snippet": "static void *dev_map_hash_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_dtab_netdev *obj = __dev_map_hash_lookup_elem(map,\n\t\t\t\t\t\t\t\t*(u32 *)key);\n\treturn obj ? &obj->val : NULL;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dev_map_hash_lookup_elem",
          "args": [
            "map",
            "*(u32 *)key"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "__dev_map_hash_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "266-278",
          "snippet": "static void *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct hlist_head *head = dev_map_index_hash(dtab, key);\n\tstruct bpf_dtab_netdev *dev;\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist,\n\t\t\t\t lockdep_is_held(&dtab->index_lock))\n\t\tif (dev->idx == key)\n\t\t\treturn dev;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct hlist_head *head = dev_map_index_hash(dtab, key);\n\tstruct bpf_dtab_netdev *dev;\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist,\n\t\t\t\t lockdep_is_held(&dtab->index_lock))\n\t\tif (dev->idx == key)\n\t\t\treturn dev;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void *dev_map_hash_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_dtab_netdev *obj = __dev_map_hash_lookup_elem(map,\n\t\t\t\t\t\t\t\t*(u32 *)key);\n\treturn obj ? &obj->val : NULL;\n}"
  },
  {
    "function_name": "dev_map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "776-781",
    "snippet": "static void *dev_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_dtab_netdev *obj = __dev_map_lookup_elem(map, *(u32 *)key);\n\n\treturn obj ? &obj->val : NULL;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dev_map_lookup_elem",
          "args": [
            "map",
            "*(u32 *)key"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "__dev_map_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "428-439",
          "snippet": "static void *__dev_map_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *obj;\n\n\tif (key >= map->max_entries)\n\t\treturn NULL;\n\n\tobj = rcu_dereference_check(dtab->netdev_map[key],\n\t\t\t\t    rcu_read_lock_bh_held());\n\treturn obj;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void *__dev_map_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *obj;\n\n\tif (key >= map->max_entries)\n\t\treturn NULL;\n\n\tobj = rcu_dereference_check(dtab->netdev_map[key],\n\t\t\t\t    rcu_read_lock_bh_held());\n\treturn obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void *dev_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_dtab_netdev *obj = __dev_map_lookup_elem(map, *(u32 *)key);\n\n\treturn obj ? &obj->val : NULL;\n}"
  },
  {
    "function_name": "dev_map_redirect_multi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "700-774",
    "snippet": "int dev_map_redirect_multi(struct net_device *dev, struct sk_buff *skb,\n\t\t\t   struct bpf_prog *xdp_prog, struct bpf_map *map,\n\t\t\t   bool exclude_ingress)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dst, *last_dst = NULL;\n\tint excluded_devices[1+MAX_NEST_DEV];\n\tstruct hlist_head *head;\n\tstruct hlist_node *next;\n\tint num_excluded = 0;\n\tunsigned int i;\n\tint err;\n\n\tif (exclude_ingress) {\n\t\tnum_excluded = get_upper_ifindexes(dev, excluded_devices);\n\t\texcluded_devices[num_excluded++] = dev->ifindex;\n\t}\n\n\tif (map->map_type == BPF_MAP_TYPE_DEVMAP) {\n\t\tfor (i = 0; i < map->max_entries; i++) {\n\t\t\tdst = rcu_dereference_check(dtab->netdev_map[i],\n\t\t\t\t\t\t    rcu_read_lock_bh_held());\n\t\t\tif (!dst)\n\t\t\t\tcontinue;\n\n\t\t\tif (is_ifindex_excluded(excluded_devices, num_excluded, dst->dev->ifindex))\n\t\t\t\tcontinue;\n\n\t\t\t/* we only need n-1 clones; last_dst enqueued below */\n\t\t\tif (!last_dst) {\n\t\t\t\tlast_dst = dst;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = dev_map_redirect_clone(last_dst, skb, xdp_prog);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tlast_dst = dst;\n\n\t\t}\n\t} else { /* BPF_MAP_TYPE_DEVMAP_HASH */\n\t\tfor (i = 0; i < dtab->n_buckets; i++) {\n\t\t\thead = dev_map_index_hash(dtab, i);\n\t\t\thlist_for_each_entry_safe(dst, next, head, index_hlist) {\n\t\t\t\tif (!dst)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (is_ifindex_excluded(excluded_devices, num_excluded,\n\t\t\t\t\t\t\tdst->dev->ifindex))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* we only need n-1 clones; last_dst enqueued below */\n\t\t\t\tif (!last_dst) {\n\t\t\t\t\tlast_dst = dst;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\terr = dev_map_redirect_clone(last_dst, skb, xdp_prog);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlast_dst = dst;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* consume the first skb and return */\n\tif (last_dst)\n\t\treturn dev_map_generic_redirect(last_dst, skb, xdp_prog);\n\n\t/* dtab is empty */\n\tconsume_skb(skb);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "consume_skb",
          "args": [
            "skb"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_map_generic_redirect",
          "args": [
            "last_dst",
            "skb",
            "xdp_prog"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_generic_redirect",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "658-678",
          "snippet": "int dev_map_generic_redirect(struct bpf_dtab_netdev *dst, struct sk_buff *skb,\n\t\t\t     struct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\terr = xdp_ok_fwd_dev(dst->dev, skb->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\t/* Redirect has already succeeded semantically at this point, so we just\n\t * return 0 even if packet is dropped. Helper below takes care of\n\t * freeing skb.\n\t */\n\tif (dev_map_bpf_prog_run_skb(skb, dst) != XDP_PASS)\n\t\treturn 0;\n\n\tskb->dev = dst->dev;\n\tgeneric_xdp_tx(skb, xdp_prog);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nint dev_map_generic_redirect(struct bpf_dtab_netdev *dst, struct sk_buff *skb,\n\t\t\t     struct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\terr = xdp_ok_fwd_dev(dst->dev, skb->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\t/* Redirect has already succeeded semantically at this point, so we just\n\t * return 0 even if packet is dropped. Helper below takes care of\n\t * freeing skb.\n\t */\n\tif (dev_map_bpf_prog_run_skb(skb, dst) != XDP_PASS)\n\t\treturn 0;\n\n\tskb->dev = dst->dev;\n\tgeneric_xdp_tx(skb, xdp_prog);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_map_redirect_clone",
          "args": [
            "last_dst",
            "skb",
            "xdp_prog"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_redirect_clone",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "680-698",
          "snippet": "static int dev_map_redirect_clone(struct bpf_dtab_netdev *dst,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct bpf_prog *xdp_prog)\n{\n\tstruct sk_buff *nskb;\n\tint err;\n\n\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn -ENOMEM;\n\n\terr = dev_map_generic_redirect(dst, nskb, xdp_prog);\n\tif (unlikely(err)) {\n\t\tconsume_skb(nskb);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_redirect_clone(struct bpf_dtab_netdev *dst,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct bpf_prog *xdp_prog)\n{\n\tstruct sk_buff *nskb;\n\tint err;\n\n\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn -ENOMEM;\n\n\terr = dev_map_generic_redirect(dst, nskb, xdp_prog);\n\tif (unlikely(err)) {\n\t\tconsume_skb(nskb);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ifindex_excluded",
          "args": [
            "excluded_devices",
            "num_excluded",
            "dst->dev->ifindex"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "is_ifindex_excluded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "559-566",
          "snippet": "static inline bool is_ifindex_excluded(int *excluded, int num_excluded, int ifindex)\n{\n\twhile (num_excluded--) {\n\t\tif (ifindex == excluded[num_excluded])\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline bool is_ifindex_excluded(int *excluded, int num_excluded, int ifindex)\n{\n\twhile (num_excluded--) {\n\t\tif (ifindex == excluded[num_excluded])\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "dst",
            "next",
            "head",
            "index_hlist"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_map_index_hash",
          "args": [
            "dtab",
            "i"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_index_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "104-108",
          "snippet": "static inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "dtab->netdev_map[i]",
            "rcu_read_lock_bh_held()"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_bh_held",
          "args": [],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "330-337",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_upper_ifindexes",
          "args": [
            "dev",
            "excluded_devices"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "get_upper_ifindexes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "572-582",
          "snippet": "static int get_upper_ifindexes(struct net_device *dev, int *indexes)\n{\n\tstruct net_device *upper;\n\tstruct list_head *iter;\n\tint n = 0;\n\n\tnetdev_for_each_upper_dev_rcu(dev, upper, iter) {\n\t\tindexes[n++] = upper->ifindex;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int get_upper_ifindexes(struct net_device *dev, int *indexes)\n{\n\tstruct net_device *upper;\n\tstruct list_head *iter;\n\tint n = 0;\n\n\tnetdev_for_each_upper_dev_rcu(dev, upper, iter) {\n\t\tindexes[n++] = upper->ifindex;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_dtab",
            "map"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nint dev_map_redirect_multi(struct net_device *dev, struct sk_buff *skb,\n\t\t\t   struct bpf_prog *xdp_prog, struct bpf_map *map,\n\t\t\t   bool exclude_ingress)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dst, *last_dst = NULL;\n\tint excluded_devices[1+MAX_NEST_DEV];\n\tstruct hlist_head *head;\n\tstruct hlist_node *next;\n\tint num_excluded = 0;\n\tunsigned int i;\n\tint err;\n\n\tif (exclude_ingress) {\n\t\tnum_excluded = get_upper_ifindexes(dev, excluded_devices);\n\t\texcluded_devices[num_excluded++] = dev->ifindex;\n\t}\n\n\tif (map->map_type == BPF_MAP_TYPE_DEVMAP) {\n\t\tfor (i = 0; i < map->max_entries; i++) {\n\t\t\tdst = rcu_dereference_check(dtab->netdev_map[i],\n\t\t\t\t\t\t    rcu_read_lock_bh_held());\n\t\t\tif (!dst)\n\t\t\t\tcontinue;\n\n\t\t\tif (is_ifindex_excluded(excluded_devices, num_excluded, dst->dev->ifindex))\n\t\t\t\tcontinue;\n\n\t\t\t/* we only need n-1 clones; last_dst enqueued below */\n\t\t\tif (!last_dst) {\n\t\t\t\tlast_dst = dst;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = dev_map_redirect_clone(last_dst, skb, xdp_prog);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tlast_dst = dst;\n\n\t\t}\n\t} else { /* BPF_MAP_TYPE_DEVMAP_HASH */\n\t\tfor (i = 0; i < dtab->n_buckets; i++) {\n\t\t\thead = dev_map_index_hash(dtab, i);\n\t\t\thlist_for_each_entry_safe(dst, next, head, index_hlist) {\n\t\t\t\tif (!dst)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (is_ifindex_excluded(excluded_devices, num_excluded,\n\t\t\t\t\t\t\tdst->dev->ifindex))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* we only need n-1 clones; last_dst enqueued below */\n\t\t\t\tif (!last_dst) {\n\t\t\t\t\tlast_dst = dst;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\terr = dev_map_redirect_clone(last_dst, skb, xdp_prog);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlast_dst = dst;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* consume the first skb and return */\n\tif (last_dst)\n\t\treturn dev_map_generic_redirect(last_dst, skb, xdp_prog);\n\n\t/* dtab is empty */\n\tconsume_skb(skb);\n\treturn 0;\n}"
  },
  {
    "function_name": "dev_map_redirect_clone",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "680-698",
    "snippet": "static int dev_map_redirect_clone(struct bpf_dtab_netdev *dst,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct bpf_prog *xdp_prog)\n{\n\tstruct sk_buff *nskb;\n\tint err;\n\n\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn -ENOMEM;\n\n\terr = dev_map_generic_redirect(dst, nskb, xdp_prog);\n\tif (unlikely(err)) {\n\t\tconsume_skb(nskb);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "consume_skb",
          "args": [
            "nskb"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_map_generic_redirect",
          "args": [
            "dst",
            "nskb",
            "xdp_prog"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_generic_redirect",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "658-678",
          "snippet": "int dev_map_generic_redirect(struct bpf_dtab_netdev *dst, struct sk_buff *skb,\n\t\t\t     struct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\terr = xdp_ok_fwd_dev(dst->dev, skb->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\t/* Redirect has already succeeded semantically at this point, so we just\n\t * return 0 even if packet is dropped. Helper below takes care of\n\t * freeing skb.\n\t */\n\tif (dev_map_bpf_prog_run_skb(skb, dst) != XDP_PASS)\n\t\treturn 0;\n\n\tskb->dev = dst->dev;\n\tgeneric_xdp_tx(skb, xdp_prog);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nint dev_map_generic_redirect(struct bpf_dtab_netdev *dst, struct sk_buff *skb,\n\t\t\t     struct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\terr = xdp_ok_fwd_dev(dst->dev, skb->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\t/* Redirect has already succeeded semantically at this point, so we just\n\t * return 0 even if packet is dropped. Helper below takes care of\n\t * freeing skb.\n\t */\n\tif (dev_map_bpf_prog_run_skb(skb, dst) != XDP_PASS)\n\t\treturn 0;\n\n\tskb->dev = dst->dev;\n\tgeneric_xdp_tx(skb, xdp_prog);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_clone",
          "args": [
            "skb",
            "GFP_ATOMIC"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_redirect_clone(struct bpf_dtab_netdev *dst,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct bpf_prog *xdp_prog)\n{\n\tstruct sk_buff *nskb;\n\tint err;\n\n\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn -ENOMEM;\n\n\terr = dev_map_generic_redirect(dst, nskb, xdp_prog);\n\tif (unlikely(err)) {\n\t\tconsume_skb(nskb);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dev_map_generic_redirect",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "658-678",
    "snippet": "int dev_map_generic_redirect(struct bpf_dtab_netdev *dst, struct sk_buff *skb,\n\t\t\t     struct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\terr = xdp_ok_fwd_dev(dst->dev, skb->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\t/* Redirect has already succeeded semantically at this point, so we just\n\t * return 0 even if packet is dropped. Helper below takes care of\n\t * freeing skb.\n\t */\n\tif (dev_map_bpf_prog_run_skb(skb, dst) != XDP_PASS)\n\t\treturn 0;\n\n\tskb->dev = dst->dev;\n\tgeneric_xdp_tx(skb, xdp_prog);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_xdp_tx",
          "args": [
            "skb",
            "xdp_prog"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_map_bpf_prog_run_skb",
          "args": [
            "skb",
            "dst"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_bpf_prog_run_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "487-516",
          "snippet": "static u32 dev_map_bpf_prog_run_skb(struct sk_buff *skb, struct bpf_dtab_netdev *dst)\n{\n\tstruct xdp_txq_info txq = { .dev = dst->dev };\n\tstruct xdp_buff xdp;\n\tu32 act;\n\n\tif (!dst->xdp_prog)\n\t\treturn XDP_PASS;\n\n\t__skb_pull(skb, skb->mac_len);\n\txdp.txq = &txq;\n\n\tact = bpf_prog_run_generic_xdp(skb, &xdp, dst->xdp_prog);\n\tswitch (act) {\n\tcase XDP_PASS:\n\t\t__skb_push(skb, skb->mac_len);\n\t\tbreak;\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(NULL, dst->xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(dst->dev, dst->xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_DROP:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\treturn act;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic u32 dev_map_bpf_prog_run_skb(struct sk_buff *skb, struct bpf_dtab_netdev *dst)\n{\n\tstruct xdp_txq_info txq = { .dev = dst->dev };\n\tstruct xdp_buff xdp;\n\tu32 act;\n\n\tif (!dst->xdp_prog)\n\t\treturn XDP_PASS;\n\n\t__skb_pull(skb, skb->mac_len);\n\txdp.txq = &txq;\n\n\tact = bpf_prog_run_generic_xdp(skb, &xdp, dst->xdp_prog);\n\tswitch (act) {\n\tcase XDP_PASS:\n\t\t__skb_push(skb, skb->mac_len);\n\t\tbreak;\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(NULL, dst->xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(dst->dev, dst->xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_DROP:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\treturn act;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdp_ok_fwd_dev",
          "args": [
            "dst->dev",
            "skb->len"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nint dev_map_generic_redirect(struct bpf_dtab_netdev *dst, struct sk_buff *skb,\n\t\t\t     struct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\terr = xdp_ok_fwd_dev(dst->dev, skb->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\t/* Redirect has already succeeded semantically at this point, so we just\n\t * return 0 even if packet is dropped. Helper below takes care of\n\t * freeing skb.\n\t */\n\tif (dev_map_bpf_prog_run_skb(skb, dst) != XDP_PASS)\n\t\treturn 0;\n\n\tskb->dev = dst->dev;\n\tgeneric_xdp_tx(skb, xdp_prog);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dev_map_enqueue_multi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "584-656",
    "snippet": "int dev_map_enqueue_multi(struct xdp_frame *xdpf, struct net_device *dev_rx,\n\t\t\t  struct bpf_map *map, bool exclude_ingress)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dst, *last_dst = NULL;\n\tint excluded_devices[1+MAX_NEST_DEV];\n\tstruct hlist_head *head;\n\tint num_excluded = 0;\n\tunsigned int i;\n\tint err;\n\n\tif (exclude_ingress) {\n\t\tnum_excluded = get_upper_ifindexes(dev_rx, excluded_devices);\n\t\texcluded_devices[num_excluded++] = dev_rx->ifindex;\n\t}\n\n\tif (map->map_type == BPF_MAP_TYPE_DEVMAP) {\n\t\tfor (i = 0; i < map->max_entries; i++) {\n\t\t\tdst = rcu_dereference_check(dtab->netdev_map[i],\n\t\t\t\t\t\t    rcu_read_lock_bh_held());\n\t\t\tif (!is_valid_dst(dst, xdpf))\n\t\t\t\tcontinue;\n\n\t\t\tif (is_ifindex_excluded(excluded_devices, num_excluded, dst->dev->ifindex))\n\t\t\t\tcontinue;\n\n\t\t\t/* we only need n-1 clones; last_dst enqueued below */\n\t\t\tif (!last_dst) {\n\t\t\t\tlast_dst = dst;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = dev_map_enqueue_clone(last_dst, dev_rx, xdpf);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tlast_dst = dst;\n\t\t}\n\t} else { /* BPF_MAP_TYPE_DEVMAP_HASH */\n\t\tfor (i = 0; i < dtab->n_buckets; i++) {\n\t\t\thead = dev_map_index_hash(dtab, i);\n\t\t\thlist_for_each_entry_rcu(dst, head, index_hlist,\n\t\t\t\t\t\t lockdep_is_held(&dtab->index_lock)) {\n\t\t\t\tif (!is_valid_dst(dst, xdpf))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (is_ifindex_excluded(excluded_devices, num_excluded,\n\t\t\t\t\t\t\tdst->dev->ifindex))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* we only need n-1 clones; last_dst enqueued below */\n\t\t\t\tif (!last_dst) {\n\t\t\t\t\tlast_dst = dst;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\terr = dev_map_enqueue_clone(last_dst, dev_rx, xdpf);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlast_dst = dst;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* consume the last copy of the frame */\n\tif (last_dst)\n\t\tbq_enqueue(last_dst->dev, xdpf, dev_rx, last_dst->xdp_prog);\n\telse\n\t\txdp_return_frame_rx_napi(xdpf); /* dtab is empty */\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdp_return_frame_rx_napi",
          "args": [
            "xdpf"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bq_enqueue",
          "args": [
            "last_dst->dev",
            "xdpf",
            "dev_rx",
            "last_dst->xdp_prog"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "bq_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "445-468",
          "snippet": "static void bq_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t       struct net_device *dev_rx, struct bpf_prog *xdp_prog)\n{\n\tstruct list_head *flush_list = this_cpu_ptr(&dev_flush_list);\n\tstruct xdp_dev_bulk_queue *bq = this_cpu_ptr(dev->xdp_bulkq);\n\n\tif (unlikely(bq->count == DEV_MAP_BULK_SIZE))\n\t\tbq_xmit_all(bq, 0);\n\n\t/* Ingress dev_rx will be the same for all xdp_frame's in\n\t * bulk_queue, because bq stored per-CPU and must be flushed\n\t * from net_device drivers NAPI func end.\n\t *\n\t * Do the same with xdp_prog and flush_list since these fields\n\t * are only ever modified together.\n\t */\n\tif (!bq->dev_rx) {\n\t\tbq->dev_rx = dev_rx;\n\t\tbq->xdp_prog = xdp_prog;\n\t\tlist_add(&bq->flush_node, flush_list);\n\t}\n\n\tbq->q[bq->count++] = xdpf;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct list_head, dev_flush_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct list_head, dev_flush_list);\n\nstatic void bq_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t       struct net_device *dev_rx, struct bpf_prog *xdp_prog)\n{\n\tstruct list_head *flush_list = this_cpu_ptr(&dev_flush_list);\n\tstruct xdp_dev_bulk_queue *bq = this_cpu_ptr(dev->xdp_bulkq);\n\n\tif (unlikely(bq->count == DEV_MAP_BULK_SIZE))\n\t\tbq_xmit_all(bq, 0);\n\n\t/* Ingress dev_rx will be the same for all xdp_frame's in\n\t * bulk_queue, because bq stored per-CPU and must be flushed\n\t * from net_device drivers NAPI func end.\n\t *\n\t * Do the same with xdp_prog and flush_list since these fields\n\t * are only ever modified together.\n\t */\n\tif (!bq->dev_rx) {\n\t\tbq->dev_rx = dev_rx;\n\t\tbq->xdp_prog = xdp_prog;\n\t\tlist_add(&bq->flush_node, flush_list);\n\t}\n\n\tbq->q[bq->count++] = xdpf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_map_enqueue_clone",
          "args": [
            "last_dst",
            "dev_rx",
            "xdpf"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_enqueue_clone",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "544-557",
          "snippet": "static int dev_map_enqueue_clone(struct bpf_dtab_netdev *obj,\n\t\t\t\t struct net_device *dev_rx,\n\t\t\t\t struct xdp_frame *xdpf)\n{\n\tstruct xdp_frame *nxdpf;\n\n\tnxdpf = xdpf_clone(xdpf);\n\tif (!nxdpf)\n\t\treturn -ENOMEM;\n\n\tbq_enqueue(obj->dev, nxdpf, dev_rx, obj->xdp_prog);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_enqueue_clone(struct bpf_dtab_netdev *obj,\n\t\t\t\t struct net_device *dev_rx,\n\t\t\t\t struct xdp_frame *xdpf)\n{\n\tstruct xdp_frame *nxdpf;\n\n\tnxdpf = xdpf_clone(xdpf);\n\tif (!nxdpf)\n\t\treturn -ENOMEM;\n\n\tbq_enqueue(obj->dev, nxdpf, dev_rx, obj->xdp_prog);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ifindex_excluded",
          "args": [
            "excluded_devices",
            "num_excluded",
            "dst->dev->ifindex"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "is_ifindex_excluded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "559-566",
          "snippet": "static inline bool is_ifindex_excluded(int *excluded, int num_excluded, int ifindex)\n{\n\twhile (num_excluded--) {\n\t\tif (ifindex == excluded[num_excluded])\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline bool is_ifindex_excluded(int *excluded, int num_excluded, int ifindex)\n{\n\twhile (num_excluded--) {\n\t\tif (ifindex == excluded[num_excluded])\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_valid_dst",
          "args": [
            "dst",
            "xdpf"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "is_valid_dst",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "532-542",
          "snippet": "static bool is_valid_dst(struct bpf_dtab_netdev *obj, struct xdp_frame *xdpf)\n{\n\tif (!obj ||\n\t    !obj->dev->netdev_ops->ndo_xdp_xmit)\n\t\treturn false;\n\n\tif (xdp_ok_fwd_dev(obj->dev, xdpf->len))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic bool is_valid_dst(struct bpf_dtab_netdev *obj, struct xdp_frame *xdpf)\n{\n\tif (!obj ||\n\t    !obj->dev->netdev_ops->ndo_xdp_xmit)\n\t\treturn false;\n\n\tif (xdp_ok_fwd_dev(obj->dev, xdpf->len))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "dst",
            "head",
            "index_hlist",
            "lockdep_is_held(&dtab->index_lock)"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&dtab->index_lock"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_map_index_hash",
          "args": [
            "dtab",
            "i"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_index_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "104-108",
          "snippet": "static inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "dtab->netdev_map[i]",
            "rcu_read_lock_bh_held()"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_bh_held",
          "args": [],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "330-337",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_upper_ifindexes",
          "args": [
            "dev_rx",
            "excluded_devices"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "get_upper_ifindexes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "572-582",
          "snippet": "static int get_upper_ifindexes(struct net_device *dev, int *indexes)\n{\n\tstruct net_device *upper;\n\tstruct list_head *iter;\n\tint n = 0;\n\n\tnetdev_for_each_upper_dev_rcu(dev, upper, iter) {\n\t\tindexes[n++] = upper->ifindex;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int get_upper_ifindexes(struct net_device *dev, int *indexes)\n{\n\tstruct net_device *upper;\n\tstruct list_head *iter;\n\tint n = 0;\n\n\tnetdev_for_each_upper_dev_rcu(dev, upper, iter) {\n\t\tindexes[n++] = upper->ifindex;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_dtab",
            "map"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nint dev_map_enqueue_multi(struct xdp_frame *xdpf, struct net_device *dev_rx,\n\t\t\t  struct bpf_map *map, bool exclude_ingress)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *dst, *last_dst = NULL;\n\tint excluded_devices[1+MAX_NEST_DEV];\n\tstruct hlist_head *head;\n\tint num_excluded = 0;\n\tunsigned int i;\n\tint err;\n\n\tif (exclude_ingress) {\n\t\tnum_excluded = get_upper_ifindexes(dev_rx, excluded_devices);\n\t\texcluded_devices[num_excluded++] = dev_rx->ifindex;\n\t}\n\n\tif (map->map_type == BPF_MAP_TYPE_DEVMAP) {\n\t\tfor (i = 0; i < map->max_entries; i++) {\n\t\t\tdst = rcu_dereference_check(dtab->netdev_map[i],\n\t\t\t\t\t\t    rcu_read_lock_bh_held());\n\t\t\tif (!is_valid_dst(dst, xdpf))\n\t\t\t\tcontinue;\n\n\t\t\tif (is_ifindex_excluded(excluded_devices, num_excluded, dst->dev->ifindex))\n\t\t\t\tcontinue;\n\n\t\t\t/* we only need n-1 clones; last_dst enqueued below */\n\t\t\tif (!last_dst) {\n\t\t\t\tlast_dst = dst;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = dev_map_enqueue_clone(last_dst, dev_rx, xdpf);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tlast_dst = dst;\n\t\t}\n\t} else { /* BPF_MAP_TYPE_DEVMAP_HASH */\n\t\tfor (i = 0; i < dtab->n_buckets; i++) {\n\t\t\thead = dev_map_index_hash(dtab, i);\n\t\t\thlist_for_each_entry_rcu(dst, head, index_hlist,\n\t\t\t\t\t\t lockdep_is_held(&dtab->index_lock)) {\n\t\t\t\tif (!is_valid_dst(dst, xdpf))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (is_ifindex_excluded(excluded_devices, num_excluded,\n\t\t\t\t\t\t\tdst->dev->ifindex))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* we only need n-1 clones; last_dst enqueued below */\n\t\t\t\tif (!last_dst) {\n\t\t\t\t\tlast_dst = dst;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\terr = dev_map_enqueue_clone(last_dst, dev_rx, xdpf);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlast_dst = dst;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* consume the last copy of the frame */\n\tif (last_dst)\n\t\tbq_enqueue(last_dst->dev, xdpf, dev_rx, last_dst->xdp_prog);\n\telse\n\t\txdp_return_frame_rx_napi(xdpf); /* dtab is empty */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_upper_ifindexes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "572-582",
    "snippet": "static int get_upper_ifindexes(struct net_device *dev, int *indexes)\n{\n\tstruct net_device *upper;\n\tstruct list_head *iter;\n\tint n = 0;\n\n\tnetdev_for_each_upper_dev_rcu(dev, upper, iter) {\n\t\tindexes[n++] = upper->ifindex;\n\t}\n\treturn n;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netdev_for_each_upper_dev_rcu",
          "args": [
            "dev",
            "upper",
            "iter"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int get_upper_ifindexes(struct net_device *dev, int *indexes)\n{\n\tstruct net_device *upper;\n\tstruct list_head *iter;\n\tint n = 0;\n\n\tnetdev_for_each_upper_dev_rcu(dev, upper, iter) {\n\t\tindexes[n++] = upper->ifindex;\n\t}\n\treturn n;\n}"
  },
  {
    "function_name": "is_ifindex_excluded",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "559-566",
    "snippet": "static inline bool is_ifindex_excluded(int *excluded, int num_excluded, int ifindex)\n{\n\twhile (num_excluded--) {\n\t\tif (ifindex == excluded[num_excluded])\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline bool is_ifindex_excluded(int *excluded, int num_excluded, int ifindex)\n{\n\twhile (num_excluded--) {\n\t\tif (ifindex == excluded[num_excluded])\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "dev_map_enqueue_clone",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "544-557",
    "snippet": "static int dev_map_enqueue_clone(struct bpf_dtab_netdev *obj,\n\t\t\t\t struct net_device *dev_rx,\n\t\t\t\t struct xdp_frame *xdpf)\n{\n\tstruct xdp_frame *nxdpf;\n\n\tnxdpf = xdpf_clone(xdpf);\n\tif (!nxdpf)\n\t\treturn -ENOMEM;\n\n\tbq_enqueue(obj->dev, nxdpf, dev_rx, obj->xdp_prog);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bq_enqueue",
          "args": [
            "obj->dev",
            "nxdpf",
            "dev_rx",
            "obj->xdp_prog"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "bq_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "445-468",
          "snippet": "static void bq_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t       struct net_device *dev_rx, struct bpf_prog *xdp_prog)\n{\n\tstruct list_head *flush_list = this_cpu_ptr(&dev_flush_list);\n\tstruct xdp_dev_bulk_queue *bq = this_cpu_ptr(dev->xdp_bulkq);\n\n\tif (unlikely(bq->count == DEV_MAP_BULK_SIZE))\n\t\tbq_xmit_all(bq, 0);\n\n\t/* Ingress dev_rx will be the same for all xdp_frame's in\n\t * bulk_queue, because bq stored per-CPU and must be flushed\n\t * from net_device drivers NAPI func end.\n\t *\n\t * Do the same with xdp_prog and flush_list since these fields\n\t * are only ever modified together.\n\t */\n\tif (!bq->dev_rx) {\n\t\tbq->dev_rx = dev_rx;\n\t\tbq->xdp_prog = xdp_prog;\n\t\tlist_add(&bq->flush_node, flush_list);\n\t}\n\n\tbq->q[bq->count++] = xdpf;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct list_head, dev_flush_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct list_head, dev_flush_list);\n\nstatic void bq_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t       struct net_device *dev_rx, struct bpf_prog *xdp_prog)\n{\n\tstruct list_head *flush_list = this_cpu_ptr(&dev_flush_list);\n\tstruct xdp_dev_bulk_queue *bq = this_cpu_ptr(dev->xdp_bulkq);\n\n\tif (unlikely(bq->count == DEV_MAP_BULK_SIZE))\n\t\tbq_xmit_all(bq, 0);\n\n\t/* Ingress dev_rx will be the same for all xdp_frame's in\n\t * bulk_queue, because bq stored per-CPU and must be flushed\n\t * from net_device drivers NAPI func end.\n\t *\n\t * Do the same with xdp_prog and flush_list since these fields\n\t * are only ever modified together.\n\t */\n\tif (!bq->dev_rx) {\n\t\tbq->dev_rx = dev_rx;\n\t\tbq->xdp_prog = xdp_prog;\n\t\tlist_add(&bq->flush_node, flush_list);\n\t}\n\n\tbq->q[bq->count++] = xdpf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdpf_clone",
          "args": [
            "xdpf"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_enqueue_clone(struct bpf_dtab_netdev *obj,\n\t\t\t\t struct net_device *dev_rx,\n\t\t\t\t struct xdp_frame *xdpf)\n{\n\tstruct xdp_frame *nxdpf;\n\n\tnxdpf = xdpf_clone(xdpf);\n\tif (!nxdpf)\n\t\treturn -ENOMEM;\n\n\tbq_enqueue(obj->dev, nxdpf, dev_rx, obj->xdp_prog);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_valid_dst",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "532-542",
    "snippet": "static bool is_valid_dst(struct bpf_dtab_netdev *obj, struct xdp_frame *xdpf)\n{\n\tif (!obj ||\n\t    !obj->dev->netdev_ops->ndo_xdp_xmit)\n\t\treturn false;\n\n\tif (xdp_ok_fwd_dev(obj->dev, xdpf->len))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdp_ok_fwd_dev",
          "args": [
            "obj->dev",
            "xdpf->len"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic bool is_valid_dst(struct bpf_dtab_netdev *obj, struct xdp_frame *xdpf)\n{\n\tif (!obj ||\n\t    !obj->dev->netdev_ops->ndo_xdp_xmit)\n\t\treturn false;\n\n\tif (xdp_ok_fwd_dev(obj->dev, xdpf->len))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "dev_map_enqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "524-530",
    "snippet": "int dev_map_enqueue(struct bpf_dtab_netdev *dst, struct xdp_frame *xdpf,\n\t\t    struct net_device *dev_rx)\n{\n\tstruct net_device *dev = dst->dev;\n\n\treturn __xdp_enqueue(dev, xdpf, dev_rx, dst->xdp_prog);\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xdp_enqueue",
          "args": [
            "dev",
            "xdpf",
            "dev_rx",
            "dst->xdp_prog"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "__xdp_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "470-485",
          "snippet": "static inline int __xdp_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t\t\tstruct net_device *dev_rx,\n\t\t\t\tstruct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\tif (!dev->netdev_ops->ndo_xdp_xmit)\n\t\treturn -EOPNOTSUPP;\n\n\terr = xdp_ok_fwd_dev(dev, xdpf->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tbq_enqueue(dev, xdpf, dev_rx, xdp_prog);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline int __xdp_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t\t\tstruct net_device *dev_rx,\n\t\t\t\tstruct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\tif (!dev->netdev_ops->ndo_xdp_xmit)\n\t\treturn -EOPNOTSUPP;\n\n\terr = xdp_ok_fwd_dev(dev, xdpf->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tbq_enqueue(dev, xdpf, dev_rx, xdp_prog);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nint dev_map_enqueue(struct bpf_dtab_netdev *dst, struct xdp_frame *xdpf,\n\t\t    struct net_device *dev_rx)\n{\n\tstruct net_device *dev = dst->dev;\n\n\treturn __xdp_enqueue(dev, xdpf, dev_rx, dst->xdp_prog);\n}"
  },
  {
    "function_name": "dev_xdp_enqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "518-522",
    "snippet": "int dev_xdp_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t    struct net_device *dev_rx)\n{\n\treturn __xdp_enqueue(dev, xdpf, dev_rx, NULL);\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xdp_enqueue",
          "args": [
            "dev",
            "xdpf",
            "dev_rx",
            "NULL"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "__xdp_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "470-485",
          "snippet": "static inline int __xdp_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t\t\tstruct net_device *dev_rx,\n\t\t\t\tstruct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\tif (!dev->netdev_ops->ndo_xdp_xmit)\n\t\treturn -EOPNOTSUPP;\n\n\terr = xdp_ok_fwd_dev(dev, xdpf->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tbq_enqueue(dev, xdpf, dev_rx, xdp_prog);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline int __xdp_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t\t\tstruct net_device *dev_rx,\n\t\t\t\tstruct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\tif (!dev->netdev_ops->ndo_xdp_xmit)\n\t\treturn -EOPNOTSUPP;\n\n\terr = xdp_ok_fwd_dev(dev, xdpf->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tbq_enqueue(dev, xdpf, dev_rx, xdp_prog);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nint dev_xdp_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t    struct net_device *dev_rx)\n{\n\treturn __xdp_enqueue(dev, xdpf, dev_rx, NULL);\n}"
  },
  {
    "function_name": "dev_map_bpf_prog_run_skb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "487-516",
    "snippet": "static u32 dev_map_bpf_prog_run_skb(struct sk_buff *skb, struct bpf_dtab_netdev *dst)\n{\n\tstruct xdp_txq_info txq = { .dev = dst->dev };\n\tstruct xdp_buff xdp;\n\tu32 act;\n\n\tif (!dst->xdp_prog)\n\t\treturn XDP_PASS;\n\n\t__skb_pull(skb, skb->mac_len);\n\txdp.txq = &txq;\n\n\tact = bpf_prog_run_generic_xdp(skb, &xdp, dst->xdp_prog);\n\tswitch (act) {\n\tcase XDP_PASS:\n\t\t__skb_push(skb, skb->mac_len);\n\t\tbreak;\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(NULL, dst->xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(dst->dev, dst->xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_DROP:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\treturn act;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "skb"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xdp_exception",
          "args": [
            "dst->dev",
            "dst->xdp_prog",
            "act"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_warn_invalid_xdp_action",
          "args": [
            "NULL",
            "dst->xdp_prog",
            "act"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__skb_push",
          "args": [
            "skb",
            "skb->mac_len"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_run_generic_xdp",
          "args": [
            "skb",
            "&xdp",
            "dst->xdp_prog"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__skb_pull",
          "args": [
            "skb",
            "skb->mac_len"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic u32 dev_map_bpf_prog_run_skb(struct sk_buff *skb, struct bpf_dtab_netdev *dst)\n{\n\tstruct xdp_txq_info txq = { .dev = dst->dev };\n\tstruct xdp_buff xdp;\n\tu32 act;\n\n\tif (!dst->xdp_prog)\n\t\treturn XDP_PASS;\n\n\t__skb_pull(skb, skb->mac_len);\n\txdp.txq = &txq;\n\n\tact = bpf_prog_run_generic_xdp(skb, &xdp, dst->xdp_prog);\n\tswitch (act) {\n\tcase XDP_PASS:\n\t\t__skb_push(skb, skb->mac_len);\n\t\tbreak;\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(NULL, dst->xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(dst->dev, dst->xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_DROP:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\treturn act;\n}"
  },
  {
    "function_name": "__xdp_enqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "470-485",
    "snippet": "static inline int __xdp_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t\t\tstruct net_device *dev_rx,\n\t\t\t\tstruct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\tif (!dev->netdev_ops->ndo_xdp_xmit)\n\t\treturn -EOPNOTSUPP;\n\n\terr = xdp_ok_fwd_dev(dev, xdpf->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tbq_enqueue(dev, xdpf, dev_rx, xdp_prog);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bq_enqueue",
          "args": [
            "dev",
            "xdpf",
            "dev_rx",
            "xdp_prog"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "bq_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "445-468",
          "snippet": "static void bq_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t       struct net_device *dev_rx, struct bpf_prog *xdp_prog)\n{\n\tstruct list_head *flush_list = this_cpu_ptr(&dev_flush_list);\n\tstruct xdp_dev_bulk_queue *bq = this_cpu_ptr(dev->xdp_bulkq);\n\n\tif (unlikely(bq->count == DEV_MAP_BULK_SIZE))\n\t\tbq_xmit_all(bq, 0);\n\n\t/* Ingress dev_rx will be the same for all xdp_frame's in\n\t * bulk_queue, because bq stored per-CPU and must be flushed\n\t * from net_device drivers NAPI func end.\n\t *\n\t * Do the same with xdp_prog and flush_list since these fields\n\t * are only ever modified together.\n\t */\n\tif (!bq->dev_rx) {\n\t\tbq->dev_rx = dev_rx;\n\t\tbq->xdp_prog = xdp_prog;\n\t\tlist_add(&bq->flush_node, flush_list);\n\t}\n\n\tbq->q[bq->count++] = xdpf;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct list_head, dev_flush_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct list_head, dev_flush_list);\n\nstatic void bq_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t       struct net_device *dev_rx, struct bpf_prog *xdp_prog)\n{\n\tstruct list_head *flush_list = this_cpu_ptr(&dev_flush_list);\n\tstruct xdp_dev_bulk_queue *bq = this_cpu_ptr(dev->xdp_bulkq);\n\n\tif (unlikely(bq->count == DEV_MAP_BULK_SIZE))\n\t\tbq_xmit_all(bq, 0);\n\n\t/* Ingress dev_rx will be the same for all xdp_frame's in\n\t * bulk_queue, because bq stored per-CPU and must be flushed\n\t * from net_device drivers NAPI func end.\n\t *\n\t * Do the same with xdp_prog and flush_list since these fields\n\t * are only ever modified together.\n\t */\n\tif (!bq->dev_rx) {\n\t\tbq->dev_rx = dev_rx;\n\t\tbq->xdp_prog = xdp_prog;\n\t\tlist_add(&bq->flush_node, flush_list);\n\t}\n\n\tbq->q[bq->count++] = xdpf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdp_ok_fwd_dev",
          "args": [
            "dev",
            "xdpf->len"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline int __xdp_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t\t\tstruct net_device *dev_rx,\n\t\t\t\tstruct bpf_prog *xdp_prog)\n{\n\tint err;\n\n\tif (!dev->netdev_ops->ndo_xdp_xmit)\n\t\treturn -EOPNOTSUPP;\n\n\terr = xdp_ok_fwd_dev(dev, xdpf->len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tbq_enqueue(dev, xdpf, dev_rx, xdp_prog);\n\treturn 0;\n}"
  },
  {
    "function_name": "bq_enqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "445-468",
    "snippet": "static void bq_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t       struct net_device *dev_rx, struct bpf_prog *xdp_prog)\n{\n\tstruct list_head *flush_list = this_cpu_ptr(&dev_flush_list);\n\tstruct xdp_dev_bulk_queue *bq = this_cpu_ptr(dev->xdp_bulkq);\n\n\tif (unlikely(bq->count == DEV_MAP_BULK_SIZE))\n\t\tbq_xmit_all(bq, 0);\n\n\t/* Ingress dev_rx will be the same for all xdp_frame's in\n\t * bulk_queue, because bq stored per-CPU and must be flushed\n\t * from net_device drivers NAPI func end.\n\t *\n\t * Do the same with xdp_prog and flush_list since these fields\n\t * are only ever modified together.\n\t */\n\tif (!bq->dev_rx) {\n\t\tbq->dev_rx = dev_rx;\n\t\tbq->xdp_prog = xdp_prog;\n\t\tlist_add(&bq->flush_node, flush_list);\n\t}\n\n\tbq->q[bq->count++] = xdpf;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct list_head, dev_flush_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&bq->flush_node",
            "flush_list"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bq_xmit_all",
          "args": [
            "bq",
            "0"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "bq_xmit_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "364-405",
          "snippet": "static void bq_xmit_all(struct xdp_dev_bulk_queue *bq, u32 flags)\n{\n\tstruct net_device *dev = bq->dev;\n\tunsigned int cnt = bq->count;\n\tint sent = 0, err = 0;\n\tint to_send = cnt;\n\tint i;\n\n\tif (unlikely(!cnt))\n\t\treturn;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct xdp_frame *xdpf = bq->q[i];\n\n\t\tprefetch(xdpf);\n\t}\n\n\tif (bq->xdp_prog) {\n\t\tto_send = dev_map_bpf_prog_run(bq->xdp_prog, bq->q, cnt, dev);\n\t\tif (!to_send)\n\t\t\tgoto out;\n\t}\n\n\tsent = dev->netdev_ops->ndo_xdp_xmit(dev, to_send, bq->q, flags);\n\tif (sent < 0) {\n\t\t/* If ndo_xdp_xmit fails with an errno, no frames have\n\t\t * been xmit'ed.\n\t\t */\n\t\terr = sent;\n\t\tsent = 0;\n\t}\n\n\t/* If not all frames have been transmitted, it is our\n\t * responsibility to free them\n\t */\n\tfor (i = sent; unlikely(i < to_send); i++)\n\t\txdp_return_frame_rx_napi(bq->q[i]);\n\nout:\n\tbq->count = 0;\n\ttrace_xdp_devmap_xmit(bq->dev_rx, dev, sent, cnt - sent, err);\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void bq_xmit_all(struct xdp_dev_bulk_queue *bq, u32 flags)\n{\n\tstruct net_device *dev = bq->dev;\n\tunsigned int cnt = bq->count;\n\tint sent = 0, err = 0;\n\tint to_send = cnt;\n\tint i;\n\n\tif (unlikely(!cnt))\n\t\treturn;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct xdp_frame *xdpf = bq->q[i];\n\n\t\tprefetch(xdpf);\n\t}\n\n\tif (bq->xdp_prog) {\n\t\tto_send = dev_map_bpf_prog_run(bq->xdp_prog, bq->q, cnt, dev);\n\t\tif (!to_send)\n\t\t\tgoto out;\n\t}\n\n\tsent = dev->netdev_ops->ndo_xdp_xmit(dev, to_send, bq->q, flags);\n\tif (sent < 0) {\n\t\t/* If ndo_xdp_xmit fails with an errno, no frames have\n\t\t * been xmit'ed.\n\t\t */\n\t\terr = sent;\n\t\tsent = 0;\n\t}\n\n\t/* If not all frames have been transmitted, it is our\n\t * responsibility to free them\n\t */\n\tfor (i = sent; unlikely(i < to_send); i++)\n\t\txdp_return_frame_rx_napi(bq->q[i]);\n\nout:\n\tbq->count = 0;\n\ttrace_xdp_devmap_xmit(bq->dev_rx, dev, sent, cnt - sent, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bq->count == DEV_MAP_BULK_SIZE"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "dev->xdp_bulkq"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&dev_flush_list"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct list_head, dev_flush_list);\n\nstatic void bq_enqueue(struct net_device *dev, struct xdp_frame *xdpf,\n\t\t       struct net_device *dev_rx, struct bpf_prog *xdp_prog)\n{\n\tstruct list_head *flush_list = this_cpu_ptr(&dev_flush_list);\n\tstruct xdp_dev_bulk_queue *bq = this_cpu_ptr(dev->xdp_bulkq);\n\n\tif (unlikely(bq->count == DEV_MAP_BULK_SIZE))\n\t\tbq_xmit_all(bq, 0);\n\n\t/* Ingress dev_rx will be the same for all xdp_frame's in\n\t * bulk_queue, because bq stored per-CPU and must be flushed\n\t * from net_device drivers NAPI func end.\n\t *\n\t * Do the same with xdp_prog and flush_list since these fields\n\t * are only ever modified together.\n\t */\n\tif (!bq->dev_rx) {\n\t\tbq->dev_rx = dev_rx;\n\t\tbq->xdp_prog = xdp_prog;\n\t\tlist_add(&bq->flush_node, flush_list);\n\t}\n\n\tbq->q[bq->count++] = xdpf;\n}"
  },
  {
    "function_name": "__dev_map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "428-439",
    "snippet": "static void *__dev_map_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *obj;\n\n\tif (key >= map->max_entries)\n\t\treturn NULL;\n\n\tobj = rcu_dereference_check(dtab->netdev_map[key],\n\t\t\t\t    rcu_read_lock_bh_held());\n\treturn obj;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "dtab->netdev_map[key]",
            "rcu_read_lock_bh_held()"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_bh_held",
          "args": [],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "330-337",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_dtab",
            "map"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void *__dev_map_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct bpf_dtab_netdev *obj;\n\n\tif (key >= map->max_entries)\n\t\treturn NULL;\n\n\tobj = rcu_dereference_check(dtab->netdev_map[key],\n\t\t\t\t    rcu_read_lock_bh_held());\n\treturn obj;\n}"
  },
  {
    "function_name": "__dev_flush",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "411-422",
    "snippet": "void __dev_flush(void)\n{\n\tstruct list_head *flush_list = this_cpu_ptr(&dev_flush_list);\n\tstruct xdp_dev_bulk_queue *bq, *tmp;\n\n\tlist_for_each_entry_safe(bq, tmp, flush_list, flush_node) {\n\t\tbq_xmit_all(bq, XDP_XMIT_FLUSH);\n\t\tbq->dev_rx = NULL;\n\t\tbq->xdp_prog = NULL;\n\t\t__list_del_clearprev(&bq->flush_node);\n\t}\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct list_head, dev_flush_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__list_del_clearprev",
          "args": [
            "&bq->flush_node"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bq_xmit_all",
          "args": [
            "bq",
            "XDP_XMIT_FLUSH"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "bq_xmit_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "364-405",
          "snippet": "static void bq_xmit_all(struct xdp_dev_bulk_queue *bq, u32 flags)\n{\n\tstruct net_device *dev = bq->dev;\n\tunsigned int cnt = bq->count;\n\tint sent = 0, err = 0;\n\tint to_send = cnt;\n\tint i;\n\n\tif (unlikely(!cnt))\n\t\treturn;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct xdp_frame *xdpf = bq->q[i];\n\n\t\tprefetch(xdpf);\n\t}\n\n\tif (bq->xdp_prog) {\n\t\tto_send = dev_map_bpf_prog_run(bq->xdp_prog, bq->q, cnt, dev);\n\t\tif (!to_send)\n\t\t\tgoto out;\n\t}\n\n\tsent = dev->netdev_ops->ndo_xdp_xmit(dev, to_send, bq->q, flags);\n\tif (sent < 0) {\n\t\t/* If ndo_xdp_xmit fails with an errno, no frames have\n\t\t * been xmit'ed.\n\t\t */\n\t\terr = sent;\n\t\tsent = 0;\n\t}\n\n\t/* If not all frames have been transmitted, it is our\n\t * responsibility to free them\n\t */\n\tfor (i = sent; unlikely(i < to_send); i++)\n\t\txdp_return_frame_rx_napi(bq->q[i]);\n\nout:\n\tbq->count = 0;\n\ttrace_xdp_devmap_xmit(bq->dev_rx, dev, sent, cnt - sent, err);\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void bq_xmit_all(struct xdp_dev_bulk_queue *bq, u32 flags)\n{\n\tstruct net_device *dev = bq->dev;\n\tunsigned int cnt = bq->count;\n\tint sent = 0, err = 0;\n\tint to_send = cnt;\n\tint i;\n\n\tif (unlikely(!cnt))\n\t\treturn;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct xdp_frame *xdpf = bq->q[i];\n\n\t\tprefetch(xdpf);\n\t}\n\n\tif (bq->xdp_prog) {\n\t\tto_send = dev_map_bpf_prog_run(bq->xdp_prog, bq->q, cnt, dev);\n\t\tif (!to_send)\n\t\t\tgoto out;\n\t}\n\n\tsent = dev->netdev_ops->ndo_xdp_xmit(dev, to_send, bq->q, flags);\n\tif (sent < 0) {\n\t\t/* If ndo_xdp_xmit fails with an errno, no frames have\n\t\t * been xmit'ed.\n\t\t */\n\t\terr = sent;\n\t\tsent = 0;\n\t}\n\n\t/* If not all frames have been transmitted, it is our\n\t * responsibility to free them\n\t */\n\tfor (i = sent; unlikely(i < to_send); i++)\n\t\txdp_return_frame_rx_napi(bq->q[i]);\n\nout:\n\tbq->count = 0;\n\ttrace_xdp_devmap_xmit(bq->dev_rx, dev, sent, cnt - sent, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "bq",
            "tmp",
            "flush_list",
            "flush_node"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&dev_flush_list"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct list_head, dev_flush_list);\n\nvoid __dev_flush(void)\n{\n\tstruct list_head *flush_list = this_cpu_ptr(&dev_flush_list);\n\tstruct xdp_dev_bulk_queue *bq, *tmp;\n\n\tlist_for_each_entry_safe(bq, tmp, flush_list, flush_node) {\n\t\tbq_xmit_all(bq, XDP_XMIT_FLUSH);\n\t\tbq->dev_rx = NULL;\n\t\tbq->xdp_prog = NULL;\n\t\t__list_del_clearprev(&bq->flush_node);\n\t}\n}"
  },
  {
    "function_name": "bq_xmit_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "364-405",
    "snippet": "static void bq_xmit_all(struct xdp_dev_bulk_queue *bq, u32 flags)\n{\n\tstruct net_device *dev = bq->dev;\n\tunsigned int cnt = bq->count;\n\tint sent = 0, err = 0;\n\tint to_send = cnt;\n\tint i;\n\n\tif (unlikely(!cnt))\n\t\treturn;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct xdp_frame *xdpf = bq->q[i];\n\n\t\tprefetch(xdpf);\n\t}\n\n\tif (bq->xdp_prog) {\n\t\tto_send = dev_map_bpf_prog_run(bq->xdp_prog, bq->q, cnt, dev);\n\t\tif (!to_send)\n\t\t\tgoto out;\n\t}\n\n\tsent = dev->netdev_ops->ndo_xdp_xmit(dev, to_send, bq->q, flags);\n\tif (sent < 0) {\n\t\t/* If ndo_xdp_xmit fails with an errno, no frames have\n\t\t * been xmit'ed.\n\t\t */\n\t\terr = sent;\n\t\tsent = 0;\n\t}\n\n\t/* If not all frames have been transmitted, it is our\n\t * responsibility to free them\n\t */\n\tfor (i = sent; unlikely(i < to_send); i++)\n\t\txdp_return_frame_rx_napi(bq->q[i]);\n\nout:\n\tbq->count = 0;\n\ttrace_xdp_devmap_xmit(bq->dev_rx, dev, sent, cnt - sent, err);\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xdp_devmap_xmit",
          "args": [
            "bq->dev_rx",
            "dev",
            "sent",
            "cnt - sent",
            "err"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdp_return_frame_rx_napi",
          "args": [
            "bq->q[i]"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "i < to_send"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev->netdev_ops->ndo_xdp_xmit",
          "args": [
            "dev",
            "to_send",
            "bq->q",
            "flags"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_map_bpf_prog_run",
          "args": [
            "bq->xdp_prog",
            "bq->q",
            "cnt",
            "dev"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_bpf_prog_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "325-362",
          "snippet": "static int dev_map_bpf_prog_run(struct bpf_prog *xdp_prog,\n\t\t\t\tstruct xdp_frame **frames, int n,\n\t\t\t\tstruct net_device *dev)\n{\n\tstruct xdp_txq_info txq = { .dev = dev };\n\tstruct xdp_buff xdp;\n\tint i, nframes = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct xdp_frame *xdpf = frames[i];\n\t\tu32 act;\n\t\tint err;\n\n\t\txdp_convert_frame_to_buff(xdpf, &xdp);\n\t\txdp.txq = &txq;\n\n\t\tact = bpf_prog_run_xdp(xdp_prog, &xdp);\n\t\tswitch (act) {\n\t\tcase XDP_PASS:\n\t\t\terr = xdp_update_frame_from_buff(&xdp, xdpf);\n\t\t\tif (unlikely(err < 0))\n\t\t\t\txdp_return_frame_rx_napi(xdpf);\n\t\t\telse\n\t\t\t\tframes[nframes++] = xdpf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbpf_warn_invalid_xdp_action(NULL, xdp_prog, act);\n\t\t\tfallthrough;\n\t\tcase XDP_ABORTED:\n\t\t\ttrace_xdp_exception(dev, xdp_prog, act);\n\t\t\tfallthrough;\n\t\tcase XDP_DROP:\n\t\t\txdp_return_frame_rx_napi(xdpf);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn nframes; /* sent frames count */\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_bpf_prog_run(struct bpf_prog *xdp_prog,\n\t\t\t\tstruct xdp_frame **frames, int n,\n\t\t\t\tstruct net_device *dev)\n{\n\tstruct xdp_txq_info txq = { .dev = dev };\n\tstruct xdp_buff xdp;\n\tint i, nframes = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct xdp_frame *xdpf = frames[i];\n\t\tu32 act;\n\t\tint err;\n\n\t\txdp_convert_frame_to_buff(xdpf, &xdp);\n\t\txdp.txq = &txq;\n\n\t\tact = bpf_prog_run_xdp(xdp_prog, &xdp);\n\t\tswitch (act) {\n\t\tcase XDP_PASS:\n\t\t\terr = xdp_update_frame_from_buff(&xdp, xdpf);\n\t\t\tif (unlikely(err < 0))\n\t\t\t\txdp_return_frame_rx_napi(xdpf);\n\t\t\telse\n\t\t\t\tframes[nframes++] = xdpf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbpf_warn_invalid_xdp_action(NULL, xdp_prog, act);\n\t\t\tfallthrough;\n\t\tcase XDP_ABORTED:\n\t\t\ttrace_xdp_exception(dev, xdp_prog, act);\n\t\t\tfallthrough;\n\t\tcase XDP_DROP:\n\t\t\txdp_return_frame_rx_napi(xdpf);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn nframes; /* sent frames count */\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefetch",
          "args": [
            "xdpf"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "prefetch_curr_exec_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5132-5141",
          "snippet": "static inline void prefetch_curr_exec_start(struct task_struct *p)\n{\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tstruct sched_entity *curr = (&p->se)->cfs_rq->curr;\n#else\n\tstruct sched_entity *curr = (&task_rq(p)->cfs)->curr;\n#endif\n\tprefetch(curr);\n\tprefetch(&curr->exec_start);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void prefetch_curr_exec_start(struct task_struct *p)\n{\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tstruct sched_entity *curr = (&p->se)->cfs_rq->curr;\n#else\n\tstruct sched_entity *curr = (&task_rq(p)->cfs)->curr;\n#endif\n\tprefetch(curr);\n\tprefetch(&curr->exec_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cnt"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void bq_xmit_all(struct xdp_dev_bulk_queue *bq, u32 flags)\n{\n\tstruct net_device *dev = bq->dev;\n\tunsigned int cnt = bq->count;\n\tint sent = 0, err = 0;\n\tint to_send = cnt;\n\tint i;\n\n\tif (unlikely(!cnt))\n\t\treturn;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct xdp_frame *xdpf = bq->q[i];\n\n\t\tprefetch(xdpf);\n\t}\n\n\tif (bq->xdp_prog) {\n\t\tto_send = dev_map_bpf_prog_run(bq->xdp_prog, bq->q, cnt, dev);\n\t\tif (!to_send)\n\t\t\tgoto out;\n\t}\n\n\tsent = dev->netdev_ops->ndo_xdp_xmit(dev, to_send, bq->q, flags);\n\tif (sent < 0) {\n\t\t/* If ndo_xdp_xmit fails with an errno, no frames have\n\t\t * been xmit'ed.\n\t\t */\n\t\terr = sent;\n\t\tsent = 0;\n\t}\n\n\t/* If not all frames have been transmitted, it is our\n\t * responsibility to free them\n\t */\n\tfor (i = sent; unlikely(i < to_send); i++)\n\t\txdp_return_frame_rx_napi(bq->q[i]);\n\nout:\n\tbq->count = 0;\n\ttrace_xdp_devmap_xmit(bq->dev_rx, dev, sent, cnt - sent, err);\n}"
  },
  {
    "function_name": "dev_map_bpf_prog_run",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "325-362",
    "snippet": "static int dev_map_bpf_prog_run(struct bpf_prog *xdp_prog,\n\t\t\t\tstruct xdp_frame **frames, int n,\n\t\t\t\tstruct net_device *dev)\n{\n\tstruct xdp_txq_info txq = { .dev = dev };\n\tstruct xdp_buff xdp;\n\tint i, nframes = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct xdp_frame *xdpf = frames[i];\n\t\tu32 act;\n\t\tint err;\n\n\t\txdp_convert_frame_to_buff(xdpf, &xdp);\n\t\txdp.txq = &txq;\n\n\t\tact = bpf_prog_run_xdp(xdp_prog, &xdp);\n\t\tswitch (act) {\n\t\tcase XDP_PASS:\n\t\t\terr = xdp_update_frame_from_buff(&xdp, xdpf);\n\t\t\tif (unlikely(err < 0))\n\t\t\t\txdp_return_frame_rx_napi(xdpf);\n\t\t\telse\n\t\t\t\tframes[nframes++] = xdpf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbpf_warn_invalid_xdp_action(NULL, xdp_prog, act);\n\t\t\tfallthrough;\n\t\tcase XDP_ABORTED:\n\t\t\ttrace_xdp_exception(dev, xdp_prog, act);\n\t\t\tfallthrough;\n\t\tcase XDP_DROP:\n\t\t\txdp_return_frame_rx_napi(xdpf);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn nframes; /* sent frames count */\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdp_return_frame_rx_napi",
          "args": [
            "xdpf"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xdp_exception",
          "args": [
            "dev",
            "xdp_prog",
            "act"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_warn_invalid_xdp_action",
          "args": [
            "NULL",
            "xdp_prog",
            "act"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdp_return_frame_rx_napi",
          "args": [
            "xdpf"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdp_update_frame_from_buff",
          "args": [
            "&xdp",
            "xdpf"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_run_xdp",
          "args": [
            "xdp_prog",
            "&xdp"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdp_convert_frame_to_buff",
          "args": [
            "xdpf",
            "&xdp"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_bpf_prog_run(struct bpf_prog *xdp_prog,\n\t\t\t\tstruct xdp_frame **frames, int n,\n\t\t\t\tstruct net_device *dev)\n{\n\tstruct xdp_txq_info txq = { .dev = dev };\n\tstruct xdp_buff xdp;\n\tint i, nframes = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct xdp_frame *xdpf = frames[i];\n\t\tu32 act;\n\t\tint err;\n\n\t\txdp_convert_frame_to_buff(xdpf, &xdp);\n\t\txdp.txq = &txq;\n\n\t\tact = bpf_prog_run_xdp(xdp_prog, &xdp);\n\t\tswitch (act) {\n\t\tcase XDP_PASS:\n\t\t\terr = xdp_update_frame_from_buff(&xdp, xdpf);\n\t\t\tif (unlikely(err < 0))\n\t\t\t\txdp_return_frame_rx_napi(xdpf);\n\t\t\telse\n\t\t\t\tframes[nframes++] = xdpf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbpf_warn_invalid_xdp_action(NULL, xdp_prog, act);\n\t\t\tfallthrough;\n\t\tcase XDP_ABORTED:\n\t\t\ttrace_xdp_exception(dev, xdp_prog, act);\n\t\t\tfallthrough;\n\t\tcase XDP_DROP:\n\t\t\txdp_return_frame_rx_napi(xdpf);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn nframes; /* sent frames count */\n}"
  },
  {
    "function_name": "dev_map_hash_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "280-323",
    "snippet": "static int dev_map_hash_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t    void *next_key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tu32 idx, *next = next_key;\n\tstruct bpf_dtab_netdev *dev, *next_dev;\n\tstruct hlist_head *head;\n\tint i = 0;\n\n\tif (!key)\n\t\tgoto find_first;\n\n\tidx = *(u32 *)key;\n\n\tdev = __dev_map_hash_lookup_elem(map, idx);\n\tif (!dev)\n\t\tgoto find_first;\n\n\tnext_dev = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(&dev->index_hlist)),\n\t\t\t\t    struct bpf_dtab_netdev, index_hlist);\n\n\tif (next_dev) {\n\t\t*next = next_dev->idx;\n\t\treturn 0;\n\t}\n\n\ti = idx & (dtab->n_buckets - 1);\n\ti++;\n\n find_first:\n\tfor (; i < dtab->n_buckets; i++) {\n\t\thead = dev_map_index_hash(dtab, i);\n\n\t\tnext_dev = hlist_entry_safe(rcu_dereference_raw(hlist_first_rcu(head)),\n\t\t\t\t\t    struct bpf_dtab_netdev,\n\t\t\t\t\t    index_hlist);\n\t\tif (next_dev) {\n\t\t\t*next = next_dev->idx;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_entry_safe",
          "args": [
            "rcu_dereference_raw(hlist_first_rcu(head))",
            "structbpf_dtab_netdev",
            "index_hlist"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "hlist_first_rcu(head)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_first_rcu",
          "args": [
            "head"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_map_index_hash",
          "args": [
            "dtab",
            "i"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_index_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "104-108",
          "snippet": "static inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry_safe",
          "args": [
            "rcu_dereference_raw(hlist_next_rcu(&dev->index_hlist))",
            "structbpf_dtab_netdev",
            "index_hlist"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "hlist_next_rcu(&dev->index_hlist)"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_next_rcu",
          "args": [
            "&dev->index_hlist"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dev_map_hash_lookup_elem",
          "args": [
            "map",
            "idx"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "__dev_map_hash_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "266-278",
          "snippet": "static void *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct hlist_head *head = dev_map_index_hash(dtab, key);\n\tstruct bpf_dtab_netdev *dev;\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist,\n\t\t\t\t lockdep_is_held(&dtab->index_lock))\n\t\tif (dev->idx == key)\n\t\t\treturn dev;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct hlist_head *head = dev_map_index_hash(dtab, key);\n\tstruct bpf_dtab_netdev *dev;\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist,\n\t\t\t\t lockdep_is_held(&dtab->index_lock))\n\t\tif (dev->idx == key)\n\t\t\treturn dev;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_dtab",
            "map"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_hash_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t    void *next_key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tu32 idx, *next = next_key;\n\tstruct bpf_dtab_netdev *dev, *next_dev;\n\tstruct hlist_head *head;\n\tint i = 0;\n\n\tif (!key)\n\t\tgoto find_first;\n\n\tidx = *(u32 *)key;\n\n\tdev = __dev_map_hash_lookup_elem(map, idx);\n\tif (!dev)\n\t\tgoto find_first;\n\n\tnext_dev = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(&dev->index_hlist)),\n\t\t\t\t    struct bpf_dtab_netdev, index_hlist);\n\n\tif (next_dev) {\n\t\t*next = next_dev->idx;\n\t\treturn 0;\n\t}\n\n\ti = idx & (dtab->n_buckets - 1);\n\ti++;\n\n find_first:\n\tfor (; i < dtab->n_buckets; i++) {\n\t\thead = dev_map_index_hash(dtab, i);\n\n\t\tnext_dev = hlist_entry_safe(rcu_dereference_raw(hlist_first_rcu(head)),\n\t\t\t\t\t    struct bpf_dtab_netdev,\n\t\t\t\t\t    index_hlist);\n\t\tif (next_dev) {\n\t\t\t*next = next_dev->idx;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "__dev_map_hash_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "266-278",
    "snippet": "static void *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct hlist_head *head = dev_map_index_hash(dtab, key);\n\tstruct bpf_dtab_netdev *dev;\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist,\n\t\t\t\t lockdep_is_held(&dtab->index_lock))\n\t\tif (dev->idx == key)\n\t\t\treturn dev;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "dev",
            "head",
            "index_hlist",
            "lockdep_is_held(&dtab->index_lock)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&dtab->index_lock"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_map_index_hash",
          "args": [
            "dtab",
            "key"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_index_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "104-108",
          "snippet": "static inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_dtab",
            "map"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic void *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tstruct hlist_head *head = dev_map_index_hash(dtab, key);\n\tstruct bpf_dtab_netdev *dev;\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist,\n\t\t\t\t lockdep_is_held(&dtab->index_lock))\n\t\tif (dev->idx == key)\n\t\t\treturn dev;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "dev_map_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "245-260",
    "snippet": "static int dev_map_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tu32 index = key ? *(u32 *)key : U32_MAX;\n\tu32 *next = next_key;\n\n\tif (index >= dtab->map.max_entries) {\n\t\t*next = 0;\n\t\treturn 0;\n\t}\n\n\tif (index == dtab->map.max_entries - 1)\n\t\treturn -ENOENT;\n\t*next = index + 1;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_dtab",
            "map"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic int dev_map_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tu32 index = key ? *(u32 *)key : U32_MAX;\n\tu32 *next = next_key;\n\n\tif (index >= dtab->map.max_entries) {\n\t\t*next = 0;\n\t\treturn 0;\n\t}\n\n\tif (index == dtab->map.max_entries - 1)\n\t\treturn -ENOENT;\n\t*next = index + 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "dev_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "182-243",
    "snippet": "static void dev_map_free(struct bpf_map *map)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tint i;\n\n\t/* At this point bpf_prog->aux->refcnt == 0 and this map->refcnt == 0,\n\t * so the programs (can be more than one that used this map) were\n\t * disconnected from events. The following synchronize_rcu() guarantees\n\t * both rcu read critical sections complete and waits for\n\t * preempt-disable regions (NAPI being the relevant context here) so we\n\t * are certain there will be no further reads against the netdev_map and\n\t * all flush operations are complete. Flush operations can only be done\n\t * from NAPI context for this reason.\n\t */\n\n\tspin_lock(&dev_map_lock);\n\tlist_del_rcu(&dtab->list);\n\tspin_unlock(&dev_map_lock);\n\n\tbpf_clear_redirect_map(map);\n\tsynchronize_rcu();\n\n\t/* Make sure prior __dev_map_entry_free() have completed. */\n\trcu_barrier();\n\n\tif (dtab->map.map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\tfor (i = 0; i < dtab->n_buckets; i++) {\n\t\t\tstruct bpf_dtab_netdev *dev;\n\t\t\tstruct hlist_head *head;\n\t\t\tstruct hlist_node *next;\n\n\t\t\thead = dev_map_index_hash(dtab, i);\n\n\t\t\thlist_for_each_entry_safe(dev, next, head, index_hlist) {\n\t\t\t\thlist_del_rcu(&dev->index_hlist);\n\t\t\t\tif (dev->xdp_prog)\n\t\t\t\t\tbpf_prog_put(dev->xdp_prog);\n\t\t\t\tdev_put(dev->dev);\n\t\t\t\tkfree(dev);\n\t\t\t}\n\t\t}\n\n\t\tbpf_map_area_free(dtab->dev_index_head);\n\t} else {\n\t\tfor (i = 0; i < dtab->map.max_entries; i++) {\n\t\t\tstruct bpf_dtab_netdev *dev;\n\n\t\t\tdev = rcu_dereference_raw(dtab->netdev_map[i]);\n\t\t\tif (!dev)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev->xdp_prog)\n\t\t\t\tbpf_prog_put(dev->xdp_prog);\n\t\t\tdev_put(dev->dev);\n\t\t\tkfree(dev);\n\t\t}\n\n\t\tbpf_map_area_free(dtab->netdev_map);\n\t}\n\n\tkfree(dtab);\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(dev_map_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dtab"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "dtab->netdev_map"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "344-347",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_put",
          "args": [
            "dev->dev"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "dev->xdp_prog"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "dtab->netdev_map[i]"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_put",
          "args": [
            "dev->dev"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&dev->index_hlist"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "dev",
            "next",
            "head",
            "index_hlist"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_map_index_hash",
          "args": [
            "dtab",
            "i"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_index_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "104-108",
          "snippet": "static inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1569-1572",
          "snippet": "void rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_clear_redirect_map",
          "args": [
            "map"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dev_map_lock"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&dtab->list"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dev_map_lock"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_dtab",
            "map"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(dev_map_lock);\n\nstatic void dev_map_free(struct bpf_map *map)\n{\n\tstruct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);\n\tint i;\n\n\t/* At this point bpf_prog->aux->refcnt == 0 and this map->refcnt == 0,\n\t * so the programs (can be more than one that used this map) were\n\t * disconnected from events. The following synchronize_rcu() guarantees\n\t * both rcu read critical sections complete and waits for\n\t * preempt-disable regions (NAPI being the relevant context here) so we\n\t * are certain there will be no further reads against the netdev_map and\n\t * all flush operations are complete. Flush operations can only be done\n\t * from NAPI context for this reason.\n\t */\n\n\tspin_lock(&dev_map_lock);\n\tlist_del_rcu(&dtab->list);\n\tspin_unlock(&dev_map_lock);\n\n\tbpf_clear_redirect_map(map);\n\tsynchronize_rcu();\n\n\t/* Make sure prior __dev_map_entry_free() have completed. */\n\trcu_barrier();\n\n\tif (dtab->map.map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\tfor (i = 0; i < dtab->n_buckets; i++) {\n\t\t\tstruct bpf_dtab_netdev *dev;\n\t\t\tstruct hlist_head *head;\n\t\t\tstruct hlist_node *next;\n\n\t\t\thead = dev_map_index_hash(dtab, i);\n\n\t\t\thlist_for_each_entry_safe(dev, next, head, index_hlist) {\n\t\t\t\thlist_del_rcu(&dev->index_hlist);\n\t\t\t\tif (dev->xdp_prog)\n\t\t\t\t\tbpf_prog_put(dev->xdp_prog);\n\t\t\t\tdev_put(dev->dev);\n\t\t\t\tkfree(dev);\n\t\t\t}\n\t\t}\n\n\t\tbpf_map_area_free(dtab->dev_index_head);\n\t} else {\n\t\tfor (i = 0; i < dtab->map.max_entries; i++) {\n\t\t\tstruct bpf_dtab_netdev *dev;\n\n\t\t\tdev = rcu_dereference_raw(dtab->netdev_map[i]);\n\t\t\tif (!dev)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev->xdp_prog)\n\t\t\t\tbpf_prog_put(dev->xdp_prog);\n\t\t\tdev_put(dev->dev);\n\t\t\tkfree(dev);\n\t\t}\n\n\t\tbpf_map_area_free(dtab->netdev_map);\n\t}\n\n\tkfree(dtab);\n}"
  },
  {
    "function_name": "dev_map_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "157-180",
    "snippet": "static struct bpf_map *dev_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_dtab *dtab;\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tdtab = kzalloc(sizeof(*dtab), GFP_USER | __GFP_ACCOUNT);\n\tif (!dtab)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = dev_map_init_map(dtab, attr);\n\tif (err) {\n\t\tkfree(dtab);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tspin_lock(&dev_map_lock);\n\tlist_add_tail_rcu(&dtab->list, &dev_map_list);\n\tspin_unlock(&dev_map_lock);\n\n\treturn &dtab->map;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(dev_map_lock);",
      "static LIST_HEAD(dev_map_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dev_map_lock"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&dtab->list",
            "&dev_map_list"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dev_map_lock"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dtab"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_map_init_map",
          "args": [
            "dtab",
            "attr"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_init_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "110-155",
          "snippet": "static int dev_map_init_map(struct bpf_dtab *dtab, union bpf_attr *attr)\n{\n\tu32 valsize = attr->value_size;\n\n\t/* check sanity of attributes. 2 value sizes supported:\n\t * 4 bytes: ifindex\n\t * 8 bytes: ifindex + prog fd\n\t */\n\tif (attr->max_entries == 0 || attr->key_size != 4 ||\n\t    (valsize != offsetofend(struct bpf_devmap_val, ifindex) &&\n\t     valsize != offsetofend(struct bpf_devmap_val, bpf_prog.fd)) ||\n\t    attr->map_flags & ~DEV_CREATE_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\t/* Lookup returns a pointer straight to dev->ifindex, so make sure the\n\t * verifier prevents writes from the BPF side\n\t */\n\tattr->map_flags |= BPF_F_RDONLY_PROG;\n\n\n\tbpf_map_init_from_attr(&dtab->map, attr);\n\n\tif (attr->map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\tdtab->n_buckets = roundup_pow_of_two(dtab->map.max_entries);\n\n\t\tif (!dtab->n_buckets) /* Overflow check */\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\tdtab->dev_index_head = dev_map_create_hash(dtab->n_buckets,\n\t\t\t\t\t\t\t   dtab->map.numa_node);\n\t\tif (!dtab->dev_index_head)\n\t\t\treturn -ENOMEM;\n\n\t\tspin_lock_init(&dtab->index_lock);\n\t} else {\n\t\tdtab->netdev_map = bpf_map_area_alloc((u64) dtab->map.max_entries *\n\t\t\t\t\t\t      sizeof(struct bpf_dtab_netdev *),\n\t\t\t\t\t\t      dtab->map.numa_node);\n\t\tif (!dtab->netdev_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define DEV_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\n#define DEV_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic int dev_map_init_map(struct bpf_dtab *dtab, union bpf_attr *attr)\n{\n\tu32 valsize = attr->value_size;\n\n\t/* check sanity of attributes. 2 value sizes supported:\n\t * 4 bytes: ifindex\n\t * 8 bytes: ifindex + prog fd\n\t */\n\tif (attr->max_entries == 0 || attr->key_size != 4 ||\n\t    (valsize != offsetofend(struct bpf_devmap_val, ifindex) &&\n\t     valsize != offsetofend(struct bpf_devmap_val, bpf_prog.fd)) ||\n\t    attr->map_flags & ~DEV_CREATE_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\t/* Lookup returns a pointer straight to dev->ifindex, so make sure the\n\t * verifier prevents writes from the BPF side\n\t */\n\tattr->map_flags |= BPF_F_RDONLY_PROG;\n\n\n\tbpf_map_init_from_attr(&dtab->map, attr);\n\n\tif (attr->map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\tdtab->n_buckets = roundup_pow_of_two(dtab->map.max_entries);\n\n\t\tif (!dtab->n_buckets) /* Overflow check */\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\tdtab->dev_index_head = dev_map_create_hash(dtab->n_buckets,\n\t\t\t\t\t\t\t   dtab->map.numa_node);\n\t\tif (!dtab->dev_index_head)\n\t\t\treturn -ENOMEM;\n\n\t\tspin_lock_init(&dtab->index_lock);\n\t} else {\n\t\tdtab->netdev_map = bpf_map_area_alloc((u64) dtab->map.max_entries *\n\t\t\t\t\t\t      sizeof(struct bpf_dtab_netdev *),\n\t\t\t\t\t\t      dtab->map.numa_node);\n\t\tif (!dtab->netdev_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*dtab)",
            "GFP_USER | __GFP_ACCOUNT"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_NET_ADMIN"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(dev_map_lock);\nstatic LIST_HEAD(dev_map_list);\n\nstatic struct bpf_map *dev_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_dtab *dtab;\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tdtab = kzalloc(sizeof(*dtab), GFP_USER | __GFP_ACCOUNT);\n\tif (!dtab)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = dev_map_init_map(dtab, attr);\n\tif (err) {\n\t\tkfree(dtab);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tspin_lock(&dev_map_lock);\n\tlist_add_tail_rcu(&dtab->list, &dev_map_list);\n\tspin_unlock(&dev_map_lock);\n\n\treturn &dtab->map;\n}"
  },
  {
    "function_name": "dev_map_init_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "110-155",
    "snippet": "static int dev_map_init_map(struct bpf_dtab *dtab, union bpf_attr *attr)\n{\n\tu32 valsize = attr->value_size;\n\n\t/* check sanity of attributes. 2 value sizes supported:\n\t * 4 bytes: ifindex\n\t * 8 bytes: ifindex + prog fd\n\t */\n\tif (attr->max_entries == 0 || attr->key_size != 4 ||\n\t    (valsize != offsetofend(struct bpf_devmap_val, ifindex) &&\n\t     valsize != offsetofend(struct bpf_devmap_val, bpf_prog.fd)) ||\n\t    attr->map_flags & ~DEV_CREATE_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\t/* Lookup returns a pointer straight to dev->ifindex, so make sure the\n\t * verifier prevents writes from the BPF side\n\t */\n\tattr->map_flags |= BPF_F_RDONLY_PROG;\n\n\n\tbpf_map_init_from_attr(&dtab->map, attr);\n\n\tif (attr->map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\tdtab->n_buckets = roundup_pow_of_two(dtab->map.max_entries);\n\n\t\tif (!dtab->n_buckets) /* Overflow check */\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\tdtab->dev_index_head = dev_map_create_hash(dtab->n_buckets,\n\t\t\t\t\t\t\t   dtab->map.numa_node);\n\t\tif (!dtab->dev_index_head)\n\t\t\treturn -ENOMEM;\n\n\t\tspin_lock_init(&dtab->index_lock);\n\t} else {\n\t\tdtab->netdev_map = bpf_map_area_alloc((u64) dtab->map.max_entries *\n\t\t\t\t\t\t      sizeof(struct bpf_dtab_netdev *),\n\t\t\t\t\t\t      dtab->map.numa_node);\n\t\tif (!dtab->netdev_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define DEV_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "(u64) dtab->map.max_entries *\n\t\t\t\t\t\t      sizeof(struct bpf_dtab_netdev *)",
            "dtab->map.numa_node"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "334-337",
          "snippet": "void *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dtab->index_lock"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_map_create_hash",
          "args": [
            "dtab->n_buckets",
            "dtab->map.numa_node"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "dev_map_create_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
          "lines": "90-102",
          "snippet": "static struct hlist_head *dev_map_create_hash(unsigned int entries,\n\t\t\t\t\t      int numa_node)\n{\n\tint i;\n\tstruct hlist_head *hash;\n\n\thash = bpf_map_area_alloc((u64) entries * sizeof(*hash), numa_node);\n\tif (hash != NULL)\n\t\tfor (i = 0; i < entries; i++)\n\t\t\tINIT_HLIST_HEAD(&hash[i]);\n\n\treturn hash;\n}",
          "includes": [
            "#include <trace/events/xdp.h>",
            "#include <linux/filter.h>",
            "#include <net/xdp.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic struct hlist_head *dev_map_create_hash(unsigned int entries,\n\t\t\t\t\t      int numa_node)\n{\n\tint i;\n\tstruct hlist_head *hash;\n\n\thash = bpf_map_area_alloc((u64) entries * sizeof(*hash), numa_node);\n\tif (hash != NULL)\n\t\tfor (i = 0; i < entries; i++)\n\t\t\tINIT_HLIST_HEAD(&hash[i]);\n\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "dtab->map.max_entries"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&dtab->map",
            "attr"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "361-370",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offsetofend",
          "args": [
            "structbpf_devmap_val",
            "bpf_prog.fd"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetofend",
          "args": [
            "structbpf_devmap_val",
            "ifindex"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\n#define DEV_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic int dev_map_init_map(struct bpf_dtab *dtab, union bpf_attr *attr)\n{\n\tu32 valsize = attr->value_size;\n\n\t/* check sanity of attributes. 2 value sizes supported:\n\t * 4 bytes: ifindex\n\t * 8 bytes: ifindex + prog fd\n\t */\n\tif (attr->max_entries == 0 || attr->key_size != 4 ||\n\t    (valsize != offsetofend(struct bpf_devmap_val, ifindex) &&\n\t     valsize != offsetofend(struct bpf_devmap_val, bpf_prog.fd)) ||\n\t    attr->map_flags & ~DEV_CREATE_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\t/* Lookup returns a pointer straight to dev->ifindex, so make sure the\n\t * verifier prevents writes from the BPF side\n\t */\n\tattr->map_flags |= BPF_F_RDONLY_PROG;\n\n\n\tbpf_map_init_from_attr(&dtab->map, attr);\n\n\tif (attr->map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\tdtab->n_buckets = roundup_pow_of_two(dtab->map.max_entries);\n\n\t\tif (!dtab->n_buckets) /* Overflow check */\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\tdtab->dev_index_head = dev_map_create_hash(dtab->n_buckets,\n\t\t\t\t\t\t\t   dtab->map.numa_node);\n\t\tif (!dtab->dev_index_head)\n\t\t\treturn -ENOMEM;\n\n\t\tspin_lock_init(&dtab->index_lock);\n\t} else {\n\t\tdtab->netdev_map = bpf_map_area_alloc((u64) dtab->map.max_entries *\n\t\t\t\t\t\t      sizeof(struct bpf_dtab_netdev *),\n\t\t\t\t\t\t      dtab->map.numa_node);\n\t\tif (!dtab->netdev_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dev_map_index_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "104-108",
    "snippet": "static inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_head *dev_map_index_hash(struct bpf_dtab *dtab,\n\t\t\t\t\t\t    int idx)\n{\n\treturn &dtab->dev_index_head[idx & (dtab->n_buckets - 1)];\n}"
  },
  {
    "function_name": "dev_map_create_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/devmap.c",
    "lines": "90-102",
    "snippet": "static struct hlist_head *dev_map_create_hash(unsigned int entries,\n\t\t\t\t\t      int numa_node)\n{\n\tint i;\n\tstruct hlist_head *hash;\n\n\thash = bpf_map_area_alloc((u64) entries * sizeof(*hash), numa_node);\n\tif (hash != NULL)\n\t\tfor (i = 0; i < entries; i++)\n\t\t\tINIT_HLIST_HEAD(&hash[i]);\n\n\treturn hash;\n}",
    "includes": [
      "#include <trace/events/xdp.h>",
      "#include <linux/filter.h>",
      "#include <net/xdp.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&hash[i]"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "(u64) entries * sizeof(*hash)",
            "numa_node"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "334-337",
          "snippet": "void *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/xdp.h>\n#include <linux/filter.h>\n#include <net/xdp.h>\n#include <linux/bpf.h>\n\nstatic struct hlist_head *dev_map_create_hash(unsigned int entries,\n\t\t\t\t\t      int numa_node)\n{\n\tint i;\n\tstruct hlist_head *hash;\n\n\thash = bpf_map_area_alloc((u64) entries * sizeof(*hash), numa_node);\n\tif (hash != NULL)\n\t\tfor (i = 0; i < entries; i++)\n\t\t\tINIT_HLIST_HEAD(&hash[i]);\n\n\treturn hash;\n}"
  }
]