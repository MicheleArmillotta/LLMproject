[
  {
    "function_name": "time64_to_tm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timeconv.c",
    "lines": "47-140",
    "snippet": "void time64_to_tm(time64_t totalsecs, int offset, struct tm *result)\n{\n\tu32 u32tmp, day_of_century, year_of_century, day_of_year, month, day;\n\tu64 u64tmp, udays, century, year;\n\tbool is_Jan_or_Feb, is_leap_year;\n\tlong days, rem;\n\tint remainder;\n\n\tdays = div_s64_rem(totalsecs, SECS_PER_DAY, &remainder);\n\trem = remainder;\n\trem += offset;\n\twhile (rem < 0) {\n\t\trem += SECS_PER_DAY;\n\t\t--days;\n\t}\n\twhile (rem >= SECS_PER_DAY) {\n\t\trem -= SECS_PER_DAY;\n\t\t++days;\n\t}\n\n\tresult->tm_hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tresult->tm_min = rem / 60;\n\tresult->tm_sec = rem % 60;\n\n\t/* January 1, 1970 was a Thursday. */\n\tresult->tm_wday = (4 + days) % 7;\n\tif (result->tm_wday < 0)\n\t\tresult->tm_wday += 7;\n\n\t/*\n\t * The following algorithm is, basically, Proposition 6.3 of Neri\n\t * and Schneider [1]. In a few words: it works on the computational\n\t * (fictitious) calendar where the year starts in March, month = 2\n\t * (*), and finishes in February, month = 13. This calendar is\n\t * mathematically convenient because the day of the year does not\n\t * depend on whether the year is leap or not. For instance:\n\t *\n\t * March 1st\t\t0-th day of the year;\n\t * ...\n\t * April 1st\t\t31-st day of the year;\n\t * ...\n\t * January 1st\t\t306-th day of the year; (Important!)\n\t * ...\n\t * February 28th\t364-th day of the year;\n\t * February 29th\t365-th day of the year (if it exists).\n\t *\n\t * After having worked out the date in the computational calendar\n\t * (using just arithmetics) it's easy to convert it to the\n\t * corresponding date in the Gregorian calendar.\n\t *\n\t * [1] \"Euclidean Affine Functions and Applications to Calendar\n\t * Algorithms\". https://arxiv.org/abs/2102.06959\n\t *\n\t * (*) The numbering of months follows tm more closely and thus,\n\t * is slightly different from [1].\n\t */\n\n\tudays\t= ((u64) days) + 2305843009213814918ULL;\n\n\tu64tmp\t\t= 4 * udays + 3;\n\tcentury\t\t= div64_u64_rem(u64tmp, 146097, &u64tmp);\n\tday_of_century\t= (u32) (u64tmp / 4);\n\n\tu32tmp\t\t= 4 * day_of_century + 3;\n\tu64tmp\t\t= 2939745ULL * u32tmp;\n\tyear_of_century\t= upper_32_bits(u64tmp);\n\tday_of_year\t= lower_32_bits(u64tmp) / 2939745 / 4;\n\n\tyear\t\t= 100 * century + year_of_century;\n\tis_leap_year\t= year_of_century ? !(year_of_century % 4) : !(century % 4);\n\n\tu32tmp\t\t= 2141 * day_of_year + 132377;\n\tmonth\t\t= u32tmp >> 16;\n\tday\t\t= ((u16) u32tmp) / 2141;\n\n\t/*\n\t * Recall that January 1st is the 306-th day of the year in the\n\t * computational (not Gregorian) calendar.\n\t */\n\tis_Jan_or_Feb\t= day_of_year >= 306;\n\n\t/* Convert to the Gregorian calendar and adjust to Unix time. */\n\tyear\t\t= year + is_Jan_or_Feb - 6313183731940000ULL;\n\tmonth\t\t= is_Jan_or_Feb ? month - 12 : month;\n\tday\t\t= day + 1;\n\tday_of_year\t+= is_Jan_or_Feb ? -306 : 31 + 28 + is_leap_year;\n\n\t/* Convert to tm's format. */\n\tresult->tm_year = (long) (year - 1900);\n\tresult->tm_mon  = (int) month;\n\tresult->tm_mday = (int) day;\n\tresult->tm_yday = (int) day_of_year;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
      "#define SECS_PER_HOUR\t(60 * 60)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lower_32_bits",
          "args": [
            "u64tmp"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upper_32_bits",
          "args": [
            "u64tmp"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "u64tmp / 4"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64_rem",
          "args": [
            "u64tmp",
            "146097",
            "&u64tmp"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_s64_rem",
          "args": [
            "totalsecs",
            "SECS_PER_DAY",
            "&remainder"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/time.h>\n\n#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)\n#define SECS_PER_HOUR\t(60 * 60)\n\nvoid time64_to_tm(time64_t totalsecs, int offset, struct tm *result)\n{\n\tu32 u32tmp, day_of_century, year_of_century, day_of_year, month, day;\n\tu64 u64tmp, udays, century, year;\n\tbool is_Jan_or_Feb, is_leap_year;\n\tlong days, rem;\n\tint remainder;\n\n\tdays = div_s64_rem(totalsecs, SECS_PER_DAY, &remainder);\n\trem = remainder;\n\trem += offset;\n\twhile (rem < 0) {\n\t\trem += SECS_PER_DAY;\n\t\t--days;\n\t}\n\twhile (rem >= SECS_PER_DAY) {\n\t\trem -= SECS_PER_DAY;\n\t\t++days;\n\t}\n\n\tresult->tm_hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tresult->tm_min = rem / 60;\n\tresult->tm_sec = rem % 60;\n\n\t/* January 1, 1970 was a Thursday. */\n\tresult->tm_wday = (4 + days) % 7;\n\tif (result->tm_wday < 0)\n\t\tresult->tm_wday += 7;\n\n\t/*\n\t * The following algorithm is, basically, Proposition 6.3 of Neri\n\t * and Schneider [1]. In a few words: it works on the computational\n\t * (fictitious) calendar where the year starts in March, month = 2\n\t * (*), and finishes in February, month = 13. This calendar is\n\t * mathematically convenient because the day of the year does not\n\t * depend on whether the year is leap or not. For instance:\n\t *\n\t * March 1st\t\t0-th day of the year;\n\t * ...\n\t * April 1st\t\t31-st day of the year;\n\t * ...\n\t * January 1st\t\t306-th day of the year; (Important!)\n\t * ...\n\t * February 28th\t364-th day of the year;\n\t * February 29th\t365-th day of the year (if it exists).\n\t *\n\t * After having worked out the date in the computational calendar\n\t * (using just arithmetics) it's easy to convert it to the\n\t * corresponding date in the Gregorian calendar.\n\t *\n\t * [1] \"Euclidean Affine Functions and Applications to Calendar\n\t * Algorithms\". https://arxiv.org/abs/2102.06959\n\t *\n\t * (*) The numbering of months follows tm more closely and thus,\n\t * is slightly different from [1].\n\t */\n\n\tudays\t= ((u64) days) + 2305843009213814918ULL;\n\n\tu64tmp\t\t= 4 * udays + 3;\n\tcentury\t\t= div64_u64_rem(u64tmp, 146097, &u64tmp);\n\tday_of_century\t= (u32) (u64tmp / 4);\n\n\tu32tmp\t\t= 4 * day_of_century + 3;\n\tu64tmp\t\t= 2939745ULL * u32tmp;\n\tyear_of_century\t= upper_32_bits(u64tmp);\n\tday_of_year\t= lower_32_bits(u64tmp) / 2939745 / 4;\n\n\tyear\t\t= 100 * century + year_of_century;\n\tis_leap_year\t= year_of_century ? !(year_of_century % 4) : !(century % 4);\n\n\tu32tmp\t\t= 2141 * day_of_year + 132377;\n\tmonth\t\t= u32tmp >> 16;\n\tday\t\t= ((u16) u32tmp) / 2141;\n\n\t/*\n\t * Recall that January 1st is the 306-th day of the year in the\n\t * computational (not Gregorian) calendar.\n\t */\n\tis_Jan_or_Feb\t= day_of_year >= 306;\n\n\t/* Convert to the Gregorian calendar and adjust to Unix time. */\n\tyear\t\t= year + is_Jan_or_Feb - 6313183731940000ULL;\n\tmonth\t\t= is_Jan_or_Feb ? month - 12 : month;\n\tday\t\t= day + 1;\n\tday_of_year\t+= is_Jan_or_Feb ? -306 : 31 + 28 + is_leap_year;\n\n\t/* Convert to tm's format. */\n\tresult->tm_year = (long) (year - 1900);\n\tresult->tm_mon  = (int) month;\n\tresult->tm_mday = (int) day;\n\tresult->tm_yday = (int) day_of_year;\n}"
  }
]