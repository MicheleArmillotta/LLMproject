[
  {
    "function_name": "event_inject_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
    "lines": "323-328",
    "snippet": "static ssize_t\nevent_inject_read(struct file *file, char __user *buf, size_t size,\n\t\t  loff_t *ppos)\n{\n\treturn -EPERM;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic ssize_t\nevent_inject_read(struct file *file, char __user *buf, size_t size,\n\t\t  loff_t *ppos)\n{\n\treturn -EPERM;\n}"
  },
  {
    "function_name": "event_inject_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
    "lines": "283-321",
    "snippet": "static ssize_t\nevent_inject_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_call *call;\n\tstruct trace_event_file *file;\n\tint err = -ENODEV, size;\n\tvoid *entry = NULL;\n\tchar *buf;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (file) {\n\t\tcall = file->event_call;\n\t\tsize = parse_entry(buf, call, &entry);\n\t\tif (size < 0)\n\t\t\terr = size;\n\t\telse\n\t\t\terr = trace_inject_entry(file, entry, size);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tkfree(entry);\n\tkfree(buf);\n\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += err;\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_inject_entry",
          "args": [
            "file",
            "entry",
            "size"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "trace_inject_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
          "lines": "16-33",
          "snippet": "static int\ntrace_inject_entry(struct trace_event_file *file, void *rec, int len)\n{\n\tstruct trace_event_buffer fbuffer;\n\tint written = 0;\n\tvoid *entry;\n\n\trcu_read_lock_sched();\n\tentry = trace_event_buffer_reserve(&fbuffer, file, len);\n\tif (entry) {\n\t\tmemcpy(entry, rec, len);\n\t\twritten = len;\n\t\ttrace_event_buffer_commit(&fbuffer);\n\t}\n\trcu_read_unlock_sched();\n\n\treturn written;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\ntrace_inject_entry(struct trace_event_file *file, void *rec, int len)\n{\n\tstruct trace_event_buffer fbuffer;\n\tint written = 0;\n\tvoid *entry;\n\n\trcu_read_lock_sched();\n\tentry = trace_event_buffer_reserve(&fbuffer, file, len);\n\tif (entry) {\n\t\tmemcpy(entry, rec, len);\n\t\twritten = len;\n\t\ttrace_event_buffer_commit(&fbuffer);\n\t}\n\trcu_read_unlock_sched();\n\n\treturn written;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_entry",
          "args": [
            "buf",
            "call",
            "&entry"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "parse_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
          "lines": "196-281",
          "snippet": "static int parse_entry(char *str, struct trace_event_call *call, void **pentry)\n{\n\tstruct ftrace_event_field *field;\n\tvoid *entry = NULL;\n\tint entry_size;\n\tu64 val = 0;\n\tint len;\n\n\tentry = trace_alloc_entry(call, &entry_size);\n\t*pentry = entry;\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\ttracing_generic_entry_update(entry, call->event.type,\n\t\t\t\t     tracing_gen_ctx());\n\n\twhile ((len = parse_field(str, call, &field, &val)) > 0) {\n\t\tif (is_function_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tif (is_string_field(field)) {\n\t\t\tchar *addr = (char *)(unsigned long) val;\n\n\t\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\t\tstrlcpy(entry + field->offset, addr, field->size);\n\t\t\t} else if (field->filter_type == FILTER_DYN_STRING ||\n\t\t\t\t   field->filter_type == FILTER_RDYN_STRING) {\n\t\t\t\tint str_len = strlen(addr) + 1;\n\t\t\t\tint str_loc = entry_size & 0xffff;\n\t\t\t\tu32 *str_item;\n\n\t\t\t\tentry_size += str_len;\n\t\t\t\t*pentry = krealloc(entry, entry_size, GFP_KERNEL);\n\t\t\t\tif (!*pentry) {\n\t\t\t\t\tkfree(entry);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tentry = *pentry;\n\n\t\t\t\tstrlcpy(entry + (entry_size - str_len), addr, str_len);\n\t\t\t\tstr_item = (u32 *)(entry + field->offset);\n\t\t\t\tif (field->filter_type == FILTER_RDYN_STRING)\n\t\t\t\t\tstr_loc -= field->offset + field->size;\n\t\t\t\t*str_item = (str_len << 16) | str_loc;\n\t\t\t} else {\n\t\t\t\tchar **paddr;\n\n\t\t\t\tpaddr = (char **)(entry + field->offset);\n\t\t\t\t*paddr = INJECT_STRING;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (field->size) {\n\t\t\tcase 1: {\n\t\t\t\tu8 tmp = (u8) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tu16 tmp = (u16) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\tu32 tmp = (u32) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 8:\n\t\t\t\tmemcpy(entry + field->offset, &val, 8);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tstr += len;\n\t}\n\n\tif (len < 0)\n\t\treturn len;\n\n\treturn entry_size;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define INJECT_STRING \"STATIC STRING CAN NOT BE INJECTED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#define INJECT_STRING \"STATIC STRING CAN NOT BE INJECTED\"\n\nstatic int parse_entry(char *str, struct trace_event_call *call, void **pentry)\n{\n\tstruct ftrace_event_field *field;\n\tvoid *entry = NULL;\n\tint entry_size;\n\tu64 val = 0;\n\tint len;\n\n\tentry = trace_alloc_entry(call, &entry_size);\n\t*pentry = entry;\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\ttracing_generic_entry_update(entry, call->event.type,\n\t\t\t\t     tracing_gen_ctx());\n\n\twhile ((len = parse_field(str, call, &field, &val)) > 0) {\n\t\tif (is_function_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tif (is_string_field(field)) {\n\t\t\tchar *addr = (char *)(unsigned long) val;\n\n\t\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\t\tstrlcpy(entry + field->offset, addr, field->size);\n\t\t\t} else if (field->filter_type == FILTER_DYN_STRING ||\n\t\t\t\t   field->filter_type == FILTER_RDYN_STRING) {\n\t\t\t\tint str_len = strlen(addr) + 1;\n\t\t\t\tint str_loc = entry_size & 0xffff;\n\t\t\t\tu32 *str_item;\n\n\t\t\t\tentry_size += str_len;\n\t\t\t\t*pentry = krealloc(entry, entry_size, GFP_KERNEL);\n\t\t\t\tif (!*pentry) {\n\t\t\t\t\tkfree(entry);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tentry = *pentry;\n\n\t\t\t\tstrlcpy(entry + (entry_size - str_len), addr, str_len);\n\t\t\t\tstr_item = (u32 *)(entry + field->offset);\n\t\t\t\tif (field->filter_type == FILTER_RDYN_STRING)\n\t\t\t\t\tstr_loc -= field->offset + field->size;\n\t\t\t\t*str_item = (str_len << 16) | str_loc;\n\t\t\t} else {\n\t\t\t\tchar **paddr;\n\n\t\t\t\tpaddr = (char **)(entry + field->offset);\n\t\t\t\t*paddr = INJECT_STRING;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (field->size) {\n\t\t\tcase 1: {\n\t\t\t\tu8 tmp = (u8) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tu16 tmp = (u16) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\tu32 tmp = (u32) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 8:\n\t\t\t\tmemcpy(entry + field->offset, &val, 8);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tstr += len;\n\t}\n\n\tif (len < 0)\n\t\treturn len;\n\n\treturn entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "filp"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strim",
          "args": [
            "buf"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "buf"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "buf"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "ubuf",
            "cnt"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic ssize_t\nevent_inject_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_call *call;\n\tstruct trace_event_file *file;\n\tint err = -ENODEV, size;\n\tvoid *entry = NULL;\n\tchar *buf;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (file) {\n\t\tcall = file->event_call;\n\t\tsize = parse_entry(buf, call, &entry);\n\t\tif (size < 0)\n\t\t\terr = size;\n\t\telse\n\t\t\terr = trace_inject_entry(file, entry, size);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tkfree(entry);\n\tkfree(buf);\n\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += err;\n\treturn cnt;\n}"
  },
  {
    "function_name": "parse_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
    "lines": "196-281",
    "snippet": "static int parse_entry(char *str, struct trace_event_call *call, void **pentry)\n{\n\tstruct ftrace_event_field *field;\n\tvoid *entry = NULL;\n\tint entry_size;\n\tu64 val = 0;\n\tint len;\n\n\tentry = trace_alloc_entry(call, &entry_size);\n\t*pentry = entry;\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\ttracing_generic_entry_update(entry, call->event.type,\n\t\t\t\t     tracing_gen_ctx());\n\n\twhile ((len = parse_field(str, call, &field, &val)) > 0) {\n\t\tif (is_function_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tif (is_string_field(field)) {\n\t\t\tchar *addr = (char *)(unsigned long) val;\n\n\t\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\t\tstrlcpy(entry + field->offset, addr, field->size);\n\t\t\t} else if (field->filter_type == FILTER_DYN_STRING ||\n\t\t\t\t   field->filter_type == FILTER_RDYN_STRING) {\n\t\t\t\tint str_len = strlen(addr) + 1;\n\t\t\t\tint str_loc = entry_size & 0xffff;\n\t\t\t\tu32 *str_item;\n\n\t\t\t\tentry_size += str_len;\n\t\t\t\t*pentry = krealloc(entry, entry_size, GFP_KERNEL);\n\t\t\t\tif (!*pentry) {\n\t\t\t\t\tkfree(entry);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tentry = *pentry;\n\n\t\t\t\tstrlcpy(entry + (entry_size - str_len), addr, str_len);\n\t\t\t\tstr_item = (u32 *)(entry + field->offset);\n\t\t\t\tif (field->filter_type == FILTER_RDYN_STRING)\n\t\t\t\t\tstr_loc -= field->offset + field->size;\n\t\t\t\t*str_item = (str_len << 16) | str_loc;\n\t\t\t} else {\n\t\t\t\tchar **paddr;\n\n\t\t\t\tpaddr = (char **)(entry + field->offset);\n\t\t\t\t*paddr = INJECT_STRING;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (field->size) {\n\t\t\tcase 1: {\n\t\t\t\tu8 tmp = (u8) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tu16 tmp = (u16) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\tu32 tmp = (u32) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 8:\n\t\t\t\tmemcpy(entry + field->offset, &val, 8);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tstr += len;\n\t}\n\n\tif (len < 0)\n\t\treturn len;\n\n\treturn entry_size;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define INJECT_STRING \"STATIC STRING CAN NOT BE INJECTED\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry + field->offset",
            "&val",
            "8"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "entry + (entry_size - str_len)",
            "addr",
            "str_len"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "entry",
            "entry_size",
            "GFP_KERNEL"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "addr"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "entry + field->offset",
            "addr",
            "field->size"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_string_field",
          "args": [
            "field"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "is_string_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1470-1477",
          "snippet": "static inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_function_field",
          "args": [
            "field"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "is_function_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1479-1482",
          "snippet": "static inline bool is_function_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_TRACE_FN;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_function_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_TRACE_FN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_field",
          "args": [
            "str",
            "call",
            "&field",
            "&val"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "parse_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
          "lines": "35-136",
          "snippet": "static int\nparse_field(char *str, struct trace_event_call *call,\n\t    struct ftrace_event_field **pf, u64 *pv)\n{\n\tstruct ftrace_event_field *field;\n\tchar *field_name;\n\tint s, i = 0;\n\tint len;\n\tu64 val;\n\n\tif (!str[i])\n\t\treturn 0;\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\tlen = i - s;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field)\n\t\treturn -ENOENT;\n\n\t*pf = field;\n\twhile (isspace(str[i]))\n\t\ti++;\n\tif (str[i] != '=')\n\t\treturn -EINVAL;\n\ti++;\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\tif (isdigit(str[i]) || str[i] == '-') {\n\t\tchar *num, c;\n\t\tint ret;\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\t\tnum = str + s;\n\t\tc = str[i];\n\t\tif (c != '\\0' && !isspace(c))\n\t\t\treturn -EINVAL;\n\t\tstr[i] = '\\0';\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num, 0, &val);\n\t\tstr[i] = c;\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*pv = val;\n\t\treturn i;\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == '\\\\' && str[i + 1]) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i])\n\t\t\treturn -EINVAL;\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL)\n\t\t\treturn -EINVAL;\n\n\t\t*pv = (unsigned long)(str + s);\n\t\tstr[i] = 0;\n\t\t/* go past the last quote */\n\t\ti++;\n\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nparse_field(char *str, struct trace_event_call *call,\n\t    struct ftrace_event_field **pf, u64 *pv)\n{\n\tstruct ftrace_event_field *field;\n\tchar *field_name;\n\tint s, i = 0;\n\tint len;\n\tu64 val;\n\n\tif (!str[i])\n\t\treturn 0;\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\tlen = i - s;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field)\n\t\treturn -ENOENT;\n\n\t*pf = field;\n\twhile (isspace(str[i]))\n\t\ti++;\n\tif (str[i] != '=')\n\t\treturn -EINVAL;\n\ti++;\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\tif (isdigit(str[i]) || str[i] == '-') {\n\t\tchar *num, c;\n\t\tint ret;\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\t\tnum = str + s;\n\t\tc = str[i];\n\t\tif (c != '\\0' && !isspace(c))\n\t\t\treturn -EINVAL;\n\t\tstr[i] = '\\0';\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num, 0, &val);\n\t\tstr[i] = c;\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*pv = val;\n\t\treturn i;\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == '\\\\' && str[i + 1]) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i])\n\t\t\treturn -EINVAL;\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL)\n\t\t\treturn -EINVAL;\n\n\t\t*pv = (unsigned long)(str + s);\n\t\tstr[i] = 0;\n\t\t/* go past the last quote */\n\t\ti++;\n\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_generic_entry_update",
          "args": [
            "entry",
            "call->event.type",
            "tracing_gen_ctx()"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_alloc_entry",
          "args": [
            "call",
            "&entry_size"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "trace_alloc_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
          "lines": "153-191",
          "snippet": "static void *trace_alloc_entry(struct trace_event_call *call, int *size)\n{\n\tint entry_size = trace_get_entry_size(call);\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\tvoid *entry = NULL;\n\n\t/* We need an extra '\\0' at the end. */\n\tentry = kzalloc(entry_size + 1, GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!is_string_field(field))\n\t\t\tcontinue;\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tcontinue;\n\t\tif (field->filter_type == FILTER_DYN_STRING ||\n\t\t    field->filter_type == FILTER_RDYN_STRING) {\n\t\t\tu32 *str_item;\n\t\t\tint str_loc = entry_size & 0xffff;\n\n\t\t\tif (field->filter_type == FILTER_RDYN_STRING)\n\t\t\t\tstr_loc -= field->offset + field->size;\n\n\t\t\tstr_item = (u32 *)(entry + field->offset);\n\t\t\t*str_item = str_loc; /* string length is 0. */\n\t\t} else {\n\t\t\tchar **paddr;\n\n\t\t\tpaddr = (char **)(entry + field->offset);\n\t\t\t*paddr = \"\";\n\t\t}\n\t}\n\n\t*size = entry_size + 1;\n\treturn entry;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void *trace_alloc_entry(struct trace_event_call *call, int *size)\n{\n\tint entry_size = trace_get_entry_size(call);\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\tvoid *entry = NULL;\n\n\t/* We need an extra '\\0' at the end. */\n\tentry = kzalloc(entry_size + 1, GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!is_string_field(field))\n\t\t\tcontinue;\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tcontinue;\n\t\tif (field->filter_type == FILTER_DYN_STRING ||\n\t\t    field->filter_type == FILTER_RDYN_STRING) {\n\t\t\tu32 *str_item;\n\t\t\tint str_loc = entry_size & 0xffff;\n\n\t\t\tif (field->filter_type == FILTER_RDYN_STRING)\n\t\t\t\tstr_loc -= field->offset + field->size;\n\n\t\t\tstr_item = (u32 *)(entry + field->offset);\n\t\t\t*str_item = str_loc; /* string length is 0. */\n\t\t} else {\n\t\t\tchar **paddr;\n\n\t\t\tpaddr = (char **)(entry + field->offset);\n\t\t\t*paddr = \"\";\n\t\t}\n\t}\n\n\t*size = entry_size + 1;\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#define INJECT_STRING \"STATIC STRING CAN NOT BE INJECTED\"\n\nstatic int parse_entry(char *str, struct trace_event_call *call, void **pentry)\n{\n\tstruct ftrace_event_field *field;\n\tvoid *entry = NULL;\n\tint entry_size;\n\tu64 val = 0;\n\tint len;\n\n\tentry = trace_alloc_entry(call, &entry_size);\n\t*pentry = entry;\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\ttracing_generic_entry_update(entry, call->event.type,\n\t\t\t\t     tracing_gen_ctx());\n\n\twhile ((len = parse_field(str, call, &field, &val)) > 0) {\n\t\tif (is_function_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tif (is_string_field(field)) {\n\t\t\tchar *addr = (char *)(unsigned long) val;\n\n\t\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\t\tstrlcpy(entry + field->offset, addr, field->size);\n\t\t\t} else if (field->filter_type == FILTER_DYN_STRING ||\n\t\t\t\t   field->filter_type == FILTER_RDYN_STRING) {\n\t\t\t\tint str_len = strlen(addr) + 1;\n\t\t\t\tint str_loc = entry_size & 0xffff;\n\t\t\t\tu32 *str_item;\n\n\t\t\t\tentry_size += str_len;\n\t\t\t\t*pentry = krealloc(entry, entry_size, GFP_KERNEL);\n\t\t\t\tif (!*pentry) {\n\t\t\t\t\tkfree(entry);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tentry = *pentry;\n\n\t\t\t\tstrlcpy(entry + (entry_size - str_len), addr, str_len);\n\t\t\t\tstr_item = (u32 *)(entry + field->offset);\n\t\t\t\tif (field->filter_type == FILTER_RDYN_STRING)\n\t\t\t\t\tstr_loc -= field->offset + field->size;\n\t\t\t\t*str_item = (str_len << 16) | str_loc;\n\t\t\t} else {\n\t\t\t\tchar **paddr;\n\n\t\t\t\tpaddr = (char **)(entry + field->offset);\n\t\t\t\t*paddr = INJECT_STRING;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (field->size) {\n\t\t\tcase 1: {\n\t\t\t\tu8 tmp = (u8) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tu16 tmp = (u16) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\tu32 tmp = (u32) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 8:\n\t\t\t\tmemcpy(entry + field->offset, &val, 8);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tstr += len;\n\t}\n\n\tif (len < 0)\n\t\treturn len;\n\n\treturn entry_size;\n}"
  },
  {
    "function_name": "trace_alloc_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
    "lines": "153-191",
    "snippet": "static void *trace_alloc_entry(struct trace_event_call *call, int *size)\n{\n\tint entry_size = trace_get_entry_size(call);\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\tvoid *entry = NULL;\n\n\t/* We need an extra '\\0' at the end. */\n\tentry = kzalloc(entry_size + 1, GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!is_string_field(field))\n\t\t\tcontinue;\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tcontinue;\n\t\tif (field->filter_type == FILTER_DYN_STRING ||\n\t\t    field->filter_type == FILTER_RDYN_STRING) {\n\t\t\tu32 *str_item;\n\t\t\tint str_loc = entry_size & 0xffff;\n\n\t\t\tif (field->filter_type == FILTER_RDYN_STRING)\n\t\t\t\tstr_loc -= field->offset + field->size;\n\n\t\t\tstr_item = (u32 *)(entry + field->offset);\n\t\t\t*str_item = str_loc; /* string length is 0. */\n\t\t} else {\n\t\t\tchar **paddr;\n\n\t\t\tpaddr = (char **)(entry + field->offset);\n\t\t\t*paddr = \"\";\n\t\t}\n\t}\n\n\t*size = entry_size + 1;\n\treturn entry;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_string_field",
          "args": [
            "field"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "is_string_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1470-1477",
          "snippet": "static inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "field",
            "head",
            "link"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "entry_size + 1",
            "GFP_KERNEL"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_entry_size",
          "args": [
            "call"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_entry_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
          "lines": "138-151",
          "snippet": "static int trace_get_entry_size(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\tint size = 0;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (field->size + field->offset > size)\n\t\t\tsize = field->size + field->offset;\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int trace_get_entry_size(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\tint size = 0;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (field->size + field->offset > size)\n\t\t\tsize = field->size + field->offset;\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void *trace_alloc_entry(struct trace_event_call *call, int *size)\n{\n\tint entry_size = trace_get_entry_size(call);\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\tvoid *entry = NULL;\n\n\t/* We need an extra '\\0' at the end. */\n\tentry = kzalloc(entry_size + 1, GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!is_string_field(field))\n\t\t\tcontinue;\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tcontinue;\n\t\tif (field->filter_type == FILTER_DYN_STRING ||\n\t\t    field->filter_type == FILTER_RDYN_STRING) {\n\t\t\tu32 *str_item;\n\t\t\tint str_loc = entry_size & 0xffff;\n\n\t\t\tif (field->filter_type == FILTER_RDYN_STRING)\n\t\t\t\tstr_loc -= field->offset + field->size;\n\n\t\t\tstr_item = (u32 *)(entry + field->offset);\n\t\t\t*str_item = str_loc; /* string length is 0. */\n\t\t} else {\n\t\t\tchar **paddr;\n\n\t\t\tpaddr = (char **)(entry + field->offset);\n\t\t\t*paddr = \"\";\n\t\t}\n\t}\n\n\t*size = entry_size + 1;\n\treturn entry;\n}"
  },
  {
    "function_name": "trace_get_entry_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
    "lines": "138-151",
    "snippet": "static int trace_get_entry_size(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\tint size = 0;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (field->size + field->offset > size)\n\t\t\tsize = field->size + field->offset;\n\t}\n\n\treturn size;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "field",
            "head",
            "link"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int trace_get_entry_size(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\tint size = 0;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (field->size + field->offset > size)\n\t\t\tsize = field->size + field->offset;\n\t}\n\n\treturn size;\n}"
  },
  {
    "function_name": "parse_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
    "lines": "35-136",
    "snippet": "static int\nparse_field(char *str, struct trace_event_call *call,\n\t    struct ftrace_event_field **pf, u64 *pv)\n{\n\tstruct ftrace_event_field *field;\n\tchar *field_name;\n\tint s, i = 0;\n\tint len;\n\tu64 val;\n\n\tif (!str[i])\n\t\treturn 0;\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\tlen = i - s;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field)\n\t\treturn -ENOENT;\n\n\t*pf = field;\n\twhile (isspace(str[i]))\n\t\ti++;\n\tif (str[i] != '=')\n\t\treturn -EINVAL;\n\ti++;\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\tif (isdigit(str[i]) || str[i] == '-') {\n\t\tchar *num, c;\n\t\tint ret;\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\t\tnum = str + s;\n\t\tc = str[i];\n\t\tif (c != '\\0' && !isspace(c))\n\t\t\treturn -EINVAL;\n\t\tstr[i] = '\\0';\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num, 0, &val);\n\t\tstr[i] = c;\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*pv = val;\n\t\treturn i;\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == '\\\\' && str[i + 1]) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i])\n\t\t\treturn -EINVAL;\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL)\n\t\t\treturn -EINVAL;\n\n\t\t*pv = (unsigned long)(str + s);\n\t\tstr[i] = 0;\n\t\t/* go past the last quote */\n\t\ti++;\n\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_string_field",
          "args": [
            "field"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "is_string_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1470-1477",
          "snippet": "static inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "num",
            "0",
            "&val"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoll",
          "args": [
            "num",
            "0",
            "&val"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "c"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "str[i]"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "str[i]"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "str[i]"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "str[i]"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "field_name"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_event_field",
          "args": [
            "call",
            "field_name"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_event_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "89-105",
          "snippet": "struct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ftrace_generic_fields);",
            "static LIST_HEAD(ftrace_common_fields);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(ftrace_generic_fields);\nstatic LIST_HEAD(ftrace_common_fields);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup_nul",
          "args": [
            "str + s",
            "len",
            "GFP_KERNEL"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "str[i]"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "str[i]"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nparse_field(char *str, struct trace_event_call *call,\n\t    struct ftrace_event_field **pf, u64 *pv)\n{\n\tstruct ftrace_event_field *field;\n\tchar *field_name;\n\tint s, i = 0;\n\tint len;\n\tu64 val;\n\n\tif (!str[i])\n\t\treturn 0;\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\tlen = i - s;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field)\n\t\treturn -ENOENT;\n\n\t*pf = field;\n\twhile (isspace(str[i]))\n\t\ti++;\n\tif (str[i] != '=')\n\t\treturn -EINVAL;\n\ti++;\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\tif (isdigit(str[i]) || str[i] == '-') {\n\t\tchar *num, c;\n\t\tint ret;\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\t\tnum = str + s;\n\t\tc = str[i];\n\t\tif (c != '\\0' && !isspace(c))\n\t\t\treturn -EINVAL;\n\t\tstr[i] = '\\0';\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num, 0, &val);\n\t\tstr[i] = c;\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*pv = val;\n\t\treturn i;\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == '\\\\' && str[i + 1]) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i])\n\t\t\treturn -EINVAL;\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL)\n\t\t\treturn -EINVAL;\n\n\t\t*pv = (unsigned long)(str + s);\n\t\tstr[i] = 0;\n\t\t/* go past the last quote */\n\t\ti++;\n\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "trace_inject_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_inject.c",
    "lines": "16-33",
    "snippet": "static int\ntrace_inject_entry(struct trace_event_file *file, void *rec, int len)\n{\n\tstruct trace_event_buffer fbuffer;\n\tint written = 0;\n\tvoid *entry;\n\n\trcu_read_lock_sched();\n\tentry = trace_event_buffer_reserve(&fbuffer, file, len);\n\tif (entry) {\n\t\tmemcpy(entry, rec, len);\n\t\twritten = len;\n\t\ttrace_event_buffer_commit(&fbuffer);\n\t}\n\trcu_read_unlock_sched();\n\n\treturn written;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_commit",
          "args": [
            "&fbuffer"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2893-2915",
          "snippet": "void trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);",
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);\nstatic __always_inline struct;\n\nvoid trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry",
            "rec",
            "len"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_reserve",
          "args": [
            "&fbuffer",
            "file",
            "len"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "462-491",
          "snippet": "void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nvoid *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\ntrace_inject_entry(struct trace_event_file *file, void *rec, int len)\n{\n\tstruct trace_event_buffer fbuffer;\n\tint written = 0;\n\tvoid *entry;\n\n\trcu_read_lock_sched();\n\tentry = trace_event_buffer_reserve(&fbuffer, file, len);\n\tif (entry) {\n\t\tmemcpy(entry, rec, len);\n\t\twritten = len;\n\t\ttrace_event_buffer_commit(&fbuffer);\n\t}\n\trcu_read_unlock_sched();\n\n\treturn written;\n}"
  }
]