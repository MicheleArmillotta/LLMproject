[
  {
    "function_name": "irq_chip_pm_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1591-1599",
    "snippet": "int irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_runtime_put",
          "args": [
            "data->chip->parent_device"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PM"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}"
  },
  {
    "function_name": "irq_chip_pm_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1568-1581",
    "snippet": "int irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_runtime_put_noidle",
          "args": [
            "data->chip->parent_device"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_runtime_get_sync",
          "args": [
            "data->chip->parent_device"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PM"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_chip_compose_msi_msg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1545-1559",
    "snippet": "int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct irq_data *pos;\n\n\tfor (pos = NULL; !pos && data; data = irqd_get_parent_data(data)) {\n\t\tif (data->chip && data->chip->irq_compose_msi_msg)\n\t\t\tpos = data;\n\t}\n\n\tif (!pos)\n\t\treturn -ENOSYS;\n\n\tpos->chip->irq_compose_msi_msg(pos, msg);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pos->chip->irq_compose_msi_msg",
          "args": [
            "pos",
            "msg"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_get_parent_data",
          "args": [
            "data"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_get_parent_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "476-483",
          "snippet": "static inline struct irq_data *irqd_get_parent_data(struct irq_data *irqd)\n{\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\treturn irqd->parent_data;\n#else\n\treturn NULL;\n#endif\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline struct irq_data *irqd_get_parent_data(struct irq_data *irqd)\n{\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\treturn irqd->parent_data;\n#else\n\treturn NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct irq_data *pos;\n\n\tfor (pos = NULL; !pos && data; data = irqd_get_parent_data(data)) {\n\t\tif (data->chip && data->chip->irq_compose_msi_msg)\n\t\t\tpos = data;\n\t}\n\n\tif (!pos)\n\t\treturn -ENOSYS;\n\n\tpos->chip->irq_compose_msi_msg(pos, msg);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_chip_release_resources_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1527-1532",
    "snippet": "void irq_chip_release_resources_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_release_resources)\n\t\tdata->chip->irq_release_resources(data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_release_resources",
          "args": [
            "data"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "irq_release_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1371-1378",
          "snippet": "static void irq_release_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_release_resources)\n\t\tc->irq_release_resources(d);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_release_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_release_resources)\n\t\tc->irq_release_resources(d);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_chip_release_resources_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_release_resources)\n\t\tdata->chip->irq_release_resources(data);\n}"
  },
  {
    "function_name": "irq_chip_request_resources_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1512-1520",
    "snippet": "int irq_chip_request_resources_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\n\tif (data->chip->irq_request_resources)\n\t\treturn data->chip->irq_request_resources(data);\n\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_request_resources",
          "args": [
            "data"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "irq_request_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1363-1369",
          "snippet": "static int irq_request_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_request_resources ? c->irq_request_resources(d) : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_request_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_request_resources ? c->irq_request_resources(d) : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_request_resources_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\n\tif (data->chip->irq_request_resources)\n\t\treturn data->chip->irq_request_resources(data);\n\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "irq_chip_set_wake_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1494-1505",
    "snippet": "int irq_chip_set_wake_parent(struct irq_data *data, unsigned int on)\n{\n\tdata = data->parent_data;\n\n\tif (data->chip->flags & IRQCHIP_SKIP_SET_WAKE)\n\t\treturn 0;\n\n\tif (data->chip->irq_set_wake)\n\t\treturn data->chip->irq_set_wake(data, on);\n\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_set_wake",
          "args": [
            "data",
            "on"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_set_wake_parent(struct irq_data *data, unsigned int on)\n{\n\tdata = data->parent_data;\n\n\tif (data->chip->flags & IRQCHIP_SKIP_SET_WAKE)\n\t\treturn 0;\n\n\tif (data->chip->irq_set_wake)\n\t\treturn data->chip->irq_set_wake(data, on);\n\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "irq_chip_set_vcpu_affinity_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1478-1485",
    "snippet": "int irq_chip_set_vcpu_affinity_parent(struct irq_data *data, void *vcpu_info)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_set_vcpu_affinity)\n\t\treturn data->chip->irq_set_vcpu_affinity(data, vcpu_info);\n\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_set_vcpu_affinity",
          "args": [
            "data",
            "vcpu_info"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_vcpu_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "643-671",
          "snippet": "int irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tint ret = -ENOSYS;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tdata = irq_desc_get_irq_data(desc);\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (chip && chip->irq_set_vcpu_affinity)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\tret = chip->irq_set_vcpu_affinity(data, vcpu_info);\n\tirq_put_desc_unlock(desc, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tint ret = -ENOSYS;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tdata = irq_desc_get_irq_data(desc);\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (chip && chip->irq_set_vcpu_affinity)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\tret = chip->irq_set_vcpu_affinity(data, vcpu_info);\n\tirq_put_desc_unlock(desc, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_set_vcpu_affinity_parent(struct irq_data *data, void *vcpu_info)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_set_vcpu_affinity)\n\t\treturn data->chip->irq_set_vcpu_affinity(data, vcpu_info);\n\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "irq_chip_retrigger_hierarchy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1463-1470",
    "snippet": "int irq_chip_retrigger_hierarchy(struct irq_data *data)\n{\n\tfor (data = data->parent_data; data; data = data->parent_data)\n\t\tif (data->chip && data->chip->irq_retrigger)\n\t\t\treturn data->chip->irq_retrigger(data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_retrigger",
          "args": [
            "data"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_retrigger_hierarchy(struct irq_data *data)\n{\n\tfor (data = data->parent_data; data; data = data->parent_data)\n\t\tif (data->chip && data->chip->irq_retrigger)\n\t\t\treturn data->chip->irq_retrigger(data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_chip_set_type_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1445-1453",
    "snippet": "int irq_chip_set_type_parent(struct irq_data *data, unsigned int type)\n{\n\tdata = data->parent_data;\n\n\tif (data->chip->irq_set_type)\n\t\treturn data->chip->irq_set_type(data, type);\n\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_set_type",
          "args": [
            "data",
            "type"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_set_type_parent(struct irq_data *data, unsigned int type)\n{\n\tdata = data->parent_data;\n\n\tif (data->chip->irq_set_type)\n\t\treturn data->chip->irq_set_type(data, type);\n\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "irq_chip_set_affinity_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1427-1435",
    "snippet": "int irq_chip_set_affinity_parent(struct irq_data *data,\n\t\t\t\t const struct cpumask *dest, bool force)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_set_affinity)\n\t\treturn data->chip->irq_set_affinity(data, dest, force);\n\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_set_affinity",
          "args": [
            "data",
            "dest",
            "force"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_set_affinity_parent(struct irq_data *data,\n\t\t\t\t const struct cpumask *dest, bool force)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_set_affinity)\n\t\treturn data->chip->irq_set_affinity(data, dest, force);\n\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "irq_chip_eoi_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1412-1416",
    "snippet": "void irq_chip_eoi_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_eoi(data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_eoi",
          "args": [
            "data"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_chip_eoi_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_eoi(data);\n}"
  },
  {
    "function_name": "irq_chip_unmask_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1401-1405",
    "snippet": "void irq_chip_unmask_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_unmask(data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_unmask",
          "args": [
            "data"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_chip_unmask_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_unmask(data);\n}"
  },
  {
    "function_name": "irq_chip_mask_ack_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1390-1394",
    "snippet": "void irq_chip_mask_ack_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_mask_ack(data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_mask_ack",
          "args": [
            "data"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_chip_mask_ack_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_mask_ack(data);\n}"
  },
  {
    "function_name": "irq_chip_mask_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1379-1383",
    "snippet": "void irq_chip_mask_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_mask(data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_mask",
          "args": [
            "data"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_chip_mask_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_mask(data);\n}"
  },
  {
    "function_name": "irq_chip_ack_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1368-1372",
    "snippet": "void irq_chip_ack_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_ack(data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_ack",
          "args": [
            "data"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_chip_ack_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_ack(data);\n}"
  },
  {
    "function_name": "irq_chip_disable_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1354-1361",
    "snippet": "void irq_chip_disable_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_disable)\n\t\tdata->chip->irq_disable(data);\n\telse\n\t\tdata->chip->irq_mask(data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_mask",
          "args": [
            "data"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->chip->irq_disable",
          "args": [
            "data"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "irq_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "386-389",
          "snippet": "void irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_chip_disable_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_disable)\n\t\tdata->chip->irq_disable(data);\n\telse\n\t\tdata->chip->irq_mask(data);\n}"
  },
  {
    "function_name": "irq_chip_enable_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1339-1346",
    "snippet": "void irq_chip_enable_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_enable)\n\t\tdata->chip->irq_enable(data);\n\telse\n\t\tdata->chip->irq_unmask(data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_unmask",
          "args": [
            "data"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->chip->irq_enable",
          "args": [
            "data"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "irq_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "335-348",
          "snippet": "void irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_chip_enable_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_enable)\n\t\tdata->chip->irq_enable(data);\n\telse\n\t\tdata->chip->irq_unmask(data);\n}"
  },
  {
    "function_name": "irq_chip_get_parent_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1321-1331",
    "snippet": "int irq_chip_get_parent_state(struct irq_data *data,\n\t\t\t      enum irqchip_irq_state which,\n\t\t\t      bool *state)\n{\n\tdata = data->parent_data;\n\n\tif (!data || !data->chip->irq_get_irqchip_state)\n\t\treturn 0;\n\n\treturn data->chip->irq_get_irqchip_state(data, which, state);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_get_irqchip_state",
          "args": [
            "data",
            "which",
            "state"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irqchip_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2800-2818",
          "snippet": "int irq_get_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool *state)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\terr = __irq_get_irqchip_state(data, which, state);\n\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_get_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool *state)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\terr = __irq_get_irqchip_state(data, which, state);\n\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_get_parent_state(struct irq_data *data,\n\t\t\t      enum irqchip_irq_state which,\n\t\t\t      bool *state)\n{\n\tdata = data->parent_data;\n\n\tif (!data || !data->chip->irq_get_irqchip_state)\n\t\treturn 0;\n\n\treturn data->chip->irq_get_irqchip_state(data, which, state);\n}"
  },
  {
    "function_name": "irq_chip_set_parent_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1299-1309",
    "snippet": "int irq_chip_set_parent_state(struct irq_data *data,\n\t\t\t      enum irqchip_irq_state which,\n\t\t\t      bool val)\n{\n\tdata = data->parent_data;\n\n\tif (!data || !data->chip->irq_set_irqchip_state)\n\t\treturn 0;\n\n\treturn data->chip->irq_set_irqchip_state(data, which, val);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_set_irqchip_state",
          "args": [
            "data",
            "which",
            "val"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_irqchip_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2833-2869",
          "snippet": "int irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool val)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (chip->irq_set_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_set_irqchip_state(data, which, val);\n\nout_unlock:\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool val)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (chip->irq_set_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_set_irqchip_state(data, which, val);\n\nout_unlock:\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_set_parent_state(struct irq_data *data,\n\t\t\t      enum irqchip_irq_state which,\n\t\t\t      bool val)\n{\n\tdata = data->parent_data;\n\n\tif (!data || !data->chip->irq_set_irqchip_state)\n\t\treturn 0;\n\n\treturn data->chip->irq_set_irqchip_state(data, which, val);\n}"
  },
  {
    "function_name": "handle_fasteoi_mask_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1249-1285",
    "snippet": "void handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __irq_disable(struct irq_desc *desc, bool mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&desc->lock"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_unmask_eoi_irq",
          "args": [
            "desc",
            "chip"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "cond_unmask_eoi_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "660-679",
          "snippet": "static void cond_unmask_eoi_irq(struct irq_desc *desc, struct irq_chip *chip)\n{\n\tif (!(desc->istate & IRQS_ONESHOT)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\treturn;\n\t}\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\tunmask_irq(desc);\n\t} else if (!(chip->flags & IRQCHIP_EOI_THREADED)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void cond_unmask_eoi_irq(struct irq_desc *desc, struct irq_chip *chip)\n{\n\tif (!(desc->istate & IRQS_ONESHOT)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\treturn;\n\t}\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\tunmask_irq(desc);\n\t} else if (!(chip->flags & IRQCHIP_EOI_THREADED)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_irq_event",
          "args": [
            "desc"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "handle_irq_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "202-215",
          "snippet": "irqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nirqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mask_irq",
          "args": [
            "desc"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "handle_fasteoi_mask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1249-1285",
          "snippet": "void handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "256-260",
          "snippet": "static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!desc->action || irqd_irq_disabled(&desc->irq_data)"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_may_run",
          "args": [
            "desc"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "irq_may_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "505-528",
          "snippet": "static bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mask_ack_irq",
          "args": [
            "desc"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "mask_ack_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "409-419",
          "snippet": "static inline void mask_ack_irq(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_mask_ack) {\n\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t} else {\n\t\tmask_irq(desc);\n\t\tif (desc->irq_data.chip->irq_ack)\n\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic inline void mask_ack_irq(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_mask_ack) {\n\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t} else {\n\t\tmask_irq(desc);\n\t\tif (desc->irq_data.chip->irq_ack)\n\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&desc->lock"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}"
  },
  {
    "function_name": "handle_fasteoi_ack_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1198-1236",
    "snippet": "void handle_fasteoi_ack_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\t/* Start handling the irq */\n\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __irq_disable(struct irq_desc *desc, bool mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&desc->lock"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_unmask_eoi_irq",
          "args": [
            "desc",
            "chip"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "cond_unmask_eoi_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "660-679",
          "snippet": "static void cond_unmask_eoi_irq(struct irq_desc *desc, struct irq_chip *chip)\n{\n\tif (!(desc->istate & IRQS_ONESHOT)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\treturn;\n\t}\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\tunmask_irq(desc);\n\t} else if (!(chip->flags & IRQCHIP_EOI_THREADED)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void cond_unmask_eoi_irq(struct irq_desc *desc, struct irq_chip *chip)\n{\n\tif (!(desc->istate & IRQS_ONESHOT)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\treturn;\n\t}\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\tunmask_irq(desc);\n\t} else if (!(chip->flags & IRQCHIP_EOI_THREADED)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_irq_event",
          "args": [
            "desc"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "handle_irq_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "202-215",
          "snippet": "irqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nirqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_ack",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mask_irq",
          "args": [
            "desc"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "handle_fasteoi_mask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1249-1285",
          "snippet": "void handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "256-260",
          "snippet": "static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!desc->action || irqd_irq_disabled(&desc->irq_data)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_may_run",
          "args": [
            "desc"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "irq_may_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "505-528",
          "snippet": "static bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&desc->lock"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_fasteoi_ack_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\t/* Start handling the irq */\n\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}"
  },
  {
    "function_name": "irq_cpu_offline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1160-1182",
    "snippet": "void irq_cpu_offline(void)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tunsigned int irq;\n\n\tfor_each_active_irq(irq) {\n\t\tdesc = irq_to_desc(irq);\n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t\tchip = irq_data_get_irq_chip(&desc->irq_data);\n\t\tif (chip && chip->irq_cpu_offline &&\n\t\t    (!(chip->flags & IRQCHIP_ONOFFLINE_ENABLED) ||\n\t\t     !irqd_irq_disabled(&desc->irq_data)))\n\t\t\tchip->irq_cpu_offline(&desc->irq_data);\n\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_cpu_offline",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_cpu_offline(void)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tunsigned int irq;\n\n\tfor_each_active_irq(irq) {\n\t\tdesc = irq_to_desc(irq);\n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t\tchip = irq_data_get_irq_chip(&desc->irq_data);\n\t\tif (chip && chip->irq_cpu_offline &&\n\t\t    (!(chip->flags & IRQCHIP_ONOFFLINE_ENABLED) ||\n\t\t     !irqd_irq_disabled(&desc->irq_data)))\n\t\t\tchip->irq_cpu_offline(&desc->irq_data);\n\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}"
  },
  {
    "function_name": "irq_cpu_online",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1130-1152",
    "snippet": "void irq_cpu_online(void)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tunsigned int irq;\n\n\tfor_each_active_irq(irq) {\n\t\tdesc = irq_to_desc(irq);\n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t\tchip = irq_data_get_irq_chip(&desc->irq_data);\n\t\tif (chip && chip->irq_cpu_online &&\n\t\t    (!(chip->flags & IRQCHIP_ONOFFLINE_ENABLED) ||\n\t\t     !irqd_irq_disabled(&desc->irq_data)))\n\t\t\tchip->irq_cpu_online(&desc->irq_data);\n\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_cpu_online",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_cpu_online(void)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tunsigned int irq;\n\n\tfor_each_active_irq(irq) {\n\t\tdesc = irq_to_desc(irq);\n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t\tchip = irq_data_get_irq_chip(&desc->irq_data);\n\t\tif (chip && chip->irq_cpu_online &&\n\t\t    (!(chip->flags & IRQCHIP_ONOFFLINE_ENABLED) ||\n\t\t     !irqd_irq_disabled(&desc->irq_data)))\n\t\t\tchip->irq_cpu_online(&desc->irq_data);\n\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}"
  },
  {
    "function_name": "irq_modify_status",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1084-1120",
    "snippet": "void irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set)\n{\n\tunsigned long flags, trigger, tmp;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t/*\n\t * Warn when a driver sets the no autoenable flag on an already\n\t * active interrupt.\n\t */\n\tWARN_ON_ONCE(!desc->depth && (set & _IRQ_NOAUTOEN));\n\n\tirq_settings_clr_and_set(desc, clr, set);\n\n\ttrigger = irqd_get_trigger_type(&desc->irq_data);\n\n\tirqd_clear(&desc->irq_data, IRQD_NO_BALANCING | IRQD_PER_CPU |\n\t\t   IRQD_TRIGGER_MASK | IRQD_LEVEL | IRQD_MOVE_PCNTXT);\n\tif (irq_settings_has_no_balance_set(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\tif (irq_settings_is_per_cpu(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\tif (irq_settings_can_move_pcntxt(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_MOVE_PCNTXT);\n\tif (irq_settings_is_level(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\n\ttmp = irq_settings_get_trigger_mask(desc);\n\tif (tmp != IRQ_TYPE_NONE)\n\t\ttrigger = tmp;\n\n\tirqd_set(&desc->irq_data, trigger);\n\n\tirq_put_desc_unlock(desc, flags);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "&desc->irq_data",
            "trigger"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_get_trigger_mask",
          "args": [
            "desc"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_get_trigger_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "73-76",
          "snippet": "static inline u32 irq_settings_get_trigger_mask(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & IRQ_TYPE_SENSE_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32 irq_settings_get_trigger_mask(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & IRQ_TYPE_SENSE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_level",
          "args": [
            "desc"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_level",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "85-88",
          "snippet": "static inline bool irq_settings_is_level(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_LEVEL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_level(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_LEVEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_can_move_pcntxt",
          "args": [
            "desc"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_can_move_pcntxt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "145-148",
          "snippet": "static inline bool irq_settings_can_move_pcntxt(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_MOVE_PCNTXT;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_can_move_pcntxt(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_MOVE_PCNTXT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu",
          "args": [
            "desc"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_has_no_balance_set",
          "args": [
            "desc"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_has_no_balance_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "68-71",
          "snippet": "static inline bool irq_settings_has_no_balance_set(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NO_BALANCING;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_has_no_balance_set(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NO_BALANCING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "&desc->irq_data",
            "IRQD_NO_BALANCING | IRQD_PER_CPU |\n\t\t   IRQD_TRIGGER_MASK | IRQD_LEVEL | IRQD_MOVE_PCNTXT"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_get_trigger_type",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_settings_clr_and_set",
          "args": [
            "desc",
            "clr",
            "set"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_clr_and_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "41-46",
          "snippet": "static inline void\nirq_settings_clr_and_set(struct irq_desc *desc, u32 clr, u32 set)\n{\n\tdesc->status_use_accessors &= ~(clr & _IRQF_MODIFY_MASK);\n\tdesc->status_use_accessors |= (set & _IRQF_MODIFY_MASK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nirq_settings_clr_and_set(struct irq_desc *desc, u32 clr, u32 set)\n{\n\tdesc->status_use_accessors &= ~(clr & _IRQF_MODIFY_MASK);\n\tdesc->status_use_accessors |= (set & _IRQF_MODIFY_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!desc->depth && (set & _IRQ_NOAUTOEN)"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set)\n{\n\tunsigned long flags, trigger, tmp;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t/*\n\t * Warn when a driver sets the no autoenable flag on an already\n\t * active interrupt.\n\t */\n\tWARN_ON_ONCE(!desc->depth && (set & _IRQ_NOAUTOEN));\n\n\tirq_settings_clr_and_set(desc, clr, set);\n\n\ttrigger = irqd_get_trigger_type(&desc->irq_data);\n\n\tirqd_clear(&desc->irq_data, IRQD_NO_BALANCING | IRQD_PER_CPU |\n\t\t   IRQD_TRIGGER_MASK | IRQD_LEVEL | IRQD_MOVE_PCNTXT);\n\tif (irq_settings_has_no_balance_set(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\tif (irq_settings_is_per_cpu(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\tif (irq_settings_can_move_pcntxt(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_MOVE_PCNTXT);\n\tif (irq_settings_is_level(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\n\ttmp = irq_settings_get_trigger_mask(desc);\n\tif (tmp != IRQ_TYPE_NONE)\n\t\ttrigger = tmp;\n\n\tirqd_set(&desc->irq_data, trigger);\n\n\tirq_put_desc_unlock(desc, flags);\n}"
  },
  {
    "function_name": "irq_set_chip_and_handler_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1075-1081",
    "snippet": "void\nirq_set_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,\n\t\t\t      irq_flow_handler_t handle, const char *name)\n{\n\tirq_set_chip(irq, chip);\n\t__irq_set_handler(irq, handle, 0, name);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_set_handler",
          "args": [
            "irq",
            "handle",
            "0",
            "name"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_set_handler",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1043-1055",
          "snippet": "void\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t__irq_do_set_handler(desc, handle, is_chained, name);\n\tirq_put_desc_busunlock(desc, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t__irq_do_set_handler(desc, handle, is_chained, name);\n\tirq_put_desc_busunlock(desc, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_chip",
          "args": [
            "irq",
            "chip"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_chip_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "145-155",
          "snippet": "int irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid\nirq_set_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,\n\t\t\t      irq_flow_handler_t handle, const char *name)\n{\n\tirq_set_chip(irq, chip);\n\t__irq_set_handler(irq, handle, 0, name);\n}"
  },
  {
    "function_name": "irq_set_chained_handler_and_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1058-1072",
    "snippet": "void\nirq_set_chained_handler_and_data(unsigned int irq, irq_flow_handler_t handle,\n\t\t\t\t void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\tdesc->irq_common_data.handler_data = data;\n\t__irq_do_set_handler(desc, handle, 1, NULL);\n\n\tirq_put_desc_busunlock(desc, flags);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_busunlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_busunlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "175-179",
          "snippet": "static inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_do_set_handler",
          "args": [
            "desc",
            "handle",
            "1",
            "NULL"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_do_set_handler",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "973-1041",
          "snippet": "static void\n__irq_do_set_handler(struct irq_desc *desc, irq_flow_handler_t handle,\n\t\t     int is_chained, const char *name)\n{\n\tif (!handle) {\n\t\thandle = handle_bad_irq;\n\t} else {\n\t\tstruct irq_data *irq_data = &desc->irq_data;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\t/*\n\t\t * With hierarchical domains we might run into a\n\t\t * situation where the outermost chip is not yet set\n\t\t * up, but the inner chips are there.  Instead of\n\t\t * bailing we install the handler, but obviously we\n\t\t * cannot enable/startup the interrupt at this point.\n\t\t */\n\t\twhile (irq_data) {\n\t\t\tif (irq_data->chip != &no_irq_chip)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Bail out if the outer chip is not set up\n\t\t\t * and the interrupt supposed to be started\n\t\t\t * right away.\n\t\t\t */\n\t\t\tif (WARN_ON(is_chained))\n\t\t\t\treturn;\n\t\t\t/* Try the parent */\n\t\t\tirq_data = irq_data->parent_data;\n\t\t}\n#endif\n\t\tif (WARN_ON(!irq_data || irq_data->chip == &no_irq_chip))\n\t\t\treturn;\n\t}\n\n\t/* Uninstall? */\n\tif (handle == handle_bad_irq) {\n\t\tif (desc->irq_data.chip != &no_irq_chip)\n\t\t\tmask_ack_irq(desc);\n\t\tirq_state_set_disabled(desc);\n\t\tif (is_chained)\n\t\t\tdesc->action = NULL;\n\t\tdesc->depth = 1;\n\t}\n\tdesc->handle_irq = handle;\n\tdesc->name = name;\n\n\tif (handle != handle_bad_irq && is_chained) {\n\t\tunsigned int type = irqd_get_trigger_type(&desc->irq_data);\n\n\t\t/*\n\t\t * We're about to start this interrupt immediately,\n\t\t * hence the need to set the trigger configuration.\n\t\t * But the .set_type callback may have overridden the\n\t\t * flow handler, ignoring that we're dealing with a\n\t\t * chained interrupt. Reset it immediately because we\n\t\t * do know better.\n\t\t */\n\t\tif (type != IRQ_TYPE_NONE) {\n\t\t\t__irq_set_trigger(desc, type);\n\t\t\tdesc->handle_irq = handle;\n\t\t}\n\n\t\tirq_settings_set_noprobe(desc);\n\t\tirq_settings_set_norequest(desc);\n\t\tirq_settings_set_nothread(desc);\n\t\tdesc->action = &chained_action;\n\t\tirq_activate_and_startup(desc, IRQ_RESEND);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct irqaction chained_action = {\n\t.handler = bad_chained_irq,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irqaction chained_action = {\n\t.handler = bad_chained_irq,\n};\n\nstatic void\n__irq_do_set_handler(struct irq_desc *desc, irq_flow_handler_t handle,\n\t\t     int is_chained, const char *name)\n{\n\tif (!handle) {\n\t\thandle = handle_bad_irq;\n\t} else {\n\t\tstruct irq_data *irq_data = &desc->irq_data;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\t/*\n\t\t * With hierarchical domains we might run into a\n\t\t * situation where the outermost chip is not yet set\n\t\t * up, but the inner chips are there.  Instead of\n\t\t * bailing we install the handler, but obviously we\n\t\t * cannot enable/startup the interrupt at this point.\n\t\t */\n\t\twhile (irq_data) {\n\t\t\tif (irq_data->chip != &no_irq_chip)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Bail out if the outer chip is not set up\n\t\t\t * and the interrupt supposed to be started\n\t\t\t * right away.\n\t\t\t */\n\t\t\tif (WARN_ON(is_chained))\n\t\t\t\treturn;\n\t\t\t/* Try the parent */\n\t\t\tirq_data = irq_data->parent_data;\n\t\t}\n#endif\n\t\tif (WARN_ON(!irq_data || irq_data->chip == &no_irq_chip))\n\t\t\treturn;\n\t}\n\n\t/* Uninstall? */\n\tif (handle == handle_bad_irq) {\n\t\tif (desc->irq_data.chip != &no_irq_chip)\n\t\t\tmask_ack_irq(desc);\n\t\tirq_state_set_disabled(desc);\n\t\tif (is_chained)\n\t\t\tdesc->action = NULL;\n\t\tdesc->depth = 1;\n\t}\n\tdesc->handle_irq = handle;\n\tdesc->name = name;\n\n\tif (handle != handle_bad_irq && is_chained) {\n\t\tunsigned int type = irqd_get_trigger_type(&desc->irq_data);\n\n\t\t/*\n\t\t * We're about to start this interrupt immediately,\n\t\t * hence the need to set the trigger configuration.\n\t\t * But the .set_type callback may have overridden the\n\t\t * flow handler, ignoring that we're dealing with a\n\t\t * chained interrupt. Reset it immediately because we\n\t\t * do know better.\n\t\t */\n\t\tif (type != IRQ_TYPE_NONE) {\n\t\t\t__irq_set_trigger(desc, type);\n\t\t\tdesc->handle_irq = handle;\n\t\t}\n\n\t\tirq_settings_set_noprobe(desc);\n\t\tirq_settings_set_norequest(desc);\n\t\tirq_settings_set_nothread(desc);\n\t\tdesc->action = &chained_action;\n\t\tirq_activate_and_startup(desc, IRQ_RESEND);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_buslock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_buslock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "169-173",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid\nirq_set_chained_handler_and_data(unsigned int irq, irq_flow_handler_t handle,\n\t\t\t\t void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\tdesc->irq_common_data.handler_data = data;\n\t__irq_do_set_handler(desc, handle, 1, NULL);\n\n\tirq_put_desc_busunlock(desc, flags);\n}"
  },
  {
    "function_name": "__irq_set_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "1043-1055",
    "snippet": "void\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t__irq_do_set_handler(desc, handle, is_chained, name);\n\tirq_put_desc_busunlock(desc, flags);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_busunlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_busunlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "175-179",
          "snippet": "static inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_do_set_handler",
          "args": [
            "desc",
            "handle",
            "is_chained",
            "name"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_do_set_handler",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "973-1041",
          "snippet": "static void\n__irq_do_set_handler(struct irq_desc *desc, irq_flow_handler_t handle,\n\t\t     int is_chained, const char *name)\n{\n\tif (!handle) {\n\t\thandle = handle_bad_irq;\n\t} else {\n\t\tstruct irq_data *irq_data = &desc->irq_data;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\t/*\n\t\t * With hierarchical domains we might run into a\n\t\t * situation where the outermost chip is not yet set\n\t\t * up, but the inner chips are there.  Instead of\n\t\t * bailing we install the handler, but obviously we\n\t\t * cannot enable/startup the interrupt at this point.\n\t\t */\n\t\twhile (irq_data) {\n\t\t\tif (irq_data->chip != &no_irq_chip)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Bail out if the outer chip is not set up\n\t\t\t * and the interrupt supposed to be started\n\t\t\t * right away.\n\t\t\t */\n\t\t\tif (WARN_ON(is_chained))\n\t\t\t\treturn;\n\t\t\t/* Try the parent */\n\t\t\tirq_data = irq_data->parent_data;\n\t\t}\n#endif\n\t\tif (WARN_ON(!irq_data || irq_data->chip == &no_irq_chip))\n\t\t\treturn;\n\t}\n\n\t/* Uninstall? */\n\tif (handle == handle_bad_irq) {\n\t\tif (desc->irq_data.chip != &no_irq_chip)\n\t\t\tmask_ack_irq(desc);\n\t\tirq_state_set_disabled(desc);\n\t\tif (is_chained)\n\t\t\tdesc->action = NULL;\n\t\tdesc->depth = 1;\n\t}\n\tdesc->handle_irq = handle;\n\tdesc->name = name;\n\n\tif (handle != handle_bad_irq && is_chained) {\n\t\tunsigned int type = irqd_get_trigger_type(&desc->irq_data);\n\n\t\t/*\n\t\t * We're about to start this interrupt immediately,\n\t\t * hence the need to set the trigger configuration.\n\t\t * But the .set_type callback may have overridden the\n\t\t * flow handler, ignoring that we're dealing with a\n\t\t * chained interrupt. Reset it immediately because we\n\t\t * do know better.\n\t\t */\n\t\tif (type != IRQ_TYPE_NONE) {\n\t\t\t__irq_set_trigger(desc, type);\n\t\t\tdesc->handle_irq = handle;\n\t\t}\n\n\t\tirq_settings_set_noprobe(desc);\n\t\tirq_settings_set_norequest(desc);\n\t\tirq_settings_set_nothread(desc);\n\t\tdesc->action = &chained_action;\n\t\tirq_activate_and_startup(desc, IRQ_RESEND);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct irqaction chained_action = {\n\t.handler = bad_chained_irq,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irqaction chained_action = {\n\t.handler = bad_chained_irq,\n};\n\nstatic void\n__irq_do_set_handler(struct irq_desc *desc, irq_flow_handler_t handle,\n\t\t     int is_chained, const char *name)\n{\n\tif (!handle) {\n\t\thandle = handle_bad_irq;\n\t} else {\n\t\tstruct irq_data *irq_data = &desc->irq_data;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\t/*\n\t\t * With hierarchical domains we might run into a\n\t\t * situation where the outermost chip is not yet set\n\t\t * up, but the inner chips are there.  Instead of\n\t\t * bailing we install the handler, but obviously we\n\t\t * cannot enable/startup the interrupt at this point.\n\t\t */\n\t\twhile (irq_data) {\n\t\t\tif (irq_data->chip != &no_irq_chip)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Bail out if the outer chip is not set up\n\t\t\t * and the interrupt supposed to be started\n\t\t\t * right away.\n\t\t\t */\n\t\t\tif (WARN_ON(is_chained))\n\t\t\t\treturn;\n\t\t\t/* Try the parent */\n\t\t\tirq_data = irq_data->parent_data;\n\t\t}\n#endif\n\t\tif (WARN_ON(!irq_data || irq_data->chip == &no_irq_chip))\n\t\t\treturn;\n\t}\n\n\t/* Uninstall? */\n\tif (handle == handle_bad_irq) {\n\t\tif (desc->irq_data.chip != &no_irq_chip)\n\t\t\tmask_ack_irq(desc);\n\t\tirq_state_set_disabled(desc);\n\t\tif (is_chained)\n\t\t\tdesc->action = NULL;\n\t\tdesc->depth = 1;\n\t}\n\tdesc->handle_irq = handle;\n\tdesc->name = name;\n\n\tif (handle != handle_bad_irq && is_chained) {\n\t\tunsigned int type = irqd_get_trigger_type(&desc->irq_data);\n\n\t\t/*\n\t\t * We're about to start this interrupt immediately,\n\t\t * hence the need to set the trigger configuration.\n\t\t * But the .set_type callback may have overridden the\n\t\t * flow handler, ignoring that we're dealing with a\n\t\t * chained interrupt. Reset it immediately because we\n\t\t * do know better.\n\t\t */\n\t\tif (type != IRQ_TYPE_NONE) {\n\t\t\t__irq_set_trigger(desc, type);\n\t\t\tdesc->handle_irq = handle;\n\t\t}\n\n\t\tirq_settings_set_noprobe(desc);\n\t\tirq_settings_set_norequest(desc);\n\t\tirq_settings_set_nothread(desc);\n\t\tdesc->action = &chained_action;\n\t\tirq_activate_and_startup(desc, IRQ_RESEND);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_buslock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_buslock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "169-173",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t__irq_do_set_handler(desc, handle, is_chained, name);\n\tirq_put_desc_busunlock(desc, flags);\n}"
  },
  {
    "function_name": "__irq_do_set_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "973-1041",
    "snippet": "static void\n__irq_do_set_handler(struct irq_desc *desc, irq_flow_handler_t handle,\n\t\t     int is_chained, const char *name)\n{\n\tif (!handle) {\n\t\thandle = handle_bad_irq;\n\t} else {\n\t\tstruct irq_data *irq_data = &desc->irq_data;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\t/*\n\t\t * With hierarchical domains we might run into a\n\t\t * situation where the outermost chip is not yet set\n\t\t * up, but the inner chips are there.  Instead of\n\t\t * bailing we install the handler, but obviously we\n\t\t * cannot enable/startup the interrupt at this point.\n\t\t */\n\t\twhile (irq_data) {\n\t\t\tif (irq_data->chip != &no_irq_chip)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Bail out if the outer chip is not set up\n\t\t\t * and the interrupt supposed to be started\n\t\t\t * right away.\n\t\t\t */\n\t\t\tif (WARN_ON(is_chained))\n\t\t\t\treturn;\n\t\t\t/* Try the parent */\n\t\t\tirq_data = irq_data->parent_data;\n\t\t}\n#endif\n\t\tif (WARN_ON(!irq_data || irq_data->chip == &no_irq_chip))\n\t\t\treturn;\n\t}\n\n\t/* Uninstall? */\n\tif (handle == handle_bad_irq) {\n\t\tif (desc->irq_data.chip != &no_irq_chip)\n\t\t\tmask_ack_irq(desc);\n\t\tirq_state_set_disabled(desc);\n\t\tif (is_chained)\n\t\t\tdesc->action = NULL;\n\t\tdesc->depth = 1;\n\t}\n\tdesc->handle_irq = handle;\n\tdesc->name = name;\n\n\tif (handle != handle_bad_irq && is_chained) {\n\t\tunsigned int type = irqd_get_trigger_type(&desc->irq_data);\n\n\t\t/*\n\t\t * We're about to start this interrupt immediately,\n\t\t * hence the need to set the trigger configuration.\n\t\t * But the .set_type callback may have overridden the\n\t\t * flow handler, ignoring that we're dealing with a\n\t\t * chained interrupt. Reset it immediately because we\n\t\t * do know better.\n\t\t */\n\t\tif (type != IRQ_TYPE_NONE) {\n\t\t\t__irq_set_trigger(desc, type);\n\t\t\tdesc->handle_irq = handle;\n\t\t}\n\n\t\tirq_settings_set_noprobe(desc);\n\t\tirq_settings_set_norequest(desc);\n\t\tirq_settings_set_nothread(desc);\n\t\tdesc->action = &chained_action;\n\t\tirq_activate_and_startup(desc, IRQ_RESEND);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct irqaction chained_action = {\n\t.handler = bad_chained_irq,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_activate_and_startup",
          "args": [
            "desc",
            "IRQ_RESEND"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "irq_activate_and_startup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "298-303",
          "snippet": "int irq_activate_and_startup(struct irq_desc *desc, bool resend)\n{\n\tif (WARN_ON(irq_activate(desc)))\n\t\treturn 0;\n\treturn irq_startup(desc, resend, IRQ_START_FORCE);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_activate_and_startup(struct irq_desc *desc, bool resend)\n{\n\tif (WARN_ON(irq_activate(desc)))\n\t\treturn 0;\n\treturn irq_startup(desc, resend, IRQ_START_FORCE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_set_nothread",
          "args": [
            "desc"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_set_nothread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "125-128",
          "snippet": "static inline void irq_settings_set_nothread(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NOTHREAD;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void irq_settings_set_nothread(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NOTHREAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_set_norequest",
          "args": [
            "desc"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_set_norequest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "110-113",
          "snippet": "static inline void irq_settings_set_norequest(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NOREQUEST;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void irq_settings_set_norequest(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NOREQUEST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_set_noprobe",
          "args": [
            "desc"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_set_noprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "140-143",
          "snippet": "static inline void irq_settings_set_noprobe(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NOPROBE;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void irq_settings_set_noprobe(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NOPROBE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_set_trigger",
          "args": [
            "desc",
            "type"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_set_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "939-992",
          "snippet": "int __irq_set_trigger(struct irq_desc *desc, unsigned long flags)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\tint ret, unmask = 0;\n\n\tif (!chip || !chip->irq_set_type) {\n\t\t/*\n\t\t * IRQF_TRIGGER_* but the PIC does not support multiple\n\t\t * flow-types?\n\t\t */\n\t\tpr_debug(\"No set_type function for IRQ %d (%s)\\n\",\n\t\t\t irq_desc_get_irq(desc),\n\t\t\t chip ? (chip->name ? : \"unknown\") : \"unknown\");\n\t\treturn 0;\n\t}\n\n\tif (chip->flags & IRQCHIP_SET_TYPE_MASKED) {\n\t\tif (!irqd_irq_masked(&desc->irq_data))\n\t\t\tmask_irq(desc);\n\t\tif (!irqd_irq_disabled(&desc->irq_data))\n\t\t\tunmask = 1;\n\t}\n\n\t/* Mask all flags except trigger mode */\n\tflags &= IRQ_TYPE_SENSE_MASK;\n\tret = chip->irq_set_type(&desc->irq_data, flags);\n\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tirqd_clear(&desc->irq_data, IRQD_TRIGGER_MASK);\n\t\tirqd_set(&desc->irq_data, flags);\n\t\tfallthrough;\n\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tflags = irqd_get_trigger_type(&desc->irq_data);\n\t\tirq_settings_set_trigger_mask(desc, flags);\n\t\tirqd_clear(&desc->irq_data, IRQD_LEVEL);\n\t\tirq_settings_clr_level(desc);\n\t\tif (flags & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tirq_settings_set_level(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Setting trigger mode %lu for irq %u failed (%pS)\\n\",\n\t\t       flags, irq_desc_get_irq(desc), chip->irq_set_type);\n\t}\n\tif (unmask)\n\t\tunmask_irq(desc);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint __irq_set_trigger(struct irq_desc *desc, unsigned long flags)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\tint ret, unmask = 0;\n\n\tif (!chip || !chip->irq_set_type) {\n\t\t/*\n\t\t * IRQF_TRIGGER_* but the PIC does not support multiple\n\t\t * flow-types?\n\t\t */\n\t\tpr_debug(\"No set_type function for IRQ %d (%s)\\n\",\n\t\t\t irq_desc_get_irq(desc),\n\t\t\t chip ? (chip->name ? : \"unknown\") : \"unknown\");\n\t\treturn 0;\n\t}\n\n\tif (chip->flags & IRQCHIP_SET_TYPE_MASKED) {\n\t\tif (!irqd_irq_masked(&desc->irq_data))\n\t\t\tmask_irq(desc);\n\t\tif (!irqd_irq_disabled(&desc->irq_data))\n\t\t\tunmask = 1;\n\t}\n\n\t/* Mask all flags except trigger mode */\n\tflags &= IRQ_TYPE_SENSE_MASK;\n\tret = chip->irq_set_type(&desc->irq_data, flags);\n\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tirqd_clear(&desc->irq_data, IRQD_TRIGGER_MASK);\n\t\tirqd_set(&desc->irq_data, flags);\n\t\tfallthrough;\n\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tflags = irqd_get_trigger_type(&desc->irq_data);\n\t\tirq_settings_set_trigger_mask(desc, flags);\n\t\tirqd_clear(&desc->irq_data, IRQD_LEVEL);\n\t\tirq_settings_clr_level(desc);\n\t\tif (flags & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tirq_settings_set_level(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Setting trigger mode %lu for irq %u failed (%pS)\\n\",\n\t\t       flags, irq_desc_get_irq(desc), chip->irq_set_type);\n\t}\n\tif (unmask)\n\t\tunmask_irq(desc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_get_trigger_type",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_state_set_disabled",
          "args": [
            "desc"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_set_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "238-241",
          "snippet": "static inline void irq_state_set_disabled(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_state_set_disabled(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mask_ack_irq",
          "args": [
            "desc"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "mask_ack_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "409-419",
          "snippet": "static inline void mask_ack_irq(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_mask_ack) {\n\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t} else {\n\t\tmask_irq(desc);\n\t\tif (desc->irq_data.chip->irq_ack)\n\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic inline void mask_ack_irq(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_mask_ack) {\n\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t} else {\n\t\tmask_irq(desc);\n\t\tif (desc->irq_data.chip->irq_ack)\n\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!irq_data || irq_data->chip == &no_irq_chip"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "is_chained"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irqaction chained_action = {\n\t.handler = bad_chained_irq,\n};\n\nstatic void\n__irq_do_set_handler(struct irq_desc *desc, irq_flow_handler_t handle,\n\t\t     int is_chained, const char *name)\n{\n\tif (!handle) {\n\t\thandle = handle_bad_irq;\n\t} else {\n\t\tstruct irq_data *irq_data = &desc->irq_data;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\t/*\n\t\t * With hierarchical domains we might run into a\n\t\t * situation where the outermost chip is not yet set\n\t\t * up, but the inner chips are there.  Instead of\n\t\t * bailing we install the handler, but obviously we\n\t\t * cannot enable/startup the interrupt at this point.\n\t\t */\n\t\twhile (irq_data) {\n\t\t\tif (irq_data->chip != &no_irq_chip)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Bail out if the outer chip is not set up\n\t\t\t * and the interrupt supposed to be started\n\t\t\t * right away.\n\t\t\t */\n\t\t\tif (WARN_ON(is_chained))\n\t\t\t\treturn;\n\t\t\t/* Try the parent */\n\t\t\tirq_data = irq_data->parent_data;\n\t\t}\n#endif\n\t\tif (WARN_ON(!irq_data || irq_data->chip == &no_irq_chip))\n\t\t\treturn;\n\t}\n\n\t/* Uninstall? */\n\tif (handle == handle_bad_irq) {\n\t\tif (desc->irq_data.chip != &no_irq_chip)\n\t\t\tmask_ack_irq(desc);\n\t\tirq_state_set_disabled(desc);\n\t\tif (is_chained)\n\t\t\tdesc->action = NULL;\n\t\tdesc->depth = 1;\n\t}\n\tdesc->handle_irq = handle;\n\tdesc->name = name;\n\n\tif (handle != handle_bad_irq && is_chained) {\n\t\tunsigned int type = irqd_get_trigger_type(&desc->irq_data);\n\n\t\t/*\n\t\t * We're about to start this interrupt immediately,\n\t\t * hence the need to set the trigger configuration.\n\t\t * But the .set_type callback may have overridden the\n\t\t * flow handler, ignoring that we're dealing with a\n\t\t * chained interrupt. Reset it immediately because we\n\t\t * do know better.\n\t\t */\n\t\tif (type != IRQ_TYPE_NONE) {\n\t\t\t__irq_set_trigger(desc, type);\n\t\t\tdesc->handle_irq = handle;\n\t\t}\n\n\t\tirq_settings_set_noprobe(desc);\n\t\tirq_settings_set_norequest(desc);\n\t\tirq_settings_set_nothread(desc);\n\t\tdesc->action = &chained_action;\n\t\tirq_activate_and_startup(desc, IRQ_RESEND);\n\t}\n}"
  },
  {
    "function_name": "handle_percpu_devid_fasteoi_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "956-971",
    "snippet": "void handle_percpu_devid_fasteoi_nmi(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irqaction *action = desc->action;\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tirqreturn_t res;\n\n\t__kstat_incr_irqs_this_cpu(desc);\n\n\ttrace_irq_handler_entry(irq, action);\n\tres = action->handler(irq, raw_cpu_ptr(action->percpu_dev_id));\n\ttrace_irq_handler_exit(irq, action, res);\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_irq_handler_exit",
          "args": [
            "irq",
            "action",
            "res"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "action->handler",
          "args": [
            "irq",
            "raw_cpu_ptr(action->percpu_dev_id)"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "action->percpu_dev_id"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_irq_handler_entry",
          "args": [
            "irq",
            "action"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "__kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "250-254",
          "snippet": "static inline void __kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__this_cpu_inc(*desc->kstat_irqs);\n\t__this_cpu_inc(kstat.irqs_sum);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void __kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__this_cpu_inc(*desc->kstat_irqs);\n\t__this_cpu_inc(kstat.irqs_sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_chip",
          "args": [
            "desc"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid handle_percpu_devid_fasteoi_nmi(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irqaction *action = desc->action;\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tirqreturn_t res;\n\n\t__kstat_incr_irqs_this_cpu(desc);\n\n\ttrace_irq_handler_entry(irq, action);\n\tres = action->handler(irq, raw_cpu_ptr(action->percpu_dev_id));\n\ttrace_irq_handler_exit(irq, action, res);\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}"
  },
  {
    "function_name": "handle_percpu_devid_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "913-946",
    "snippet": "void handle_percpu_devid_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irqaction *action = desc->action;\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tirqreturn_t res;\n\n\t/*\n\t * PER CPU interrupts are not serialized. Do not touch\n\t * desc->tot_count.\n\t */\n\t__kstat_incr_irqs_this_cpu(desc);\n\n\tif (chip->irq_ack)\n\t\tchip->irq_ack(&desc->irq_data);\n\n\tif (likely(action)) {\n\t\ttrace_irq_handler_entry(irq, action);\n\t\tres = action->handler(irq, raw_cpu_ptr(action->percpu_dev_id));\n\t\ttrace_irq_handler_exit(irq, action, res);\n\t} else {\n\t\tunsigned int cpu = smp_processor_id();\n\t\tbool enabled = cpumask_test_cpu(cpu, desc->percpu_enabled);\n\n\t\tif (enabled)\n\t\t\tirq_percpu_disable(desc, cpu);\n\n\t\tpr_err_once(\"Spurious%s percpu IRQ%u on CPU%u\\n\",\n\t\t\t    enabled ? \" and unmasked\" : \"\", irq, cpu);\n\t}\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err_once",
          "args": [
            "\"Spurious%s percpu IRQ%u on CPU%u\\n\"",
            "enabled ? \" and unmasked\" : \"\"",
            "irq",
            "cpu"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_percpu_disable",
          "args": [
            "desc",
            "cpu"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "irq_percpu_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "400-407",
          "snippet": "void irq_percpu_disable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_disable)\n\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);\n\tcpumask_clear_cpu(cpu, desc->percpu_enabled);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_percpu_disable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_disable)\n\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);\n\tcpumask_clear_cpu(cpu, desc->percpu_enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "desc->percpu_enabled"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_irq_handler_exit",
          "args": [
            "irq",
            "action",
            "res"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "action->handler",
          "args": [
            "irq",
            "raw_cpu_ptr(action->percpu_dev_id)"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "action->percpu_dev_id"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_irq_handler_entry",
          "args": [
            "irq",
            "action"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "action"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chip->irq_ack",
          "args": [
            "&desc->irq_data"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "__kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "250-254",
          "snippet": "static inline void __kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__this_cpu_inc(*desc->kstat_irqs);\n\t__this_cpu_inc(kstat.irqs_sum);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void __kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__this_cpu_inc(*desc->kstat_irqs);\n\t__this_cpu_inc(kstat.irqs_sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_chip",
          "args": [
            "desc"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid handle_percpu_devid_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irqaction *action = desc->action;\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tirqreturn_t res;\n\n\t/*\n\t * PER CPU interrupts are not serialized. Do not touch\n\t * desc->tot_count.\n\t */\n\t__kstat_incr_irqs_this_cpu(desc);\n\n\tif (chip->irq_ack)\n\t\tchip->irq_ack(&desc->irq_data);\n\n\tif (likely(action)) {\n\t\ttrace_irq_handler_entry(irq, action);\n\t\tres = action->handler(irq, raw_cpu_ptr(action->percpu_dev_id));\n\t\ttrace_irq_handler_exit(irq, action, res);\n\t} else {\n\t\tunsigned int cpu = smp_processor_id();\n\t\tbool enabled = cpumask_test_cpu(cpu, desc->percpu_enabled);\n\n\t\tif (enabled)\n\t\t\tirq_percpu_disable(desc, cpu);\n\n\t\tpr_err_once(\"Spurious%s percpu IRQ%u on CPU%u\\n\",\n\t\t\t    enabled ? \" and unmasked\" : \"\", irq, cpu);\n\t}\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}"
  },
  {
    "function_name": "handle_percpu_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "883-900",
    "snippet": "void handle_percpu_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\t/*\n\t * PER CPU interrupts are not serialized. Do not touch\n\t * desc->tot_count.\n\t */\n\t__kstat_incr_irqs_this_cpu(desc);\n\n\tif (chip->irq_ack)\n\t\tchip->irq_ack(&desc->irq_data);\n\n\thandle_irq_event_percpu(desc);\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_irq_event_percpu",
          "args": [
            "desc"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "handle_irq_event_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "189-200",
          "snippet": "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc)\n{\n\tirqreturn_t retval;\n\n\tretval = __handle_irq_event_percpu(desc);\n\n\tadd_interrupt_randomness(desc->irq_data.irq);\n\n\tif (!irq_settings_no_debug(desc))\n\t\tnote_interrupt(desc, retval);\n\treturn retval;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc)\n{\n\tirqreturn_t retval;\n\n\tretval = __handle_irq_event_percpu(desc);\n\n\tadd_interrupt_randomness(desc->irq_data.irq);\n\n\tif (!irq_settings_no_debug(desc))\n\t\tnote_interrupt(desc, retval);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_ack",
          "args": [
            "&desc->irq_data"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "__kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "250-254",
          "snippet": "static inline void __kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__this_cpu_inc(*desc->kstat_irqs);\n\t__this_cpu_inc(kstat.irqs_sum);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void __kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__this_cpu_inc(*desc->kstat_irqs);\n\t__this_cpu_inc(kstat.irqs_sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_chip",
          "args": [
            "desc"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid handle_percpu_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\t/*\n\t * PER CPU interrupts are not serialized. Do not touch\n\t * desc->tot_count.\n\t */\n\t__kstat_incr_irqs_this_cpu(desc);\n\n\tif (chip->irq_ack)\n\t\tchip->irq_ack(&desc->irq_data);\n\n\thandle_irq_event_percpu(desc);\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}"
  },
  {
    "function_name": "handle_edge_eoi_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "838-874",
    "snippet": "void handle_edge_eoi_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\traw_spin_lock(&desc->lock);\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (!irq_may_run(desc)) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_eoi;\n\t}\n\n\t/*\n\t * If its disabled or no action available then mask it and get\n\t * out of here.\n\t */\n\tif (irqd_irq_disabled(&desc->irq_data) || !desc->action) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_eoi;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\n\tdo {\n\t\tif (unlikely(!desc->action))\n\t\t\tgoto out_eoi;\n\n\t\thandle_irq_event(desc);\n\n\t} while ((desc->istate & IRQS_PENDING) &&\n\t\t !irqd_irq_disabled(&desc->irq_data));\n\nout_eoi:\n\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __irq_disable(struct irq_desc *desc, bool mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&desc->lock"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_irq_event",
          "args": [
            "desc"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "handle_irq_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "202-215",
          "snippet": "irqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nirqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!desc->action"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "256-260",
          "snippet": "static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_may_run",
          "args": [
            "desc"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "irq_may_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "505-528",
          "snippet": "static bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&desc->lock"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_chip",
          "args": [
            "desc"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_edge_eoi_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\traw_spin_lock(&desc->lock);\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (!irq_may_run(desc)) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_eoi;\n\t}\n\n\t/*\n\t * If its disabled or no action available then mask it and get\n\t * out of here.\n\t */\n\tif (irqd_irq_disabled(&desc->irq_data) || !desc->action) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_eoi;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\n\tdo {\n\t\tif (unlikely(!desc->action))\n\t\t\tgoto out_eoi;\n\n\t\thandle_irq_event(desc);\n\n\t} while ((desc->istate & IRQS_PENDING) &&\n\t\t !irqd_irq_disabled(&desc->irq_data));\n\nout_eoi:\n\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}"
  },
  {
    "function_name": "handle_edge_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "776-827",
    "snippet": "void handle_edge_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (!irq_may_run(desc)) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_ack_irq(desc);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If its disabled or no action available then mask it and get\n\t * out of here.\n\t */\n\tif (irqd_irq_disabled(&desc->irq_data) || !desc->action) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_ack_irq(desc);\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\n\t/* Start handling the irq */\n\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\n\tdo {\n\t\tif (unlikely(!desc->action)) {\n\t\t\tmask_irq(desc);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * When another irq arrived while we were handling\n\t\t * one, we could have masked the irq.\n\t\t * Reenable it, if it was not disabled in meantime.\n\t\t */\n\t\tif (unlikely(desc->istate & IRQS_PENDING)) {\n\t\t\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t\t\t    irqd_irq_masked(&desc->irq_data))\n\t\t\t\tunmask_irq(desc);\n\t\t}\n\n\t\thandle_irq_event(desc);\n\n\t} while ((desc->istate & IRQS_PENDING) &&\n\t\t !irqd_irq_disabled(&desc->irq_data));\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __irq_disable(struct irq_desc *desc, bool mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&desc->lock"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_irq_event",
          "args": [
            "desc"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "handle_irq_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "202-215",
          "snippet": "irqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nirqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmask_irq",
          "args": [
            "desc"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "cond_unmask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "608-620",
          "snippet": "static void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_masked",
          "args": [
            "&desc->irq_data"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "desc->istate & IRQS_PENDING"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mask_irq",
          "args": [
            "desc"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "handle_fasteoi_mask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1249-1285",
          "snippet": "void handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!desc->action"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_ack",
          "args": [
            "&desc->irq_data"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "256-260",
          "snippet": "static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mask_ack_irq",
          "args": [
            "desc"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "mask_ack_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "409-419",
          "snippet": "static inline void mask_ack_irq(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_mask_ack) {\n\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t} else {\n\t\tmask_irq(desc);\n\t\tif (desc->irq_data.chip->irq_ack)\n\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic inline void mask_ack_irq(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_mask_ack) {\n\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t} else {\n\t\tmask_irq(desc);\n\t\tif (desc->irq_data.chip->irq_ack)\n\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_may_run",
          "args": [
            "desc"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "irq_may_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "505-528",
          "snippet": "static bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&desc->lock"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_edge_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (!irq_may_run(desc)) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_ack_irq(desc);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If its disabled or no action available then mask it and get\n\t * out of here.\n\t */\n\tif (irqd_irq_disabled(&desc->irq_data) || !desc->action) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_ack_irq(desc);\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\n\t/* Start handling the irq */\n\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\n\tdo {\n\t\tif (unlikely(!desc->action)) {\n\t\t\tmask_irq(desc);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * When another irq arrived while we were handling\n\t\t * one, we could have masked the irq.\n\t\t * Reenable it, if it was not disabled in meantime.\n\t\t */\n\t\tif (unlikely(desc->istate & IRQS_PENDING)) {\n\t\t\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t\t\t    irqd_irq_masked(&desc->irq_data))\n\t\t\t\tunmask_irq(desc);\n\t\t}\n\n\t\thandle_irq_event(desc);\n\n\t} while ((desc->istate & IRQS_PENDING) &&\n\t\t !irqd_irq_disabled(&desc->irq_data));\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}"
  },
  {
    "function_name": "handle_fasteoi_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "740-758",
    "snippet": "void handle_fasteoi_nmi(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irqaction *action = desc->action;\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tirqreturn_t res;\n\n\t__kstat_incr_irqs_this_cpu(desc);\n\n\ttrace_irq_handler_entry(irq, action);\n\t/*\n\t * NMIs cannot be shared, there is only one action.\n\t */\n\tres = action->handler(irq, action->dev_id);\n\ttrace_irq_handler_exit(irq, action, res);\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_irq_handler_exit",
          "args": [
            "irq",
            "action",
            "res"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "action->handler",
          "args": [
            "irq",
            "action->dev_id"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_irq_handler_entry",
          "args": [
            "irq",
            "action"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "__kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "250-254",
          "snippet": "static inline void __kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__this_cpu_inc(*desc->kstat_irqs);\n\t__this_cpu_inc(kstat.irqs_sum);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void __kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__this_cpu_inc(*desc->kstat_irqs);\n\t__this_cpu_inc(kstat.irqs_sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_chip",
          "args": [
            "desc"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid handle_fasteoi_nmi(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irqaction *action = desc->action;\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tirqreturn_t res;\n\n\t__kstat_incr_irqs_this_cpu(desc);\n\n\ttrace_irq_handler_entry(irq, action);\n\t/*\n\t * NMIs cannot be shared, there is only one action.\n\t */\n\tres = action->handler(irq, action->dev_id);\n\ttrace_irq_handler_exit(irq, action, res);\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}"
  },
  {
    "function_name": "handle_fasteoi_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "690-725",
    "snippet": "void handle_fasteoi_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __irq_disable(struct irq_desc *desc, bool mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&desc->lock"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_unmask_eoi_irq",
          "args": [
            "desc",
            "chip"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "cond_unmask_eoi_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "660-679",
          "snippet": "static void cond_unmask_eoi_irq(struct irq_desc *desc, struct irq_chip *chip)\n{\n\tif (!(desc->istate & IRQS_ONESHOT)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\treturn;\n\t}\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\tunmask_irq(desc);\n\t} else if (!(chip->flags & IRQCHIP_EOI_THREADED)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void cond_unmask_eoi_irq(struct irq_desc *desc, struct irq_chip *chip)\n{\n\tif (!(desc->istate & IRQS_ONESHOT)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\treturn;\n\t}\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\tunmask_irq(desc);\n\t} else if (!(chip->flags & IRQCHIP_EOI_THREADED)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_irq_event",
          "args": [
            "desc"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "handle_irq_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "202-215",
          "snippet": "irqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nirqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mask_irq",
          "args": [
            "desc"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "handle_fasteoi_mask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1249-1285",
          "snippet": "void handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "256-260",
          "snippet": "static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!desc->action || irqd_irq_disabled(&desc->irq_data)"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_may_run",
          "args": [
            "desc"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "irq_may_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "505-528",
          "snippet": "static bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&desc->lock"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_fasteoi_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}"
  },
  {
    "function_name": "cond_unmask_eoi_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "660-679",
    "snippet": "static void cond_unmask_eoi_irq(struct irq_desc *desc, struct irq_chip *chip)\n{\n\tif (!(desc->istate & IRQS_ONESHOT)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\treturn;\n\t}\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\tunmask_irq(desc);\n\t} else if (!(chip->flags & IRQCHIP_EOI_THREADED)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmask_irq",
          "args": [
            "desc"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "cond_unmask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "608-620",
          "snippet": "static void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_masked",
          "args": [
            "&desc->irq_data"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void cond_unmask_eoi_irq(struct irq_desc *desc, struct irq_chip *chip)\n{\n\tif (!(desc->istate & IRQS_ONESHOT)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\treturn;\n\t}\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\tunmask_irq(desc);\n\t} else if (!(chip->flags & IRQCHIP_EOI_THREADED)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t}\n}"
  },
  {
    "function_name": "handle_level_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "631-657",
    "snippet": "void handle_level_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * keep it masked and get out of here\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\thandle_irq_event(desc);\n\n\tcond_unmask_irq(desc);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&desc->lock"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_unmask_irq",
          "args": [
            "desc"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "cond_unmask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "608-620",
          "snippet": "static void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_irq_event",
          "args": [
            "desc"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "handle_irq_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "202-215",
          "snippet": "irqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nirqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "256-260",
          "snippet": "static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!desc->action || irqd_irq_disabled(&desc->irq_data)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_may_run",
          "args": [
            "desc"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "irq_may_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "505-528",
          "snippet": "static bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mask_ack_irq",
          "args": [
            "desc"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "mask_ack_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "409-419",
          "snippet": "static inline void mask_ack_irq(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_mask_ack) {\n\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t} else {\n\t\tmask_irq(desc);\n\t\tif (desc->irq_data.chip->irq_ack)\n\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic inline void mask_ack_irq(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_mask_ack) {\n\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t} else {\n\t\tmask_irq(desc);\n\t\tif (desc->irq_data.chip->irq_ack)\n\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&desc->lock"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid handle_level_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * keep it masked and get out of here\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\thandle_irq_event(desc);\n\n\tcond_unmask_irq(desc);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}"
  },
  {
    "function_name": "cond_unmask_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "608-620",
    "snippet": "static void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmask_irq",
          "args": [
            "desc"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "cond_unmask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "608-620",
          "snippet": "static void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_masked",
          "args": [
            "&desc->irq_data"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}"
  },
  {
    "function_name": "handle_untracked_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "576-601",
    "snippet": "void handle_untracked_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\t__handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&desc->lock"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "&desc->irq_data",
            "IRQD_IRQ_INPROGRESS"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&desc->lock"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__handle_irq_event_percpu",
          "args": [
            "desc"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "__handle_irq_event_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "139-187",
          "snippet": "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc)\n{\n\tirqreturn_t retval = IRQ_NONE;\n\tunsigned int irq = desc->irq_data.irq;\n\tstruct irqaction *action;\n\n\trecord_irq_time(desc);\n\n\tfor_each_action_of_desc(desc, action) {\n\t\tirqreturn_t res;\n\n\t\t/*\n\t\t * If this IRQ would be threaded under force_irqthreads, mark it so.\n\t\t */\n\t\tif (irq_settings_can_thread(desc) &&\n\t\t    !(action->flags & (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT)))\n\t\t\tlockdep_hardirq_threaded();\n\n\t\ttrace_irq_handler_entry(irq, action);\n\t\tres = action->handler(irq, action->dev_id);\n\t\ttrace_irq_handler_exit(irq, action, res);\n\n\t\tif (WARN_ONCE(!irqs_disabled(),\"irq %u handler %pS enabled interrupts\\n\",\n\t\t\t      irq, action->handler))\n\t\t\tlocal_irq_disable();\n\n\t\tswitch (res) {\n\t\tcase IRQ_WAKE_THREAD:\n\t\t\t/*\n\t\t\t * Catch drivers which return WAKE_THREAD but\n\t\t\t * did not set up a thread function\n\t\t\t */\n\t\t\tif (unlikely(!action->thread_fn)) {\n\t\t\t\twarn_no_thread(irq, action);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t__irq_wake_thread(desc, action);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tretval |= res;\n\t}\n\n\treturn retval;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc)\n{\n\tirqreturn_t retval = IRQ_NONE;\n\tunsigned int irq = desc->irq_data.irq;\n\tstruct irqaction *action;\n\n\trecord_irq_time(desc);\n\n\tfor_each_action_of_desc(desc, action) {\n\t\tirqreturn_t res;\n\n\t\t/*\n\t\t * If this IRQ would be threaded under force_irqthreads, mark it so.\n\t\t */\n\t\tif (irq_settings_can_thread(desc) &&\n\t\t    !(action->flags & (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT)))\n\t\t\tlockdep_hardirq_threaded();\n\n\t\ttrace_irq_handler_entry(irq, action);\n\t\tres = action->handler(irq, action->dev_id);\n\t\ttrace_irq_handler_exit(irq, action, res);\n\n\t\tif (WARN_ONCE(!irqs_disabled(),\"irq %u handler %pS enabled interrupts\\n\",\n\t\t\t      irq, action->handler))\n\t\t\tlocal_irq_disable();\n\n\t\tswitch (res) {\n\t\tcase IRQ_WAKE_THREAD:\n\t\t\t/*\n\t\t\t * Catch drivers which return WAKE_THREAD but\n\t\t\t * did not set up a thread function\n\t\t\t */\n\t\t\tif (unlikely(!action->thread_fn)) {\n\t\t\t\twarn_no_thread(irq, action);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t__irq_wake_thread(desc, action);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tretval |= res;\n\t}\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "&desc->irq_data",
            "IRQD_IRQ_INPROGRESS"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!desc->action || irqd_irq_disabled(&desc->irq_data)"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_may_run",
          "args": [
            "desc"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "irq_may_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "505-528",
          "snippet": "static bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid handle_untracked_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\t__handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}"
  },
  {
    "function_name": "handle_simple_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "541-560",
    "snippet": "void handle_simple_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\thandle_irq_event(desc);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&desc->lock"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_irq_event",
          "args": [
            "desc"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "handle_irq_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "202-215",
          "snippet": "irqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nirqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "256-260",
          "snippet": "static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!desc->action || irqd_irq_disabled(&desc->irq_data)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_may_run",
          "args": [
            "desc"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "irq_may_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "505-528",
          "snippet": "static bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&desc->lock"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid handle_simple_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\thandle_irq_event(desc);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}"
  },
  {
    "function_name": "irq_may_run",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "505-528",
    "snippet": "static bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __irq_disable(struct irq_desc *desc, bool mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_check_poll",
          "args": [
            "desc"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "irq_check_poll",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "498-503",
          "snippet": "static bool irq_check_poll(struct irq_desc *desc)\n{\n\tif (!(desc->istate & IRQS_POLL_INPROGRESS))\n\t\treturn false;\n\treturn irq_wait_for_poll(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic bool irq_check_poll(struct irq_desc *desc)\n{\n\tif (!(desc->istate & IRQS_POLL_INPROGRESS))\n\t\treturn false;\n\treturn irq_wait_for_poll(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_pm_check_wakeup",
          "args": [
            "desc"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "irq_pm_check_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "277-277",
          "snippet": "static inline bool irq_pm_check_wakeup(struct irq_desc *desc) { return false; }",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline bool irq_pm_check_wakeup(struct irq_desc *desc) { return false; }"
        }
      },
      {
        "call_info": {
          "callee": "irqd_has_set",
          "args": [
            "&desc->irq_data",
            "mask"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_has_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "233-236",
          "snippet": "static inline bool irqd_has_set(struct irq_data *d, unsigned int mask)\n{\n\treturn __irqd_to_state(d) & mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline bool irqd_has_set(struct irq_data *d, unsigned int mask)\n{\n\treturn __irqd_to_state(d) & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t/*\n\t * If the interrupt is not in progress and is not an armed\n\t * wakeup interrupt, proceed.\n\t */\n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t/*\n\t * If the interrupt is an armed wakeup source, mark it pending\n\t * and suspended, disable it and notify the pm core about the\n\t * event.\n\t */\n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t/*\n\t * Handle a potential concurrent poll on a different core.\n\t */\n\treturn irq_check_poll(desc);\n}"
  },
  {
    "function_name": "irq_check_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "498-503",
    "snippet": "static bool irq_check_poll(struct irq_desc *desc)\n{\n\tif (!(desc->istate & IRQS_POLL_INPROGRESS))\n\t\treturn false;\n\treturn irq_wait_for_poll(desc);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_wait_for_poll",
          "args": [
            "desc"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "irq_wait_for_poll",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
          "lines": "36-56",
          "snippet": "bool irq_wait_for_poll(struct irq_desc *desc)\n\t__must_hold(&desc->lock)\n{\n\tif (WARN_ONCE(irq_poll_cpu == smp_processor_id(),\n\t\t      \"irq poll in progress on cpu %d for irq %d\\n\",\n\t\t      smp_processor_id(), desc->irq_data.irq))\n\t\treturn false;\n\n#ifdef CONFIG_SMP\n\tdo {\n\t\traw_spin_unlock(&desc->lock);\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\t\traw_spin_lock(&desc->lock);\n\t} while (irqd_irq_inprogress(&desc->irq_data));\n\t/* Might have been disabled in meantime */\n\treturn !irqd_irq_disabled(&desc->irq_data) && desc->action;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/timer.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int irq_poll_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic int irq_poll_cpu;\n\nbool irq_wait_for_poll(struct irq_desc *desc)\n\t__must_hold(&desc->lock)\n{\n\tif (WARN_ONCE(irq_poll_cpu == smp_processor_id(),\n\t\t      \"irq poll in progress on cpu %d for irq %d\\n\",\n\t\t      smp_processor_id(), desc->irq_data.irq))\n\t\treturn false;\n\n#ifdef CONFIG_SMP\n\tdo {\n\t\traw_spin_unlock(&desc->lock);\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\t\traw_spin_lock(&desc->lock);\n\t} while (irqd_irq_inprogress(&desc->irq_data));\n\t/* Might have been disabled in meantime */\n\treturn !irqd_irq_disabled(&desc->irq_data) && desc->action;\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic bool irq_check_poll(struct irq_desc *desc)\n{\n\tif (!(desc->istate & IRQS_POLL_INPROGRESS))\n\t\treturn false;\n\treturn irq_wait_for_poll(desc);\n}"
  },
  {
    "function_name": "handle_nested_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "461-495",
    "snippet": "void handle_nested_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tirqreturn_t action_ret;\n\n\tmight_sleep();\n\n\traw_spin_lock_irq(&desc->lock);\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\taction = desc->action;\n\tif (unlikely(!action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock_irq(&desc->lock);\n\n\taction_ret = IRQ_NONE;\n\tfor_each_action_of_desc(desc, action)\n\t\taction_ret |= action->thread_fn(action->irq, action->dev_id);\n\n\tif (!irq_settings_no_debug(desc))\n\t\tnote_interrupt(desc, action_ret);\n\n\traw_spin_lock_irq(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\nout_unlock:\n\traw_spin_unlock_irq(&desc->lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "&desc->irq_data",
            "IRQD_IRQ_INPROGRESS"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "note_interrupt",
          "args": [
            "desc",
            "action_ret"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "note_interrupt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
          "lines": "272-432",
          "snippet": "void note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq;\n\n\tif (desc->istate & IRQS_POLL_INPROGRESS ||\n\t    irq_settings_is_polled(desc))\n\t\treturn;\n\n\tif (bad_action_ret(action_ret)) {\n\t\treport_bad_irq(desc, action_ret);\n\t\treturn;\n\t}\n\n\t/*\n\t * We cannot call note_interrupt from the threaded handler\n\t * because we need to look at the compound of all handlers\n\t * (primary and threaded). Aside of that in the threaded\n\t * shared case we have no serialization against an incoming\n\t * hardware interrupt while we are dealing with a threaded\n\t * result.\n\t *\n\t * So in case a thread is woken, we just note the fact and\n\t * defer the analysis to the next hardware interrupt.\n\t *\n\t * The threaded handlers store whether they successfully\n\t * handled an interrupt and we check whether that number\n\t * changed versus the last invocation.\n\t *\n\t * We could handle all interrupts with the delayed by one\n\t * mechanism, but for the non forced threaded case we'd just\n\t * add pointless overhead to the straight hardirq interrupts\n\t * for the sake of a few lines less code.\n\t */\n\tif (action_ret & IRQ_WAKE_THREAD) {\n\t\t/*\n\t\t * There is a thread woken. Check whether one of the\n\t\t * shared primary handlers returned IRQ_HANDLED. If\n\t\t * not we defer the spurious detection to the next\n\t\t * interrupt.\n\t\t */\n\t\tif (action_ret == IRQ_WAKE_THREAD) {\n\t\t\tint handled;\n\t\t\t/*\n\t\t\t * We use bit 31 of thread_handled_last to\n\t\t\t * denote the deferred spurious detection\n\t\t\t * active. No locking necessary as\n\t\t\t * thread_handled_last is only accessed here\n\t\t\t * and we have the guarantee that hard\n\t\t\t * interrupts are not reentrant.\n\t\t\t */\n\t\t\tif (!(desc->threads_handled_last & SPURIOUS_DEFERRED)) {\n\t\t\t\tdesc->threads_handled_last |= SPURIOUS_DEFERRED;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Check whether one of the threaded handlers\n\t\t\t * returned IRQ_HANDLED since the last\n\t\t\t * interrupt happened.\n\t\t\t *\n\t\t\t * For simplicity we just set bit 31, as it is\n\t\t\t * set in threads_handled_last as well. So we\n\t\t\t * avoid extra masking. And we really do not\n\t\t\t * care about the high bits of the handled\n\t\t\t * count. We just care about the count being\n\t\t\t * different than the one we saw before.\n\t\t\t */\n\t\t\thandled = atomic_read(&desc->threads_handled);\n\t\t\thandled |= SPURIOUS_DEFERRED;\n\t\t\tif (handled != desc->threads_handled_last) {\n\t\t\t\taction_ret = IRQ_HANDLED;\n\t\t\t\t/*\n\t\t\t\t * Note: We keep the SPURIOUS_DEFERRED\n\t\t\t\t * bit set. We are handling the\n\t\t\t\t * previous invocation right now.\n\t\t\t\t * Keep it for the current one, so the\n\t\t\t\t * next hardware interrupt will\n\t\t\t\t * account for it.\n\t\t\t\t */\n\t\t\t\tdesc->threads_handled_last = handled;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * None of the threaded handlers felt\n\t\t\t\t * responsible for the last interrupt\n\t\t\t\t *\n\t\t\t\t * We keep the SPURIOUS_DEFERRED bit\n\t\t\t\t * set in threads_handled_last as we\n\t\t\t\t * need to account for the current\n\t\t\t\t * interrupt as well.\n\t\t\t\t */\n\t\t\t\taction_ret = IRQ_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * One of the primary handlers returned\n\t\t\t * IRQ_HANDLED. So we don't care about the\n\t\t\t * threaded handlers on the same line. Clear\n\t\t\t * the deferred detection bit.\n\t\t\t *\n\t\t\t * In theory we could/should check whether the\n\t\t\t * deferred bit is set and take the result of\n\t\t\t * the previous run into account here as\n\t\t\t * well. But it's really not worth the\n\t\t\t * trouble. If every other interrupt is\n\t\t\t * handled we never trigger the spurious\n\t\t\t * detector. And if this is just the one out\n\t\t\t * of 100k unhandled ones which is handled\n\t\t\t * then we merily delay the spurious detection\n\t\t\t * by one hard interrupt. Not a real problem.\n\t\t\t */\n\t\t\tdesc->threads_handled_last &= ~SPURIOUS_DEFERRED;\n\t\t}\n\t}\n\n\tif (unlikely(action_ret == IRQ_NONE)) {\n\t\t/*\n\t\t * If we are seeing only the odd spurious IRQ caused by\n\t\t * bus asynchronicity then don't eventually trigger an error,\n\t\t * otherwise the counter becomes a doomsday timer for otherwise\n\t\t * working systems\n\t\t */\n\t\tif (time_after(jiffies, desc->last_unhandled + HZ/10))\n\t\t\tdesc->irqs_unhandled = 1;\n\t\telse\n\t\t\tdesc->irqs_unhandled++;\n\t\tdesc->last_unhandled = jiffies;\n\t}\n\n\tirq = irq_desc_get_irq(desc);\n\tif (unlikely(try_misrouted_irq(irq, desc, action_ret))) {\n\t\tint ok = misrouted_irq(irq);\n\t\tif (action_ret == IRQ_NONE)\n\t\t\tdesc->irqs_unhandled -= ok;\n\t}\n\n\tif (likely(!desc->irqs_unhandled))\n\t\treturn;\n\n\t/* Now getting into unhandled irq detection */\n\tdesc->irq_count++;\n\tif (likely(desc->irq_count < 100000))\n\t\treturn;\n\n\tdesc->irq_count = 0;\n\tif (unlikely(desc->irqs_unhandled > 99900)) {\n\t\t/*\n\t\t * The interrupt is stuck\n\t\t */\n\t\t__report_bad_irq(desc, action_ret);\n\t\t/*\n\t\t * Now kill the IRQ\n\t\t */\n\t\tprintk(KERN_EMERG \"Disabling IRQ #%d\\n\", irq);\n\t\tdesc->istate |= IRQS_SPURIOUS_DISABLED;\n\t\tdesc->depth++;\n\t\tirq_disable(desc);\n\n\t\tmod_timer(&poll_spurious_irq_timer,\n\t\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);\n\t}\n\tdesc->irqs_unhandled = 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/timer.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [
            "#define SPURIOUS_DEFERRED\t0x80000000",
            "#define POLL_SPURIOUS_IRQ_INTERVAL (HZ/10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\n#define SPURIOUS_DEFERRED\t0x80000000\n#define POLL_SPURIOUS_IRQ_INTERVAL (HZ/10)\n\nvoid note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq;\n\n\tif (desc->istate & IRQS_POLL_INPROGRESS ||\n\t    irq_settings_is_polled(desc))\n\t\treturn;\n\n\tif (bad_action_ret(action_ret)) {\n\t\treport_bad_irq(desc, action_ret);\n\t\treturn;\n\t}\n\n\t/*\n\t * We cannot call note_interrupt from the threaded handler\n\t * because we need to look at the compound of all handlers\n\t * (primary and threaded). Aside of that in the threaded\n\t * shared case we have no serialization against an incoming\n\t * hardware interrupt while we are dealing with a threaded\n\t * result.\n\t *\n\t * So in case a thread is woken, we just note the fact and\n\t * defer the analysis to the next hardware interrupt.\n\t *\n\t * The threaded handlers store whether they successfully\n\t * handled an interrupt and we check whether that number\n\t * changed versus the last invocation.\n\t *\n\t * We could handle all interrupts with the delayed by one\n\t * mechanism, but for the non forced threaded case we'd just\n\t * add pointless overhead to the straight hardirq interrupts\n\t * for the sake of a few lines less code.\n\t */\n\tif (action_ret & IRQ_WAKE_THREAD) {\n\t\t/*\n\t\t * There is a thread woken. Check whether one of the\n\t\t * shared primary handlers returned IRQ_HANDLED. If\n\t\t * not we defer the spurious detection to the next\n\t\t * interrupt.\n\t\t */\n\t\tif (action_ret == IRQ_WAKE_THREAD) {\n\t\t\tint handled;\n\t\t\t/*\n\t\t\t * We use bit 31 of thread_handled_last to\n\t\t\t * denote the deferred spurious detection\n\t\t\t * active. No locking necessary as\n\t\t\t * thread_handled_last is only accessed here\n\t\t\t * and we have the guarantee that hard\n\t\t\t * interrupts are not reentrant.\n\t\t\t */\n\t\t\tif (!(desc->threads_handled_last & SPURIOUS_DEFERRED)) {\n\t\t\t\tdesc->threads_handled_last |= SPURIOUS_DEFERRED;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Check whether one of the threaded handlers\n\t\t\t * returned IRQ_HANDLED since the last\n\t\t\t * interrupt happened.\n\t\t\t *\n\t\t\t * For simplicity we just set bit 31, as it is\n\t\t\t * set in threads_handled_last as well. So we\n\t\t\t * avoid extra masking. And we really do not\n\t\t\t * care about the high bits of the handled\n\t\t\t * count. We just care about the count being\n\t\t\t * different than the one we saw before.\n\t\t\t */\n\t\t\thandled = atomic_read(&desc->threads_handled);\n\t\t\thandled |= SPURIOUS_DEFERRED;\n\t\t\tif (handled != desc->threads_handled_last) {\n\t\t\t\taction_ret = IRQ_HANDLED;\n\t\t\t\t/*\n\t\t\t\t * Note: We keep the SPURIOUS_DEFERRED\n\t\t\t\t * bit set. We are handling the\n\t\t\t\t * previous invocation right now.\n\t\t\t\t * Keep it for the current one, so the\n\t\t\t\t * next hardware interrupt will\n\t\t\t\t * account for it.\n\t\t\t\t */\n\t\t\t\tdesc->threads_handled_last = handled;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * None of the threaded handlers felt\n\t\t\t\t * responsible for the last interrupt\n\t\t\t\t *\n\t\t\t\t * We keep the SPURIOUS_DEFERRED bit\n\t\t\t\t * set in threads_handled_last as we\n\t\t\t\t * need to account for the current\n\t\t\t\t * interrupt as well.\n\t\t\t\t */\n\t\t\t\taction_ret = IRQ_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * One of the primary handlers returned\n\t\t\t * IRQ_HANDLED. So we don't care about the\n\t\t\t * threaded handlers on the same line. Clear\n\t\t\t * the deferred detection bit.\n\t\t\t *\n\t\t\t * In theory we could/should check whether the\n\t\t\t * deferred bit is set and take the result of\n\t\t\t * the previous run into account here as\n\t\t\t * well. But it's really not worth the\n\t\t\t * trouble. If every other interrupt is\n\t\t\t * handled we never trigger the spurious\n\t\t\t * detector. And if this is just the one out\n\t\t\t * of 100k unhandled ones which is handled\n\t\t\t * then we merily delay the spurious detection\n\t\t\t * by one hard interrupt. Not a real problem.\n\t\t\t */\n\t\t\tdesc->threads_handled_last &= ~SPURIOUS_DEFERRED;\n\t\t}\n\t}\n\n\tif (unlikely(action_ret == IRQ_NONE)) {\n\t\t/*\n\t\t * If we are seeing only the odd spurious IRQ caused by\n\t\t * bus asynchronicity then don't eventually trigger an error,\n\t\t * otherwise the counter becomes a doomsday timer for otherwise\n\t\t * working systems\n\t\t */\n\t\tif (time_after(jiffies, desc->last_unhandled + HZ/10))\n\t\t\tdesc->irqs_unhandled = 1;\n\t\telse\n\t\t\tdesc->irqs_unhandled++;\n\t\tdesc->last_unhandled = jiffies;\n\t}\n\n\tirq = irq_desc_get_irq(desc);\n\tif (unlikely(try_misrouted_irq(irq, desc, action_ret))) {\n\t\tint ok = misrouted_irq(irq);\n\t\tif (action_ret == IRQ_NONE)\n\t\t\tdesc->irqs_unhandled -= ok;\n\t}\n\n\tif (likely(!desc->irqs_unhandled))\n\t\treturn;\n\n\t/* Now getting into unhandled irq detection */\n\tdesc->irq_count++;\n\tif (likely(desc->irq_count < 100000))\n\t\treturn;\n\n\tdesc->irq_count = 0;\n\tif (unlikely(desc->irqs_unhandled > 99900)) {\n\t\t/*\n\t\t * The interrupt is stuck\n\t\t */\n\t\t__report_bad_irq(desc, action_ret);\n\t\t/*\n\t\t * Now kill the IRQ\n\t\t */\n\t\tprintk(KERN_EMERG \"Disabling IRQ #%d\\n\", irq);\n\t\tdesc->istate |= IRQS_SPURIOUS_DISABLED;\n\t\tdesc->depth++;\n\t\tirq_disable(desc);\n\n\t\tmod_timer(&poll_spurious_irq_timer,\n\t\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);\n\t}\n\tdesc->irqs_unhandled = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_no_debug",
          "args": [
            "desc"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_no_debug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "185-188",
          "snippet": "static inline bool irq_settings_no_debug(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NO_DEBUG;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_no_debug(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NO_DEBUG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "action->thread_fn",
          "args": [
            "action->irq",
            "action->dev_id"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_action_of_desc",
          "args": [
            "desc",
            "action"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "&desc->irq_data",
            "IRQD_IRQ_INPROGRESS"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstat_incr_irqs_this_cpu",
          "args": [
            "desc"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "kstat_incr_irqs_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "256-260",
          "snippet": "static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!action || irqd_irq_disabled(&desc->irq_data)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid handle_nested_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tirqreturn_t action_ret;\n\n\tmight_sleep();\n\n\traw_spin_lock_irq(&desc->lock);\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\taction = desc->action;\n\tif (unlikely(!action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock_irq(&desc->lock);\n\n\taction_ret = IRQ_NONE;\n\tfor_each_action_of_desc(desc, action)\n\t\taction_ret |= action->thread_fn(action->irq, action->dev_id);\n\n\tif (!irq_settings_no_debug(desc))\n\t\tnote_interrupt(desc, action_ret);\n\n\traw_spin_lock_irq(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\nout_unlock:\n\traw_spin_unlock_irq(&desc->lock);\n}"
  },
  {
    "function_name": "unmask_threaded_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "443-451",
    "snippet": "void unmask_threaded_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\tif (chip->flags & IRQCHIP_EOI_THREADED)\n\t\tchip->irq_eoi(&desc->irq_data);\n\n\tunmask_irq(desc);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmask_irq",
          "args": [
            "desc"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "cond_unmask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "608-620",
          "snippet": "static void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid unmask_threaded_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\tif (chip->flags & IRQCHIP_EOI_THREADED)\n\t\tchip->irq_eoi(&desc->irq_data);\n\n\tunmask_irq(desc);\n}"
  },
  {
    "function_name": "unmask_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "432-441",
    "snippet": "void unmask_irq(struct irq_desc *desc)\n{\n\tif (!irqd_irq_masked(&desc->irq_data))\n\t\treturn;\n\n\tif (desc->irq_data.chip->irq_unmask) {\n\t\tdesc->irq_data.chip->irq_unmask(&desc->irq_data);\n\t\tirq_state_clr_masked(desc);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_state_clr_masked",
          "args": [
            "desc"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_clr_masked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "171-174",
          "snippet": "static void irq_state_clr_masked(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void irq_state_clr_masked(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_unmask",
          "args": [
            "&desc->irq_data"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_masked",
          "args": [
            "&desc->irq_data"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid unmask_irq(struct irq_desc *desc)\n{\n\tif (!irqd_irq_masked(&desc->irq_data))\n\t\treturn;\n\n\tif (desc->irq_data.chip->irq_unmask) {\n\t\tdesc->irq_data.chip->irq_unmask(&desc->irq_data);\n\t\tirq_state_clr_masked(desc);\n\t}\n}"
  },
  {
    "function_name": "mask_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "421-430",
    "snippet": "void mask_irq(struct irq_desc *desc)\n{\n\tif (irqd_irq_masked(&desc->irq_data))\n\t\treturn;\n\n\tif (desc->irq_data.chip->irq_mask) {\n\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_state_set_masked",
          "args": [
            "desc"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_set_masked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "243-246",
          "snippet": "static inline void irq_state_set_masked(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_state_set_masked(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_mask",
          "args": [
            "&desc->irq_data"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_masked",
          "args": [
            "&desc->irq_data"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid mask_irq(struct irq_desc *desc)\n{\n\tif (irqd_irq_masked(&desc->irq_data))\n\t\treturn;\n\n\tif (desc->irq_data.chip->irq_mask) {\n\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t}\n}"
  },
  {
    "function_name": "mask_ack_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "409-419",
    "snippet": "static inline void mask_ack_irq(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_mask_ack) {\n\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t} else {\n\t\tmask_irq(desc);\n\t\tif (desc->irq_data.chip->irq_ack)\n\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_ack",
          "args": [
            "&desc->irq_data"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mask_irq",
          "args": [
            "desc"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "handle_fasteoi_mask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1249-1285",
          "snippet": "void handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_state_set_masked",
          "args": [
            "desc"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_set_masked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "243-246",
          "snippet": "static inline void irq_state_set_masked(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_state_set_masked(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_mask_ack",
          "args": [
            "&desc->irq_data"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic inline void mask_ack_irq(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_mask_ack) {\n\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t} else {\n\t\tmask_irq(desc);\n\t\tif (desc->irq_data.chip->irq_ack)\n\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\t}\n}"
  },
  {
    "function_name": "irq_percpu_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "400-407",
    "snippet": "void irq_percpu_disable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_disable)\n\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);\n\tcpumask_clear_cpu(cpu, desc->percpu_enabled);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "desc->percpu_enabled"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_mask",
          "args": [
            "&desc->irq_data"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_disable",
          "args": [
            "&desc->irq_data"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "irq_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "386-389",
          "snippet": "void irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_percpu_disable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_disable)\n\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);\n\tcpumask_clear_cpu(cpu, desc->percpu_enabled);\n}"
  },
  {
    "function_name": "irq_percpu_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "391-398",
    "snippet": "void irq_percpu_enable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_enable)\n\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_unmask(&desc->irq_data);\n\tcpumask_set_cpu(cpu, desc->percpu_enabled);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "desc->percpu_enabled"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_unmask",
          "args": [
            "&desc->irq_data"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_enable",
          "args": [
            "&desc->irq_data"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "irq_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "335-348",
          "snippet": "void irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_percpu_enable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_enable)\n\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_unmask(&desc->irq_data);\n\tcpumask_set_cpu(cpu, desc->percpu_enabled);\n}"
  },
  {
    "function_name": "irq_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "386-389",
    "snippet": "void irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_disable",
          "args": [
            "desc",
            "irq_settings_disable_unlazy(desc)"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "350-364",
          "snippet": "static void __irq_disable(struct irq_desc *desc, bool mask)\n{\n\tif (irqd_irq_disabled(&desc->irq_data)) {\n\t\tif (mask)\n\t\t\tmask_irq(desc);\n\t} else {\n\t\tirq_state_set_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_disable) {\n\t\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else if (mask) {\n\t\t\tmask_irq(desc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask)\n{\n\tif (irqd_irq_disabled(&desc->irq_data)) {\n\t\tif (mask)\n\t\t\tmask_irq(desc);\n\t} else {\n\t\tirq_state_set_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_disable) {\n\t\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else if (mask) {\n\t\t\tmask_irq(desc);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_disable_unlazy",
          "args": [
            "desc"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_disable_unlazy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "165-168",
          "snippet": "static inline bool irq_settings_disable_unlazy(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_DISABLE_UNLAZY;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_disable_unlazy(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_DISABLE_UNLAZY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}"
  },
  {
    "function_name": "__irq_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "350-364",
    "snippet": "static void __irq_disable(struct irq_desc *desc, bool mask)\n{\n\tif (irqd_irq_disabled(&desc->irq_data)) {\n\t\tif (mask)\n\t\t\tmask_irq(desc);\n\t} else {\n\t\tirq_state_set_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_disable) {\n\t\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else if (mask) {\n\t\t\tmask_irq(desc);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __irq_disable(struct irq_desc *desc, bool mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mask_irq",
          "args": [
            "desc"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "handle_fasteoi_mask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1249-1285",
          "snippet": "void handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_state_set_masked",
          "args": [
            "desc"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_set_masked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "243-246",
          "snippet": "static inline void irq_state_set_masked(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_state_set_masked(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_disable",
          "args": [
            "&desc->irq_data"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "irq_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "386-389",
          "snippet": "void irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_state_set_disabled",
          "args": [
            "desc"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_set_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "238-241",
          "snippet": "static inline void irq_state_set_disabled(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_state_set_disabled(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask)\n{\n\tif (irqd_irq_disabled(&desc->irq_data)) {\n\t\tif (mask)\n\t\t\tmask_irq(desc);\n\t} else {\n\t\tirq_state_set_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_disable) {\n\t\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else if (mask) {\n\t\t\tmask_irq(desc);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "irq_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "335-348",
    "snippet": "void irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmask_irq",
          "args": [
            "desc"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "cond_unmask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "608-620",
          "snippet": "static void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_state_clr_masked",
          "args": [
            "desc"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_clr_masked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "171-174",
          "snippet": "static void irq_state_clr_masked(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void irq_state_clr_masked(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_enable",
          "args": [
            "&desc->irq_data"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "irq_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "335-348",
          "snippet": "void irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "irq_state_clr_disabled",
          "args": [
            "desc"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_clr_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "166-169",
          "snippet": "static void irq_state_clr_disabled(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_DISABLED);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void irq_state_clr_disabled(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_DISABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "irq_shutdown_and_deactivate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "323-333",
    "snippet": "void irq_shutdown_and_deactivate(struct irq_desc *desc)\n{\n\tirq_shutdown(desc);\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_deactivate_irq",
          "args": [
            "&desc->irq_data"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_deactivate_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "470-473",
          "snippet": "static inline void irq_domain_deactivate_irq(struct irq_data *data)\n{\n\tirqd_clr_activated(data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irq_domain_deactivate_irq(struct irq_data *data)\n{\n\tirqd_clr_activated(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_shutdown",
          "args": [
            "desc"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "irq_shutdown_and_deactivate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "323-333",
          "snippet": "void irq_shutdown_and_deactivate(struct irq_desc *desc)\n{\n\tirq_shutdown(desc);\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_shutdown_and_deactivate(struct irq_desc *desc)\n{\n\tirq_shutdown(desc);\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}"
  },
  {
    "function_name": "irq_shutdown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "307-320",
    "snippet": "void irq_shutdown(struct irq_desc *desc)\n{\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tdesc->depth = 1;\n\t\tif (desc->irq_data.chip->irq_shutdown) {\n\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);\n\t\t\tirq_state_set_disabled(desc);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else {\n\t\t\t__irq_disable(desc, true);\n\t\t}\n\t\tirq_state_clr_started(desc);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_state_clr_started",
          "args": [
            "desc"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_clr_started",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "176-179",
          "snippet": "static void irq_state_clr_started(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_STARTED);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void irq_state_clr_started(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_STARTED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_disable",
          "args": [
            "desc",
            "true"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "350-364",
          "snippet": "static void __irq_disable(struct irq_desc *desc, bool mask)\n{\n\tif (irqd_irq_disabled(&desc->irq_data)) {\n\t\tif (mask)\n\t\t\tmask_irq(desc);\n\t} else {\n\t\tirq_state_set_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_disable) {\n\t\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else if (mask) {\n\t\t\tmask_irq(desc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask)\n{\n\tif (irqd_irq_disabled(&desc->irq_data)) {\n\t\tif (mask)\n\t\t\tmask_irq(desc);\n\t} else {\n\t\tirq_state_set_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_disable) {\n\t\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else if (mask) {\n\t\t\tmask_irq(desc);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_state_set_masked",
          "args": [
            "desc"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_set_masked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "243-246",
          "snippet": "static inline void irq_state_set_masked(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_state_set_masked(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_state_set_disabled",
          "args": [
            "desc"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_set_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "238-241",
          "snippet": "static inline void irq_state_set_disabled(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_state_set_disabled(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_shutdown",
          "args": [
            "&desc->irq_data"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "irq_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "307-320",
          "snippet": "void irq_shutdown(struct irq_desc *desc)\n{\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tdesc->depth = 1;\n\t\tif (desc->irq_data.chip->irq_shutdown) {\n\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);\n\t\t\tirq_state_set_disabled(desc);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else {\n\t\t\t__irq_disable(desc, true);\n\t\t}\n\t\tirq_state_clr_started(desc);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_started",
          "args": [
            "&desc->irq_data"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_shutdown(struct irq_desc *desc)\n{\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tdesc->depth = 1;\n\t\tif (desc->irq_data.chip->irq_shutdown) {\n\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);\n\t\t\tirq_state_set_disabled(desc);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else {\n\t\t\t__irq_disable(desc, true);\n\t\t}\n\t\tirq_state_clr_started(desc);\n\t}\n}"
  },
  {
    "function_name": "irq_activate_and_startup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "298-303",
    "snippet": "int irq_activate_and_startup(struct irq_desc *desc, bool resend)\n{\n\tif (WARN_ON(irq_activate(desc)))\n\t\treturn 0;\n\treturn irq_startup(desc, resend, IRQ_START_FORCE);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_startup",
          "args": [
            "desc",
            "resend",
            "IRQ_START_FORCE"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "irq_startup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "255-287",
          "snippet": "int irq_startup(struct irq_desc *desc, bool resend, bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct cpumask *aff = irq_data_get_affinity_mask(d);\n\tint ret = 0;\n\n\tdesc->depth = 0;\n\n\tif (irqd_is_started(d)) {\n\t\tirq_enable(desc);\n\t} else {\n\t\tswitch (__irq_startup_managed(desc, aff, force)) {\n\t\tcase IRQ_STARTUP_NORMAL:\n\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tret = __irq_startup(desc);\n\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_MANAGED:\n\t\t\tirq_do_set_affinity(d, aff, false);\n\t\t\tret = __irq_startup(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_ABORT:\n\t\t\tirqd_set_managed_shutdown(d);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (resend)\n\t\tcheck_irq_resend(desc, false);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_startup(struct irq_desc *desc, bool resend, bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct cpumask *aff = irq_data_get_affinity_mask(d);\n\tint ret = 0;\n\n\tdesc->depth = 0;\n\n\tif (irqd_is_started(d)) {\n\t\tirq_enable(desc);\n\t} else {\n\t\tswitch (__irq_startup_managed(desc, aff, force)) {\n\t\tcase IRQ_STARTUP_NORMAL:\n\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tret = __irq_startup(desc);\n\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_MANAGED:\n\t\t\tirq_do_set_affinity(d, aff, false);\n\t\t\tret = __irq_startup(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_ABORT:\n\t\t\tirqd_set_managed_shutdown(d);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (resend)\n\t\tcheck_irq_resend(desc, false);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irq_activate(desc)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_activate",
          "args": [
            "desc"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "irq_activate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "289-296",
          "snippet": "int irq_activate(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\tif (!irqd_affinity_is_managed(d))\n\t\treturn irq_domain_activate_irq(d, false);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_activate(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\tif (!irqd_affinity_is_managed(d))\n\t\treturn irq_domain_activate_irq(d, false);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_activate_and_startup(struct irq_desc *desc, bool resend)\n{\n\tif (WARN_ON(irq_activate(desc)))\n\t\treturn 0;\n\treturn irq_startup(desc, resend, IRQ_START_FORCE);\n}"
  },
  {
    "function_name": "irq_activate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "289-296",
    "snippet": "int irq_activate(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\tif (!irqd_affinity_is_managed(d))\n\t\treturn irq_domain_activate_irq(d, false);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_activate_irq",
          "args": [
            "d",
            "false"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_activate_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "465-469",
          "snippet": "static inline int irq_domain_activate_irq(struct irq_data *data, bool reserve)\n{\n\tirqd_set_activated(data);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline int irq_domain_activate_irq(struct irq_data *data, bool reserve)\n{\n\tirqd_set_activated(data);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_affinity_is_managed",
          "args": [
            "d"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_activate(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\tif (!irqd_affinity_is_managed(d))\n\t\treturn irq_domain_activate_irq(d, false);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_startup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "255-287",
    "snippet": "int irq_startup(struct irq_desc *desc, bool resend, bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct cpumask *aff = irq_data_get_affinity_mask(d);\n\tint ret = 0;\n\n\tdesc->depth = 0;\n\n\tif (irqd_is_started(d)) {\n\t\tirq_enable(desc);\n\t} else {\n\t\tswitch (__irq_startup_managed(desc, aff, force)) {\n\t\tcase IRQ_STARTUP_NORMAL:\n\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tret = __irq_startup(desc);\n\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_MANAGED:\n\t\t\tirq_do_set_affinity(d, aff, false);\n\t\t\tret = __irq_startup(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_ABORT:\n\t\t\tirqd_set_managed_shutdown(d);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (resend)\n\t\tcheck_irq_resend(desc, false);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_irq_resend",
          "args": [
            "desc",
            "false"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_resend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/resend.c",
          "lines": "106-135",
          "snippet": "int check_irq_resend(struct irq_desc *desc, bool inject)\n{\n\tint err = 0;\n\n\t/*\n\t * We do not resend level type interrupts. Level type interrupts\n\t * are resent by hardware when they are still active. Clear the\n\t * pending bit so suspend/resume does not get confused.\n\t */\n\tif (irq_settings_is_level(desc)) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc->istate & IRQS_REPLAY)\n\t\treturn -EBUSY;\n\n\tif (!(desc->istate & IRQS_PENDING) && !inject)\n\t\treturn 0;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\n\tif (!try_retrigger(desc))\n\t\terr = irq_sw_resend(desc);\n\n\t/* If the retrigger was successful, mark it with the REPLAY bit */\n\tif (!err)\n\t\tdesc->istate |= IRQS_REPLAY;\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nint check_irq_resend(struct irq_desc *desc, bool inject)\n{\n\tint err = 0;\n\n\t/*\n\t * We do not resend level type interrupts. Level type interrupts\n\t * are resent by hardware when they are still active. Clear the\n\t * pending bit so suspend/resume does not get confused.\n\t */\n\tif (irq_settings_is_level(desc)) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc->istate & IRQS_REPLAY)\n\t\treturn -EBUSY;\n\n\tif (!(desc->istate & IRQS_PENDING) && !inject)\n\t\treturn 0;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\n\tif (!try_retrigger(desc))\n\t\terr = irq_sw_resend(desc);\n\n\t/* If the retrigger was successful, mark it with the REPLAY bit */\n\tif (!err)\n\t\tdesc->istate |= IRQS_REPLAY;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_set_managed_shutdown",
          "args": [
            "d"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set_managed_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "213-216",
          "snippet": "static inline void irqd_set_managed_shutdown(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_MANAGED_SHUTDOWN;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set_managed_shutdown(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_MANAGED_SHUTDOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_startup",
          "args": [
            "desc"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_startup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "236-253",
          "snippet": "static int __irq_startup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tint ret = 0;\n\n\t/* Warn if this interrupt is not activated but try nevertheless */\n\tWARN_ON_ONCE(!irqd_is_activated(d));\n\n\tif (d->chip->irq_startup) {\n\t\tret = d->chip->irq_startup(d);\n\t\tirq_state_clr_disabled(desc);\n\t\tirq_state_clr_masked(desc);\n\t} else {\n\t\tirq_enable(desc);\n\t}\n\tirq_state_set_started(desc);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic int __irq_startup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tint ret = 0;\n\n\t/* Warn if this interrupt is not activated but try nevertheless */\n\tWARN_ON_ONCE(!irqd_is_activated(d));\n\n\tif (d->chip->irq_startup) {\n\t\tret = d->chip->irq_startup(d);\n\t\tirq_state_clr_disabled(desc);\n\t\tirq_state_clr_masked(desc);\n\t} else {\n\t\tirq_enable(desc);\n\t}\n\tirq_state_set_started(desc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_do_set_affinity",
          "args": [
            "d",
            "aff",
            "false"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "irq_do_set_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "220-281",
          "snippet": "int irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t\tbool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tint ret;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If this is a managed interrupt and housekeeping is enabled on\n\t * it check whether the requested affinity mask intersects with\n\t * a housekeeping CPU. If so, then remove the isolated CPUs from\n\t * the mask and just keep the housekeeping CPU(s). This prevents\n\t * the affinity setter from routing the interrupt to an isolated\n\t * CPU to avoid that I/O submitted from a housekeeping CPU causes\n\t * interrupts on an isolated one.\n\t *\n\t * If the masks do not intersect or include online CPU(s) then\n\t * keep the requested mask. The isolated target CPUs are only\n\t * receiving interrupts when the I/O operation was submitted\n\t * directly from them.\n\t *\n\t * If all housekeeping CPUs in the affinity mask are offline, the\n\t * interrupt will be migrated by the CPU hotplug code once a\n\t * housekeeping CPU which belongs to the affinity mask comes\n\t * online.\n\t */\n\tif (irqd_affinity_is_managed(data) &&\n\t    housekeeping_enabled(HK_FLAG_MANAGED_IRQ)) {\n\t\tconst struct cpumask *hk_mask, *prog_mask;\n\n\t\tstatic DEFINE_RAW_SPINLOCK(tmp_mask_lock);\n\t\tstatic struct cpumask tmp_mask;\n\n\t\thk_mask = housekeeping_cpumask(HK_FLAG_MANAGED_IRQ);\n\n\t\traw_spin_lock(&tmp_mask_lock);\n\t\tcpumask_and(&tmp_mask, mask, hk_mask);\n\t\tif (!cpumask_intersects(&tmp_mask, cpu_online_mask))\n\t\t\tprog_mask = mask;\n\t\telse\n\t\t\tprog_mask = &tmp_mask;\n\t\tret = chip->irq_set_affinity(data, prog_mask, force);\n\t\traw_spin_unlock(&tmp_mask_lock);\n\t} else {\n\t\tret = chip->irq_set_affinity(data, mask, force);\n\t}\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\t\tfallthrough;\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tirq_validate_effective_affinity(data);\n\t\tirq_set_thread_affinity(desc);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t\tbool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tint ret;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If this is a managed interrupt and housekeeping is enabled on\n\t * it check whether the requested affinity mask intersects with\n\t * a housekeeping CPU. If so, then remove the isolated CPUs from\n\t * the mask and just keep the housekeeping CPU(s). This prevents\n\t * the affinity setter from routing the interrupt to an isolated\n\t * CPU to avoid that I/O submitted from a housekeeping CPU causes\n\t * interrupts on an isolated one.\n\t *\n\t * If the masks do not intersect or include online CPU(s) then\n\t * keep the requested mask. The isolated target CPUs are only\n\t * receiving interrupts when the I/O operation was submitted\n\t * directly from them.\n\t *\n\t * If all housekeeping CPUs in the affinity mask are offline, the\n\t * interrupt will be migrated by the CPU hotplug code once a\n\t * housekeeping CPU which belongs to the affinity mask comes\n\t * online.\n\t */\n\tif (irqd_affinity_is_managed(data) &&\n\t    housekeeping_enabled(HK_FLAG_MANAGED_IRQ)) {\n\t\tconst struct cpumask *hk_mask, *prog_mask;\n\n\t\tstatic DEFINE_RAW_SPINLOCK(tmp_mask_lock);\n\t\tstatic struct cpumask tmp_mask;\n\n\t\thk_mask = housekeeping_cpumask(HK_FLAG_MANAGED_IRQ);\n\n\t\traw_spin_lock(&tmp_mask_lock);\n\t\tcpumask_and(&tmp_mask, mask, hk_mask);\n\t\tif (!cpumask_intersects(&tmp_mask, cpu_online_mask))\n\t\t\tprog_mask = mask;\n\t\telse\n\t\t\tprog_mask = &tmp_mask;\n\t\tret = chip->irq_set_affinity(data, prog_mask, force);\n\t\traw_spin_unlock(&tmp_mask_lock);\n\t} else {\n\t\tret = chip->irq_set_affinity(data, mask, force);\n\t}\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\t\tfallthrough;\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tirq_validate_effective_affinity(data);\n\t\tirq_set_thread_affinity(desc);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_setup_affinity",
          "args": [
            "desc"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "624-627",
          "snippet": "int irq_setup_affinity(struct irq_desc *desc)\n{\n\treturn irq_select_affinity(irq_desc_get_irq(desc));\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_setup_affinity(struct irq_desc *desc)\n{\n\treturn irq_select_affinity(irq_desc_get_irq(desc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_startup_managed",
          "args": [
            "desc",
            "aff",
            "force"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_startup_managed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "229-233",
          "snippet": "static __always_inline int\n__irq_startup_managed(struct irq_desc *desc, struct cpumask *aff, bool force)\n{\n\treturn IRQ_STARTUP_NORMAL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic __always_inline int\n__irq_startup_managed(struct irq_desc *desc, struct cpumask *aff, bool force)\n{\n\treturn IRQ_STARTUP_NORMAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_enable",
          "args": [
            "desc"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "irq_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "335-348",
          "snippet": "void irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_started",
          "args": [
            "d"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_affinity_mask",
          "args": [
            "d"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_startup(struct irq_desc *desc, bool resend, bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct cpumask *aff = irq_data_get_affinity_mask(d);\n\tint ret = 0;\n\n\tdesc->depth = 0;\n\n\tif (irqd_is_started(d)) {\n\t\tirq_enable(desc);\n\t} else {\n\t\tswitch (__irq_startup_managed(desc, aff, force)) {\n\t\tcase IRQ_STARTUP_NORMAL:\n\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tret = __irq_startup(desc);\n\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_MANAGED:\n\t\t\tirq_do_set_affinity(d, aff, false);\n\t\t\tret = __irq_startup(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_ABORT:\n\t\t\tirqd_set_managed_shutdown(d);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (resend)\n\t\tcheck_irq_resend(desc, false);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__irq_startup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "236-253",
    "snippet": "static int __irq_startup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tint ret = 0;\n\n\t/* Warn if this interrupt is not activated but try nevertheless */\n\tWARN_ON_ONCE(!irqd_is_activated(d));\n\n\tif (d->chip->irq_startup) {\n\t\tret = d->chip->irq_startup(d);\n\t\tirq_state_clr_disabled(desc);\n\t\tirq_state_clr_masked(desc);\n\t} else {\n\t\tirq_enable(desc);\n\t}\n\tirq_state_set_started(desc);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_state_set_started",
          "args": [
            "desc"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_set_started",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "181-184",
          "snippet": "static void irq_state_set_started(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_STARTED);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void irq_state_set_started(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_STARTED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_enable",
          "args": [
            "desc"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "irq_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "335-348",
          "snippet": "void irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_state_clr_masked",
          "args": [
            "desc"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_clr_masked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "171-174",
          "snippet": "static void irq_state_clr_masked(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void irq_state_clr_masked(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_state_clr_disabled",
          "args": [
            "desc"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_clr_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "166-169",
          "snippet": "static void irq_state_clr_disabled(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_DISABLED);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void irq_state_clr_disabled(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_DISABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->chip->irq_startup",
          "args": [
            "d"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!irqd_is_activated(d)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_is_activated",
          "args": [
            "d"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic int __irq_startup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tint ret = 0;\n\n\t/* Warn if this interrupt is not activated but try nevertheless */\n\tWARN_ON_ONCE(!irqd_is_activated(d));\n\n\tif (d->chip->irq_startup) {\n\t\tret = d->chip->irq_startup(d);\n\t\tirq_state_clr_disabled(desc);\n\t\tirq_state_clr_masked(desc);\n\t} else {\n\t\tirq_enable(desc);\n\t}\n\tirq_state_set_started(desc);\n\treturn ret;\n}"
  },
  {
    "function_name": "__irq_startup_managed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "229-233",
    "snippet": "static __always_inline int\n__irq_startup_managed(struct irq_desc *desc, struct cpumask *aff, bool force)\n{\n\treturn IRQ_STARTUP_NORMAL;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic __always_inline int\n__irq_startup_managed(struct irq_desc *desc, struct cpumask *aff, bool force)\n{\n\treturn IRQ_STARTUP_NORMAL;\n}"
  },
  {
    "function_name": "__irq_startup_managed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "193-227",
    "snippet": "static int\n__irq_startup_managed(struct irq_desc *desc, struct cpumask *aff, bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\tif (!irqd_affinity_is_managed(d))\n\t\treturn IRQ_STARTUP_NORMAL;\n\n\tirqd_clr_managed_shutdown(d);\n\n\tif (cpumask_any_and(aff, cpu_online_mask) >= nr_cpu_ids) {\n\t\t/*\n\t\t * Catch code which fiddles with enable_irq() on a managed\n\t\t * and potentially shutdown IRQ. Chained interrupt\n\t\t * installment or irq auto probing should not happen on\n\t\t * managed irqs either.\n\t\t */\n\t\tif (WARN_ON_ONCE(force))\n\t\t\treturn IRQ_STARTUP_ABORT;\n\t\t/*\n\t\t * The interrupt was requested, but there is no online CPU\n\t\t * in it's affinity mask. Put it into managed shutdown\n\t\t * state and let the cpu hotplug mechanism start it up once\n\t\t * a CPU in the mask becomes available.\n\t\t */\n\t\treturn IRQ_STARTUP_ABORT;\n\t}\n\t/*\n\t * Managed interrupts have reserved resources, so this should not\n\t * happen.\n\t */\n\tif (WARN_ON(irq_domain_activate_irq(d, false)))\n\t\treturn IRQ_STARTUP_ABORT;\n\treturn IRQ_STARTUP_MANAGED;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __irq_disable(struct irq_desc *desc, bool mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irq_domain_activate_irq(d, false)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_activate_irq",
          "args": [
            "d",
            "false"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_activate_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "465-469",
          "snippet": "static inline int irq_domain_activate_irq(struct irq_data *data, bool reserve)\n{\n\tirqd_set_activated(data);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline int irq_domain_activate_irq(struct irq_data *data, bool reserve)\n{\n\tirqd_set_activated(data);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "force"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "aff",
            "cpu_online_mask"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_clr_managed_shutdown",
          "args": [
            "d"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clr_managed_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "218-221",
          "snippet": "static inline void irqd_clr_managed_shutdown(struct irq_data *d)\n{\n\t__irqd_to_state(d) &= ~IRQD_MANAGED_SHUTDOWN;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clr_managed_shutdown(struct irq_data *d)\n{\n\t__irqd_to_state(d) &= ~IRQD_MANAGED_SHUTDOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_affinity_is_managed",
          "args": [
            "d"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nstatic int\n__irq_startup_managed(struct irq_desc *desc, struct cpumask *aff, bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\tif (!irqd_affinity_is_managed(d))\n\t\treturn IRQ_STARTUP_NORMAL;\n\n\tirqd_clr_managed_shutdown(d);\n\n\tif (cpumask_any_and(aff, cpu_online_mask) >= nr_cpu_ids) {\n\t\t/*\n\t\t * Catch code which fiddles with enable_irq() on a managed\n\t\t * and potentially shutdown IRQ. Chained interrupt\n\t\t * installment or irq auto probing should not happen on\n\t\t * managed irqs either.\n\t\t */\n\t\tif (WARN_ON_ONCE(force))\n\t\t\treturn IRQ_STARTUP_ABORT;\n\t\t/*\n\t\t * The interrupt was requested, but there is no online CPU\n\t\t * in it's affinity mask. Put it into managed shutdown\n\t\t * state and let the cpu hotplug mechanism start it up once\n\t\t * a CPU in the mask becomes available.\n\t\t */\n\t\treturn IRQ_STARTUP_ABORT;\n\t}\n\t/*\n\t * Managed interrupts have reserved resources, so this should not\n\t * happen.\n\t */\n\tif (WARN_ON(irq_domain_activate_irq(d, false)))\n\t\treturn IRQ_STARTUP_ABORT;\n\treturn IRQ_STARTUP_MANAGED;\n}"
  },
  {
    "function_name": "irq_state_set_started",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "181-184",
    "snippet": "static void irq_state_set_started(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_STARTED);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "&desc->irq_data",
            "IRQD_IRQ_STARTED"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void irq_state_set_started(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_STARTED);\n}"
  },
  {
    "function_name": "irq_state_clr_started",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "176-179",
    "snippet": "static void irq_state_clr_started(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_STARTED);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "&desc->irq_data",
            "IRQD_IRQ_STARTED"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void irq_state_clr_started(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_STARTED);\n}"
  },
  {
    "function_name": "irq_state_clr_masked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "171-174",
    "snippet": "static void irq_state_clr_masked(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "&desc->irq_data",
            "IRQD_IRQ_MASKED"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void irq_state_clr_masked(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);\n}"
  },
  {
    "function_name": "irq_state_clr_disabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "166-169",
    "snippet": "static void irq_state_clr_disabled(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_DISABLED);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "&desc->irq_data",
            "IRQD_IRQ_DISABLED"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void irq_state_clr_disabled(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_DISABLED);\n}"
  },
  {
    "function_name": "irq_get_irq_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "158-163",
    "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
  },
  {
    "function_name": "irq_set_chip_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "145-155",
    "snippet": "int irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_set_msi_desc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "133-136",
    "snippet": "int irq_set_msi_desc(unsigned int irq, struct msi_desc *entry)\n{\n\treturn irq_set_msi_desc_off(irq, 0, entry);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_set_msi_desc_off",
          "args": [
            "irq",
            "0",
            "entry"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_msi_desc_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "111-124",
          "snippet": "int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,\n\t\t\t struct msi_desc *entry)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.msi_desc = entry;\n\tif (entry && !irq_offset)\n\t\tentry->irq = irq_base;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,\n\t\t\t struct msi_desc *entry)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.msi_desc = entry;\n\tif (entry && !irq_offset)\n\t\tentry->irq = irq_base;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_msi_desc(unsigned int irq, struct msi_desc *entry)\n{\n\treturn irq_set_msi_desc_off(irq, 0, entry);\n}"
  },
  {
    "function_name": "irq_set_msi_desc_off",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "111-124",
    "snippet": "int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,\n\t\t\t struct msi_desc *entry)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.msi_desc = entry;\n\tif (entry && !irq_offset)\n\t\tentry->irq = irq_base;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq_base + irq_offset",
            "&flags",
            "IRQ_GET_DESC_CHECK_GLOBAL"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,\n\t\t\t struct msi_desc *entry)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.msi_desc = entry;\n\tif (entry && !irq_offset)\n\t\tentry->irq = irq_base;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_set_handler_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "90-100",
    "snippet": "int irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_set_irq_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "68-80",
    "snippet": "int irq_set_irq_type(unsigned int irq, unsigned int type)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\tint ret = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tret = __irq_set_trigger(desc, type);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_busunlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_busunlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "175-179",
          "snippet": "static inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_set_trigger",
          "args": [
            "desc",
            "type"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_set_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "939-992",
          "snippet": "int __irq_set_trigger(struct irq_desc *desc, unsigned long flags)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\tint ret, unmask = 0;\n\n\tif (!chip || !chip->irq_set_type) {\n\t\t/*\n\t\t * IRQF_TRIGGER_* but the PIC does not support multiple\n\t\t * flow-types?\n\t\t */\n\t\tpr_debug(\"No set_type function for IRQ %d (%s)\\n\",\n\t\t\t irq_desc_get_irq(desc),\n\t\t\t chip ? (chip->name ? : \"unknown\") : \"unknown\");\n\t\treturn 0;\n\t}\n\n\tif (chip->flags & IRQCHIP_SET_TYPE_MASKED) {\n\t\tif (!irqd_irq_masked(&desc->irq_data))\n\t\t\tmask_irq(desc);\n\t\tif (!irqd_irq_disabled(&desc->irq_data))\n\t\t\tunmask = 1;\n\t}\n\n\t/* Mask all flags except trigger mode */\n\tflags &= IRQ_TYPE_SENSE_MASK;\n\tret = chip->irq_set_type(&desc->irq_data, flags);\n\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tirqd_clear(&desc->irq_data, IRQD_TRIGGER_MASK);\n\t\tirqd_set(&desc->irq_data, flags);\n\t\tfallthrough;\n\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tflags = irqd_get_trigger_type(&desc->irq_data);\n\t\tirq_settings_set_trigger_mask(desc, flags);\n\t\tirqd_clear(&desc->irq_data, IRQD_LEVEL);\n\t\tirq_settings_clr_level(desc);\n\t\tif (flags & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tirq_settings_set_level(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Setting trigger mode %lu for irq %u failed (%pS)\\n\",\n\t\t       flags, irq_desc_get_irq(desc), chip->irq_set_type);\n\t}\n\tif (unmask)\n\t\tunmask_irq(desc);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint __irq_set_trigger(struct irq_desc *desc, unsigned long flags)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\tint ret, unmask = 0;\n\n\tif (!chip || !chip->irq_set_type) {\n\t\t/*\n\t\t * IRQF_TRIGGER_* but the PIC does not support multiple\n\t\t * flow-types?\n\t\t */\n\t\tpr_debug(\"No set_type function for IRQ %d (%s)\\n\",\n\t\t\t irq_desc_get_irq(desc),\n\t\t\t chip ? (chip->name ? : \"unknown\") : \"unknown\");\n\t\treturn 0;\n\t}\n\n\tif (chip->flags & IRQCHIP_SET_TYPE_MASKED) {\n\t\tif (!irqd_irq_masked(&desc->irq_data))\n\t\t\tmask_irq(desc);\n\t\tif (!irqd_irq_disabled(&desc->irq_data))\n\t\t\tunmask = 1;\n\t}\n\n\t/* Mask all flags except trigger mode */\n\tflags &= IRQ_TYPE_SENSE_MASK;\n\tret = chip->irq_set_type(&desc->irq_data, flags);\n\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tirqd_clear(&desc->irq_data, IRQD_TRIGGER_MASK);\n\t\tirqd_set(&desc->irq_data, flags);\n\t\tfallthrough;\n\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tflags = irqd_get_trigger_type(&desc->irq_data);\n\t\tirq_settings_set_trigger_mask(desc, flags);\n\t\tirqd_clear(&desc->irq_data, IRQD_LEVEL);\n\t\tirq_settings_clr_level(desc);\n\t\tif (flags & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tirq_settings_set_level(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Setting trigger mode %lu for irq %u failed (%pS)\\n\",\n\t\t       flags, irq_desc_get_irq(desc), chip->irq_set_type);\n\t}\n\tif (unmask)\n\t\tunmask_irq(desc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_buslock",
          "args": [
            "irq",
            "&flags",
            "IRQ_GET_DESC_CHECK_GLOBAL"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_buslock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "169-173",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_irq_type(unsigned int irq, unsigned int type)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\tint ret = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tret = __irq_set_trigger(desc, type);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_set_chip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "41-60",
    "snippet": "int irq_set_chip(unsigned int irq, struct irq_chip *chip)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!chip)\n\t\tchip = &no_irq_chip;\n\n\tdesc->irq_data.chip = chip;\n\tirq_put_desc_unlock(desc, flags);\n\t/*\n\t * For !CONFIG_SPARSE_IRQ make the irq show up in\n\t * allocated_irqs.\n\t */\n\tirq_mark_irq(irq);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_mark_irq",
          "args": [
            "irq"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "irq_mark_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "95-95",
          "snippet": "static inline void irq_mark_irq(unsigned int irq) { }",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool irq_can_set_affinity_usr(unsigned int irq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern bool irq_can_set_affinity_usr(unsigned int irq);\n\nstatic inline void irq_mark_irq(unsigned int irq) { }"
        }
      },
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_chip(unsigned int irq, struct irq_chip *chip)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!chip)\n\t\tchip = &no_irq_chip;\n\n\tdesc->irq_data.chip = chip;\n\tirq_put_desc_unlock(desc, flags);\n\t/*\n\t * For !CONFIG_SPARSE_IRQ make the irq show up in\n\t * allocated_irqs.\n\t */\n\tirq_mark_irq(irq);\n\treturn 0;\n}"
  },
  {
    "function_name": "bad_chained_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
    "lines": "22-26",
    "snippet": "static irqreturn_t bad_chained_irq(int irq, void *dev_id)\n{\n\tWARN_ONCE(1, \"Chained irq %d should not call an action\\n\", irq);\n\treturn IRQ_NONE;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/msi.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Chained irq %d should not call an action\\n\"",
            "irq"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic irqreturn_t bad_chained_irq(int irq, void *dev_id)\n{\n\tWARN_ONCE(1, \"Chained irq %d should not call an action\\n\", irq);\n\treturn IRQ_NONE;\n}"
  }
]