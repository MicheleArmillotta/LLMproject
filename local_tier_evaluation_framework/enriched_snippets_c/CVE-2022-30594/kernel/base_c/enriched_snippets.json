[
  {
    "function_name": "gcov_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/base.c",
    "lines": "133-136",
    "snippet": "static int __init gcov_init(void)\n{\n\treturn register_module_notifier(&gcov_nb);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&gcov_nb"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "307-310",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int __init gcov_init(void)\n{\n\treturn register_module_notifier(&gcov_nb);\n}"
  },
  {
    "function_name": "gcov_module_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/base.c",
    "lines": "103-127",
    "snippet": "static int gcov_module_notifier(struct notifier_block *nb, unsigned long event,\n\t\t\t\tvoid *data)\n{\n\tstruct module *mod = data;\n\tstruct gcov_info *info = NULL;\n\tstruct gcov_info *prev = NULL;\n\n\tif (event != MODULE_STATE_GOING)\n\t\treturn NOTIFY_OK;\n\tmutex_lock(&gcov_lock);\n\n\t/* Remove entries located in module from linked list. */\n\twhile ((info = gcov_info_next(info))) {\n\t\tif (gcov_info_within_module(info, mod)) {\n\t\t\tgcov_info_unlink(prev, info);\n\t\t\tif (gcov_events_enabled)\n\t\t\t\tgcov_event(GCOV_REMOVE, info);\n\t\t} else\n\t\t\tprev = info;\n\t}\n\n\tmutex_unlock(&gcov_lock);\n\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int gcov_events_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&gcov_lock"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_event",
          "args": [
            "GCOV_REMOVE",
            "info"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "838-861",
          "snippet": "void gcov_event(enum gcov_action action, struct gcov_info *info)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tswitch (action) {\n\tcase GCOV_ADD:\n\t\tif (node)\n\t\t\tadd_info(node, info);\n\t\telse\n\t\t\tadd_node(info);\n\t\tbreak;\n\tcase GCOV_REMOVE:\n\t\tif (node)\n\t\t\tremove_info(node, info);\n\t\telse {\n\t\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t\tbreak;\n\t}\n\tmutex_unlock(&node_lock);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic void remove_node(struct gcov_node *node);\n\nvoid gcov_event(enum gcov_action action, struct gcov_info *info)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tswitch (action) {\n\tcase GCOV_ADD:\n\t\tif (node)\n\t\t\tadd_info(node, info);\n\t\telse\n\t\t\tadd_node(info);\n\t\tbreak;\n\tcase GCOV_REMOVE:\n\t\tif (node)\n\t\t\tremove_info(node, info);\n\t\telse {\n\t\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t\tbreak;\n\t}\n\tmutex_unlock(&node_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_unlink",
          "args": [
            "prev",
            "info"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_unlink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "144-150",
          "snippet": "void gcov_info_unlink(struct gcov_info *prev, struct gcov_info *info)\n{\n\tif (prev)\n\t\tprev->next = info->next;\n\telse\n\t\tgcov_info_head = info->next;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_info *gcov_info_head;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct gcov_info *gcov_info_head;\n\nvoid gcov_info_unlink(struct gcov_info *prev, struct gcov_info *info)\n{\n\tif (prev)\n\t\tprev->next = info->next;\n\telse\n\t\tgcov_info_head = info->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_within_module",
          "args": [
            "info",
            "mod"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_within_module",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "159-162",
          "snippet": "bool gcov_info_within_module(struct gcov_info *info, struct module *mod)\n{\n\treturn within_module((unsigned long)info, mod);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nbool gcov_info_within_module(struct gcov_info *info, struct module *mod)\n{\n\treturn within_module((unsigned long)info, mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_next",
          "args": [
            "info"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "121-127",
          "snippet": "struct gcov_info *gcov_info_next(struct gcov_info *info)\n{\n\tif (!info)\n\t\treturn gcov_info_head;\n\n\treturn info->next;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_info *gcov_info_head;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct gcov_info *gcov_info_head;\n\nstruct gcov_info *gcov_info_next(struct gcov_info *info)\n{\n\tif (!info)\n\t\treturn gcov_info_head;\n\n\treturn info->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&gcov_lock"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nint gcov_events_enabled;\n\nstatic int gcov_module_notifier(struct notifier_block *nb, unsigned long event,\n\t\t\t\tvoid *data)\n{\n\tstruct module *mod = data;\n\tstruct gcov_info *info = NULL;\n\tstruct gcov_info *prev = NULL;\n\n\tif (event != MODULE_STATE_GOING)\n\t\treturn NOTIFY_OK;\n\tmutex_lock(&gcov_lock);\n\n\t/* Remove entries located in module from linked list. */\n\twhile ((info = gcov_info_next(info))) {\n\t\tif (gcov_info_within_module(info, mod)) {\n\t\t\tgcov_info_unlink(prev, info);\n\t\t\tif (gcov_events_enabled)\n\t\t\t\tgcov_event(GCOV_REMOVE, info);\n\t\t} else\n\t\t\tprev = info;\n\t}\n\n\tmutex_unlock(&gcov_lock);\n\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "store_gcov_u64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/base.c",
    "lines": "87-99",
    "snippet": "size_t store_gcov_u64(void *buffer, size_t off, u64 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\n\t\tdata[0] = (v & 0xffffffffUL);\n\t\tdata[1] = (v >> 32);\n\t}\n\n\treturn sizeof(*data) * 2;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nsize_t store_gcov_u64(void *buffer, size_t off, u64 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\n\t\tdata[0] = (v & 0xffffffffUL);\n\t\tdata[1] = (v >> 32);\n\t}\n\n\treturn sizeof(*data) * 2;\n}"
  },
  {
    "function_name": "store_gcov_u32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/base.c",
    "lines": "63-73",
    "snippet": "size_t store_gcov_u32(void *buffer, size_t off, u32 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\t\t*data = v;\n\t}\n\n\treturn sizeof(*data);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nsize_t store_gcov_u32(void *buffer, size_t off, u32 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\t\t*data = v;\n\t}\n\n\treturn sizeof(*data);\n}"
  },
  {
    "function_name": "gcov_enable_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/base.c",
    "lines": "36-50",
    "snippet": "void gcov_enable_events(void)\n{\n\tstruct gcov_info *info = NULL;\n\n\tmutex_lock(&gcov_lock);\n\tgcov_events_enabled = 1;\n\n\t/* Perform event callback for previously registered entries. */\n\twhile ((info = gcov_info_next(info))) {\n\t\tgcov_event(GCOV_ADD, info);\n\t\tcond_resched();\n\t}\n\n\tmutex_unlock(&gcov_lock);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int gcov_events_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&gcov_lock"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_event",
          "args": [
            "GCOV_ADD",
            "info"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "838-861",
          "snippet": "void gcov_event(enum gcov_action action, struct gcov_info *info)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tswitch (action) {\n\tcase GCOV_ADD:\n\t\tif (node)\n\t\t\tadd_info(node, info);\n\t\telse\n\t\t\tadd_node(info);\n\t\tbreak;\n\tcase GCOV_REMOVE:\n\t\tif (node)\n\t\t\tremove_info(node, info);\n\t\telse {\n\t\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t\tbreak;\n\t}\n\tmutex_unlock(&node_lock);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic void remove_node(struct gcov_node *node);\n\nvoid gcov_event(enum gcov_action action, struct gcov_info *info)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tswitch (action) {\n\tcase GCOV_ADD:\n\t\tif (node)\n\t\t\tadd_info(node, info);\n\t\telse\n\t\t\tadd_node(info);\n\t\tbreak;\n\tcase GCOV_REMOVE:\n\t\tif (node)\n\t\t\tremove_info(node, info);\n\t\telse {\n\t\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t\tbreak;\n\t}\n\tmutex_unlock(&node_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_next",
          "args": [
            "info"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "121-127",
          "snippet": "struct gcov_info *gcov_info_next(struct gcov_info *info)\n{\n\tif (!info)\n\t\treturn gcov_info_head;\n\n\treturn info->next;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_info *gcov_info_head;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct gcov_info *gcov_info_head;\n\nstruct gcov_info *gcov_info_next(struct gcov_info *info)\n{\n\tif (!info)\n\t\treturn gcov_info_head;\n\n\treturn info->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&gcov_lock"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nint gcov_events_enabled;\n\nvoid gcov_enable_events(void)\n{\n\tstruct gcov_info *info = NULL;\n\n\tmutex_lock(&gcov_lock);\n\tgcov_events_enabled = 1;\n\n\t/* Perform event callback for previously registered entries. */\n\twhile ((info = gcov_info_next(info))) {\n\t\tgcov_event(GCOV_ADD, info);\n\t\tcond_resched();\n\t}\n\n\tmutex_unlock(&gcov_lock);\n}"
  }
]