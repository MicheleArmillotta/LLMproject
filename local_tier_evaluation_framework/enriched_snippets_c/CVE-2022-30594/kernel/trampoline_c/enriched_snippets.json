[
  {
    "function_name": "init_trampolines",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "655-662",
    "snippet": "static int __init init_trampolines(void)\n{\n\tint i;\n\n\tfor (i = 0; i < TRAMPOLINE_TABLE_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&trampoline_table[i]);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [
      "#define TRAMPOLINE_TABLE_SIZE (1 << TRAMPOLINE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head trampoline_table[TRAMPOLINE_TABLE_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&trampoline_table[i]"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\n#define TRAMPOLINE_TABLE_SIZE (1 << TRAMPOLINE_HASH_BITS)\n\nstatic struct hlist_head trampoline_table[TRAMPOLINE_TABLE_SIZE];\n\nstatic int __init init_trampolines(void)\n{\n\tint i;\n\n\tfor (i = 0; i < TRAMPOLINE_TABLE_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&trampoline_table[i]);\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_prepare_bpf_trampoline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "646-653",
    "snippet": "int __weak\narch_prepare_bpf_trampoline(struct bpf_tramp_image *tr, void *image, void *image_end,\n\t\t\t    const struct btf_func_model *m, u32 flags,\n\t\t\t    struct bpf_tramp_progs *tprogs,\n\t\t\t    void *orig_call)\n{\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nint __weak\narch_prepare_bpf_trampoline(struct bpf_tramp_image *tr, void *image, void *image_end,\n\t\t\t    const struct btf_func_model *m, u32 flags,\n\t\t\t    struct bpf_tramp_progs *tprogs,\n\t\t\t    void *orig_call)\n{\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "__bpf_tramp_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "641-644",
    "snippet": "void notrace __bpf_tramp_exit(struct bpf_tramp_image *tr)\n{\n\tpercpu_ref_put(&tr->pcref);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_put",
          "args": [
            "&tr->pcref"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nvoid notrace __bpf_tramp_exit(struct bpf_tramp_image *tr)\n{\n\tpercpu_ref_put(&tr->pcref);\n}"
  },
  {
    "function_name": "__bpf_tramp_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "636-639",
    "snippet": "void notrace __bpf_tramp_enter(struct bpf_tramp_image *tr)\n{\n\tpercpu_ref_get(&tr->pcref);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_get",
          "args": [
            "&tr->pcref"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nvoid notrace __bpf_tramp_enter(struct bpf_tramp_image *tr)\n{\n\tpercpu_ref_get(&tr->pcref);\n}"
  },
  {
    "function_name": "__bpf_prog_exit_sleepable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "628-634",
    "snippet": "void notrace __bpf_prog_exit_sleepable(struct bpf_prog *prog, u64 start)\n{\n\tupdate_prog_stats(prog, start);\n\t__this_cpu_dec(*(prog->active));\n\tmigrate_enable();\n\trcu_read_unlock_trace();\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline u64"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_trace",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_enable",
          "args": [],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2178-2206",
          "snippet": "void migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "*(prog->active)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_prog_stats",
          "args": [
            "prog",
            "start"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "update_prog_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "585-605",
          "snippet": "static void notrace update_prog_stats(struct bpf_prog *prog,\n\t\t\t\t      u64 start)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key) &&\n\t    /* static_key could be enabled in __bpf_prog_enter*\n\t     * and disabled in __bpf_prog_exit*.\n\t     * And vice versa.\n\t     * Hence check that 'start' is valid.\n\t     */\n\t    start > NO_START_TIME) {\n\t\tunsigned long flags;\n\n\t\tstats = this_cpu_ptr(prog->stats);\n\t\tflags = u64_stats_update_begin_irqsave(&stats->syncp);\n\t\tu64_stats_inc(&stats->cnt);\n\t\tu64_stats_add(&stats->nsecs, sched_clock() - start);\n\t\tu64_stats_update_end_irqrestore(&stats->syncp, flags);\n\t}\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define NO_START_TIME 1"
          ],
          "globals_used": [
            "static __always_inline u64"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\n#define NO_START_TIME 1\n\nstatic __always_inline u64;\n\nstatic void notrace update_prog_stats(struct bpf_prog *prog,\n\t\t\t\t      u64 start)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key) &&\n\t    /* static_key could be enabled in __bpf_prog_enter*\n\t     * and disabled in __bpf_prog_exit*.\n\t     * And vice versa.\n\t     * Hence check that 'start' is valid.\n\t     */\n\t    start > NO_START_TIME) {\n\t\tunsigned long flags;\n\n\t\tstats = this_cpu_ptr(prog->stats);\n\t\tflags = u64_stats_update_begin_irqsave(&stats->syncp);\n\t\tu64_stats_inc(&stats->cnt);\n\t\tu64_stats_add(&stats->nsecs, sched_clock() - start);\n\t\tu64_stats_update_end_irqrestore(&stats->syncp, flags);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic __always_inline u64;\n\nvoid notrace __bpf_prog_exit_sleepable(struct bpf_prog *prog, u64 start)\n{\n\tupdate_prog_stats(prog, start);\n\t__this_cpu_dec(*(prog->active));\n\tmigrate_enable();\n\trcu_read_unlock_trace();\n}"
  },
  {
    "function_name": "__bpf_prog_enter_sleepable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "616-626",
    "snippet": "u64 notrace __bpf_prog_enter_sleepable(struct bpf_prog *prog)\n{\n\trcu_read_lock_trace();\n\tmigrate_disable();\n\tmight_fault();\n\tif (unlikely(__this_cpu_inc_return(*(prog->active)) != 1)) {\n\t\tinc_misses_counter(prog);\n\t\treturn 0;\n\t}\n\treturn bpf_prog_start_time();\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline u64"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_start_time",
          "args": [],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_start_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "538-548",
          "snippet": "notrace bpf_prog_start_time(void)\n{\n\tu64 start = NO_START_TIME;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key)) {\n\t\tstart = sched_clock();\n\t\tif (unlikely(!start))\n\t\t\tstart = NO_START_TIME;\n\t}\n\treturn start;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define NO_START_TIME 1"
          ],
          "globals_used": [
            "static __always_inline u64"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\n#define NO_START_TIME 1\n\nstatic __always_inline u64;\n\nnotrace bpf_prog_start_time(void)\n{\n\tu64 start = NO_START_TIME;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key)) {\n\t\tstart = sched_clock();\n\t\tif (unlikely(!start))\n\t\t\tstart = NO_START_TIME;\n\t}\n\treturn start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_misses_counter",
          "args": [
            "prog"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "inc_misses_counter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "550-558",
          "snippet": "static void notrace inc_misses_counter(struct bpf_prog *prog)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tstats = this_cpu_ptr(prog->stats);\n\tu64_stats_update_begin(&stats->syncp);\n\tu64_stats_inc(&stats->misses);\n\tu64_stats_update_end(&stats->syncp);\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void notrace inc_misses_counter(struct bpf_prog *prog)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tstats = this_cpu_ptr(prog->stats);\n\tu64_stats_update_begin(&stats->syncp);\n\tu64_stats_inc(&stats->misses);\n\tu64_stats_update_end(&stats->syncp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__this_cpu_inc_return(*(prog->active)) != 1"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "*(prog->active)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_fault",
          "args": [],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_disable",
          "args": [],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2162-2175",
          "snippet": "void migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_trace",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic __always_inline u64;\n\nu64 notrace __bpf_prog_enter_sleepable(struct bpf_prog *prog)\n{\n\trcu_read_lock_trace();\n\tmigrate_disable();\n\tmight_fault();\n\tif (unlikely(__this_cpu_inc_return(*(prog->active)) != 1)) {\n\t\tinc_misses_counter(prog);\n\t\treturn 0;\n\t}\n\treturn bpf_prog_start_time();\n}"
  },
  {
    "function_name": "__bpf_prog_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "607-614",
    "snippet": "void notrace __bpf_prog_exit(struct bpf_prog *prog, u64 start)\n\t__releases(RCU)\n{\n\tupdate_prog_stats(prog, start);\n\t__this_cpu_dec(*(prog->active));\n\tmigrate_enable();\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline u64"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_enable",
          "args": [],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2178-2206",
          "snippet": "void migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "*(prog->active)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_prog_stats",
          "args": [
            "prog",
            "start"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "update_prog_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "585-605",
          "snippet": "static void notrace update_prog_stats(struct bpf_prog *prog,\n\t\t\t\t      u64 start)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key) &&\n\t    /* static_key could be enabled in __bpf_prog_enter*\n\t     * and disabled in __bpf_prog_exit*.\n\t     * And vice versa.\n\t     * Hence check that 'start' is valid.\n\t     */\n\t    start > NO_START_TIME) {\n\t\tunsigned long flags;\n\n\t\tstats = this_cpu_ptr(prog->stats);\n\t\tflags = u64_stats_update_begin_irqsave(&stats->syncp);\n\t\tu64_stats_inc(&stats->cnt);\n\t\tu64_stats_add(&stats->nsecs, sched_clock() - start);\n\t\tu64_stats_update_end_irqrestore(&stats->syncp, flags);\n\t}\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define NO_START_TIME 1"
          ],
          "globals_used": [
            "static __always_inline u64"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\n#define NO_START_TIME 1\n\nstatic __always_inline u64;\n\nstatic void notrace update_prog_stats(struct bpf_prog *prog,\n\t\t\t\t      u64 start)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key) &&\n\t    /* static_key could be enabled in __bpf_prog_enter*\n\t     * and disabled in __bpf_prog_exit*.\n\t     * And vice versa.\n\t     * Hence check that 'start' is valid.\n\t     */\n\t    start > NO_START_TIME) {\n\t\tunsigned long flags;\n\n\t\tstats = this_cpu_ptr(prog->stats);\n\t\tflags = u64_stats_update_begin_irqsave(&stats->syncp);\n\t\tu64_stats_inc(&stats->cnt);\n\t\tu64_stats_add(&stats->nsecs, sched_clock() - start);\n\t\tu64_stats_update_end_irqrestore(&stats->syncp, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "RCU"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic __always_inline u64;\n\nvoid notrace __bpf_prog_exit(struct bpf_prog *prog, u64 start)\n\t__releases(RCU)\n{\n\tupdate_prog_stats(prog, start);\n\t__this_cpu_dec(*(prog->active));\n\tmigrate_enable();\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "update_prog_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "585-605",
    "snippet": "static void notrace update_prog_stats(struct bpf_prog *prog,\n\t\t\t\t      u64 start)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key) &&\n\t    /* static_key could be enabled in __bpf_prog_enter*\n\t     * and disabled in __bpf_prog_exit*.\n\t     * And vice versa.\n\t     * Hence check that 'start' is valid.\n\t     */\n\t    start > NO_START_TIME) {\n\t\tunsigned long flags;\n\n\t\tstats = this_cpu_ptr(prog->stats);\n\t\tflags = u64_stats_update_begin_irqsave(&stats->syncp);\n\t\tu64_stats_inc(&stats->cnt);\n\t\tu64_stats_add(&stats->nsecs, sched_clock() - start);\n\t\tu64_stats_update_end_irqrestore(&stats->syncp, flags);\n\t}\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [
      "#define NO_START_TIME 1"
    ],
    "globals_used": [
      "static __always_inline u64"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_stats_update_end_irqrestore",
          "args": [
            "&stats->syncp",
            "flags"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_add",
          "args": [
            "&stats->nsecs",
            "sched_clock() - start"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_stats_inc",
          "args": [
            "&stats->cnt"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_update_begin_irqsave",
          "args": [
            "&stats->syncp"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "prog->stats"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&bpf_stats_enabled_key"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\n#define NO_START_TIME 1\n\nstatic __always_inline u64;\n\nstatic void notrace update_prog_stats(struct bpf_prog *prog,\n\t\t\t\t      u64 start)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key) &&\n\t    /* static_key could be enabled in __bpf_prog_enter*\n\t     * and disabled in __bpf_prog_exit*.\n\t     * And vice versa.\n\t     * Hence check that 'start' is valid.\n\t     */\n\t    start > NO_START_TIME) {\n\t\tunsigned long flags;\n\n\t\tstats = this_cpu_ptr(prog->stats);\n\t\tflags = u64_stats_update_begin_irqsave(&stats->syncp);\n\t\tu64_stats_inc(&stats->cnt);\n\t\tu64_stats_add(&stats->nsecs, sched_clock() - start);\n\t\tu64_stats_update_end_irqrestore(&stats->syncp, flags);\n\t}\n}"
  },
  {
    "function_name": "__bpf_prog_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "573-583",
    "snippet": "u64 notrace __bpf_prog_enter(struct bpf_prog *prog)\n\t__acquires(RCU)\n{\n\trcu_read_lock();\n\tmigrate_disable();\n\tif (unlikely(__this_cpu_inc_return(*(prog->active)) != 1)) {\n\t\tinc_misses_counter(prog);\n\t\treturn 0;\n\t}\n\treturn bpf_prog_start_time();\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline u64"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_start_time",
          "args": [],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_start_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "538-548",
          "snippet": "notrace bpf_prog_start_time(void)\n{\n\tu64 start = NO_START_TIME;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key)) {\n\t\tstart = sched_clock();\n\t\tif (unlikely(!start))\n\t\t\tstart = NO_START_TIME;\n\t}\n\treturn start;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define NO_START_TIME 1"
          ],
          "globals_used": [
            "static __always_inline u64"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\n#define NO_START_TIME 1\n\nstatic __always_inline u64;\n\nnotrace bpf_prog_start_time(void)\n{\n\tu64 start = NO_START_TIME;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key)) {\n\t\tstart = sched_clock();\n\t\tif (unlikely(!start))\n\t\t\tstart = NO_START_TIME;\n\t}\n\treturn start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_misses_counter",
          "args": [
            "prog"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "inc_misses_counter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "550-558",
          "snippet": "static void notrace inc_misses_counter(struct bpf_prog *prog)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tstats = this_cpu_ptr(prog->stats);\n\tu64_stats_update_begin(&stats->syncp);\n\tu64_stats_inc(&stats->misses);\n\tu64_stats_update_end(&stats->syncp);\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void notrace inc_misses_counter(struct bpf_prog *prog)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tstats = this_cpu_ptr(prog->stats);\n\tu64_stats_update_begin(&stats->syncp);\n\tu64_stats_inc(&stats->misses);\n\tu64_stats_update_end(&stats->syncp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__this_cpu_inc_return(*(prog->active)) != 1"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "*(prog->active)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_disable",
          "args": [],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2162-2175",
          "snippet": "void migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic __always_inline u64;\n\nu64 notrace __bpf_prog_enter(struct bpf_prog *prog)\n\t__acquires(RCU)\n{\n\trcu_read_lock();\n\tmigrate_disable();\n\tif (unlikely(__this_cpu_inc_return(*(prog->active)) != 1)) {\n\t\tinc_misses_counter(prog);\n\t\treturn 0;\n\t}\n\treturn bpf_prog_start_time();\n}"
  },
  {
    "function_name": "inc_misses_counter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "550-558",
    "snippet": "static void notrace inc_misses_counter(struct bpf_prog *prog)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tstats = this_cpu_ptr(prog->stats);\n\tu64_stats_update_begin(&stats->syncp);\n\tu64_stats_inc(&stats->misses);\n\tu64_stats_update_end(&stats->syncp);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_stats_update_end",
          "args": [
            "&stats->syncp"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_inc",
          "args": [
            "&stats->misses"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_update_begin",
          "args": [
            "&stats->syncp"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "prog->stats"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void notrace inc_misses_counter(struct bpf_prog *prog)\n{\n\tstruct bpf_prog_stats *stats;\n\n\tstats = this_cpu_ptr(prog->stats);\n\tu64_stats_update_begin(&stats->syncp);\n\tu64_stats_inc(&stats->misses);\n\tu64_stats_update_end(&stats->syncp);\n}"
  },
  {
    "function_name": "bpf_prog_start_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "538-548",
    "snippet": "notrace bpf_prog_start_time(void)\n{\n\tu64 start = NO_START_TIME;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key)) {\n\t\tstart = sched_clock();\n\t\tif (unlikely(!start))\n\t\t\tstart = NO_START_TIME;\n\t}\n\treturn start;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [
      "#define NO_START_TIME 1"
    ],
    "globals_used": [
      "static __always_inline u64"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!start"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&bpf_stats_enabled_key"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\n#define NO_START_TIME 1\n\nstatic __always_inline u64;\n\nnotrace bpf_prog_start_time(void)\n{\n\tu64 start = NO_START_TIME;\n\n\tif (static_branch_unlikely(&bpf_stats_enabled_key)) {\n\t\tstart = sched_clock();\n\t\tif (unlikely(!start))\n\t\t\tstart = NO_START_TIME;\n\t}\n\treturn start;\n}"
  },
  {
    "function_name": "bpf_trampoline_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "513-535",
    "snippet": "void bpf_trampoline_put(struct bpf_trampoline *tr)\n{\n\tif (!tr)\n\t\treturn;\n\tmutex_lock(&trampoline_mutex);\n\tif (!refcount_dec_and_test(&tr->refcnt))\n\t\tgoto out;\n\tWARN_ON_ONCE(mutex_is_locked(&tr->mutex));\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FENTRY])))\n\t\tgoto out;\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FEXIT])))\n\t\tgoto out;\n\t/* This code will be executed even when the last bpf_tramp_image\n\t * is alive. All progs are detached from the trampoline and the\n\t * trampoline image is patched with jmp into epilogue to skip\n\t * fexit progs. The fentry-only trampoline will be freed via\n\t * multiple rcu callbacks.\n\t */\n\thlist_del(&tr->hlist);\n\tkfree(tr);\nout:\n\tmutex_unlock(&trampoline_mutex);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(trampoline_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trampoline_mutex"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tr"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&tr->hlist"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FEXIT])"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&tr->progs_hlist[BPF_TRAMP_FEXIT]"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FENTRY])"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&tr->progs_hlist[BPF_TRAMP_FENTRY]"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "mutex_is_locked(&tr->mutex)"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&tr->mutex"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&tr->refcnt"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trampoline_mutex"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic DEFINE_MUTEX(trampoline_mutex);\n\nvoid bpf_trampoline_put(struct bpf_trampoline *tr)\n{\n\tif (!tr)\n\t\treturn;\n\tmutex_lock(&trampoline_mutex);\n\tif (!refcount_dec_and_test(&tr->refcnt))\n\t\tgoto out;\n\tWARN_ON_ONCE(mutex_is_locked(&tr->mutex));\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FENTRY])))\n\t\tgoto out;\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FEXIT])))\n\t\tgoto out;\n\t/* This code will be executed even when the last bpf_tramp_image\n\t * is alive. All progs are detached from the trampoline and the\n\t * trampoline image is patched with jmp into epilogue to skip\n\t * fexit progs. The fentry-only trampoline will be freed via\n\t * multiple rcu callbacks.\n\t */\n\thlist_del(&tr->hlist);\n\tkfree(tr);\nout:\n\tmutex_unlock(&trampoline_mutex);\n}"
  },
  {
    "function_name": "bpf_trampoline_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "493-511",
    "snippet": "struct bpf_trampoline *bpf_trampoline_get(u64 key,\n\t\t\t\t\t  struct bpf_attach_target_info *tgt_info)\n{\n\tstruct bpf_trampoline *tr;\n\n\ttr = bpf_trampoline_lookup(key);\n\tif (!tr)\n\t\treturn NULL;\n\n\tmutex_lock(&tr->mutex);\n\tif (tr->func.addr)\n\t\tgoto out;\n\n\tmemcpy(&tr->func.model, &tgt_info->fmodel, sizeof(tgt_info->fmodel));\n\ttr->func.addr = (void *)tgt_info->tgt_addr;\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn tr;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline u64"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tr->mutex"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tr->func.model",
            "&tgt_info->fmodel",
            "sizeof(tgt_info->fmodel)"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tr->mutex"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_lookup",
          "args": [
            "key"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "70-98",
          "snippet": "static struct bpf_trampoline *bpf_trampoline_lookup(u64 key)\n{\n\tstruct bpf_trampoline *tr;\n\tstruct hlist_head *head;\n\tint i;\n\n\tmutex_lock(&trampoline_mutex);\n\thead = &trampoline_table[hash_64(key, TRAMPOLINE_HASH_BITS)];\n\thlist_for_each_entry(tr, head, hlist) {\n\t\tif (tr->key == key) {\n\t\t\trefcount_inc(&tr->refcnt);\n\t\t\tgoto out;\n\t\t}\n\t}\n\ttr = kzalloc(sizeof(*tr), GFP_KERNEL);\n\tif (!tr)\n\t\tgoto out;\n\n\ttr->key = key;\n\tINIT_HLIST_NODE(&tr->hlist);\n\thlist_add_head(&tr->hlist, head);\n\trefcount_set(&tr->refcnt, 1);\n\tmutex_init(&tr->mutex);\n\tfor (i = 0; i < BPF_TRAMP_MAX; i++)\n\t\tINIT_HLIST_HEAD(&tr->progs_hlist[i]);\nout:\n\tmutex_unlock(&trampoline_mutex);\n\treturn tr;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define TRAMPOLINE_HASH_BITS 10"
          ],
          "globals_used": [
            "static struct hlist_head trampoline_table[TRAMPOLINE_TABLE_SIZE];",
            "static DEFINE_MUTEX(trampoline_mutex);",
            "static __always_inline u64"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\n#define TRAMPOLINE_HASH_BITS 10\n\nstatic struct hlist_head trampoline_table[TRAMPOLINE_TABLE_SIZE];\nstatic DEFINE_MUTEX(trampoline_mutex);\nstatic __always_inline u64;\n\nstatic struct bpf_trampoline *bpf_trampoline_lookup(u64 key)\n{\n\tstruct bpf_trampoline *tr;\n\tstruct hlist_head *head;\n\tint i;\n\n\tmutex_lock(&trampoline_mutex);\n\thead = &trampoline_table[hash_64(key, TRAMPOLINE_HASH_BITS)];\n\thlist_for_each_entry(tr, head, hlist) {\n\t\tif (tr->key == key) {\n\t\t\trefcount_inc(&tr->refcnt);\n\t\t\tgoto out;\n\t\t}\n\t}\n\ttr = kzalloc(sizeof(*tr), GFP_KERNEL);\n\tif (!tr)\n\t\tgoto out;\n\n\ttr->key = key;\n\tINIT_HLIST_NODE(&tr->hlist);\n\thlist_add_head(&tr->hlist, head);\n\trefcount_set(&tr->refcnt, 1);\n\tmutex_init(&tr->mutex);\n\tfor (i = 0; i < BPF_TRAMP_MAX; i++)\n\t\tINIT_HLIST_HEAD(&tr->progs_hlist[i]);\nout:\n\tmutex_unlock(&trampoline_mutex);\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic __always_inline u64;\n\nstruct bpf_trampoline *bpf_trampoline_get(u64 key,\n\t\t\t\t\t  struct bpf_attach_target_info *tgt_info)\n{\n\tstruct bpf_trampoline *tr;\n\n\ttr = bpf_trampoline_lookup(key);\n\tif (!tr)\n\t\treturn NULL;\n\n\tmutex_lock(&tr->mutex);\n\tif (tr->func.addr)\n\t\tgoto out;\n\n\tmemcpy(&tr->func.model, &tgt_info->fmodel, sizeof(tgt_info->fmodel));\n\ttr->func.addr = (void *)tgt_info->tgt_addr;\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn tr;\n}"
  },
  {
    "function_name": "bpf_trampoline_unlink_prog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "471-491",
    "snippet": "int bpf_trampoline_unlink_prog(struct bpf_prog *prog, struct bpf_trampoline *tr)\n{\n\tenum bpf_tramp_prog_type kind;\n\tint err;\n\n\tkind = bpf_attach_type_to_tramp(prog);\n\tmutex_lock(&tr->mutex);\n\tif (kind == BPF_TRAMP_REPLACE) {\n\t\tWARN_ON_ONCE(!tr->extension_prog);\n\t\terr = bpf_arch_text_poke(tr->func.addr, BPF_MOD_JUMP,\n\t\t\t\t\t tr->extension_prog->bpf_func, NULL);\n\t\ttr->extension_prog = NULL;\n\t\tgoto out;\n\t}\n\thlist_del_init(&prog->aux->tramp_hlist);\n\ttr->progs_cnt[kind]--;\n\terr = bpf_trampoline_update(tr);\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tr->mutex"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_update",
          "args": [
            "tr"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "342-398",
          "snippet": "static int bpf_trampoline_update(struct bpf_trampoline *tr)\n{\n\tstruct bpf_tramp_image *im;\n\tstruct bpf_tramp_progs *tprogs;\n\tu32 flags = BPF_TRAMP_F_RESTORE_REGS;\n\tbool ip_arg = false;\n\tint err, total;\n\n\ttprogs = bpf_trampoline_get_progs(tr, &total, &ip_arg);\n\tif (IS_ERR(tprogs))\n\t\treturn PTR_ERR(tprogs);\n\n\tif (total == 0) {\n\t\terr = unregister_fentry(tr, tr->cur_image->image);\n\t\tbpf_tramp_image_put(tr->cur_image);\n\t\ttr->cur_image = NULL;\n\t\ttr->selector = 0;\n\t\tgoto out;\n\t}\n\n\tim = bpf_tramp_image_alloc(tr->key, tr->selector);\n\tif (IS_ERR(im)) {\n\t\terr = PTR_ERR(im);\n\t\tgoto out;\n\t}\n\n\tif (tprogs[BPF_TRAMP_FEXIT].nr_progs ||\n\t    tprogs[BPF_TRAMP_MODIFY_RETURN].nr_progs)\n\t\tflags = BPF_TRAMP_F_CALL_ORIG | BPF_TRAMP_F_SKIP_FRAME;\n\n\tif (ip_arg)\n\t\tflags |= BPF_TRAMP_F_IP_ARG;\n\n\terr = arch_prepare_bpf_trampoline(im, im->image, im->image + PAGE_SIZE,\n\t\t\t\t\t  &tr->func.model, flags, tprogs,\n\t\t\t\t\t  tr->func.addr);\n\tif (err < 0)\n\t\tgoto out;\n\n\tWARN_ON(tr->cur_image && tr->selector == 0);\n\tWARN_ON(!tr->cur_image && tr->selector);\n\tif (tr->cur_image)\n\t\t/* progs already running at this address */\n\t\terr = modify_fentry(tr, tr->cur_image->image, im->image);\n\telse\n\t\t/* first time registering */\n\t\terr = register_fentry(tr, im->image);\n\tif (err)\n\t\tgoto out;\n\tif (tr->cur_image)\n\t\tbpf_tramp_image_put(tr->cur_image);\n\ttr->cur_image = im;\n\ttr->selector++;\nout:\n\tkfree(tprogs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int bpf_trampoline_update(struct bpf_trampoline *tr)\n{\n\tstruct bpf_tramp_image *im;\n\tstruct bpf_tramp_progs *tprogs;\n\tu32 flags = BPF_TRAMP_F_RESTORE_REGS;\n\tbool ip_arg = false;\n\tint err, total;\n\n\ttprogs = bpf_trampoline_get_progs(tr, &total, &ip_arg);\n\tif (IS_ERR(tprogs))\n\t\treturn PTR_ERR(tprogs);\n\n\tif (total == 0) {\n\t\terr = unregister_fentry(tr, tr->cur_image->image);\n\t\tbpf_tramp_image_put(tr->cur_image);\n\t\ttr->cur_image = NULL;\n\t\ttr->selector = 0;\n\t\tgoto out;\n\t}\n\n\tim = bpf_tramp_image_alloc(tr->key, tr->selector);\n\tif (IS_ERR(im)) {\n\t\terr = PTR_ERR(im);\n\t\tgoto out;\n\t}\n\n\tif (tprogs[BPF_TRAMP_FEXIT].nr_progs ||\n\t    tprogs[BPF_TRAMP_MODIFY_RETURN].nr_progs)\n\t\tflags = BPF_TRAMP_F_CALL_ORIG | BPF_TRAMP_F_SKIP_FRAME;\n\n\tif (ip_arg)\n\t\tflags |= BPF_TRAMP_F_IP_ARG;\n\n\terr = arch_prepare_bpf_trampoline(im, im->image, im->image + PAGE_SIZE,\n\t\t\t\t\t  &tr->func.model, flags, tprogs,\n\t\t\t\t\t  tr->func.addr);\n\tif (err < 0)\n\t\tgoto out;\n\n\tWARN_ON(tr->cur_image && tr->selector == 0);\n\tWARN_ON(!tr->cur_image && tr->selector);\n\tif (tr->cur_image)\n\t\t/* progs already running at this address */\n\t\terr = modify_fentry(tr, tr->cur_image->image, im->image);\n\telse\n\t\t/* first time registering */\n\t\terr = register_fentry(tr, im->image);\n\tif (err)\n\t\tgoto out;\n\tif (tr->cur_image)\n\t\tbpf_tramp_image_put(tr->cur_image);\n\ttr->cur_image = im;\n\ttr->selector++;\nout:\n\tkfree(tprogs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&prog->aux->tramp_hlist"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_arch_text_poke",
          "args": [
            "tr->func.addr",
            "BPF_MOD_JUMP",
            "tr->extension_prog->bpf_func",
            "NULL"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_arch_text_poke",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2450-2454",
          "snippet": "int __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nint __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tr->extension_prog"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tr->mutex"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_attach_type_to_tramp",
          "args": [
            "prog"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_attach_type_to_tramp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "400-420",
          "snippet": "static enum bpf_tramp_prog_type bpf_attach_type_to_tramp(struct bpf_prog *prog)\n{\n\tswitch (prog->expected_attach_type) {\n\tcase BPF_TRACE_FENTRY:\n\t\treturn BPF_TRAMP_FENTRY;\n\tcase BPF_MODIFY_RETURN:\n\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tcase BPF_TRACE_FEXIT:\n\t\treturn BPF_TRAMP_FEXIT;\n\tcase BPF_LSM_MAC:\n\t\tif (!prog->aux->attach_func_proto->type)\n\t\t\t/* The function returns void, we cannot modify its\n\t\t\t * return value.\n\t\t\t */\n\t\t\treturn BPF_TRAMP_FEXIT;\n\t\telse\n\t\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tdefault:\n\t\treturn BPF_TRAMP_REPLACE;\n\t}\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic enum bpf_tramp_prog_type bpf_attach_type_to_tramp(struct bpf_prog *prog)\n{\n\tswitch (prog->expected_attach_type) {\n\tcase BPF_TRACE_FENTRY:\n\t\treturn BPF_TRAMP_FENTRY;\n\tcase BPF_MODIFY_RETURN:\n\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tcase BPF_TRACE_FEXIT:\n\t\treturn BPF_TRAMP_FEXIT;\n\tcase BPF_LSM_MAC:\n\t\tif (!prog->aux->attach_func_proto->type)\n\t\t\t/* The function returns void, we cannot modify its\n\t\t\t * return value.\n\t\t\t */\n\t\t\treturn BPF_TRAMP_FEXIT;\n\t\telse\n\t\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tdefault:\n\t\treturn BPF_TRAMP_REPLACE;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nint bpf_trampoline_unlink_prog(struct bpf_prog *prog, struct bpf_trampoline *tr)\n{\n\tenum bpf_tramp_prog_type kind;\n\tint err;\n\n\tkind = bpf_attach_type_to_tramp(prog);\n\tmutex_lock(&tr->mutex);\n\tif (kind == BPF_TRAMP_REPLACE) {\n\t\tWARN_ON_ONCE(!tr->extension_prog);\n\t\terr = bpf_arch_text_poke(tr->func.addr, BPF_MOD_JUMP,\n\t\t\t\t\t tr->extension_prog->bpf_func, NULL);\n\t\ttr->extension_prog = NULL;\n\t\tgoto out;\n\t}\n\thlist_del_init(&prog->aux->tramp_hlist);\n\ttr->progs_cnt[kind]--;\n\terr = bpf_trampoline_update(tr);\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_trampoline_link_prog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "422-468",
    "snippet": "int bpf_trampoline_link_prog(struct bpf_prog *prog, struct bpf_trampoline *tr)\n{\n\tenum bpf_tramp_prog_type kind;\n\tint err = 0;\n\tint cnt;\n\n\tkind = bpf_attach_type_to_tramp(prog);\n\tmutex_lock(&tr->mutex);\n\tif (tr->extension_prog) {\n\t\t/* cannot attach fentry/fexit if extension prog is attached.\n\t\t * cannot overwrite extension prog either.\n\t\t */\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tcnt = tr->progs_cnt[BPF_TRAMP_FENTRY] + tr->progs_cnt[BPF_TRAMP_FEXIT];\n\tif (kind == BPF_TRAMP_REPLACE) {\n\t\t/* Cannot attach extension if fentry/fexit are in use. */\n\t\tif (cnt) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\ttr->extension_prog = prog;\n\t\terr = bpf_arch_text_poke(tr->func.addr, BPF_MOD_JUMP, NULL,\n\t\t\t\t\t prog->bpf_func);\n\t\tgoto out;\n\t}\n\tif (cnt >= BPF_MAX_TRAMP_PROGS) {\n\t\terr = -E2BIG;\n\t\tgoto out;\n\t}\n\tif (!hlist_unhashed(&prog->aux->tramp_hlist)) {\n\t\t/* prog already linked */\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\thlist_add_head(&prog->aux->tramp_hlist, &tr->progs_hlist[kind]);\n\ttr->progs_cnt[kind]++;\n\terr = bpf_trampoline_update(tr);\n\tif (err) {\n\t\thlist_del_init(&prog->aux->tramp_hlist);\n\t\ttr->progs_cnt[kind]--;\n\t}\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tr->mutex"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&prog->aux->tramp_hlist"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_update",
          "args": [
            "tr"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "342-398",
          "snippet": "static int bpf_trampoline_update(struct bpf_trampoline *tr)\n{\n\tstruct bpf_tramp_image *im;\n\tstruct bpf_tramp_progs *tprogs;\n\tu32 flags = BPF_TRAMP_F_RESTORE_REGS;\n\tbool ip_arg = false;\n\tint err, total;\n\n\ttprogs = bpf_trampoline_get_progs(tr, &total, &ip_arg);\n\tif (IS_ERR(tprogs))\n\t\treturn PTR_ERR(tprogs);\n\n\tif (total == 0) {\n\t\terr = unregister_fentry(tr, tr->cur_image->image);\n\t\tbpf_tramp_image_put(tr->cur_image);\n\t\ttr->cur_image = NULL;\n\t\ttr->selector = 0;\n\t\tgoto out;\n\t}\n\n\tim = bpf_tramp_image_alloc(tr->key, tr->selector);\n\tif (IS_ERR(im)) {\n\t\terr = PTR_ERR(im);\n\t\tgoto out;\n\t}\n\n\tif (tprogs[BPF_TRAMP_FEXIT].nr_progs ||\n\t    tprogs[BPF_TRAMP_MODIFY_RETURN].nr_progs)\n\t\tflags = BPF_TRAMP_F_CALL_ORIG | BPF_TRAMP_F_SKIP_FRAME;\n\n\tif (ip_arg)\n\t\tflags |= BPF_TRAMP_F_IP_ARG;\n\n\terr = arch_prepare_bpf_trampoline(im, im->image, im->image + PAGE_SIZE,\n\t\t\t\t\t  &tr->func.model, flags, tprogs,\n\t\t\t\t\t  tr->func.addr);\n\tif (err < 0)\n\t\tgoto out;\n\n\tWARN_ON(tr->cur_image && tr->selector == 0);\n\tWARN_ON(!tr->cur_image && tr->selector);\n\tif (tr->cur_image)\n\t\t/* progs already running at this address */\n\t\terr = modify_fentry(tr, tr->cur_image->image, im->image);\n\telse\n\t\t/* first time registering */\n\t\terr = register_fentry(tr, im->image);\n\tif (err)\n\t\tgoto out;\n\tif (tr->cur_image)\n\t\tbpf_tramp_image_put(tr->cur_image);\n\ttr->cur_image = im;\n\ttr->selector++;\nout:\n\tkfree(tprogs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int bpf_trampoline_update(struct bpf_trampoline *tr)\n{\n\tstruct bpf_tramp_image *im;\n\tstruct bpf_tramp_progs *tprogs;\n\tu32 flags = BPF_TRAMP_F_RESTORE_REGS;\n\tbool ip_arg = false;\n\tint err, total;\n\n\ttprogs = bpf_trampoline_get_progs(tr, &total, &ip_arg);\n\tif (IS_ERR(tprogs))\n\t\treturn PTR_ERR(tprogs);\n\n\tif (total == 0) {\n\t\terr = unregister_fentry(tr, tr->cur_image->image);\n\t\tbpf_tramp_image_put(tr->cur_image);\n\t\ttr->cur_image = NULL;\n\t\ttr->selector = 0;\n\t\tgoto out;\n\t}\n\n\tim = bpf_tramp_image_alloc(tr->key, tr->selector);\n\tif (IS_ERR(im)) {\n\t\terr = PTR_ERR(im);\n\t\tgoto out;\n\t}\n\n\tif (tprogs[BPF_TRAMP_FEXIT].nr_progs ||\n\t    tprogs[BPF_TRAMP_MODIFY_RETURN].nr_progs)\n\t\tflags = BPF_TRAMP_F_CALL_ORIG | BPF_TRAMP_F_SKIP_FRAME;\n\n\tif (ip_arg)\n\t\tflags |= BPF_TRAMP_F_IP_ARG;\n\n\terr = arch_prepare_bpf_trampoline(im, im->image, im->image + PAGE_SIZE,\n\t\t\t\t\t  &tr->func.model, flags, tprogs,\n\t\t\t\t\t  tr->func.addr);\n\tif (err < 0)\n\t\tgoto out;\n\n\tWARN_ON(tr->cur_image && tr->selector == 0);\n\tWARN_ON(!tr->cur_image && tr->selector);\n\tif (tr->cur_image)\n\t\t/* progs already running at this address */\n\t\terr = modify_fentry(tr, tr->cur_image->image, im->image);\n\telse\n\t\t/* first time registering */\n\t\terr = register_fentry(tr, im->image);\n\tif (err)\n\t\tgoto out;\n\tif (tr->cur_image)\n\t\tbpf_tramp_image_put(tr->cur_image);\n\ttr->cur_image = im;\n\ttr->selector++;\nout:\n\tkfree(tprogs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&prog->aux->tramp_hlist",
            "&tr->progs_hlist[kind]"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&prog->aux->tramp_hlist"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_arch_text_poke",
          "args": [
            "tr->func.addr",
            "BPF_MOD_JUMP",
            "NULL",
            "prog->bpf_func"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_arch_text_poke",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2450-2454",
          "snippet": "int __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nint __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tr->mutex"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_attach_type_to_tramp",
          "args": [
            "prog"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_attach_type_to_tramp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "400-420",
          "snippet": "static enum bpf_tramp_prog_type bpf_attach_type_to_tramp(struct bpf_prog *prog)\n{\n\tswitch (prog->expected_attach_type) {\n\tcase BPF_TRACE_FENTRY:\n\t\treturn BPF_TRAMP_FENTRY;\n\tcase BPF_MODIFY_RETURN:\n\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tcase BPF_TRACE_FEXIT:\n\t\treturn BPF_TRAMP_FEXIT;\n\tcase BPF_LSM_MAC:\n\t\tif (!prog->aux->attach_func_proto->type)\n\t\t\t/* The function returns void, we cannot modify its\n\t\t\t * return value.\n\t\t\t */\n\t\t\treturn BPF_TRAMP_FEXIT;\n\t\telse\n\t\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tdefault:\n\t\treturn BPF_TRAMP_REPLACE;\n\t}\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic enum bpf_tramp_prog_type bpf_attach_type_to_tramp(struct bpf_prog *prog)\n{\n\tswitch (prog->expected_attach_type) {\n\tcase BPF_TRACE_FENTRY:\n\t\treturn BPF_TRAMP_FENTRY;\n\tcase BPF_MODIFY_RETURN:\n\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tcase BPF_TRACE_FEXIT:\n\t\treturn BPF_TRAMP_FEXIT;\n\tcase BPF_LSM_MAC:\n\t\tif (!prog->aux->attach_func_proto->type)\n\t\t\t/* The function returns void, we cannot modify its\n\t\t\t * return value.\n\t\t\t */\n\t\t\treturn BPF_TRAMP_FEXIT;\n\t\telse\n\t\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tdefault:\n\t\treturn BPF_TRAMP_REPLACE;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nint bpf_trampoline_link_prog(struct bpf_prog *prog, struct bpf_trampoline *tr)\n{\n\tenum bpf_tramp_prog_type kind;\n\tint err = 0;\n\tint cnt;\n\n\tkind = bpf_attach_type_to_tramp(prog);\n\tmutex_lock(&tr->mutex);\n\tif (tr->extension_prog) {\n\t\t/* cannot attach fentry/fexit if extension prog is attached.\n\t\t * cannot overwrite extension prog either.\n\t\t */\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tcnt = tr->progs_cnt[BPF_TRAMP_FENTRY] + tr->progs_cnt[BPF_TRAMP_FEXIT];\n\tif (kind == BPF_TRAMP_REPLACE) {\n\t\t/* Cannot attach extension if fentry/fexit are in use. */\n\t\tif (cnt) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\ttr->extension_prog = prog;\n\t\terr = bpf_arch_text_poke(tr->func.addr, BPF_MOD_JUMP, NULL,\n\t\t\t\t\t prog->bpf_func);\n\t\tgoto out;\n\t}\n\tif (cnt >= BPF_MAX_TRAMP_PROGS) {\n\t\terr = -E2BIG;\n\t\tgoto out;\n\t}\n\tif (!hlist_unhashed(&prog->aux->tramp_hlist)) {\n\t\t/* prog already linked */\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\thlist_add_head(&prog->aux->tramp_hlist, &tr->progs_hlist[kind]);\n\ttr->progs_cnt[kind]++;\n\terr = bpf_trampoline_update(tr);\n\tif (err) {\n\t\thlist_del_init(&prog->aux->tramp_hlist);\n\t\ttr->progs_cnt[kind]--;\n\t}\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_attach_type_to_tramp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "400-420",
    "snippet": "static enum bpf_tramp_prog_type bpf_attach_type_to_tramp(struct bpf_prog *prog)\n{\n\tswitch (prog->expected_attach_type) {\n\tcase BPF_TRACE_FENTRY:\n\t\treturn BPF_TRAMP_FENTRY;\n\tcase BPF_MODIFY_RETURN:\n\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tcase BPF_TRACE_FEXIT:\n\t\treturn BPF_TRAMP_FEXIT;\n\tcase BPF_LSM_MAC:\n\t\tif (!prog->aux->attach_func_proto->type)\n\t\t\t/* The function returns void, we cannot modify its\n\t\t\t * return value.\n\t\t\t */\n\t\t\treturn BPF_TRAMP_FEXIT;\n\t\telse\n\t\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tdefault:\n\t\treturn BPF_TRAMP_REPLACE;\n\t}\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic enum bpf_tramp_prog_type bpf_attach_type_to_tramp(struct bpf_prog *prog)\n{\n\tswitch (prog->expected_attach_type) {\n\tcase BPF_TRACE_FENTRY:\n\t\treturn BPF_TRAMP_FENTRY;\n\tcase BPF_MODIFY_RETURN:\n\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tcase BPF_TRACE_FEXIT:\n\t\treturn BPF_TRAMP_FEXIT;\n\tcase BPF_LSM_MAC:\n\t\tif (!prog->aux->attach_func_proto->type)\n\t\t\t/* The function returns void, we cannot modify its\n\t\t\t * return value.\n\t\t\t */\n\t\t\treturn BPF_TRAMP_FEXIT;\n\t\telse\n\t\t\treturn BPF_TRAMP_MODIFY_RETURN;\n\tdefault:\n\t\treturn BPF_TRAMP_REPLACE;\n\t}\n}"
  },
  {
    "function_name": "bpf_trampoline_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "342-398",
    "snippet": "static int bpf_trampoline_update(struct bpf_trampoline *tr)\n{\n\tstruct bpf_tramp_image *im;\n\tstruct bpf_tramp_progs *tprogs;\n\tu32 flags = BPF_TRAMP_F_RESTORE_REGS;\n\tbool ip_arg = false;\n\tint err, total;\n\n\ttprogs = bpf_trampoline_get_progs(tr, &total, &ip_arg);\n\tif (IS_ERR(tprogs))\n\t\treturn PTR_ERR(tprogs);\n\n\tif (total == 0) {\n\t\terr = unregister_fentry(tr, tr->cur_image->image);\n\t\tbpf_tramp_image_put(tr->cur_image);\n\t\ttr->cur_image = NULL;\n\t\ttr->selector = 0;\n\t\tgoto out;\n\t}\n\n\tim = bpf_tramp_image_alloc(tr->key, tr->selector);\n\tif (IS_ERR(im)) {\n\t\terr = PTR_ERR(im);\n\t\tgoto out;\n\t}\n\n\tif (tprogs[BPF_TRAMP_FEXIT].nr_progs ||\n\t    tprogs[BPF_TRAMP_MODIFY_RETURN].nr_progs)\n\t\tflags = BPF_TRAMP_F_CALL_ORIG | BPF_TRAMP_F_SKIP_FRAME;\n\n\tif (ip_arg)\n\t\tflags |= BPF_TRAMP_F_IP_ARG;\n\n\terr = arch_prepare_bpf_trampoline(im, im->image, im->image + PAGE_SIZE,\n\t\t\t\t\t  &tr->func.model, flags, tprogs,\n\t\t\t\t\t  tr->func.addr);\n\tif (err < 0)\n\t\tgoto out;\n\n\tWARN_ON(tr->cur_image && tr->selector == 0);\n\tWARN_ON(!tr->cur_image && tr->selector);\n\tif (tr->cur_image)\n\t\t/* progs already running at this address */\n\t\terr = modify_fentry(tr, tr->cur_image->image, im->image);\n\telse\n\t\t/* first time registering */\n\t\terr = register_fentry(tr, im->image);\n\tif (err)\n\t\tgoto out;\n\tif (tr->cur_image)\n\t\tbpf_tramp_image_put(tr->cur_image);\n\ttr->cur_image = im;\n\ttr->selector++;\nout:\n\tkfree(tprogs);\n\treturn err;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tprogs"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_tramp_image_put",
          "args": [
            "tr->cur_image"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_tramp_image_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "254-300",
          "snippet": "static void bpf_tramp_image_put(struct bpf_tramp_image *im)\n{\n\t/* The trampoline image that calls original function is using:\n\t * rcu_read_lock_trace to protect sleepable bpf progs\n\t * rcu_read_lock to protect normal bpf progs\n\t * percpu_ref to protect trampoline itself\n\t * rcu tasks to protect trampoline asm not covered by percpu_ref\n\t * (which are few asm insns before __bpf_tramp_enter and\n\t *  after __bpf_tramp_exit)\n\t *\n\t * The trampoline is unreachable before bpf_tramp_image_put().\n\t *\n\t * First, patch the trampoline to avoid calling into fexit progs.\n\t * The progs will be freed even if the original function is still\n\t * executing or sleeping.\n\t * In case of CONFIG_PREEMPT=y use call_rcu_tasks() to wait on\n\t * first few asm instructions to execute and call into\n\t * __bpf_tramp_enter->percpu_ref_get.\n\t * Then use percpu_ref_kill to wait for the trampoline and the original\n\t * function to finish.\n\t * Then use call_rcu_tasks() to make sure few asm insns in\n\t * the trampoline epilogue are done as well.\n\t *\n\t * In !PREEMPT case the task that got interrupted in the first asm\n\t * insns won't go through an RCU quiescent state which the\n\t * percpu_ref_kill will be waiting for. Hence the first\n\t * call_rcu_tasks() is not necessary.\n\t */\n\tif (im->ip_after_call) {\n\t\tint err = bpf_arch_text_poke(im->ip_after_call, BPF_MOD_JUMP,\n\t\t\t\t\t     NULL, im->ip_epilogue);\n\t\tWARN_ON(err);\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tcall_rcu_tasks(&im->rcu, __bpf_tramp_image_put_rcu_tasks);\n\t\telse\n\t\t\tpercpu_ref_kill(&im->pcref);\n\t\treturn;\n\t}\n\n\t/* The trampoline without fexit and fmod_ret progs doesn't call original\n\t * function and doesn't use percpu_ref.\n\t * Use call_rcu_tasks_trace() to wait for sleepable progs to finish.\n\t * Then use call_rcu_tasks() to wait for the rest of trampoline asm\n\t * and normal progs.\n\t */\n\tcall_rcu_tasks_trace(&im->rcu, __bpf_tramp_image_put_rcu_tasks);\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void bpf_tramp_image_put(struct bpf_tramp_image *im)\n{\n\t/* The trampoline image that calls original function is using:\n\t * rcu_read_lock_trace to protect sleepable bpf progs\n\t * rcu_read_lock to protect normal bpf progs\n\t * percpu_ref to protect trampoline itself\n\t * rcu tasks to protect trampoline asm not covered by percpu_ref\n\t * (which are few asm insns before __bpf_tramp_enter and\n\t *  after __bpf_tramp_exit)\n\t *\n\t * The trampoline is unreachable before bpf_tramp_image_put().\n\t *\n\t * First, patch the trampoline to avoid calling into fexit progs.\n\t * The progs will be freed even if the original function is still\n\t * executing or sleeping.\n\t * In case of CONFIG_PREEMPT=y use call_rcu_tasks() to wait on\n\t * first few asm instructions to execute and call into\n\t * __bpf_tramp_enter->percpu_ref_get.\n\t * Then use percpu_ref_kill to wait for the trampoline and the original\n\t * function to finish.\n\t * Then use call_rcu_tasks() to make sure few asm insns in\n\t * the trampoline epilogue are done as well.\n\t *\n\t * In !PREEMPT case the task that got interrupted in the first asm\n\t * insns won't go through an RCU quiescent state which the\n\t * percpu_ref_kill will be waiting for. Hence the first\n\t * call_rcu_tasks() is not necessary.\n\t */\n\tif (im->ip_after_call) {\n\t\tint err = bpf_arch_text_poke(im->ip_after_call, BPF_MOD_JUMP,\n\t\t\t\t\t     NULL, im->ip_epilogue);\n\t\tWARN_ON(err);\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tcall_rcu_tasks(&im->rcu, __bpf_tramp_image_put_rcu_tasks);\n\t\telse\n\t\t\tpercpu_ref_kill(&im->pcref);\n\t\treturn;\n\t}\n\n\t/* The trampoline without fexit and fmod_ret progs doesn't call original\n\t * function and doesn't use percpu_ref.\n\t * Use call_rcu_tasks_trace() to wait for sleepable progs to finish.\n\t * Then use call_rcu_tasks() to wait for the rest of trampoline asm\n\t * and normal progs.\n\t */\n\tcall_rcu_tasks_trace(&im->rcu, __bpf_tramp_image_put_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_fentry",
          "args": [
            "tr",
            "im->image"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "register_fentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "160-181",
          "snippet": "static int register_fentry(struct bpf_trampoline *tr, void *new_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tret = is_ftrace_location(ip);\n\tif (ret < 0)\n\t\treturn ret;\n\ttr->func.ftrace_managed = ret;\n\n\tif (bpf_trampoline_module_get(tr))\n\t\treturn -ENOENT;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = register_ftrace_direct((long)ip, (long)new_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, NULL, new_addr);\n\n\tif (ret)\n\t\tbpf_trampoline_module_put(tr);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int register_fentry(struct bpf_trampoline *tr, void *new_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tret = is_ftrace_location(ip);\n\tif (ret < 0)\n\t\treturn ret;\n\ttr->func.ftrace_managed = ret;\n\n\tif (bpf_trampoline_module_get(tr))\n\t\treturn -ENOENT;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = register_ftrace_direct((long)ip, (long)new_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, NULL, new_addr);\n\n\tif (ret)\n\t\tbpf_trampoline_module_put(tr);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify_fentry",
          "args": [
            "tr",
            "tr->cur_image->image",
            "im->image"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "modify_fentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "147-157",
          "snippet": "static int modify_fentry(struct bpf_trampoline *tr, void *old_addr, void *new_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = modify_ftrace_direct((long)ip, (long)old_addr, (long)new_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, old_addr, new_addr);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int modify_fentry(struct bpf_trampoline *tr, void *old_addr, void *new_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = modify_ftrace_direct((long)ip, (long)old_addr, (long)new_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, old_addr, new_addr);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!tr->cur_image && tr->selector"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tr->cur_image && tr->selector == 0"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_prepare_bpf_trampoline",
          "args": [
            "im",
            "im->image",
            "im->image + PAGE_SIZE",
            "&tr->func.model",
            "flags",
            "tprogs",
            "tr->func.addr"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "arch_prepare_bpf_trampoline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "646-653",
          "snippet": "int __weak\narch_prepare_bpf_trampoline(struct bpf_tramp_image *tr, void *image, void *image_end,\n\t\t\t    const struct btf_func_model *m, u32 flags,\n\t\t\t    struct bpf_tramp_progs *tprogs,\n\t\t\t    void *orig_call)\n{\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nint __weak\narch_prepare_bpf_trampoline(struct bpf_tramp_image *tr, void *image, void *image_end,\n\t\t\t    const struct btf_func_model *m, u32 flags,\n\t\t\t    struct bpf_tramp_progs *tprogs,\n\t\t\t    void *orig_call)\n{\n\treturn -ENOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "im"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "im"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_tramp_image_alloc",
          "args": [
            "tr->key",
            "tr->selector"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_tramp_image_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "302-340",
          "snippet": "static struct bpf_tramp_image *bpf_tramp_image_alloc(u64 key, u32 idx)\n{\n\tstruct bpf_tramp_image *im;\n\tstruct bpf_ksym *ksym;\n\tvoid *image;\n\tint err = -ENOMEM;\n\n\tim = kzalloc(sizeof(*im), GFP_KERNEL);\n\tif (!im)\n\t\tgoto out;\n\n\terr = bpf_jit_charge_modmem(1);\n\tif (err)\n\t\tgoto out_free_im;\n\n\terr = -ENOMEM;\n\tim->image = image = bpf_jit_alloc_exec_page();\n\tif (!image)\n\t\tgoto out_uncharge;\n\n\terr = percpu_ref_init(&im->pcref, __bpf_tramp_image_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto out_free_image;\n\n\tksym = &im->ksym;\n\tINIT_LIST_HEAD_RCU(&ksym->lnode);\n\tsnprintf(ksym->name, KSYM_NAME_LEN, \"bpf_trampoline_%llu_%u\", key, idx);\n\tbpf_image_ksym_add(image, ksym);\n\treturn im;\n\nout_free_image:\n\tbpf_jit_free_exec(im->image);\nout_uncharge:\n\tbpf_jit_uncharge_modmem(1);\nout_free_im:\n\tkfree(im);\nout:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline u64"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic __always_inline u64;\n\nstatic struct bpf_tramp_image *bpf_tramp_image_alloc(u64 key, u32 idx)\n{\n\tstruct bpf_tramp_image *im;\n\tstruct bpf_ksym *ksym;\n\tvoid *image;\n\tint err = -ENOMEM;\n\n\tim = kzalloc(sizeof(*im), GFP_KERNEL);\n\tif (!im)\n\t\tgoto out;\n\n\terr = bpf_jit_charge_modmem(1);\n\tif (err)\n\t\tgoto out_free_im;\n\n\terr = -ENOMEM;\n\tim->image = image = bpf_jit_alloc_exec_page();\n\tif (!image)\n\t\tgoto out_uncharge;\n\n\terr = percpu_ref_init(&im->pcref, __bpf_tramp_image_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto out_free_image;\n\n\tksym = &im->ksym;\n\tINIT_LIST_HEAD_RCU(&ksym->lnode);\n\tsnprintf(ksym->name, KSYM_NAME_LEN, \"bpf_trampoline_%llu_%u\", key, idx);\n\tbpf_image_ksym_add(image, ksym);\n\treturn im;\n\nout_free_image:\n\tbpf_jit_free_exec(im->image);\nout_uncharge:\n\tbpf_jit_uncharge_modmem(1);\nout_free_im:\n\tkfree(im);\nout:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_fentry",
          "args": [
            "tr",
            "tr->cur_image->image"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_fentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "132-145",
          "snippet": "static int unregister_fentry(struct bpf_trampoline *tr, void *old_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = unregister_ftrace_direct((long)ip, (long)old_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, old_addr, NULL);\n\n\tif (!ret)\n\t\tbpf_trampoline_module_put(tr);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int unregister_fentry(struct bpf_trampoline *tr, void *old_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = unregister_ftrace_direct((long)ip, (long)old_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, old_addr, NULL);\n\n\tif (!ret)\n\t\tbpf_trampoline_module_put(tr);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tprogs"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tprogs"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_get_progs",
          "args": [
            "tr",
            "&total",
            "&ip_arg"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_get_progs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "183-207",
          "snippet": "static struct bpf_tramp_progs *\nbpf_trampoline_get_progs(const struct bpf_trampoline *tr, int *total, bool *ip_arg)\n{\n\tconst struct bpf_prog_aux *aux;\n\tstruct bpf_tramp_progs *tprogs;\n\tstruct bpf_prog **progs;\n\tint kind;\n\n\t*total = 0;\n\ttprogs = kcalloc(BPF_TRAMP_MAX, sizeof(*tprogs), GFP_KERNEL);\n\tif (!tprogs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (kind = 0; kind < BPF_TRAMP_MAX; kind++) {\n\t\ttprogs[kind].nr_progs = tr->progs_cnt[kind];\n\t\t*total += tr->progs_cnt[kind];\n\t\tprogs = tprogs[kind].progs;\n\n\t\thlist_for_each_entry(aux, &tr->progs_hlist[kind], tramp_hlist) {\n\t\t\t*ip_arg |= aux->prog->call_get_func_ip;\n\t\t\t*progs++ = aux->prog;\n\t\t}\n\t}\n\treturn tprogs;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic struct bpf_tramp_progs *\nbpf_trampoline_get_progs(const struct bpf_trampoline *tr, int *total, bool *ip_arg)\n{\n\tconst struct bpf_prog_aux *aux;\n\tstruct bpf_tramp_progs *tprogs;\n\tstruct bpf_prog **progs;\n\tint kind;\n\n\t*total = 0;\n\ttprogs = kcalloc(BPF_TRAMP_MAX, sizeof(*tprogs), GFP_KERNEL);\n\tif (!tprogs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (kind = 0; kind < BPF_TRAMP_MAX; kind++) {\n\t\ttprogs[kind].nr_progs = tr->progs_cnt[kind];\n\t\t*total += tr->progs_cnt[kind];\n\t\tprogs = tprogs[kind].progs;\n\n\t\thlist_for_each_entry(aux, &tr->progs_hlist[kind], tramp_hlist) {\n\t\t\t*ip_arg |= aux->prog->call_get_func_ip;\n\t\t\t*progs++ = aux->prog;\n\t\t}\n\t}\n\treturn tprogs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int bpf_trampoline_update(struct bpf_trampoline *tr)\n{\n\tstruct bpf_tramp_image *im;\n\tstruct bpf_tramp_progs *tprogs;\n\tu32 flags = BPF_TRAMP_F_RESTORE_REGS;\n\tbool ip_arg = false;\n\tint err, total;\n\n\ttprogs = bpf_trampoline_get_progs(tr, &total, &ip_arg);\n\tif (IS_ERR(tprogs))\n\t\treturn PTR_ERR(tprogs);\n\n\tif (total == 0) {\n\t\terr = unregister_fentry(tr, tr->cur_image->image);\n\t\tbpf_tramp_image_put(tr->cur_image);\n\t\ttr->cur_image = NULL;\n\t\ttr->selector = 0;\n\t\tgoto out;\n\t}\n\n\tim = bpf_tramp_image_alloc(tr->key, tr->selector);\n\tif (IS_ERR(im)) {\n\t\terr = PTR_ERR(im);\n\t\tgoto out;\n\t}\n\n\tif (tprogs[BPF_TRAMP_FEXIT].nr_progs ||\n\t    tprogs[BPF_TRAMP_MODIFY_RETURN].nr_progs)\n\t\tflags = BPF_TRAMP_F_CALL_ORIG | BPF_TRAMP_F_SKIP_FRAME;\n\n\tif (ip_arg)\n\t\tflags |= BPF_TRAMP_F_IP_ARG;\n\n\terr = arch_prepare_bpf_trampoline(im, im->image, im->image + PAGE_SIZE,\n\t\t\t\t\t  &tr->func.model, flags, tprogs,\n\t\t\t\t\t  tr->func.addr);\n\tif (err < 0)\n\t\tgoto out;\n\n\tWARN_ON(tr->cur_image && tr->selector == 0);\n\tWARN_ON(!tr->cur_image && tr->selector);\n\tif (tr->cur_image)\n\t\t/* progs already running at this address */\n\t\terr = modify_fentry(tr, tr->cur_image->image, im->image);\n\telse\n\t\t/* first time registering */\n\t\terr = register_fentry(tr, im->image);\n\tif (err)\n\t\tgoto out;\n\tif (tr->cur_image)\n\t\tbpf_tramp_image_put(tr->cur_image);\n\ttr->cur_image = im;\n\ttr->selector++;\nout:\n\tkfree(tprogs);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_tramp_image_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "302-340",
    "snippet": "static struct bpf_tramp_image *bpf_tramp_image_alloc(u64 key, u32 idx)\n{\n\tstruct bpf_tramp_image *im;\n\tstruct bpf_ksym *ksym;\n\tvoid *image;\n\tint err = -ENOMEM;\n\n\tim = kzalloc(sizeof(*im), GFP_KERNEL);\n\tif (!im)\n\t\tgoto out;\n\n\terr = bpf_jit_charge_modmem(1);\n\tif (err)\n\t\tgoto out_free_im;\n\n\terr = -ENOMEM;\n\tim->image = image = bpf_jit_alloc_exec_page();\n\tif (!image)\n\t\tgoto out_uncharge;\n\n\terr = percpu_ref_init(&im->pcref, __bpf_tramp_image_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto out_free_image;\n\n\tksym = &im->ksym;\n\tINIT_LIST_HEAD_RCU(&ksym->lnode);\n\tsnprintf(ksym->name, KSYM_NAME_LEN, \"bpf_trampoline_%llu_%u\", key, idx);\n\tbpf_image_ksym_add(image, ksym);\n\treturn im;\n\nout_free_image:\n\tbpf_jit_free_exec(im->image);\nout_uncharge:\n\tbpf_jit_uncharge_modmem(1);\nout_free_im:\n\tkfree(im);\nout:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline u64"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "im"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_uncharge_modmem",
          "args": [
            "1"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_uncharge_modmem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "849-852",
          "snippet": "void bpf_jit_uncharge_modmem(u32 pages)\n{\n\tatomic_long_sub(pages, &bpf_jit_current);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_jit_uncharge_modmem(u32 pages)\n{\n\tatomic_long_sub(pages, &bpf_jit_current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_free_exec",
          "args": [
            "im->image"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_free_exec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "859-862",
          "snippet": "void __weak bpf_jit_free_exec(void *addr)\n{\n\tmodule_memfree(addr);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nvoid __weak bpf_jit_free_exec(void *addr)\n{\n\tmodule_memfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_image_ksym_add",
          "args": [
            "image",
            "ksym"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_image_ksym_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "54-61",
          "snippet": "void bpf_image_ksym_add(void *data, struct bpf_ksym *ksym)\n{\n\tksym->start = (unsigned long) data;\n\tksym->end = ksym->start + PAGE_SIZE;\n\tbpf_ksym_add(ksym);\n\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_BPF, ksym->start,\n\t\t\t   PAGE_SIZE, false, ksym->name);\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nvoid bpf_image_ksym_add(void *data, struct bpf_ksym *ksym)\n{\n\tksym->start = (unsigned long) data;\n\tksym->end = ksym->start + PAGE_SIZE;\n\tbpf_ksym_add(ksym);\n\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_BPF, ksym->start,\n\t\t\t   PAGE_SIZE, false, ksym->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ksym->name",
            "KSYM_NAME_LEN",
            "\"bpf_trampoline_%llu_%u\"",
            "key",
            "idx"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD_RCU",
          "args": [
            "&ksym->lnode"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&im->pcref",
            "__bpf_tramp_image_release",
            "0",
            "GFP_KERNEL"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_jit_alloc_exec_page",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_alloc_exec_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "38-52",
          "snippet": "void *bpf_jit_alloc_exec_page(void)\n{\n\tvoid *image;\n\n\timage = bpf_jit_alloc_exec(PAGE_SIZE);\n\tif (!image)\n\t\treturn NULL;\n\n\tset_vm_flush_reset_perms(image);\n\t/* Keep image as writeable. The alternative is to keep flipping ro/rw\n\t * everytime new program is attached or detached.\n\t */\n\tset_memory_x((long)image, 1);\n\treturn image;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nvoid *bpf_jit_alloc_exec_page(void)\n{\n\tvoid *image;\n\n\timage = bpf_jit_alloc_exec(PAGE_SIZE);\n\tif (!image)\n\t\treturn NULL;\n\n\tset_vm_flush_reset_perms(image);\n\t/* Keep image as writeable. The alternative is to keep flipping ro/rw\n\t * everytime new program is attached or detached.\n\t */\n\tset_memory_x((long)image, 1);\n\treturn image;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_charge_modmem",
          "args": [
            "1"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_charge_modmem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "836-847",
          "snippet": "int bpf_jit_charge_modmem(u32 pages)\n{\n\tif (atomic_long_add_return(pages, &bpf_jit_current) >\n\t    (bpf_jit_limit >> PAGE_SHIFT)) {\n\t\tif (!bpf_capable()) {\n\t\t\tatomic_long_sub(pages, &bpf_jit_current);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_jit_charge_modmem(u32 pages)\n{\n\tif (atomic_long_add_return(pages, &bpf_jit_current) >\n\t    (bpf_jit_limit >> PAGE_SHIFT)) {\n\t\tif (!bpf_capable()) {\n\t\t\tatomic_long_sub(pages, &bpf_jit_current);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*im)",
            "GFP_KERNEL"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic __always_inline u64;\n\nstatic struct bpf_tramp_image *bpf_tramp_image_alloc(u64 key, u32 idx)\n{\n\tstruct bpf_tramp_image *im;\n\tstruct bpf_ksym *ksym;\n\tvoid *image;\n\tint err = -ENOMEM;\n\n\tim = kzalloc(sizeof(*im), GFP_KERNEL);\n\tif (!im)\n\t\tgoto out;\n\n\terr = bpf_jit_charge_modmem(1);\n\tif (err)\n\t\tgoto out_free_im;\n\n\terr = -ENOMEM;\n\tim->image = image = bpf_jit_alloc_exec_page();\n\tif (!image)\n\t\tgoto out_uncharge;\n\n\terr = percpu_ref_init(&im->pcref, __bpf_tramp_image_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto out_free_image;\n\n\tksym = &im->ksym;\n\tINIT_LIST_HEAD_RCU(&ksym->lnode);\n\tsnprintf(ksym->name, KSYM_NAME_LEN, \"bpf_trampoline_%llu_%u\", key, idx);\n\tbpf_image_ksym_add(image, ksym);\n\treturn im;\n\nout_free_image:\n\tbpf_jit_free_exec(im->image);\nout_uncharge:\n\tbpf_jit_uncharge_modmem(1);\nout_free_im:\n\tkfree(im);\nout:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "bpf_tramp_image_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "254-300",
    "snippet": "static void bpf_tramp_image_put(struct bpf_tramp_image *im)\n{\n\t/* The trampoline image that calls original function is using:\n\t * rcu_read_lock_trace to protect sleepable bpf progs\n\t * rcu_read_lock to protect normal bpf progs\n\t * percpu_ref to protect trampoline itself\n\t * rcu tasks to protect trampoline asm not covered by percpu_ref\n\t * (which are few asm insns before __bpf_tramp_enter and\n\t *  after __bpf_tramp_exit)\n\t *\n\t * The trampoline is unreachable before bpf_tramp_image_put().\n\t *\n\t * First, patch the trampoline to avoid calling into fexit progs.\n\t * The progs will be freed even if the original function is still\n\t * executing or sleeping.\n\t * In case of CONFIG_PREEMPT=y use call_rcu_tasks() to wait on\n\t * first few asm instructions to execute and call into\n\t * __bpf_tramp_enter->percpu_ref_get.\n\t * Then use percpu_ref_kill to wait for the trampoline and the original\n\t * function to finish.\n\t * Then use call_rcu_tasks() to make sure few asm insns in\n\t * the trampoline epilogue are done as well.\n\t *\n\t * In !PREEMPT case the task that got interrupted in the first asm\n\t * insns won't go through an RCU quiescent state which the\n\t * percpu_ref_kill will be waiting for. Hence the first\n\t * call_rcu_tasks() is not necessary.\n\t */\n\tif (im->ip_after_call) {\n\t\tint err = bpf_arch_text_poke(im->ip_after_call, BPF_MOD_JUMP,\n\t\t\t\t\t     NULL, im->ip_epilogue);\n\t\tWARN_ON(err);\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tcall_rcu_tasks(&im->rcu, __bpf_tramp_image_put_rcu_tasks);\n\t\telse\n\t\t\tpercpu_ref_kill(&im->pcref);\n\t\treturn;\n\t}\n\n\t/* The trampoline without fexit and fmod_ret progs doesn't call original\n\t * function and doesn't use percpu_ref.\n\t * Use call_rcu_tasks_trace() to wait for sleepable progs to finish.\n\t * Then use call_rcu_tasks() to wait for the rest of trampoline asm\n\t * and normal progs.\n\t */\n\tcall_rcu_tasks_trace(&im->rcu, __bpf_tramp_image_put_rcu_tasks);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_tasks_trace",
          "args": [
            "&im->rcu",
            "__bpf_tramp_image_put_rcu_tasks"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "&im->pcref"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPTION"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "err"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_arch_text_poke",
          "args": [
            "im->ip_after_call",
            "BPF_MOD_JUMP",
            "NULL",
            "im->ip_epilogue"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_arch_text_poke",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2450-2454",
          "snippet": "int __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nint __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void bpf_tramp_image_put(struct bpf_tramp_image *im)\n{\n\t/* The trampoline image that calls original function is using:\n\t * rcu_read_lock_trace to protect sleepable bpf progs\n\t * rcu_read_lock to protect normal bpf progs\n\t * percpu_ref to protect trampoline itself\n\t * rcu tasks to protect trampoline asm not covered by percpu_ref\n\t * (which are few asm insns before __bpf_tramp_enter and\n\t *  after __bpf_tramp_exit)\n\t *\n\t * The trampoline is unreachable before bpf_tramp_image_put().\n\t *\n\t * First, patch the trampoline to avoid calling into fexit progs.\n\t * The progs will be freed even if the original function is still\n\t * executing or sleeping.\n\t * In case of CONFIG_PREEMPT=y use call_rcu_tasks() to wait on\n\t * first few asm instructions to execute and call into\n\t * __bpf_tramp_enter->percpu_ref_get.\n\t * Then use percpu_ref_kill to wait for the trampoline and the original\n\t * function to finish.\n\t * Then use call_rcu_tasks() to make sure few asm insns in\n\t * the trampoline epilogue are done as well.\n\t *\n\t * In !PREEMPT case the task that got interrupted in the first asm\n\t * insns won't go through an RCU quiescent state which the\n\t * percpu_ref_kill will be waiting for. Hence the first\n\t * call_rcu_tasks() is not necessary.\n\t */\n\tif (im->ip_after_call) {\n\t\tint err = bpf_arch_text_poke(im->ip_after_call, BPF_MOD_JUMP,\n\t\t\t\t\t     NULL, im->ip_epilogue);\n\t\tWARN_ON(err);\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tcall_rcu_tasks(&im->rcu, __bpf_tramp_image_put_rcu_tasks);\n\t\telse\n\t\t\tpercpu_ref_kill(&im->pcref);\n\t\treturn;\n\t}\n\n\t/* The trampoline without fexit and fmod_ret progs doesn't call original\n\t * function and doesn't use percpu_ref.\n\t * Use call_rcu_tasks_trace() to wait for sleepable progs to finish.\n\t * Then use call_rcu_tasks() to wait for the rest of trampoline asm\n\t * and normal progs.\n\t */\n\tcall_rcu_tasks_trace(&im->rcu, __bpf_tramp_image_put_rcu_tasks);\n}"
  },
  {
    "function_name": "__bpf_tramp_image_put_rcu_tasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "241-252",
    "snippet": "static void __bpf_tramp_image_put_rcu_tasks(struct rcu_head *rcu)\n{\n\tstruct bpf_tramp_image *im;\n\n\tim = container_of(rcu, struct bpf_tramp_image, rcu);\n\tif (im->ip_after_call)\n\t\t/* the case of fmod_ret/fexit trampoline and CONFIG_PREEMPTION=y */\n\t\tpercpu_ref_kill(&im->pcref);\n\telse\n\t\t/* the case of fentry trampoline */\n\t\tcall_rcu_tasks(&im->rcu, __bpf_tramp_image_put_rcu);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_tasks",
          "args": [
            "&im->rcu",
            "__bpf_tramp_image_put_rcu"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "&im->pcref"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_tramp_image",
            "rcu"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void __bpf_tramp_image_put_rcu_tasks(struct rcu_head *rcu)\n{\n\tstruct bpf_tramp_image *im;\n\n\tim = container_of(rcu, struct bpf_tramp_image, rcu);\n\tif (im->ip_after_call)\n\t\t/* the case of fmod_ret/fexit trampoline and CONFIG_PREEMPTION=y */\n\t\tpercpu_ref_kill(&im->pcref);\n\telse\n\t\t/* the case of fentry trampoline */\n\t\tcall_rcu_tasks(&im->rcu, __bpf_tramp_image_put_rcu);\n}"
  },
  {
    "function_name": "__bpf_tramp_image_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "232-238",
    "snippet": "static void __bpf_tramp_image_release(struct percpu_ref *pcref)\n{\n\tstruct bpf_tramp_image *im;\n\n\tim = container_of(pcref, struct bpf_tramp_image, pcref);\n\tcall_rcu_tasks(&im->rcu, __bpf_tramp_image_put_rcu);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_tasks",
          "args": [
            "&im->rcu",
            "__bpf_tramp_image_put_rcu"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "pcref",
            "structbpf_tramp_image",
            "pcref"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void __bpf_tramp_image_release(struct percpu_ref *pcref)\n{\n\tstruct bpf_tramp_image *im;\n\n\tim = container_of(pcref, struct bpf_tramp_image, pcref);\n\tcall_rcu_tasks(&im->rcu, __bpf_tramp_image_put_rcu);\n}"
  },
  {
    "function_name": "__bpf_tramp_image_put_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "222-229",
    "snippet": "static void __bpf_tramp_image_put_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_tramp_image *im;\n\n\tim = container_of(rcu, struct bpf_tramp_image, rcu);\n\tINIT_WORK(&im->work, __bpf_tramp_image_put_deferred);\n\tschedule_work(&im->work);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&im->work"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&im->work",
            "__bpf_tramp_image_put_deferred"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_tramp_image",
            "rcu"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void __bpf_tramp_image_put_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_tramp_image *im;\n\n\tim = container_of(rcu, struct bpf_tramp_image, rcu);\n\tINIT_WORK(&im->work, __bpf_tramp_image_put_deferred);\n\tschedule_work(&im->work);\n}"
  },
  {
    "function_name": "__bpf_tramp_image_put_deferred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "209-219",
    "snippet": "static void __bpf_tramp_image_put_deferred(struct work_struct *work)\n{\n\tstruct bpf_tramp_image *im;\n\n\tim = container_of(work, struct bpf_tramp_image, work);\n\tbpf_image_ksym_del(&im->ksym);\n\tbpf_jit_free_exec(im->image);\n\tbpf_jit_uncharge_modmem(1);\n\tpercpu_ref_exit(&im->pcref);\n\tkfree_rcu(im, rcu);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "im",
            "rcu"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&im->pcref"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_jit_uncharge_modmem",
          "args": [
            "1"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_uncharge_modmem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "849-852",
          "snippet": "void bpf_jit_uncharge_modmem(u32 pages)\n{\n\tatomic_long_sub(pages, &bpf_jit_current);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_jit_uncharge_modmem(u32 pages)\n{\n\tatomic_long_sub(pages, &bpf_jit_current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_free_exec",
          "args": [
            "im->image"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_free_exec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "859-862",
          "snippet": "void __weak bpf_jit_free_exec(void *addr)\n{\n\tmodule_memfree(addr);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nvoid __weak bpf_jit_free_exec(void *addr)\n{\n\tmodule_memfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_image_ksym_del",
          "args": [
            "&im->ksym"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_image_ksym_del",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "63-68",
          "snippet": "void bpf_image_ksym_del(struct bpf_ksym *ksym)\n{\n\tbpf_ksym_del(ksym);\n\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_BPF, ksym->start,\n\t\t\t   PAGE_SIZE, true, ksym->name);\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nvoid bpf_image_ksym_del(struct bpf_ksym *ksym)\n{\n\tbpf_ksym_del(ksym);\n\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_BPF, ksym->start,\n\t\t\t   PAGE_SIZE, true, ksym->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbpf_tramp_image",
            "work"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void __bpf_tramp_image_put_deferred(struct work_struct *work)\n{\n\tstruct bpf_tramp_image *im;\n\n\tim = container_of(work, struct bpf_tramp_image, work);\n\tbpf_image_ksym_del(&im->ksym);\n\tbpf_jit_free_exec(im->image);\n\tbpf_jit_uncharge_modmem(1);\n\tpercpu_ref_exit(&im->pcref);\n\tkfree_rcu(im, rcu);\n}"
  },
  {
    "function_name": "bpf_trampoline_get_progs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "183-207",
    "snippet": "static struct bpf_tramp_progs *\nbpf_trampoline_get_progs(const struct bpf_trampoline *tr, int *total, bool *ip_arg)\n{\n\tconst struct bpf_prog_aux *aux;\n\tstruct bpf_tramp_progs *tprogs;\n\tstruct bpf_prog **progs;\n\tint kind;\n\n\t*total = 0;\n\ttprogs = kcalloc(BPF_TRAMP_MAX, sizeof(*tprogs), GFP_KERNEL);\n\tif (!tprogs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (kind = 0; kind < BPF_TRAMP_MAX; kind++) {\n\t\ttprogs[kind].nr_progs = tr->progs_cnt[kind];\n\t\t*total += tr->progs_cnt[kind];\n\t\tprogs = tprogs[kind].progs;\n\n\t\thlist_for_each_entry(aux, &tr->progs_hlist[kind], tramp_hlist) {\n\t\t\t*ip_arg |= aux->prog->call_get_func_ip;\n\t\t\t*progs++ = aux->prog;\n\t\t}\n\t}\n\treturn tprogs;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "aux",
            "&tr->progs_hlist[kind]",
            "tramp_hlist"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "BPF_TRAMP_MAX",
            "sizeof(*tprogs)",
            "GFP_KERNEL"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic struct bpf_tramp_progs *\nbpf_trampoline_get_progs(const struct bpf_trampoline *tr, int *total, bool *ip_arg)\n{\n\tconst struct bpf_prog_aux *aux;\n\tstruct bpf_tramp_progs *tprogs;\n\tstruct bpf_prog **progs;\n\tint kind;\n\n\t*total = 0;\n\ttprogs = kcalloc(BPF_TRAMP_MAX, sizeof(*tprogs), GFP_KERNEL);\n\tif (!tprogs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (kind = 0; kind < BPF_TRAMP_MAX; kind++) {\n\t\ttprogs[kind].nr_progs = tr->progs_cnt[kind];\n\t\t*total += tr->progs_cnt[kind];\n\t\tprogs = tprogs[kind].progs;\n\n\t\thlist_for_each_entry(aux, &tr->progs_hlist[kind], tramp_hlist) {\n\t\t\t*ip_arg |= aux->prog->call_get_func_ip;\n\t\t\t*progs++ = aux->prog;\n\t\t}\n\t}\n\treturn tprogs;\n}"
  },
  {
    "function_name": "register_fentry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "160-181",
    "snippet": "static int register_fentry(struct bpf_trampoline *tr, void *new_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tret = is_ftrace_location(ip);\n\tif (ret < 0)\n\t\treturn ret;\n\ttr->func.ftrace_managed = ret;\n\n\tif (bpf_trampoline_module_get(tr))\n\t\treturn -ENOENT;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = register_ftrace_direct((long)ip, (long)new_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, NULL, new_addr);\n\n\tif (ret)\n\t\tbpf_trampoline_module_put(tr);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_trampoline_module_put",
          "args": [
            "tr"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "114-118",
          "snippet": "static void bpf_trampoline_module_put(struct bpf_trampoline *tr)\n{\n\tmodule_put(tr->mod);\n\ttr->mod = NULL;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void bpf_trampoline_module_put(struct bpf_trampoline *tr)\n{\n\tmodule_put(tr->mod);\n\ttr->mod = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_arch_text_poke",
          "args": [
            "ip",
            "BPF_MOD_CALL",
            "NULL",
            "new_addr"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_arch_text_poke",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2450-2454",
          "snippet": "int __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nint __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_ftrace_direct",
          "args": [
            "(long)ip",
            "(long)new_addr"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_direct_multi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5531-5550",
          "snippet": "int unregister_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\tint err;\n\n\tif (check_direct_multi(ops))\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\terr = unregister_ftrace_function(ops);\n\tremove_direct_functions_hash(hash, addr);\n\tmutex_unlock(&direct_mutex);\n\n\t/* cleanup for possible another register call */\n\tops->func = NULL;\n\tops->trampoline = 0;\n\treturn err;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\tint err;\n\n\tif (check_direct_multi(ops))\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\terr = unregister_ftrace_function(ops);\n\tremove_direct_functions_hash(hash, addr);\n\tmutex_unlock(&direct_mutex);\n\n\t/* cleanup for possible another register call */\n\tops->func = NULL;\n\tops->trampoline = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_module_get",
          "args": [
            "tr"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "100-112",
          "snippet": "static int bpf_trampoline_module_get(struct bpf_trampoline *tr)\n{\n\tstruct module *mod;\n\tint err = 0;\n\n\tpreempt_disable();\n\tmod = __module_text_address((unsigned long) tr->func.addr);\n\tif (mod && !try_module_get(mod))\n\t\terr = -ENOENT;\n\tpreempt_enable();\n\ttr->mod = mod;\n\treturn err;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int bpf_trampoline_module_get(struct bpf_trampoline *tr)\n{\n\tstruct module *mod;\n\tint err = 0;\n\n\tpreempt_disable();\n\tmod = __module_text_address((unsigned long) tr->func.addr);\n\tif (mod && !try_module_get(mod))\n\t\terr = -ENOENT;\n\tpreempt_enable();\n\ttr->mod = mod;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ftrace_location",
          "args": [
            "ip"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "is_ftrace_location",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "120-130",
          "snippet": "static int is_ftrace_location(void *ip)\n{\n\tlong addr;\n\n\taddr = ftrace_location((long)ip);\n\tif (!addr)\n\t\treturn 0;\n\tif (WARN_ON_ONCE(addr != (long)ip))\n\t\treturn -EFAULT;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int is_ftrace_location(void *ip)\n{\n\tlong addr;\n\n\taddr = ftrace_location((long)ip);\n\tif (!addr)\n\t\treturn 0;\n\tif (WARN_ON_ONCE(addr != (long)ip))\n\t\treturn -EFAULT;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int register_fentry(struct bpf_trampoline *tr, void *new_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tret = is_ftrace_location(ip);\n\tif (ret < 0)\n\t\treturn ret;\n\ttr->func.ftrace_managed = ret;\n\n\tif (bpf_trampoline_module_get(tr))\n\t\treturn -ENOENT;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = register_ftrace_direct((long)ip, (long)new_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, NULL, new_addr);\n\n\tif (ret)\n\t\tbpf_trampoline_module_put(tr);\n\treturn ret;\n}"
  },
  {
    "function_name": "modify_fentry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "147-157",
    "snippet": "static int modify_fentry(struct bpf_trampoline *tr, void *old_addr, void *new_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = modify_ftrace_direct((long)ip, (long)old_addr, (long)new_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, old_addr, new_addr);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_arch_text_poke",
          "args": [
            "ip",
            "BPF_MOD_CALL",
            "old_addr",
            "new_addr"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_arch_text_poke",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2450-2454",
          "snippet": "int __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nint __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify_ftrace_direct",
          "args": [
            "(long)ip",
            "(long)old_addr",
            "(long)new_addr"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "modify_ftrace_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5346-5404",
          "snippet": "int modify_ftrace_direct(unsigned long ip,\n\t\t\t unsigned long old_addr, unsigned long new_addr)\n{\n\tstruct ftrace_direct_func *direct, *new_direct = NULL;\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&direct_mutex);\n\n\tmutex_lock(&ftrace_lock);\n\tentry = find_direct_entry(&ip, &rec);\n\tif (!entry)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tif (entry->direct != old_addr)\n\t\tgoto out_unlock;\n\n\tdirect = ftrace_find_direct_func(old_addr);\n\tif (WARN_ON(!direct))\n\t\tgoto out_unlock;\n\tif (direct->count > 1) {\n\t\tret = -ENOMEM;\n\t\tnew_direct = ftrace_alloc_direct_func(new_addr);\n\t\tif (!new_direct)\n\t\t\tgoto out_unlock;\n\t\tdirect->count--;\n\t\tnew_direct->count++;\n\t} else {\n\t\tdirect->addr = new_addr;\n\t}\n\n\t/*\n\t * If there's no other ftrace callback on the rec->ip location,\n\t * then it can be changed directly by the architecture.\n\t * If there is another caller, then we just need to change the\n\t * direct caller helper to point to @new_addr.\n\t */\n\tif (ftrace_rec_count(rec) == 1) {\n\t\tret = ftrace_modify_direct_caller(entry, rec, old_addr, new_addr);\n\t} else {\n\t\tentry->direct = new_addr;\n\t\tret = 0;\n\t}\n\n\tif (unlikely(ret && new_direct)) {\n\t\tdirect->count++;\n\t\tlist_del_rcu(&new_direct->next);\n\t\tsynchronize_rcu_tasks();\n\t\tkfree(new_direct);\n\t\tftrace_direct_func_count--;\n\t}\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\tmutex_unlock(&direct_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint modify_ftrace_direct(unsigned long ip,\n\t\t\t unsigned long old_addr, unsigned long new_addr)\n{\n\tstruct ftrace_direct_func *direct, *new_direct = NULL;\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&direct_mutex);\n\n\tmutex_lock(&ftrace_lock);\n\tentry = find_direct_entry(&ip, &rec);\n\tif (!entry)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tif (entry->direct != old_addr)\n\t\tgoto out_unlock;\n\n\tdirect = ftrace_find_direct_func(old_addr);\n\tif (WARN_ON(!direct))\n\t\tgoto out_unlock;\n\tif (direct->count > 1) {\n\t\tret = -ENOMEM;\n\t\tnew_direct = ftrace_alloc_direct_func(new_addr);\n\t\tif (!new_direct)\n\t\t\tgoto out_unlock;\n\t\tdirect->count--;\n\t\tnew_direct->count++;\n\t} else {\n\t\tdirect->addr = new_addr;\n\t}\n\n\t/*\n\t * If there's no other ftrace callback on the rec->ip location,\n\t * then it can be changed directly by the architecture.\n\t * If there is another caller, then we just need to change the\n\t * direct caller helper to point to @new_addr.\n\t */\n\tif (ftrace_rec_count(rec) == 1) {\n\t\tret = ftrace_modify_direct_caller(entry, rec, old_addr, new_addr);\n\t} else {\n\t\tentry->direct = new_addr;\n\t\tret = 0;\n\t}\n\n\tif (unlikely(ret && new_direct)) {\n\t\tdirect->count++;\n\t\tlist_del_rcu(&new_direct->next);\n\t\tsynchronize_rcu_tasks();\n\t\tkfree(new_direct);\n\t\tftrace_direct_func_count--;\n\t}\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\tmutex_unlock(&direct_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int modify_fentry(struct bpf_trampoline *tr, void *old_addr, void *new_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = modify_ftrace_direct((long)ip, (long)old_addr, (long)new_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, old_addr, new_addr);\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_fentry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "132-145",
    "snippet": "static int unregister_fentry(struct bpf_trampoline *tr, void *old_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = unregister_ftrace_direct((long)ip, (long)old_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, old_addr, NULL);\n\n\tif (!ret)\n\t\tbpf_trampoline_module_put(tr);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_trampoline_module_put",
          "args": [
            "tr"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "114-118",
          "snippet": "static void bpf_trampoline_module_put(struct bpf_trampoline *tr)\n{\n\tmodule_put(tr->mod);\n\ttr->mod = NULL;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void bpf_trampoline_module_put(struct bpf_trampoline *tr)\n{\n\tmodule_put(tr->mod);\n\ttr->mod = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_arch_text_poke",
          "args": [
            "ip",
            "BPF_MOD_CALL",
            "old_addr",
            "NULL"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_arch_text_poke",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2450-2454",
          "snippet": "int __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nint __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_direct",
          "args": [
            "(long)ip",
            "(long)old_addr"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_direct_multi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5531-5550",
          "snippet": "int unregister_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\tint err;\n\n\tif (check_direct_multi(ops))\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\terr = unregister_ftrace_function(ops);\n\tremove_direct_functions_hash(hash, addr);\n\tmutex_unlock(&direct_mutex);\n\n\t/* cleanup for possible another register call */\n\tops->func = NULL;\n\tops->trampoline = 0;\n\treturn err;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\tint err;\n\n\tif (check_direct_multi(ops))\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\terr = unregister_ftrace_function(ops);\n\tremove_direct_functions_hash(hash, addr);\n\tmutex_unlock(&direct_mutex);\n\n\t/* cleanup for possible another register call */\n\tops->func = NULL;\n\tops->trampoline = 0;\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int unregister_fentry(struct bpf_trampoline *tr, void *old_addr)\n{\n\tvoid *ip = tr->func.addr;\n\tint ret;\n\n\tif (tr->func.ftrace_managed)\n\t\tret = unregister_ftrace_direct((long)ip, (long)old_addr);\n\telse\n\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, old_addr, NULL);\n\n\tif (!ret)\n\t\tbpf_trampoline_module_put(tr);\n\treturn ret;\n}"
  },
  {
    "function_name": "is_ftrace_location",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "120-130",
    "snippet": "static int is_ftrace_location(void *ip)\n{\n\tlong addr;\n\n\taddr = ftrace_location((long)ip);\n\tif (!addr)\n\t\treturn 0;\n\tif (WARN_ON_ONCE(addr != (long)ip))\n\t\treturn -EFAULT;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "addr != (long)ip"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_location",
          "args": [
            "(long)ip"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "is_ftrace_location",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "120-130",
          "snippet": "static int is_ftrace_location(void *ip)\n{\n\tlong addr;\n\n\taddr = ftrace_location((long)ip);\n\tif (!addr)\n\t\treturn 0;\n\tif (WARN_ON_ONCE(addr != (long)ip))\n\t\treturn -EFAULT;\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int is_ftrace_location(void *ip)\n{\n\tlong addr;\n\n\taddr = ftrace_location((long)ip);\n\tif (!addr)\n\t\treturn 0;\n\tif (WARN_ON_ONCE(addr != (long)ip))\n\t\treturn -EFAULT;\n\treturn 1;\n}"
  },
  {
    "function_name": "bpf_trampoline_module_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "114-118",
    "snippet": "static void bpf_trampoline_module_put(struct bpf_trampoline *tr)\n{\n\tmodule_put(tr->mod);\n\ttr->mod = NULL;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "tr->mod"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "114-118",
          "snippet": "static void bpf_trampoline_module_put(struct bpf_trampoline *tr)\n{\n\tmodule_put(tr->mod);\n\ttr->mod = NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void bpf_trampoline_module_put(struct bpf_trampoline *tr)\n{\n\tmodule_put(tr->mod);\n\ttr->mod = NULL;\n}"
  },
  {
    "function_name": "bpf_trampoline_module_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "100-112",
    "snippet": "static int bpf_trampoline_module_get(struct bpf_trampoline *tr)\n{\n\tstruct module *mod;\n\tint err = 0;\n\n\tpreempt_disable();\n\tmod = __module_text_address((unsigned long) tr->func.addr);\n\tif (mod && !try_module_get(mod))\n\t\terr = -ENOENT;\n\tpreempt_enable();\n\ttr->mod = mod;\n\treturn err;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "mod"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__module_text_address",
          "args": [
            "(unsigned long) tr->func.addr"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "__module_text_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4780-4790",
          "snippet": "struct module *__module_text_address(unsigned long addr)\n{\n\tstruct module *mod = __module_address(addr);\n\tif (mod) {\n\t\t/* Make sure it's within the text section. */\n\t\tif (!within(addr, mod->init_layout.base, mod->init_layout.text_size)\n\t\t    && !within(addr, mod->core_layout.base, mod->core_layout.text_size))\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nstruct module *__module_text_address(unsigned long addr)\n{\n\tstruct module *mod = __module_address(addr);\n\tif (mod) {\n\t\t/* Make sure it's within the text section. */\n\t\tif (!within(addr, mod->init_layout.base, mod->init_layout.text_size)\n\t\t    && !within(addr, mod->core_layout.base, mod->core_layout.text_size))\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic int bpf_trampoline_module_get(struct bpf_trampoline *tr)\n{\n\tstruct module *mod;\n\tint err = 0;\n\n\tpreempt_disable();\n\tmod = __module_text_address((unsigned long) tr->func.addr);\n\tif (mod && !try_module_get(mod))\n\t\terr = -ENOENT;\n\tpreempt_enable();\n\ttr->mod = mod;\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_trampoline_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "70-98",
    "snippet": "static struct bpf_trampoline *bpf_trampoline_lookup(u64 key)\n{\n\tstruct bpf_trampoline *tr;\n\tstruct hlist_head *head;\n\tint i;\n\n\tmutex_lock(&trampoline_mutex);\n\thead = &trampoline_table[hash_64(key, TRAMPOLINE_HASH_BITS)];\n\thlist_for_each_entry(tr, head, hlist) {\n\t\tif (tr->key == key) {\n\t\t\trefcount_inc(&tr->refcnt);\n\t\t\tgoto out;\n\t\t}\n\t}\n\ttr = kzalloc(sizeof(*tr), GFP_KERNEL);\n\tif (!tr)\n\t\tgoto out;\n\n\ttr->key = key;\n\tINIT_HLIST_NODE(&tr->hlist);\n\thlist_add_head(&tr->hlist, head);\n\trefcount_set(&tr->refcnt, 1);\n\tmutex_init(&tr->mutex);\n\tfor (i = 0; i < BPF_TRAMP_MAX; i++)\n\t\tINIT_HLIST_HEAD(&tr->progs_hlist[i]);\nout:\n\tmutex_unlock(&trampoline_mutex);\n\treturn tr;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [
      "#define TRAMPOLINE_HASH_BITS 10"
    ],
    "globals_used": [
      "static struct hlist_head trampoline_table[TRAMPOLINE_TABLE_SIZE];",
      "static DEFINE_MUTEX(trampoline_mutex);",
      "static __always_inline u64"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trampoline_mutex"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&tr->progs_hlist[i]"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&tr->mutex"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&tr->refcnt",
            "1"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&tr->hlist",
            "head"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&tr->hlist"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tr)",
            "GFP_KERNEL"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&tr->refcnt"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "tr",
            "head",
            "hlist"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_64",
          "args": [
            "key",
            "TRAMPOLINE_HASH_BITS"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trampoline_mutex"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\n#define TRAMPOLINE_HASH_BITS 10\n\nstatic struct hlist_head trampoline_table[TRAMPOLINE_TABLE_SIZE];\nstatic DEFINE_MUTEX(trampoline_mutex);\nstatic __always_inline u64;\n\nstatic struct bpf_trampoline *bpf_trampoline_lookup(u64 key)\n{\n\tstruct bpf_trampoline *tr;\n\tstruct hlist_head *head;\n\tint i;\n\n\tmutex_lock(&trampoline_mutex);\n\thead = &trampoline_table[hash_64(key, TRAMPOLINE_HASH_BITS)];\n\thlist_for_each_entry(tr, head, hlist) {\n\t\tif (tr->key == key) {\n\t\t\trefcount_inc(&tr->refcnt);\n\t\t\tgoto out;\n\t\t}\n\t}\n\ttr = kzalloc(sizeof(*tr), GFP_KERNEL);\n\tif (!tr)\n\t\tgoto out;\n\n\ttr->key = key;\n\tINIT_HLIST_NODE(&tr->hlist);\n\thlist_add_head(&tr->hlist, head);\n\trefcount_set(&tr->refcnt, 1);\n\tmutex_init(&tr->mutex);\n\tfor (i = 0; i < BPF_TRAMP_MAX; i++)\n\t\tINIT_HLIST_HEAD(&tr->progs_hlist[i]);\nout:\n\tmutex_unlock(&trampoline_mutex);\n\treturn tr;\n}"
  },
  {
    "function_name": "bpf_image_ksym_del",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "63-68",
    "snippet": "void bpf_image_ksym_del(struct bpf_ksym *ksym)\n{\n\tbpf_ksym_del(ksym);\n\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_BPF, ksym->start,\n\t\t\t   PAGE_SIZE, true, ksym->name);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_ksymbol",
          "args": [
            "PERF_RECORD_KSYMBOL_TYPE_BPF",
            "ksym->start",
            "PAGE_SIZE",
            "true",
            "ksym->name"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_ksymbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "8843-8887",
          "snippet": "void perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_ksymbol_events",
            "static __must_check struct",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic atomic_t nr_ksymbol_events;\nstatic __must_check struct;\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_ksym_del",
          "args": [
            "ksym"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_ksym_del",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "639-644",
          "snippet": "void bpf_ksym_del(struct bpf_ksym *ksym)\n{\n\tspin_lock_bh(&bpf_lock);\n\t__bpf_ksym_del(ksym);\n\tspin_unlock_bh(&bpf_lock);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_ksym_del(struct bpf_ksym *ksym)\n{\n\tspin_lock_bh(&bpf_lock);\n\t__bpf_ksym_del(ksym);\n\tspin_unlock_bh(&bpf_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nvoid bpf_image_ksym_del(struct bpf_ksym *ksym)\n{\n\tbpf_ksym_del(ksym);\n\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_BPF, ksym->start,\n\t\t\t   PAGE_SIZE, true, ksym->name);\n}"
  },
  {
    "function_name": "bpf_image_ksym_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "54-61",
    "snippet": "void bpf_image_ksym_add(void *data, struct bpf_ksym *ksym)\n{\n\tksym->start = (unsigned long) data;\n\tksym->end = ksym->start + PAGE_SIZE;\n\tbpf_ksym_add(ksym);\n\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_BPF, ksym->start,\n\t\t\t   PAGE_SIZE, false, ksym->name);\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_ksymbol",
          "args": [
            "PERF_RECORD_KSYMBOL_TYPE_BPF",
            "ksym->start",
            "PAGE_SIZE",
            "false",
            "ksym->name"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_ksymbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "8843-8887",
          "snippet": "void perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_ksymbol_events",
            "static __must_check struct",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic atomic_t nr_ksymbol_events;\nstatic __must_check struct;\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_ksym_add",
          "args": [
            "ksym"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_ksym_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "621-628",
          "snippet": "void bpf_ksym_add(struct bpf_ksym *ksym)\n{\n\tspin_lock_bh(&bpf_lock);\n\tWARN_ON_ONCE(!list_empty(&ksym->lnode));\n\tlist_add_tail_rcu(&ksym->lnode, &bpf_kallsyms);\n\tlatch_tree_insert(&ksym->tnode, &bpf_tree, &bpf_tree_ops);\n\tspin_unlock_bh(&bpf_lock);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_ksym_add(struct bpf_ksym *ksym)\n{\n\tspin_lock_bh(&bpf_lock);\n\tWARN_ON_ONCE(!list_empty(&ksym->lnode));\n\tlist_add_tail_rcu(&ksym->lnode, &bpf_kallsyms);\n\tlatch_tree_insert(&ksym->tnode, &bpf_tree, &bpf_tree_ops);\n\tspin_unlock_bh(&bpf_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nvoid bpf_image_ksym_add(void *data, struct bpf_ksym *ksym)\n{\n\tksym->start = (unsigned long) data;\n\tksym->end = ksym->start + PAGE_SIZE;\n\tbpf_ksym_add(ksym);\n\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_BPF, ksym->start,\n\t\t\t   PAGE_SIZE, false, ksym->name);\n}"
  },
  {
    "function_name": "bpf_jit_alloc_exec_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "38-52",
    "snippet": "void *bpf_jit_alloc_exec_page(void)\n{\n\tvoid *image;\n\n\timage = bpf_jit_alloc_exec(PAGE_SIZE);\n\tif (!image)\n\t\treturn NULL;\n\n\tset_vm_flush_reset_perms(image);\n\t/* Keep image as writeable. The alternative is to keep flipping ro/rw\n\t * everytime new program is attached or detached.\n\t */\n\tset_memory_x((long)image, 1);\n\treturn image;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_memory_x",
          "args": [
            "(long)image",
            "1"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_vm_flush_reset_perms",
          "args": [
            "image"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_jit_alloc_exec",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_alloc_exec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "854-857",
          "snippet": "void *__weak bpf_jit_alloc_exec(unsigned long size)\n{\n\treturn module_alloc(size);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nvoid *__weak bpf_jit_alloc_exec(unsigned long size)\n{\n\treturn module_alloc(size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nvoid *bpf_jit_alloc_exec_page(void)\n{\n\tvoid *image;\n\n\timage = bpf_jit_alloc_exec(PAGE_SIZE);\n\tif (!image)\n\t\treturn NULL;\n\n\tset_vm_flush_reset_perms(image);\n\t/* Keep image as writeable. The alternative is to keep flipping ro/rw\n\t * everytime new program is attached or detached.\n\t */\n\tset_memory_x((long)image, 1);\n\treturn image;\n}"
  },
  {
    "function_name": "bpf_prog_has_trampoline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
    "lines": "30-36",
    "snippet": "bool bpf_prog_has_trampoline(const struct bpf_prog *prog)\n{\n\tenum bpf_attach_type eatype = prog->expected_attach_type;\n\n\treturn eatype == BPF_TRACE_FENTRY || eatype == BPF_TRACE_FEXIT ||\n\t       eatype == BPF_MODIFY_RETURN;\n}",
    "includes": [
      "#include <linux/static_call.h>",
      "#include <linux/module.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nbool bpf_prog_has_trampoline(const struct bpf_prog *prog)\n{\n\tenum bpf_attach_type eatype = prog->expected_attach_type;\n\n\treturn eatype == BPF_TRACE_FENTRY || eatype == BPF_TRACE_FEXIT ||\n\t       eatype == BPF_MODIFY_RETURN;\n}"
  }
]