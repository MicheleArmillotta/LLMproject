[
  {
    "function_name": "cg_sockopt_get_prologue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "2076-2083",
    "snippet": "static int cg_sockopt_get_prologue(struct bpf_insn *insn_buf,\n\t\t\t\t   bool direct_write,\n\t\t\t\t   const struct bpf_prog *prog)\n{\n\t/* Nothing to do for sockopt argument. The data is kzalloc'ated.\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int cg_sockopt_get_prologue(struct bpf_insn *insn_buf,\n\t\t\t\t   bool direct_write,\n\t\t\t\t   const struct bpf_prog *prog)\n{\n\t/* Nothing to do for sockopt argument. The data is kzalloc'ated.\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "cg_sockopt_convert_ctx_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "2029-2074",
    "snippet": "static u32 cg_sockopt_convert_ctx_access(enum bpf_access_type type,\n\t\t\t\t\t const struct bpf_insn *si,\n\t\t\t\t\t struct bpf_insn *insn_buf,\n\t\t\t\t\t struct bpf_prog *prog,\n\t\t\t\t\t u32 *target_size)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\n\tswitch (si->off) {\n\tcase offsetof(struct bpf_sockopt, sk):\n\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, sk);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, level):\n\t\tif (type == BPF_WRITE)\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, level);\n\t\telse\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, level);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optname):\n\t\tif (type == BPF_WRITE)\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, optname);\n\t\telse\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optname);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optlen):\n\t\tif (type == BPF_WRITE)\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, optlen);\n\t\telse\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optlen);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, retval):\n\t\tif (type == BPF_WRITE)\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, retval);\n\t\telse\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, retval);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optval):\n\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optval);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optval_end):\n\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optval_end);\n\t\tbreak;\n\t}\n\n\treturn insn - insn_buf;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CG_SOCKOPT_ACCESS_FIELD",
          "args": [
            "BPF_LDX_MEM",
            "optval_end"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CG_SOCKOPT_ACCESS_FIELD",
          "args": [
            "BPF_LDX_MEM",
            "optval"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CG_SOCKOPT_ACCESS_FIELD",
          "args": [
            "BPF_LDX_MEM",
            "retval"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CG_SOCKOPT_ACCESS_FIELD",
          "args": [
            "BPF_STX_MEM",
            "retval"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CG_SOCKOPT_ACCESS_FIELD",
          "args": [
            "BPF_LDX_MEM",
            "optlen"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CG_SOCKOPT_ACCESS_FIELD",
          "args": [
            "BPF_STX_MEM",
            "optlen"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CG_SOCKOPT_ACCESS_FIELD",
          "args": [
            "BPF_LDX_MEM",
            "optname"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CG_SOCKOPT_ACCESS_FIELD",
          "args": [
            "BPF_STX_MEM",
            "optname"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CG_SOCKOPT_ACCESS_FIELD",
          "args": [
            "BPF_LDX_MEM",
            "level"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CG_SOCKOPT_ACCESS_FIELD",
          "args": [
            "BPF_STX_MEM",
            "level"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CG_SOCKOPT_ACCESS_FIELD",
          "args": [
            "BPF_LDX_MEM",
            "sk"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 cg_sockopt_convert_ctx_access(enum bpf_access_type type,\n\t\t\t\t\t const struct bpf_insn *si,\n\t\t\t\t\t struct bpf_insn *insn_buf,\n\t\t\t\t\t struct bpf_prog *prog,\n\t\t\t\t\t u32 *target_size)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\n\tswitch (si->off) {\n\tcase offsetof(struct bpf_sockopt, sk):\n\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, sk);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, level):\n\t\tif (type == BPF_WRITE)\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, level);\n\t\telse\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, level);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optname):\n\t\tif (type == BPF_WRITE)\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, optname);\n\t\telse\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optname);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optlen):\n\t\tif (type == BPF_WRITE)\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, optlen);\n\t\telse\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optlen);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, retval):\n\t\tif (type == BPF_WRITE)\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, retval);\n\t\telse\n\t\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, retval);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optval):\n\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optval);\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optval_end):\n\t\t*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optval_end);\n\t\tbreak;\n\t}\n\n\treturn insn - insn_buf;\n}"
  },
  {
    "function_name": "cg_sockopt_is_valid_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1962-2022",
    "snippet": "static bool cg_sockopt_is_valid_access(int off, int size,\n\t\t\t\t       enum bpf_access_type type,\n\t\t\t\t       const struct bpf_prog *prog,\n\t\t\t\t       struct bpf_insn_access_aux *info)\n{\n\tconst int size_default = sizeof(__u32);\n\n\tif (off < 0 || off >= sizeof(struct bpf_sockopt))\n\t\treturn false;\n\n\tif (off % size != 0)\n\t\treturn false;\n\n\tif (type == BPF_WRITE) {\n\t\tswitch (off) {\n\t\tcase offsetof(struct bpf_sockopt, retval):\n\t\t\tif (size != size_default)\n\t\t\t\treturn false;\n\t\t\treturn prog->expected_attach_type ==\n\t\t\t\tBPF_CGROUP_GETSOCKOPT;\n\t\tcase offsetof(struct bpf_sockopt, optname):\n\t\t\tfallthrough;\n\t\tcase offsetof(struct bpf_sockopt, level):\n\t\t\tif (size != size_default)\n\t\t\t\treturn false;\n\t\t\treturn prog->expected_attach_type ==\n\t\t\t\tBPF_CGROUP_SETSOCKOPT;\n\t\tcase offsetof(struct bpf_sockopt, optlen):\n\t\t\treturn size == size_default;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tswitch (off) {\n\tcase offsetof(struct bpf_sockopt, sk):\n\t\tif (size != sizeof(__u64))\n\t\t\treturn false;\n\t\tinfo->reg_type = PTR_TO_SOCKET;\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optval):\n\t\tif (size != sizeof(__u64))\n\t\t\treturn false;\n\t\tinfo->reg_type = PTR_TO_PACKET;\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optval_end):\n\t\tif (size != sizeof(__u64))\n\t\t\treturn false;\n\t\tinfo->reg_type = PTR_TO_PACKET_END;\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, retval):\n\t\tif (size != size_default)\n\t\t\treturn false;\n\t\treturn prog->expected_attach_type == BPF_CGROUP_GETSOCKOPT;\n\tdefault:\n\t\tif (size != size_default)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool cg_sockopt_is_valid_access(int off, int size,\n\t\t\t\t       enum bpf_access_type type,\n\t\t\t\t       const struct bpf_prog *prog,\n\t\t\t\t       struct bpf_insn_access_aux *info)\n{\n\tconst int size_default = sizeof(__u32);\n\n\tif (off < 0 || off >= sizeof(struct bpf_sockopt))\n\t\treturn false;\n\n\tif (off % size != 0)\n\t\treturn false;\n\n\tif (type == BPF_WRITE) {\n\t\tswitch (off) {\n\t\tcase offsetof(struct bpf_sockopt, retval):\n\t\t\tif (size != size_default)\n\t\t\t\treturn false;\n\t\t\treturn prog->expected_attach_type ==\n\t\t\t\tBPF_CGROUP_GETSOCKOPT;\n\t\tcase offsetof(struct bpf_sockopt, optname):\n\t\t\tfallthrough;\n\t\tcase offsetof(struct bpf_sockopt, level):\n\t\t\tif (size != size_default)\n\t\t\t\treturn false;\n\t\t\treturn prog->expected_attach_type ==\n\t\t\t\tBPF_CGROUP_SETSOCKOPT;\n\t\tcase offsetof(struct bpf_sockopt, optlen):\n\t\t\treturn size == size_default;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tswitch (off) {\n\tcase offsetof(struct bpf_sockopt, sk):\n\t\tif (size != sizeof(__u64))\n\t\t\treturn false;\n\t\tinfo->reg_type = PTR_TO_SOCKET;\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optval):\n\t\tif (size != sizeof(__u64))\n\t\t\treturn false;\n\t\tinfo->reg_type = PTR_TO_PACKET;\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, optval_end):\n\t\tif (size != sizeof(__u64))\n\t\t\treturn false;\n\t\tinfo->reg_type = PTR_TO_PACKET_END;\n\t\tbreak;\n\tcase offsetof(struct bpf_sockopt, retval):\n\t\tif (size != size_default)\n\t\t\treturn false;\n\t\treturn prog->expected_attach_type == BPF_CGROUP_GETSOCKOPT;\n\tdefault:\n\t\tif (size != size_default)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "cg_sockopt_func_proto",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1933-1960",
    "snippet": "static const struct bpf_func_proto *\ncg_sockopt_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n#ifdef CONFIG_NET\n\tcase BPF_FUNC_get_netns_cookie:\n\t\treturn &bpf_get_netns_cookie_sockopt_proto;\n\tcase BPF_FUNC_sk_storage_get:\n\t\treturn &bpf_sk_storage_get_proto;\n\tcase BPF_FUNC_sk_storage_delete:\n\t\treturn &bpf_sk_storage_delete_proto;\n\tcase BPF_FUNC_setsockopt:\n\t\tif (prog->expected_attach_type == BPF_CGROUP_SETSOCKOPT)\n\t\t\treturn &bpf_sk_setsockopt_proto;\n\t\treturn NULL;\n\tcase BPF_FUNC_getsockopt:\n\t\tif (prog->expected_attach_type == BPF_CGROUP_SETSOCKOPT)\n\t\t\treturn &bpf_sk_getsockopt_proto;\n\t\treturn NULL;\n#endif\n#ifdef CONFIG_INET\n\tcase BPF_FUNC_tcp_sock:\n\t\treturn &bpf_tcp_sock_proto;\n#endif\n\tdefault:\n\t\treturn cgroup_base_func_proto(func_id, prog);\n\t}\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_func_proto",
          "args": [
            "func_id",
            "prog"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_func_proto",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1215-1230",
          "snippet": "static const struct bpf_func_proto *\ncgroup_base_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_local_storage:\n\t\treturn &bpf_get_local_storage_proto;\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_event_output_data_proto;\n\tdefault:\n\t\treturn bpf_base_func_proto(func_id);\n\t}\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto *\ncgroup_base_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_local_storage:\n\t\treturn &bpf_get_local_storage_proto;\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_event_output_data_proto;\n\tdefault:\n\t\treturn bpf_base_func_proto(func_id);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto *\ncg_sockopt_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n#ifdef CONFIG_NET\n\tcase BPF_FUNC_get_netns_cookie:\n\t\treturn &bpf_get_netns_cookie_sockopt_proto;\n\tcase BPF_FUNC_sk_storage_get:\n\t\treturn &bpf_sk_storage_get_proto;\n\tcase BPF_FUNC_sk_storage_delete:\n\t\treturn &bpf_sk_storage_delete_proto;\n\tcase BPF_FUNC_setsockopt:\n\t\tif (prog->expected_attach_type == BPF_CGROUP_SETSOCKOPT)\n\t\t\treturn &bpf_sk_setsockopt_proto;\n\t\treturn NULL;\n\tcase BPF_FUNC_getsockopt:\n\t\tif (prog->expected_attach_type == BPF_CGROUP_SETSOCKOPT)\n\t\t\treturn &bpf_sk_getsockopt_proto;\n\t\treturn NULL;\n#endif\n#ifdef CONFIG_INET\n\tcase BPF_FUNC_tcp_sock:\n\t\treturn &bpf_tcp_sock_proto;\n#endif\n\tdefault:\n\t\treturn cgroup_base_func_proto(func_id, prog);\n\t}\n}"
  },
  {
    "function_name": "sysctl_convert_ctx_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1846-1906",
    "snippet": "static u32 sysctl_convert_ctx_access(enum bpf_access_type type,\n\t\t\t\t     const struct bpf_insn *si,\n\t\t\t\t     struct bpf_insn *insn_buf,\n\t\t\t\t     struct bpf_prog *prog, u32 *target_size)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\tu32 read_size;\n\n\tswitch (si->off) {\n\tcase offsetof(struct bpf_sysctl, write):\n\t\t*insn++ = BPF_LDX_MEM(\n\t\t\tBPF_SIZE(si->code), si->dst_reg, si->src_reg,\n\t\t\tbpf_target_off(struct bpf_sysctl_kern, write,\n\t\t\t\t       sizeof_field(struct bpf_sysctl_kern,\n\t\t\t\t\t\t    write),\n\t\t\t\t       target_size));\n\t\tbreak;\n\tcase offsetof(struct bpf_sysctl, file_pos):\n\t\t/* ppos is a pointer so it should be accessed via indirect\n\t\t * loads and stores. Also for stores additional temporary\n\t\t * register is used since neither src_reg nor dst_reg can be\n\t\t * overridden.\n\t\t */\n\t\tif (type == BPF_WRITE) {\n\t\t\tint treg = BPF_REG_9;\n\n\t\t\tif (si->src_reg == treg || si->dst_reg == treg)\n\t\t\t\t--treg;\n\t\t\tif (si->src_reg == treg || si->dst_reg == treg)\n\t\t\t\t--treg;\n\t\t\t*insn++ = BPF_STX_MEM(\n\t\t\t\tBPF_DW, si->dst_reg, treg,\n\t\t\t\toffsetof(struct bpf_sysctl_kern, tmp_reg));\n\t\t\t*insn++ = BPF_LDX_MEM(\n\t\t\t\tBPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos),\n\t\t\t\ttreg, si->dst_reg,\n\t\t\t\toffsetof(struct bpf_sysctl_kern, ppos));\n\t\t\t*insn++ = BPF_STX_MEM(\n\t\t\t\tBPF_SIZEOF(u32), treg, si->src_reg,\n\t\t\t\tbpf_ctx_narrow_access_offset(\n\t\t\t\t\t0, sizeof(u32), sizeof(loff_t)));\n\t\t\t*insn++ = BPF_LDX_MEM(\n\t\t\t\tBPF_DW, treg, si->dst_reg,\n\t\t\t\toffsetof(struct bpf_sysctl_kern, tmp_reg));\n\t\t} else {\n\t\t\t*insn++ = BPF_LDX_MEM(\n\t\t\t\tBPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos),\n\t\t\t\tsi->dst_reg, si->src_reg,\n\t\t\t\toffsetof(struct bpf_sysctl_kern, ppos));\n\t\t\tread_size = bpf_size_to_bytes(BPF_SIZE(si->code));\n\t\t\t*insn++ = BPF_LDX_MEM(\n\t\t\t\tBPF_SIZE(si->code), si->dst_reg, si->dst_reg,\n\t\t\t\tbpf_ctx_narrow_access_offset(\n\t\t\t\t\t0, read_size, sizeof(loff_t)));\n\t\t}\n\t\t*target_size = sizeof(u32);\n\t\tbreak;\n\t}\n\n\treturn insn - insn_buf;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_SIZE(si->code)",
            "si->dst_reg",
            "si->dst_reg",
            "bpf_ctx_narrow_access_offset(\n\t\t\t\t\t0, read_size, sizeof(loff_t))"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_narrow_access_offset",
          "args": [
            "0",
            "read_size",
            "sizeof(loff_t)"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "si->code"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_size_to_bytes",
          "args": [
            "BPF_SIZE(si->code)"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "si->code"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos)",
            "si->dst_reg",
            "si->src_reg",
            "offsetof(struct bpf_sysctl_kern, ppos)"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_FIELD_SIZEOF",
          "args": [
            "structbpf_sysctl_kern",
            "ppos"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_DW",
            "treg",
            "si->dst_reg",
            "offsetof(struct bpf_sysctl_kern, tmp_reg)"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_STX_MEM",
          "args": [
            "BPF_SIZEOF(u32)",
            "treg",
            "si->src_reg",
            "bpf_ctx_narrow_access_offset(\n\t\t\t\t\t0, sizeof(u32), sizeof(loff_t))"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_narrow_access_offset",
          "args": [
            "0",
            "sizeof(u32)",
            "sizeof(loff_t)"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZEOF",
          "args": [
            "u32"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos)",
            "treg",
            "si->dst_reg",
            "offsetof(struct bpf_sysctl_kern, ppos)"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_FIELD_SIZEOF",
          "args": [
            "structbpf_sysctl_kern",
            "ppos"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_STX_MEM",
          "args": [
            "BPF_DW",
            "si->dst_reg",
            "treg",
            "offsetof(struct bpf_sysctl_kern, tmp_reg)"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_SIZE(si->code)",
            "si->dst_reg",
            "si->src_reg",
            "bpf_target_off(struct bpf_sysctl_kern, write,\n\t\t\t\t       sizeof_field(struct bpf_sysctl_kern,\n\t\t\t\t\t\t    write),\n\t\t\t\t       target_size)"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_target_off",
          "args": [
            "structbpf_sysctl_kern",
            "write",
            "sizeof_field(struct bpf_sysctl_kern,\n\t\t\t\t\t\t    write)",
            "target_size"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeof_field",
          "args": [
            "structbpf_sysctl_kern",
            "write"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "si->code"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 sysctl_convert_ctx_access(enum bpf_access_type type,\n\t\t\t\t     const struct bpf_insn *si,\n\t\t\t\t     struct bpf_insn *insn_buf,\n\t\t\t\t     struct bpf_prog *prog, u32 *target_size)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\tu32 read_size;\n\n\tswitch (si->off) {\n\tcase offsetof(struct bpf_sysctl, write):\n\t\t*insn++ = BPF_LDX_MEM(\n\t\t\tBPF_SIZE(si->code), si->dst_reg, si->src_reg,\n\t\t\tbpf_target_off(struct bpf_sysctl_kern, write,\n\t\t\t\t       sizeof_field(struct bpf_sysctl_kern,\n\t\t\t\t\t\t    write),\n\t\t\t\t       target_size));\n\t\tbreak;\n\tcase offsetof(struct bpf_sysctl, file_pos):\n\t\t/* ppos is a pointer so it should be accessed via indirect\n\t\t * loads and stores. Also for stores additional temporary\n\t\t * register is used since neither src_reg nor dst_reg can be\n\t\t * overridden.\n\t\t */\n\t\tif (type == BPF_WRITE) {\n\t\t\tint treg = BPF_REG_9;\n\n\t\t\tif (si->src_reg == treg || si->dst_reg == treg)\n\t\t\t\t--treg;\n\t\t\tif (si->src_reg == treg || si->dst_reg == treg)\n\t\t\t\t--treg;\n\t\t\t*insn++ = BPF_STX_MEM(\n\t\t\t\tBPF_DW, si->dst_reg, treg,\n\t\t\t\toffsetof(struct bpf_sysctl_kern, tmp_reg));\n\t\t\t*insn++ = BPF_LDX_MEM(\n\t\t\t\tBPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos),\n\t\t\t\ttreg, si->dst_reg,\n\t\t\t\toffsetof(struct bpf_sysctl_kern, ppos));\n\t\t\t*insn++ = BPF_STX_MEM(\n\t\t\t\tBPF_SIZEOF(u32), treg, si->src_reg,\n\t\t\t\tbpf_ctx_narrow_access_offset(\n\t\t\t\t\t0, sizeof(u32), sizeof(loff_t)));\n\t\t\t*insn++ = BPF_LDX_MEM(\n\t\t\t\tBPF_DW, treg, si->dst_reg,\n\t\t\t\toffsetof(struct bpf_sysctl_kern, tmp_reg));\n\t\t} else {\n\t\t\t*insn++ = BPF_LDX_MEM(\n\t\t\t\tBPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos),\n\t\t\t\tsi->dst_reg, si->src_reg,\n\t\t\t\toffsetof(struct bpf_sysctl_kern, ppos));\n\t\t\tread_size = bpf_size_to_bytes(BPF_SIZE(si->code));\n\t\t\t*insn++ = BPF_LDX_MEM(\n\t\t\t\tBPF_SIZE(si->code), si->dst_reg, si->dst_reg,\n\t\t\t\tbpf_ctx_narrow_access_offset(\n\t\t\t\t\t0, read_size, sizeof(loff_t)));\n\t\t}\n\t\t*target_size = sizeof(u32);\n\t\tbreak;\n\t}\n\n\treturn insn - insn_buf;\n}"
  },
  {
    "function_name": "sysctl_is_valid_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1819-1844",
    "snippet": "static bool sysctl_is_valid_access(int off, int size, enum bpf_access_type type,\n\t\t\t\t   const struct bpf_prog *prog,\n\t\t\t\t   struct bpf_insn_access_aux *info)\n{\n\tconst int size_default = sizeof(__u32);\n\n\tif (off < 0 || off + size > sizeof(struct bpf_sysctl) || off % size)\n\t\treturn false;\n\n\tswitch (off) {\n\tcase bpf_ctx_range(struct bpf_sysctl, write):\n\t\tif (type != BPF_READ)\n\t\t\treturn false;\n\t\tbpf_ctx_record_field_size(info, size_default);\n\t\treturn bpf_ctx_narrow_access_ok(off, size, size_default);\n\tcase bpf_ctx_range(struct bpf_sysctl, file_pos):\n\t\tif (type == BPF_READ) {\n\t\t\tbpf_ctx_record_field_size(info, size_default);\n\t\t\treturn bpf_ctx_narrow_access_ok(off, size, size_default);\n\t\t} else {\n\t\t\treturn size == size_default;\n\t\t}\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_ctx_narrow_access_ok",
          "args": [
            "off",
            "size",
            "size_default"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_record_field_size",
          "args": [
            "info",
            "size_default"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_range",
          "args": [
            "structbpf_sysctl",
            "file_pos"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_narrow_access_ok",
          "args": [
            "off",
            "size",
            "size_default"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_record_field_size",
          "args": [
            "info",
            "size_default"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_range",
          "args": [
            "structbpf_sysctl",
            "write"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool sysctl_is_valid_access(int off, int size, enum bpf_access_type type,\n\t\t\t\t   const struct bpf_prog *prog,\n\t\t\t\t   struct bpf_insn_access_aux *info)\n{\n\tconst int size_default = sizeof(__u32);\n\n\tif (off < 0 || off + size > sizeof(struct bpf_sysctl) || off % size)\n\t\treturn false;\n\n\tswitch (off) {\n\tcase bpf_ctx_range(struct bpf_sysctl, write):\n\t\tif (type != BPF_READ)\n\t\t\treturn false;\n\t\tbpf_ctx_record_field_size(info, size_default);\n\t\treturn bpf_ctx_narrow_access_ok(off, size, size_default);\n\tcase bpf_ctx_range(struct bpf_sysctl, file_pos):\n\t\tif (type == BPF_READ) {\n\t\t\tbpf_ctx_record_field_size(info, size_default);\n\t\t\treturn bpf_ctx_narrow_access_ok(off, size, size_default);\n\t\t} else {\n\t\t\treturn size == size_default;\n\t\t}\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "sysctl_func_proto",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1796-1817",
    "snippet": "static const struct bpf_func_proto *\nsysctl_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_strtol:\n\t\treturn &bpf_strtol_proto;\n\tcase BPF_FUNC_strtoul:\n\t\treturn &bpf_strtoul_proto;\n\tcase BPF_FUNC_sysctl_get_name:\n\t\treturn &bpf_sysctl_get_name_proto;\n\tcase BPF_FUNC_sysctl_get_current_value:\n\t\treturn &bpf_sysctl_get_current_value_proto;\n\tcase BPF_FUNC_sysctl_get_new_value:\n\t\treturn &bpf_sysctl_get_new_value_proto;\n\tcase BPF_FUNC_sysctl_set_new_value:\n\t\treturn &bpf_sysctl_set_new_value_proto;\n\tcase BPF_FUNC_ktime_get_coarse_ns:\n\t\treturn &bpf_ktime_get_coarse_ns_proto;\n\tdefault:\n\t\treturn cgroup_base_func_proto(func_id, prog);\n\t}\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_func_proto bpf_sysctl_get_name_proto = {\n\t.func\t\t= bpf_sysctl_get_name,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n\t.arg4_type\t= ARG_ANYTHING,\n};",
      "static const struct bpf_func_proto bpf_sysctl_get_current_value_proto = {\n\t.func\t\t= bpf_sysctl_get_current_value,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};",
      "static const struct bpf_func_proto bpf_sysctl_get_new_value_proto = {\n\t.func\t\t= bpf_sysctl_get_new_value,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};",
      "static const struct bpf_func_proto bpf_sysctl_set_new_value_proto = {\n\t.func\t\t= bpf_sysctl_set_new_value,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_MEM | MEM_RDONLY,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_func_proto",
          "args": [
            "func_id",
            "prog"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_func_proto",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1215-1230",
          "snippet": "static const struct bpf_func_proto *\ncgroup_base_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_local_storage:\n\t\treturn &bpf_get_local_storage_proto;\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_event_output_data_proto;\n\tdefault:\n\t\treturn bpf_base_func_proto(func_id);\n\t}\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto *\ncgroup_base_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_local_storage:\n\t\treturn &bpf_get_local_storage_proto;\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_event_output_data_proto;\n\tdefault:\n\t\treturn bpf_base_func_proto(func_id);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_sysctl_get_name_proto = {\n\t.func\t\t= bpf_sysctl_get_name,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n\t.arg4_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_sysctl_get_current_value_proto = {\n\t.func\t\t= bpf_sysctl_get_current_value,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};\nstatic const struct bpf_func_proto bpf_sysctl_get_new_value_proto = {\n\t.func\t\t= bpf_sysctl_get_new_value,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};\nstatic const struct bpf_func_proto bpf_sysctl_set_new_value_proto = {\n\t.func\t\t= bpf_sysctl_set_new_value,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_MEM | MEM_RDONLY,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};\n\nstatic const struct bpf_func_proto *\nsysctl_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_strtol:\n\t\treturn &bpf_strtol_proto;\n\tcase BPF_FUNC_strtoul:\n\t\treturn &bpf_strtoul_proto;\n\tcase BPF_FUNC_sysctl_get_name:\n\t\treturn &bpf_sysctl_get_name_proto;\n\tcase BPF_FUNC_sysctl_get_current_value:\n\t\treturn &bpf_sysctl_get_current_value_proto;\n\tcase BPF_FUNC_sysctl_get_new_value:\n\t\treturn &bpf_sysctl_get_new_value_proto;\n\tcase BPF_FUNC_sysctl_set_new_value:\n\t\treturn &bpf_sysctl_set_new_value_proto;\n\tcase BPF_FUNC_ktime_get_coarse_ns:\n\t\treturn &bpf_ktime_get_coarse_ns_proto;\n\tdefault:\n\t\treturn cgroup_base_func_proto(func_id, prog);\n\t}\n}"
  },
  {
    "function_name": "copy_sysctl_value",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1710-1734",
    "snippet": "static int copy_sysctl_value(char *dst, size_t dst_len, char *src,\n\t\t\t     size_t src_len)\n{\n\tif (!dst)\n\t\treturn -EINVAL;\n\n\tif (!dst_len)\n\t\treturn -E2BIG;\n\n\tif (!src || !src_len) {\n\t\tmemset(dst, 0, dst_len);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(dst, src, min(dst_len, src_len));\n\n\tif (dst_len > src_len) {\n\t\tmemset(dst + src_len, '\\0', dst_len - src_len);\n\t\treturn src_len;\n\t}\n\n\tdst[dst_len - 1] = '\\0';\n\n\treturn -E2BIG;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dst + src_len",
            "'\\0'",
            "dst_len - src_len"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "min(dst_len, src_len)"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "dst_len",
            "src_len"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "__reg_combine_min_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "9059-9087",
          "snippet": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dst",
            "0",
            "dst_len"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int copy_sysctl_value(char *dst, size_t dst_len, char *src,\n\t\t\t     size_t src_len)\n{\n\tif (!dst)\n\t\treturn -EINVAL;\n\n\tif (!dst_len)\n\t\treturn -E2BIG;\n\n\tif (!src || !src_len) {\n\t\tmemset(dst, 0, dst_len);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(dst, src, min(dst_len, src_len));\n\n\tif (dst_len > src_len) {\n\t\tmemset(dst + src_len, '\\0', dst_len - src_len);\n\t\treturn src_len;\n\t}\n\n\tdst[dst_len - 1] = '\\0';\n\n\treturn -E2BIG;\n}"
  },
  {
    "function_name": "sysctl_cpy_dir",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1648-1677",
    "snippet": "static ssize_t sysctl_cpy_dir(const struct ctl_dir *dir, char **bufp,\n\t\t\t      size_t *lenp)\n{\n\tssize_t tmp_ret = 0, ret;\n\n\tif (dir->header.parent) {\n\t\ttmp_ret = sysctl_cpy_dir(dir->header.parent, bufp, lenp);\n\t\tif (tmp_ret < 0)\n\t\t\treturn tmp_ret;\n\t}\n\n\tret = strscpy(*bufp, dir->header.ctl_table[0].procname, *lenp);\n\tif (ret < 0)\n\t\treturn ret;\n\t*bufp += ret;\n\t*lenp -= ret;\n\tret += tmp_ret;\n\n\t/* Avoid leading slash. */\n\tif (!ret)\n\t\treturn ret;\n\n\ttmp_ret = strscpy(*bufp, \"/\", *lenp);\n\tif (tmp_ret < 0)\n\t\treturn tmp_ret;\n\t*bufp += tmp_ret;\n\t*lenp -= tmp_ret;\n\n\treturn ret + tmp_ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "*bufp",
            "\"/\"",
            "*lenp"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "*bufp",
            "dir->header.ctl_table[0].procname",
            "*lenp"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctl_cpy_dir",
          "args": [
            "dir->header.parent",
            "bufp",
            "lenp"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_cpy_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1648-1677",
          "snippet": "static ssize_t sysctl_cpy_dir(const struct ctl_dir *dir, char **bufp,\n\t\t\t      size_t *lenp)\n{\n\tssize_t tmp_ret = 0, ret;\n\n\tif (dir->header.parent) {\n\t\ttmp_ret = sysctl_cpy_dir(dir->header.parent, bufp, lenp);\n\t\tif (tmp_ret < 0)\n\t\t\treturn tmp_ret;\n\t}\n\n\tret = strscpy(*bufp, dir->header.ctl_table[0].procname, *lenp);\n\tif (ret < 0)\n\t\treturn ret;\n\t*bufp += ret;\n\t*lenp -= ret;\n\tret += tmp_ret;\n\n\t/* Avoid leading slash. */\n\tif (!ret)\n\t\treturn ret;\n\n\ttmp_ret = strscpy(*bufp, \"/\", *lenp);\n\tif (tmp_ret < 0)\n\t\treturn tmp_ret;\n\t*bufp += tmp_ret;\n\t*lenp -= tmp_ret;\n\n\treturn ret + tmp_ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sysctl_cpy_dir(const struct ctl_dir *dir, char **bufp,\n\t\t\t      size_t *lenp)\n{\n\tssize_t tmp_ret = 0, ret;\n\n\tif (dir->header.parent) {\n\t\ttmp_ret = sysctl_cpy_dir(dir->header.parent, bufp, lenp);\n\t\tif (tmp_ret < 0)\n\t\t\treturn tmp_ret;\n\t}\n\n\tret = strscpy(*bufp, dir->header.ctl_table[0].procname, *lenp);\n\tif (ret < 0)\n\t\treturn ret;\n\t*bufp += ret;\n\t*lenp -= ret;\n\tret += tmp_ret;\n\n\t/* Avoid leading slash. */\n\tif (!ret)\n\t\treturn ret;\n\n\ttmp_ret = strscpy(*bufp, \"/\", *lenp);\n\tif (tmp_ret < 0)\n\t\treturn tmp_ret;\n\t*bufp += tmp_ret;\n\t*lenp -= tmp_ret;\n\n\treturn ret + tmp_ret;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_getsockopt_kern",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1601-1645",
    "snippet": "int __cgroup_bpf_run_filter_getsockopt_kern(struct sock *sk, int level,\n\t\t\t\t\t    int optname, void *optval,\n\t\t\t\t\t    int *optlen, int retval)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tstruct bpf_sockopt_kern ctx = {\n\t\t.sk = sk,\n\t\t.level = level,\n\t\t.optname = optname,\n\t\t.retval = retval,\n\t\t.optlen = *optlen,\n\t\t.optval = optval,\n\t\t.optval_end = optval + *optlen,\n\t};\n\tint ret;\n\n\t/* Note that __cgroup_bpf_run_filter_getsockopt doesn't copy\n\t * user data back into BPF buffer when reval != 0. This is\n\t * done as an optimization to avoid extra copy, assuming\n\t * kernel won't populate the data in case of an error.\n\t * Here we always pass the data and memset() should\n\t * be called if that data shouldn't be \"exported\".\n\t */\n\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[CGROUP_GETSOCKOPT],\n\t\t\t\t    &ctx, bpf_prog_run);\n\tif (!ret)\n\t\treturn -EPERM;\n\n\tif (ctx.optlen > *optlen)\n\t\treturn -EFAULT;\n\n\t/* BPF programs only allowed to set retval to 0, not some\n\t * arbitrary value.\n\t */\n\tif (ctx.retval != 0 && ctx.retval != retval)\n\t\treturn -EFAULT;\n\n\t/* BPF programs can shrink the buffer, export the modifications.\n\t */\n\tif (ctx.optlen != 0)\n\t\t*optlen = ctx.optlen;\n\n\treturn ctx.retval;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY_CG",
          "args": [
            "cgrp->bpf.effective[CGROUP_GETSOCKOPT]",
            "&ctx",
            "bpf_prog_run"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "&sk->sk_cgrp_data"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_getsockopt_kern(struct sock *sk, int level,\n\t\t\t\t\t    int optname, void *optval,\n\t\t\t\t\t    int *optlen, int retval)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tstruct bpf_sockopt_kern ctx = {\n\t\t.sk = sk,\n\t\t.level = level,\n\t\t.optname = optname,\n\t\t.retval = retval,\n\t\t.optlen = *optlen,\n\t\t.optval = optval,\n\t\t.optval_end = optval + *optlen,\n\t};\n\tint ret;\n\n\t/* Note that __cgroup_bpf_run_filter_getsockopt doesn't copy\n\t * user data back into BPF buffer when reval != 0. This is\n\t * done as an optimization to avoid extra copy, assuming\n\t * kernel won't populate the data in case of an error.\n\t * Here we always pass the data and memset() should\n\t * be called if that data shouldn't be \"exported\".\n\t */\n\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[CGROUP_GETSOCKOPT],\n\t\t\t\t    &ctx, bpf_prog_run);\n\tif (!ret)\n\t\treturn -EPERM;\n\n\tif (ctx.optlen > *optlen)\n\t\treturn -EFAULT;\n\n\t/* BPF programs only allowed to set retval to 0, not some\n\t * arbitrary value.\n\t */\n\tif (ctx.retval != 0 && ctx.retval != retval)\n\t\treturn -EFAULT;\n\n\t/* BPF programs can shrink the buffer, export the modifications.\n\t */\n\tif (ctx.optlen != 0)\n\t\t*optlen = ctx.optlen;\n\n\treturn ctx.retval;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_getsockopt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1510-1599",
    "snippet": "int __cgroup_bpf_run_filter_getsockopt(struct sock *sk, int level,\n\t\t\t\t       int optname, char __user *optval,\n\t\t\t\t       int __user *optlen, int max_optlen,\n\t\t\t\t       int retval)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tstruct bpf_sockopt_buf buf = {};\n\tstruct bpf_sockopt_kern ctx = {\n\t\t.sk = sk,\n\t\t.level = level,\n\t\t.optname = optname,\n\t\t.retval = retval,\n\t};\n\tint ret;\n\n\t/* Opportunistic check to see whether we have any BPF program\n\t * attached to the hook so we don't waste time allocating\n\t * memory and locking the socket.\n\t */\n\tif (__cgroup_bpf_prog_array_is_empty(cgrp, CGROUP_GETSOCKOPT))\n\t\treturn retval;\n\n\tctx.optlen = max_optlen;\n\n\tmax_optlen = sockopt_alloc_buf(&ctx, max_optlen, &buf);\n\tif (max_optlen < 0)\n\t\treturn max_optlen;\n\n\tif (!retval) {\n\t\t/* If kernel getsockopt finished successfully,\n\t\t * copy whatever was returned to the user back\n\t\t * into our temporary buffer. Set optlen to the\n\t\t * one that kernel returned as well to let\n\t\t * BPF programs inspect the value.\n\t\t */\n\n\t\tif (get_user(ctx.optlen, optlen)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ctx.optlen < 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_from_user(ctx.optval, optval,\n\t\t\t\t   min(ctx.optlen, max_optlen)) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlock_sock(sk);\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[CGROUP_GETSOCKOPT],\n\t\t\t\t    &ctx, bpf_prog_run);\n\trelease_sock(sk);\n\n\tif (!ret) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (ctx.optlen > max_optlen || ctx.optlen < 0) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* BPF programs only allowed to set retval to 0, not some\n\t * arbitrary value.\n\t */\n\tif (ctx.retval != 0 && ctx.retval != retval) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (ctx.optlen != 0) {\n\t\tif (copy_to_user(optval, ctx.optval, ctx.optlen) ||\n\t\t    put_user(ctx.optlen, optlen)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ctx.retval;\n\nout:\n\tsockopt_free_buf(&ctx, &buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sockopt_free_buf",
          "args": [
            "&ctx",
            "&buf"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "sockopt_free_buf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1402-1408",
          "snippet": "static void sockopt_free_buf(struct bpf_sockopt_kern *ctx,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (ctx->optval == buf->data)\n\t\treturn;\n\tkfree(ctx->optval);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void sockopt_free_buf(struct bpf_sockopt_kern *ctx,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (ctx->optval == buf->data)\n\t\treturn;\n\tkfree(ctx->optval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "ctx.optlen",
            "optlen"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "optval",
            "ctx.optval",
            "ctx.optlen"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_sock",
          "args": [
            "sk"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY_CG",
          "args": [
            "cgrp->bpf.effective[CGROUP_GETSOCKOPT]",
            "&ctx",
            "bpf_prog_run"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_sock",
          "args": [
            "sk"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "ctx.optval",
            "optval",
            "min(ctx.optlen, max_optlen)"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ctx.optlen",
            "max_optlen"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "__reg_combine_min_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "9059-9087",
          "snippet": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "ctx.optlen",
            "optlen"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "530-557",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sockopt_alloc_buf",
          "args": [
            "&ctx",
            "max_optlen",
            "&buf"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "sockopt_alloc_buf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1371-1400",
          "snippet": "static int sockopt_alloc_buf(struct bpf_sockopt_kern *ctx, int max_optlen,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (unlikely(max_optlen < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(max_optlen > PAGE_SIZE)) {\n\t\t/* We don't expose optvals that are greater than PAGE_SIZE\n\t\t * to the BPF program.\n\t\t */\n\t\tmax_optlen = PAGE_SIZE;\n\t}\n\n\tif (max_optlen <= sizeof(buf->data)) {\n\t\t/* When the optval fits into BPF_SOCKOPT_KERN_BUF_SIZE\n\t\t * bytes avoid the cost of kzalloc.\n\t\t */\n\t\tctx->optval = buf->data;\n\t\tctx->optval_end = ctx->optval + max_optlen;\n\t\treturn max_optlen;\n\t}\n\n\tctx->optval = kzalloc(max_optlen, GFP_USER);\n\tif (!ctx->optval)\n\t\treturn -ENOMEM;\n\n\tctx->optval_end = ctx->optval + max_optlen;\n\n\treturn max_optlen;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int sockopt_alloc_buf(struct bpf_sockopt_kern *ctx, int max_optlen,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (unlikely(max_optlen < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(max_optlen > PAGE_SIZE)) {\n\t\t/* We don't expose optvals that are greater than PAGE_SIZE\n\t\t * to the BPF program.\n\t\t */\n\t\tmax_optlen = PAGE_SIZE;\n\t}\n\n\tif (max_optlen <= sizeof(buf->data)) {\n\t\t/* When the optval fits into BPF_SOCKOPT_KERN_BUF_SIZE\n\t\t * bytes avoid the cost of kzalloc.\n\t\t */\n\t\tctx->optval = buf->data;\n\t\tctx->optval_end = ctx->optval + max_optlen;\n\t\treturn max_optlen;\n\t}\n\n\tctx->optval = kzalloc(max_optlen, GFP_USER);\n\tif (!ctx->optval)\n\t\treturn -ENOMEM;\n\n\tctx->optval_end = ctx->optval + max_optlen;\n\n\treturn max_optlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cgroup_bpf_prog_array_is_empty",
          "args": [
            "cgrp",
            "CGROUP_GETSOCKOPT"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_prog_array_is_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1357-1369",
          "snippet": "static bool __cgroup_bpf_prog_array_is_empty(struct cgroup *cgrp,\n\t\t\t\t\t     enum cgroup_bpf_attach_type attach_type)\n{\n\tstruct bpf_prog_array *prog_array;\n\tbool empty;\n\n\trcu_read_lock();\n\tprog_array = rcu_dereference(cgrp->bpf.effective[attach_type]);\n\tempty = bpf_prog_array_is_empty(prog_array);\n\trcu_read_unlock();\n\n\treturn empty;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool __cgroup_bpf_prog_array_is_empty(struct cgroup *cgrp,\n\t\t\t\t\t     enum cgroup_bpf_attach_type attach_type)\n{\n\tstruct bpf_prog_array *prog_array;\n\tbool empty;\n\n\trcu_read_lock();\n\tprog_array = rcu_dereference(cgrp->bpf.effective[attach_type]);\n\tempty = bpf_prog_array_is_empty(prog_array);\n\trcu_read_unlock();\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "&sk->sk_cgrp_data"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_getsockopt(struct sock *sk, int level,\n\t\t\t\t       int optname, char __user *optval,\n\t\t\t\t       int __user *optlen, int max_optlen,\n\t\t\t\t       int retval)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tstruct bpf_sockopt_buf buf = {};\n\tstruct bpf_sockopt_kern ctx = {\n\t\t.sk = sk,\n\t\t.level = level,\n\t\t.optname = optname,\n\t\t.retval = retval,\n\t};\n\tint ret;\n\n\t/* Opportunistic check to see whether we have any BPF program\n\t * attached to the hook so we don't waste time allocating\n\t * memory and locking the socket.\n\t */\n\tif (__cgroup_bpf_prog_array_is_empty(cgrp, CGROUP_GETSOCKOPT))\n\t\treturn retval;\n\n\tctx.optlen = max_optlen;\n\n\tmax_optlen = sockopt_alloc_buf(&ctx, max_optlen, &buf);\n\tif (max_optlen < 0)\n\t\treturn max_optlen;\n\n\tif (!retval) {\n\t\t/* If kernel getsockopt finished successfully,\n\t\t * copy whatever was returned to the user back\n\t\t * into our temporary buffer. Set optlen to the\n\t\t * one that kernel returned as well to let\n\t\t * BPF programs inspect the value.\n\t\t */\n\n\t\tif (get_user(ctx.optlen, optlen)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ctx.optlen < 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_from_user(ctx.optval, optval,\n\t\t\t\t   min(ctx.optlen, max_optlen)) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlock_sock(sk);\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[CGROUP_GETSOCKOPT],\n\t\t\t\t    &ctx, bpf_prog_run);\n\trelease_sock(sk);\n\n\tif (!ret) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (ctx.optlen > max_optlen || ctx.optlen < 0) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* BPF programs only allowed to set retval to 0, not some\n\t * arbitrary value.\n\t */\n\tif (ctx.retval != 0 && ctx.retval != retval) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (ctx.optlen != 0) {\n\t\tif (copy_to_user(optval, ctx.optval, ctx.optlen) ||\n\t\t    put_user(ctx.optlen, optlen)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ctx.retval;\n\nout:\n\tsockopt_free_buf(&ctx, &buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_setsockopt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1416-1508",
    "snippet": "int __cgroup_bpf_run_filter_setsockopt(struct sock *sk, int *level,\n\t\t\t\t       int *optname, char __user *optval,\n\t\t\t\t       int *optlen, char **kernel_optval)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tstruct bpf_sockopt_buf buf = {};\n\tstruct bpf_sockopt_kern ctx = {\n\t\t.sk = sk,\n\t\t.level = *level,\n\t\t.optname = *optname,\n\t};\n\tint ret, max_optlen;\n\n\t/* Opportunistic check to see whether we have any BPF program\n\t * attached to the hook so we don't waste time allocating\n\t * memory and locking the socket.\n\t */\n\tif (__cgroup_bpf_prog_array_is_empty(cgrp, CGROUP_SETSOCKOPT))\n\t\treturn 0;\n\n\t/* Allocate a bit more than the initial user buffer for\n\t * BPF program. The canonical use case is overriding\n\t * TCP_CONGESTION(nv) to TCP_CONGESTION(cubic).\n\t */\n\tmax_optlen = max_t(int, 16, *optlen);\n\n\tmax_optlen = sockopt_alloc_buf(&ctx, max_optlen, &buf);\n\tif (max_optlen < 0)\n\t\treturn max_optlen;\n\n\tctx.optlen = *optlen;\n\n\tif (copy_from_user(ctx.optval, optval, min(*optlen, max_optlen)) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[CGROUP_SETSOCKOPT],\n\t\t\t\t    &ctx, bpf_prog_run);\n\trelease_sock(sk);\n\n\tif (!ret) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (ctx.optlen == -1) {\n\t\t/* optlen set to -1, bypass kernel */\n\t\tret = 1;\n\t} else if (ctx.optlen > max_optlen || ctx.optlen < -1) {\n\t\t/* optlen is out of bounds */\n\t\tret = -EFAULT;\n\t} else {\n\t\t/* optlen within bounds, run kernel handler */\n\t\tret = 0;\n\n\t\t/* export any potential modifications */\n\t\t*level = ctx.level;\n\t\t*optname = ctx.optname;\n\n\t\t/* optlen == 0 from BPF indicates that we should\n\t\t * use original userspace data.\n\t\t */\n\t\tif (ctx.optlen != 0) {\n\t\t\t*optlen = ctx.optlen;\n\t\t\t/* We've used bpf_sockopt_kern->buf as an intermediary\n\t\t\t * storage, but the BPF program indicates that we need\n\t\t\t * to pass this data to the kernel setsockopt handler.\n\t\t\t * No way to export on-stack buf, have to allocate a\n\t\t\t * new buffer.\n\t\t\t */\n\t\t\tif (!sockopt_buf_allocated(&ctx, &buf)) {\n\t\t\t\tvoid *p = kmalloc(ctx.optlen, GFP_USER);\n\n\t\t\t\tif (!p) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(p, ctx.optval, ctx.optlen);\n\t\t\t\t*kernel_optval = p;\n\t\t\t} else {\n\t\t\t\t*kernel_optval = ctx.optval;\n\t\t\t}\n\t\t\t/* export and don't free sockopt buf */\n\t\t\treturn 0;\n\t\t}\n\t}\n\nout:\n\tsockopt_free_buf(&ctx, &buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sockopt_free_buf",
          "args": [
            "&ctx",
            "&buf"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "sockopt_free_buf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1402-1408",
          "snippet": "static void sockopt_free_buf(struct bpf_sockopt_kern *ctx,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (ctx->optval == buf->data)\n\t\treturn;\n\tkfree(ctx->optval);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void sockopt_free_buf(struct bpf_sockopt_kern *ctx,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (ctx->optval == buf->data)\n\t\treturn;\n\tkfree(ctx->optval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "ctx.optval",
            "ctx.optlen"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "ctx.optlen",
            "GFP_USER"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sockopt_buf_allocated",
          "args": [
            "&ctx",
            "&buf"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "sockopt_buf_allocated",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1410-1414",
          "snippet": "static bool sockopt_buf_allocated(struct bpf_sockopt_kern *ctx,\n\t\t\t\t  struct bpf_sockopt_buf *buf)\n{\n\treturn ctx->optval != buf->data;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool sockopt_buf_allocated(struct bpf_sockopt_kern *ctx,\n\t\t\t\t  struct bpf_sockopt_buf *buf)\n{\n\treturn ctx->optval != buf->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_sock",
          "args": [
            "sk"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY_CG",
          "args": [
            "cgrp->bpf.effective[CGROUP_SETSOCKOPT]",
            "&ctx",
            "bpf_prog_run"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_sock",
          "args": [
            "sk"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "ctx.optval",
            "optval",
            "min(*optlen, max_optlen)"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "*optlen",
            "max_optlen"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "__reg_combine_min_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "9059-9087",
          "snippet": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sockopt_alloc_buf",
          "args": [
            "&ctx",
            "max_optlen",
            "&buf"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "sockopt_alloc_buf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1371-1400",
          "snippet": "static int sockopt_alloc_buf(struct bpf_sockopt_kern *ctx, int max_optlen,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (unlikely(max_optlen < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(max_optlen > PAGE_SIZE)) {\n\t\t/* We don't expose optvals that are greater than PAGE_SIZE\n\t\t * to the BPF program.\n\t\t */\n\t\tmax_optlen = PAGE_SIZE;\n\t}\n\n\tif (max_optlen <= sizeof(buf->data)) {\n\t\t/* When the optval fits into BPF_SOCKOPT_KERN_BUF_SIZE\n\t\t * bytes avoid the cost of kzalloc.\n\t\t */\n\t\tctx->optval = buf->data;\n\t\tctx->optval_end = ctx->optval + max_optlen;\n\t\treturn max_optlen;\n\t}\n\n\tctx->optval = kzalloc(max_optlen, GFP_USER);\n\tif (!ctx->optval)\n\t\treturn -ENOMEM;\n\n\tctx->optval_end = ctx->optval + max_optlen;\n\n\treturn max_optlen;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int sockopt_alloc_buf(struct bpf_sockopt_kern *ctx, int max_optlen,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (unlikely(max_optlen < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(max_optlen > PAGE_SIZE)) {\n\t\t/* We don't expose optvals that are greater than PAGE_SIZE\n\t\t * to the BPF program.\n\t\t */\n\t\tmax_optlen = PAGE_SIZE;\n\t}\n\n\tif (max_optlen <= sizeof(buf->data)) {\n\t\t/* When the optval fits into BPF_SOCKOPT_KERN_BUF_SIZE\n\t\t * bytes avoid the cost of kzalloc.\n\t\t */\n\t\tctx->optval = buf->data;\n\t\tctx->optval_end = ctx->optval + max_optlen;\n\t\treturn max_optlen;\n\t}\n\n\tctx->optval = kzalloc(max_optlen, GFP_USER);\n\tif (!ctx->optval)\n\t\treturn -ENOMEM;\n\n\tctx->optval_end = ctx->optval + max_optlen;\n\n\treturn max_optlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "int",
            "16",
            "*optlen"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1831-1865",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cgroup_bpf_prog_array_is_empty",
          "args": [
            "cgrp",
            "CGROUP_SETSOCKOPT"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_prog_array_is_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1357-1369",
          "snippet": "static bool __cgroup_bpf_prog_array_is_empty(struct cgroup *cgrp,\n\t\t\t\t\t     enum cgroup_bpf_attach_type attach_type)\n{\n\tstruct bpf_prog_array *prog_array;\n\tbool empty;\n\n\trcu_read_lock();\n\tprog_array = rcu_dereference(cgrp->bpf.effective[attach_type]);\n\tempty = bpf_prog_array_is_empty(prog_array);\n\trcu_read_unlock();\n\n\treturn empty;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool __cgroup_bpf_prog_array_is_empty(struct cgroup *cgrp,\n\t\t\t\t\t     enum cgroup_bpf_attach_type attach_type)\n{\n\tstruct bpf_prog_array *prog_array;\n\tbool empty;\n\n\trcu_read_lock();\n\tprog_array = rcu_dereference(cgrp->bpf.effective[attach_type]);\n\tempty = bpf_prog_array_is_empty(prog_array);\n\trcu_read_unlock();\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "&sk->sk_cgrp_data"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_setsockopt(struct sock *sk, int *level,\n\t\t\t\t       int *optname, char __user *optval,\n\t\t\t\t       int *optlen, char **kernel_optval)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tstruct bpf_sockopt_buf buf = {};\n\tstruct bpf_sockopt_kern ctx = {\n\t\t.sk = sk,\n\t\t.level = *level,\n\t\t.optname = *optname,\n\t};\n\tint ret, max_optlen;\n\n\t/* Opportunistic check to see whether we have any BPF program\n\t * attached to the hook so we don't waste time allocating\n\t * memory and locking the socket.\n\t */\n\tif (__cgroup_bpf_prog_array_is_empty(cgrp, CGROUP_SETSOCKOPT))\n\t\treturn 0;\n\n\t/* Allocate a bit more than the initial user buffer for\n\t * BPF program. The canonical use case is overriding\n\t * TCP_CONGESTION(nv) to TCP_CONGESTION(cubic).\n\t */\n\tmax_optlen = max_t(int, 16, *optlen);\n\n\tmax_optlen = sockopt_alloc_buf(&ctx, max_optlen, &buf);\n\tif (max_optlen < 0)\n\t\treturn max_optlen;\n\n\tctx.optlen = *optlen;\n\n\tif (copy_from_user(ctx.optval, optval, min(*optlen, max_optlen)) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[CGROUP_SETSOCKOPT],\n\t\t\t\t    &ctx, bpf_prog_run);\n\trelease_sock(sk);\n\n\tif (!ret) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (ctx.optlen == -1) {\n\t\t/* optlen set to -1, bypass kernel */\n\t\tret = 1;\n\t} else if (ctx.optlen > max_optlen || ctx.optlen < -1) {\n\t\t/* optlen is out of bounds */\n\t\tret = -EFAULT;\n\t} else {\n\t\t/* optlen within bounds, run kernel handler */\n\t\tret = 0;\n\n\t\t/* export any potential modifications */\n\t\t*level = ctx.level;\n\t\t*optname = ctx.optname;\n\n\t\t/* optlen == 0 from BPF indicates that we should\n\t\t * use original userspace data.\n\t\t */\n\t\tif (ctx.optlen != 0) {\n\t\t\t*optlen = ctx.optlen;\n\t\t\t/* We've used bpf_sockopt_kern->buf as an intermediary\n\t\t\t * storage, but the BPF program indicates that we need\n\t\t\t * to pass this data to the kernel setsockopt handler.\n\t\t\t * No way to export on-stack buf, have to allocate a\n\t\t\t * new buffer.\n\t\t\t */\n\t\t\tif (!sockopt_buf_allocated(&ctx, &buf)) {\n\t\t\t\tvoid *p = kmalloc(ctx.optlen, GFP_USER);\n\n\t\t\t\tif (!p) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(p, ctx.optval, ctx.optlen);\n\t\t\t\t*kernel_optval = p;\n\t\t\t} else {\n\t\t\t\t*kernel_optval = ctx.optval;\n\t\t\t}\n\t\t\t/* export and don't free sockopt buf */\n\t\t\treturn 0;\n\t\t}\n\t}\n\nout:\n\tsockopt_free_buf(&ctx, &buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "sockopt_buf_allocated",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1410-1414",
    "snippet": "static bool sockopt_buf_allocated(struct bpf_sockopt_kern *ctx,\n\t\t\t\t  struct bpf_sockopt_buf *buf)\n{\n\treturn ctx->optval != buf->data;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool sockopt_buf_allocated(struct bpf_sockopt_kern *ctx,\n\t\t\t\t  struct bpf_sockopt_buf *buf)\n{\n\treturn ctx->optval != buf->data;\n}"
  },
  {
    "function_name": "sockopt_free_buf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1402-1408",
    "snippet": "static void sockopt_free_buf(struct bpf_sockopt_kern *ctx,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (ctx->optval == buf->data)\n\t\treturn;\n\tkfree(ctx->optval);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx->optval"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void sockopt_free_buf(struct bpf_sockopt_kern *ctx,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (ctx->optval == buf->data)\n\t\treturn;\n\tkfree(ctx->optval);\n}"
  },
  {
    "function_name": "sockopt_alloc_buf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1371-1400",
    "snippet": "static int sockopt_alloc_buf(struct bpf_sockopt_kern *ctx, int max_optlen,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (unlikely(max_optlen < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(max_optlen > PAGE_SIZE)) {\n\t\t/* We don't expose optvals that are greater than PAGE_SIZE\n\t\t * to the BPF program.\n\t\t */\n\t\tmax_optlen = PAGE_SIZE;\n\t}\n\n\tif (max_optlen <= sizeof(buf->data)) {\n\t\t/* When the optval fits into BPF_SOCKOPT_KERN_BUF_SIZE\n\t\t * bytes avoid the cost of kzalloc.\n\t\t */\n\t\tctx->optval = buf->data;\n\t\tctx->optval_end = ctx->optval + max_optlen;\n\t\treturn max_optlen;\n\t}\n\n\tctx->optval = kzalloc(max_optlen, GFP_USER);\n\tif (!ctx->optval)\n\t\treturn -ENOMEM;\n\n\tctx->optval_end = ctx->optval + max_optlen;\n\n\treturn max_optlen;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "max_optlen",
            "GFP_USER"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "max_optlen > PAGE_SIZE"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "max_optlen < 0"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int sockopt_alloc_buf(struct bpf_sockopt_kern *ctx, int max_optlen,\n\t\t\t     struct bpf_sockopt_buf *buf)\n{\n\tif (unlikely(max_optlen < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(max_optlen > PAGE_SIZE)) {\n\t\t/* We don't expose optvals that are greater than PAGE_SIZE\n\t\t * to the BPF program.\n\t\t */\n\t\tmax_optlen = PAGE_SIZE;\n\t}\n\n\tif (max_optlen <= sizeof(buf->data)) {\n\t\t/* When the optval fits into BPF_SOCKOPT_KERN_BUF_SIZE\n\t\t * bytes avoid the cost of kzalloc.\n\t\t */\n\t\tctx->optval = buf->data;\n\t\tctx->optval_end = ctx->optval + max_optlen;\n\t\treturn max_optlen;\n\t}\n\n\tctx->optval = kzalloc(max_optlen, GFP_USER);\n\tif (!ctx->optval)\n\t\treturn -ENOMEM;\n\n\tctx->optval_end = ctx->optval + max_optlen;\n\n\treturn max_optlen;\n}"
  },
  {
    "function_name": "__cgroup_bpf_prog_array_is_empty",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1357-1369",
    "snippet": "static bool __cgroup_bpf_prog_array_is_empty(struct cgroup *cgrp,\n\t\t\t\t\t     enum cgroup_bpf_attach_type attach_type)\n{\n\tstruct bpf_prog_array *prog_array;\n\tbool empty;\n\n\trcu_read_lock();\n\tprog_array = rcu_dereference(cgrp->bpf.effective[attach_type]);\n\tempty = bpf_prog_array_is_empty(prog_array);\n\trcu_read_unlock();\n\n\treturn empty;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_is_empty",
          "args": [
            "prog_array"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_is_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2013-2021",
          "snippet": "bool bpf_prog_array_is_empty(struct bpf_prog_array *array)\n{\n\tstruct bpf_prog_array_item *item;\n\n\tfor (item = array->items; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nbool bpf_prog_array_is_empty(struct bpf_prog_array *array)\n{\n\tstruct bpf_prog_array_item *item;\n\n\tfor (item = array->items; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "cgrp->bpf.effective[attach_type]"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool __cgroup_bpf_prog_array_is_empty(struct cgroup *cgrp,\n\t\t\t\t\t     enum cgroup_bpf_attach_type attach_type)\n{\n\tstruct bpf_prog_array *prog_array;\n\tbool empty;\n\n\trcu_read_lock();\n\tprog_array = rcu_dereference(cgrp->bpf.effective[attach_type]);\n\tempty = bpf_prog_array_is_empty(prog_array);\n\trcu_read_unlock();\n\n\treturn empty;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_sysctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1297-1354",
    "snippet": "int __cgroup_bpf_run_filter_sysctl(struct ctl_table_header *head,\n\t\t\t\t   struct ctl_table *table, int write,\n\t\t\t\t   char **buf, size_t *pcount, loff_t *ppos,\n\t\t\t\t   enum cgroup_bpf_attach_type atype)\n{\n\tstruct bpf_sysctl_kern ctx = {\n\t\t.head = head,\n\t\t.table = table,\n\t\t.write = write,\n\t\t.ppos = ppos,\n\t\t.cur_val = NULL,\n\t\t.cur_len = PAGE_SIZE,\n\t\t.new_val = NULL,\n\t\t.new_len = 0,\n\t\t.new_updated = 0,\n\t};\n\tstruct cgroup *cgrp;\n\tloff_t pos = 0;\n\tint ret;\n\n\tctx.cur_val = kmalloc_track_caller(ctx.cur_len, GFP_KERNEL);\n\tif (!ctx.cur_val ||\n\t    table->proc_handler(table, 0, ctx.cur_val, &ctx.cur_len, &pos)) {\n\t\t/* Let BPF program decide how to proceed. */\n\t\tctx.cur_len = 0;\n\t}\n\n\tif (write && *buf && *pcount) {\n\t\t/* BPF program should be able to override new value with a\n\t\t * buffer bigger than provided by user.\n\t\t */\n\t\tctx.new_val = kmalloc_track_caller(PAGE_SIZE, GFP_KERNEL);\n\t\tctx.new_len = min_t(size_t, PAGE_SIZE, *pcount);\n\t\tif (ctx.new_val) {\n\t\t\tmemcpy(ctx.new_val, *buf, ctx.new_len);\n\t\t} else {\n\t\t\t/* Let BPF program decide how to proceed. */\n\t\t\tctx.new_len = 0;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tcgrp = task_dfl_cgroup(current);\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[atype], &ctx, bpf_prog_run);\n\trcu_read_unlock();\n\n\tkfree(ctx.cur_val);\n\n\tif (ret == 1 && ctx.new_updated) {\n\t\tkfree(*buf);\n\t\t*buf = ctx.new_val;\n\t\t*pcount = ctx.new_len;\n\t} else {\n\t\tkfree(ctx.new_val);\n\t}\n\n\treturn ret == 1 ? 0 : -EPERM;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx.new_val"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY_CG",
          "args": [
            "cgrp->bpf.effective[atype]",
            "&ctx",
            "bpf_prog_run"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_dfl_cgroup",
          "args": [
            "current"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ctx.new_val",
            "*buf",
            "ctx.new_len"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_SIZE",
            "*pcount"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_track_caller",
          "args": [
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->proc_handler",
          "args": [
            "table",
            "0",
            "ctx.cur_val",
            "&ctx.cur_len",
            "&pos"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_track_caller",
          "args": [
            "ctx.cur_len",
            "GFP_KERNEL"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_sysctl(struct ctl_table_header *head,\n\t\t\t\t   struct ctl_table *table, int write,\n\t\t\t\t   char **buf, size_t *pcount, loff_t *ppos,\n\t\t\t\t   enum cgroup_bpf_attach_type atype)\n{\n\tstruct bpf_sysctl_kern ctx = {\n\t\t.head = head,\n\t\t.table = table,\n\t\t.write = write,\n\t\t.ppos = ppos,\n\t\t.cur_val = NULL,\n\t\t.cur_len = PAGE_SIZE,\n\t\t.new_val = NULL,\n\t\t.new_len = 0,\n\t\t.new_updated = 0,\n\t};\n\tstruct cgroup *cgrp;\n\tloff_t pos = 0;\n\tint ret;\n\n\tctx.cur_val = kmalloc_track_caller(ctx.cur_len, GFP_KERNEL);\n\tif (!ctx.cur_val ||\n\t    table->proc_handler(table, 0, ctx.cur_val, &ctx.cur_len, &pos)) {\n\t\t/* Let BPF program decide how to proceed. */\n\t\tctx.cur_len = 0;\n\t}\n\n\tif (write && *buf && *pcount) {\n\t\t/* BPF program should be able to override new value with a\n\t\t * buffer bigger than provided by user.\n\t\t */\n\t\tctx.new_val = kmalloc_track_caller(PAGE_SIZE, GFP_KERNEL);\n\t\tctx.new_len = min_t(size_t, PAGE_SIZE, *pcount);\n\t\tif (ctx.new_val) {\n\t\t\tmemcpy(ctx.new_val, *buf, ctx.new_len);\n\t\t} else {\n\t\t\t/* Let BPF program decide how to proceed. */\n\t\t\tctx.new_len = 0;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tcgrp = task_dfl_cgroup(current);\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[atype], &ctx, bpf_prog_run);\n\trcu_read_unlock();\n\n\tkfree(ctx.cur_val);\n\n\tif (ret == 1 && ctx.new_updated) {\n\t\tkfree(*buf);\n\t\t*buf = ctx.new_val;\n\t\t*pcount = ctx.new_len;\n\t} else {\n\t\tkfree(ctx.new_val);\n\t}\n\n\treturn ret == 1 ? 0 : -EPERM;\n}"
  },
  {
    "function_name": "cgroup_dev_is_valid_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1238-1266",
    "snippet": "static bool cgroup_dev_is_valid_access(int off, int size,\n\t\t\t\t       enum bpf_access_type type,\n\t\t\t\t       const struct bpf_prog *prog,\n\t\t\t\t       struct bpf_insn_access_aux *info)\n{\n\tconst int size_default = sizeof(__u32);\n\n\tif (type == BPF_WRITE)\n\t\treturn false;\n\n\tif (off < 0 || off + size > sizeof(struct bpf_cgroup_dev_ctx))\n\t\treturn false;\n\t/* The verifier guarantees that size > 0. */\n\tif (off % size != 0)\n\t\treturn false;\n\n\tswitch (off) {\n\tcase bpf_ctx_range(struct bpf_cgroup_dev_ctx, access_type):\n\t\tbpf_ctx_record_field_size(info, size_default);\n\t\tif (!bpf_ctx_narrow_access_ok(off, size, size_default))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (size != size_default)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_ctx_narrow_access_ok",
          "args": [
            "off",
            "size",
            "size_default"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_record_field_size",
          "args": [
            "info",
            "size_default"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_range",
          "args": [
            "structbpf_cgroup_dev_ctx",
            "access_type"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool cgroup_dev_is_valid_access(int off, int size,\n\t\t\t\t       enum bpf_access_type type,\n\t\t\t\t       const struct bpf_prog *prog,\n\t\t\t\t       struct bpf_insn_access_aux *info)\n{\n\tconst int size_default = sizeof(__u32);\n\n\tif (type == BPF_WRITE)\n\t\treturn false;\n\n\tif (off < 0 || off + size > sizeof(struct bpf_cgroup_dev_ctx))\n\t\treturn false;\n\t/* The verifier guarantees that size > 0. */\n\tif (off % size != 0)\n\t\treturn false;\n\n\tswitch (off) {\n\tcase bpf_ctx_range(struct bpf_cgroup_dev_ctx, access_type):\n\t\tbpf_ctx_record_field_size(info, size_default);\n\t\tif (!bpf_ctx_narrow_access_ok(off, size, size_default))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (size != size_default)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "cgroup_dev_func_proto",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1232-1236",
    "snippet": "static const struct bpf_func_proto *\ncgroup_dev_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\treturn cgroup_base_func_proto(func_id, prog);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_func_proto",
          "args": [
            "func_id",
            "prog"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_func_proto",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1215-1230",
          "snippet": "static const struct bpf_func_proto *\ncgroup_base_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_local_storage:\n\t\treturn &bpf_get_local_storage_proto;\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_event_output_data_proto;\n\tdefault:\n\t\treturn bpf_base_func_proto(func_id);\n\t}\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto *\ncgroup_base_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_local_storage:\n\t\treturn &bpf_get_local_storage_proto;\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_event_output_data_proto;\n\tdefault:\n\t\treturn bpf_base_func_proto(func_id);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto *\ncgroup_dev_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\treturn cgroup_base_func_proto(func_id, prog);\n}"
  },
  {
    "function_name": "cgroup_base_func_proto",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1215-1230",
    "snippet": "static const struct bpf_func_proto *\ncgroup_base_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_local_storage:\n\t\treturn &bpf_get_local_storage_proto;\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_event_output_data_proto;\n\tdefault:\n\t\treturn bpf_base_func_proto(func_id);\n\t}\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_base_func_proto",
          "args": [
            "func_id"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_base_func_proto",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "1354-1459",
          "snippet": "const struct bpf_func_proto *\nbpf_base_func_proto(enum bpf_func_id func_id)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_map_push_elem:\n\t\treturn &bpf_map_push_elem_proto;\n\tcase BPF_FUNC_map_pop_elem:\n\t\treturn &bpf_map_pop_elem_proto;\n\tcase BPF_FUNC_map_peek_elem:\n\t\treturn &bpf_map_peek_elem_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_raw_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_ktime_get_boot_ns:\n\t\treturn &bpf_ktime_get_boot_ns_proto;\n\tcase BPF_FUNC_ringbuf_output:\n\t\treturn &bpf_ringbuf_output_proto;\n\tcase BPF_FUNC_ringbuf_reserve:\n\t\treturn &bpf_ringbuf_reserve_proto;\n\tcase BPF_FUNC_ringbuf_submit:\n\t\treturn &bpf_ringbuf_submit_proto;\n\tcase BPF_FUNC_ringbuf_discard:\n\t\treturn &bpf_ringbuf_discard_proto;\n\tcase BPF_FUNC_ringbuf_query:\n\t\treturn &bpf_ringbuf_query_proto;\n\tcase BPF_FUNC_for_each_map_elem:\n\t\treturn &bpf_for_each_map_elem_proto;\n\tcase BPF_FUNC_loop:\n\t\treturn &bpf_loop_proto;\n\tcase BPF_FUNC_strncmp:\n\t\treturn &bpf_strncmp_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!bpf_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_spin_lock:\n\t\treturn &bpf_spin_lock_proto;\n\tcase BPF_FUNC_spin_unlock:\n\t\treturn &bpf_spin_unlock_proto;\n\tcase BPF_FUNC_jiffies64:\n\t\treturn &bpf_jiffies64_proto;\n\tcase BPF_FUNC_per_cpu_ptr:\n\t\treturn &bpf_per_cpu_ptr_proto;\n\tcase BPF_FUNC_this_cpu_ptr:\n\t\treturn &bpf_this_cpu_ptr_proto;\n\tcase BPF_FUNC_timer_init:\n\t\treturn &bpf_timer_init_proto;\n\tcase BPF_FUNC_timer_set_callback:\n\t\treturn &bpf_timer_set_callback_proto;\n\tcase BPF_FUNC_timer_start:\n\t\treturn &bpf_timer_start_proto;\n\tcase BPF_FUNC_timer_cancel:\n\t\treturn &bpf_timer_cancel_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!perfmon_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_task_btf:\n\t\treturn &bpf_get_current_task_btf_proto;\n\tcase BPF_FUNC_probe_read_user:\n\t\treturn &bpf_probe_read_user_proto;\n\tcase BPF_FUNC_probe_read_kernel:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_proto;\n\tcase BPF_FUNC_probe_read_user_str:\n\t\treturn &bpf_probe_read_user_str_proto;\n\tcase BPF_FUNC_probe_read_kernel_str:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_str_proto;\n\tcase BPF_FUNC_snprintf_btf:\n\t\treturn &bpf_snprintf_btf_proto;\n\tcase BPF_FUNC_snprintf:\n\t\treturn &bpf_snprintf_proto;\n\tcase BPF_FUNC_task_pt_regs:\n\t\treturn &bpf_task_pt_regs_proto;\n\tcase BPF_FUNC_trace_vprintk:\n\t\treturn bpf_get_trace_vprintk_proto();\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto = {\n\t.func\t\t= bpf_map_lookup_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_PTR_TO_MAP_VALUE_OR_NULL,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};",
            "const struct bpf_func_proto bpf_map_update_elem_proto = {\n\t.func\t\t= bpf_map_update_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n\t.arg3_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg4_type\t= ARG_ANYTHING,\n};",
            "const struct bpf_func_proto bpf_map_delete_elem_proto = {\n\t.func\t\t= bpf_map_delete_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};",
            "const struct bpf_func_proto bpf_map_push_elem_proto = {\n\t.func\t\t= bpf_map_push_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
            "const struct bpf_func_proto bpf_map_pop_elem_proto = {\n\t.func\t\t= bpf_map_pop_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};",
            "const struct bpf_func_proto bpf_map_peek_elem_proto = {\n\t.func\t\t= bpf_map_peek_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto = {\n\t.func\t\t= bpf_user_rnd_u32,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto = {\n\t.func\t\t= bpf_get_numa_node_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto = {\n\t.func\t\t= bpf_ktime_get_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto = {\n\t.func\t\t= bpf_ktime_get_boot_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_spin_lock_proto = {\n\t.func\t\t= bpf_spin_lock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};",
            "const struct bpf_func_proto bpf_spin_unlock_proto = {\n\t.func\t\t= bpf_spin_unlock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};",
            "const struct bpf_func_proto bpf_jiffies64_proto = {\n\t.func\t\t= bpf_jiffies64,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_strncmp_proto = {\n\t.func\t\t= bpf_strncmp,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n};",
            "static const struct bpf_func_proto bpf_get_raw_smp_processor_id_proto = {\n\t.func\t\t= bpf_get_raw_cpu_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_per_cpu_ptr_proto = {\n\t.func\t\t= bpf_per_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n\t.arg2_type\t= ARG_ANYTHING,\n};",
            "const struct bpf_func_proto bpf_this_cpu_ptr_proto = {\n\t.func\t\t= bpf_this_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n};",
            "const struct bpf_func_proto bpf_snprintf_proto = {\n\t.func\t\t= bpf_snprintf,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM_OR_NULL,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n\t.arg4_type\t= ARG_PTR_TO_MEM | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};",
            "static const struct bpf_func_proto bpf_timer_init_proto = {\n\t.func\t\t= bpf_timer_init,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_timer_set_callback_proto = {\n\t.func\t\t= bpf_timer_set_callback,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_PTR_TO_FUNC,\n};",
            "static const struct bpf_func_proto bpf_timer_start_proto = {\n\t.func\t\t= bpf_timer_start,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_ANYTHING,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_timer_cancel_proto = {\n\t.func\t\t= bpf_timer_cancel,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto = {\n\t.func\t\t= bpf_map_lookup_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_PTR_TO_MAP_VALUE_OR_NULL,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};\nconst struct bpf_func_proto bpf_map_update_elem_proto = {\n\t.func\t\t= bpf_map_update_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n\t.arg3_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg4_type\t= ARG_ANYTHING,\n};\nconst struct bpf_func_proto bpf_map_delete_elem_proto = {\n\t.func\t\t= bpf_map_delete_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};\nconst struct bpf_func_proto bpf_map_push_elem_proto = {\n\t.func\t\t= bpf_map_push_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nconst struct bpf_func_proto bpf_map_pop_elem_proto = {\n\t.func\t\t= bpf_map_pop_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};\nconst struct bpf_func_proto bpf_map_peek_elem_proto = {\n\t.func\t\t= bpf_map_peek_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};\nconst struct bpf_func_proto bpf_get_prandom_u32_proto = {\n\t.func\t\t= bpf_user_rnd_u32,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_get_numa_node_id_proto = {\n\t.func\t\t= bpf_get_numa_node_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_ktime_get_ns_proto = {\n\t.func\t\t= bpf_ktime_get_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto = {\n\t.func\t\t= bpf_ktime_get_boot_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_spin_lock_proto = {\n\t.func\t\t= bpf_spin_lock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};\nconst struct bpf_func_proto bpf_spin_unlock_proto = {\n\t.func\t\t= bpf_spin_unlock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};\nconst struct bpf_func_proto bpf_jiffies64_proto = {\n\t.func\t\t= bpf_jiffies64,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_strncmp_proto = {\n\t.func\t\t= bpf_strncmp,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n};\nstatic const struct bpf_func_proto bpf_get_raw_smp_processor_id_proto = {\n\t.func\t\t= bpf_get_raw_cpu_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_per_cpu_ptr_proto = {\n\t.func\t\t= bpf_per_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n\t.arg2_type\t= ARG_ANYTHING,\n};\nconst struct bpf_func_proto bpf_this_cpu_ptr_proto = {\n\t.func\t\t= bpf_this_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n};\nconst struct bpf_func_proto bpf_snprintf_proto = {\n\t.func\t\t= bpf_snprintf,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM_OR_NULL,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n\t.arg4_type\t= ARG_PTR_TO_MEM | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};\nstatic const struct bpf_func_proto bpf_timer_init_proto = {\n\t.func\t\t= bpf_timer_init,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_timer_set_callback_proto = {\n\t.func\t\t= bpf_timer_set_callback,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_PTR_TO_FUNC,\n};\nstatic const struct bpf_func_proto bpf_timer_start_proto = {\n\t.func\t\t= bpf_timer_start,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_ANYTHING,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_timer_cancel_proto = {\n\t.func\t\t= bpf_timer_cancel,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n};\n\nconst struct bpf_func_proto *\nbpf_base_func_proto(enum bpf_func_id func_id)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_map_push_elem:\n\t\treturn &bpf_map_push_elem_proto;\n\tcase BPF_FUNC_map_pop_elem:\n\t\treturn &bpf_map_pop_elem_proto;\n\tcase BPF_FUNC_map_peek_elem:\n\t\treturn &bpf_map_peek_elem_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_raw_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_ktime_get_boot_ns:\n\t\treturn &bpf_ktime_get_boot_ns_proto;\n\tcase BPF_FUNC_ringbuf_output:\n\t\treturn &bpf_ringbuf_output_proto;\n\tcase BPF_FUNC_ringbuf_reserve:\n\t\treturn &bpf_ringbuf_reserve_proto;\n\tcase BPF_FUNC_ringbuf_submit:\n\t\treturn &bpf_ringbuf_submit_proto;\n\tcase BPF_FUNC_ringbuf_discard:\n\t\treturn &bpf_ringbuf_discard_proto;\n\tcase BPF_FUNC_ringbuf_query:\n\t\treturn &bpf_ringbuf_query_proto;\n\tcase BPF_FUNC_for_each_map_elem:\n\t\treturn &bpf_for_each_map_elem_proto;\n\tcase BPF_FUNC_loop:\n\t\treturn &bpf_loop_proto;\n\tcase BPF_FUNC_strncmp:\n\t\treturn &bpf_strncmp_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!bpf_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_spin_lock:\n\t\treturn &bpf_spin_lock_proto;\n\tcase BPF_FUNC_spin_unlock:\n\t\treturn &bpf_spin_unlock_proto;\n\tcase BPF_FUNC_jiffies64:\n\t\treturn &bpf_jiffies64_proto;\n\tcase BPF_FUNC_per_cpu_ptr:\n\t\treturn &bpf_per_cpu_ptr_proto;\n\tcase BPF_FUNC_this_cpu_ptr:\n\t\treturn &bpf_this_cpu_ptr_proto;\n\tcase BPF_FUNC_timer_init:\n\t\treturn &bpf_timer_init_proto;\n\tcase BPF_FUNC_timer_set_callback:\n\t\treturn &bpf_timer_set_callback_proto;\n\tcase BPF_FUNC_timer_start:\n\t\treturn &bpf_timer_start_proto;\n\tcase BPF_FUNC_timer_cancel:\n\t\treturn &bpf_timer_cancel_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!perfmon_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_task_btf:\n\t\treturn &bpf_get_current_task_btf_proto;\n\tcase BPF_FUNC_probe_read_user:\n\t\treturn &bpf_probe_read_user_proto;\n\tcase BPF_FUNC_probe_read_kernel:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_proto;\n\tcase BPF_FUNC_probe_read_user_str:\n\t\treturn &bpf_probe_read_user_str_proto;\n\tcase BPF_FUNC_probe_read_kernel_str:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_str_proto;\n\tcase BPF_FUNC_snprintf_btf:\n\t\treturn &bpf_snprintf_btf_proto;\n\tcase BPF_FUNC_snprintf:\n\t\treturn &bpf_snprintf_proto;\n\tcase BPF_FUNC_task_pt_regs:\n\t\treturn &bpf_task_pt_regs_proto;\n\tcase BPF_FUNC_trace_vprintk:\n\t\treturn bpf_get_trace_vprintk_proto();\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto *\ncgroup_base_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_local_storage:\n\t\treturn &bpf_get_local_storage_proto;\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_event_output_data_proto;\n\tdefault:\n\t\treturn bpf_base_func_proto(func_id);\n\t}\n}"
  },
  {
    "function_name": "__cgroup_bpf_check_dev_permission",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1195-1213",
    "snippet": "int __cgroup_bpf_check_dev_permission(short dev_type, u32 major, u32 minor,\n\t\t\t\t      short access, enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup *cgrp;\n\tstruct bpf_cgroup_dev_ctx ctx = {\n\t\t.access_type = (access << 16) | dev_type,\n\t\t.major = major,\n\t\t.minor = minor,\n\t};\n\tint allow;\n\n\trcu_read_lock();\n\tcgrp = task_dfl_cgroup(current);\n\tallow = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[atype], &ctx,\n\t\t\t\t      bpf_prog_run);\n\trcu_read_unlock();\n\n\treturn !allow;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY_CG",
          "args": [
            "cgrp->bpf.effective[atype]",
            "&ctx",
            "bpf_prog_run"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_dfl_cgroup",
          "args": [
            "current"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_check_dev_permission(short dev_type, u32 major, u32 minor,\n\t\t\t\t      short access, enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup *cgrp;\n\tstruct bpf_cgroup_dev_ctx ctx = {\n\t\t.access_type = (access << 16) | dev_type,\n\t\t.major = major,\n\t\t.minor = minor,\n\t};\n\tint allow;\n\n\trcu_read_lock();\n\tcgrp = task_dfl_cgroup(current);\n\tallow = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[atype], &ctx,\n\t\t\t\t      bpf_prog_run);\n\trcu_read_unlock();\n\n\treturn !allow;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_sock_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1182-1192",
    "snippet": "int __cgroup_bpf_run_filter_sock_ops(struct sock *sk,\n\t\t\t\t     struct bpf_sock_ops_kern *sock_ops,\n\t\t\t\t     enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tint ret;\n\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[atype], sock_ops,\n\t\t\t\t    bpf_prog_run);\n\treturn ret == 1 ? 0 : -EPERM;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY_CG",
          "args": [
            "cgrp->bpf.effective[atype]",
            "sock_ops",
            "bpf_prog_run"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "&sk->sk_cgrp_data"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_sock_ops(struct sock *sk,\n\t\t\t\t     struct bpf_sock_ops_kern *sock_ops,\n\t\t\t\t     enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tint ret;\n\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[atype], sock_ops,\n\t\t\t\t    bpf_prog_run);\n\treturn ret == 1 ? 0 : -EPERM;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_sock_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1132-1163",
    "snippet": "int __cgroup_bpf_run_filter_sock_addr(struct sock *sk,\n\t\t\t\t      struct sockaddr *uaddr,\n\t\t\t\t      enum cgroup_bpf_attach_type atype,\n\t\t\t\t      void *t_ctx,\n\t\t\t\t      u32 *flags)\n{\n\tstruct bpf_sock_addr_kern ctx = {\n\t\t.sk = sk,\n\t\t.uaddr = uaddr,\n\t\t.t_ctx = t_ctx,\n\t};\n\tstruct sockaddr_storage unspec;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* Check socket family since not all sockets represent network\n\t * endpoint (e.g. AF_UNIX).\n\t */\n\tif (sk->sk_family != AF_INET && sk->sk_family != AF_INET6)\n\t\treturn 0;\n\n\tif (!ctx.uaddr) {\n\t\tmemset(&unspec, 0, sizeof(unspec));\n\t\tctx.uaddr = (struct sockaddr *)&unspec;\n\t}\n\n\tcgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tret = BPF_PROG_RUN_ARRAY_CG_FLAGS(cgrp->bpf.effective[atype], &ctx,\n\t\t\t\t          bpf_prog_run, flags);\n\n\treturn ret == 1 ? 0 : -EPERM;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY_CG_FLAGS",
          "args": [
            "cgrp->bpf.effective[atype]",
            "&ctx",
            "bpf_prog_run",
            "flags"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "&sk->sk_cgrp_data"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&unspec",
            "0",
            "sizeof(unspec)"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_sock_addr(struct sock *sk,\n\t\t\t\t      struct sockaddr *uaddr,\n\t\t\t\t      enum cgroup_bpf_attach_type atype,\n\t\t\t\t      void *t_ctx,\n\t\t\t\t      u32 *flags)\n{\n\tstruct bpf_sock_addr_kern ctx = {\n\t\t.sk = sk,\n\t\t.uaddr = uaddr,\n\t\t.t_ctx = t_ctx,\n\t};\n\tstruct sockaddr_storage unspec;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* Check socket family since not all sockets represent network\n\t * endpoint (e.g. AF_UNIX).\n\t */\n\tif (sk->sk_family != AF_INET && sk->sk_family != AF_INET6)\n\t\treturn 0;\n\n\tif (!ctx.uaddr) {\n\t\tmemset(&unspec, 0, sizeof(unspec));\n\t\tctx.uaddr = (struct sockaddr *)&unspec;\n\t}\n\n\tcgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tret = BPF_PROG_RUN_ARRAY_CG_FLAGS(cgrp->bpf.effective[atype], &ctx,\n\t\t\t\t          bpf_prog_run, flags);\n\n\treturn ret == 1 ? 0 : -EPERM;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_sk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1106-1114",
    "snippet": "int __cgroup_bpf_run_filter_sk(struct sock *sk,\n\t\t\t       enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tint ret;\n\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[atype], sk, bpf_prog_run);\n\treturn ret == 1 ? 0 : -EPERM;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY_CG",
          "args": [
            "cgrp->bpf.effective[atype]",
            "sk",
            "bpf_prog_run"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "&sk->sk_cgrp_data"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_sk(struct sock *sk,\n\t\t\t       enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tint ret;\n\n\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[atype], sk, bpf_prog_run);\n\treturn ret == 1 ? 0 : -EPERM;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_skb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1053-1090",
    "snippet": "int __cgroup_bpf_run_filter_skb(struct sock *sk,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tenum cgroup_bpf_attach_type atype)\n{\n\tunsigned int offset = skb->data - skb_network_header(skb);\n\tstruct sock *save_sk;\n\tvoid *saved_data_end;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tif (!sk || !sk_fullsock(sk))\n\t\treturn 0;\n\n\tif (sk->sk_family != AF_INET && sk->sk_family != AF_INET6)\n\t\treturn 0;\n\n\tcgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tsave_sk = skb->sk;\n\tskb->sk = sk;\n\t__skb_push(skb, offset);\n\n\t/* compute pointers for the bpf prog */\n\tbpf_compute_and_save_data_end(skb, &saved_data_end);\n\n\tif (atype == CGROUP_INET_EGRESS) {\n\t\tret = BPF_PROG_CGROUP_INET_EGRESS_RUN_ARRAY(\n\t\t\tcgrp->bpf.effective[atype], skb, __bpf_prog_run_save_cb);\n\t} else {\n\t\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[atype], skb,\n\t\t\t\t\t    __bpf_prog_run_save_cb);\n\t\tret = (ret == 1 ? 0 : -EPERM);\n\t}\n\tbpf_restore_data_end(skb, saved_data_end);\n\t__skb_pull(skb, offset);\n\tskb->sk = save_sk;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__skb_pull",
          "args": [
            "skb",
            "offset"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_restore_data_end",
          "args": [
            "skb",
            "saved_data_end"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY_CG",
          "args": [
            "cgrp->bpf.effective[atype]",
            "skb",
            "__bpf_prog_run_save_cb"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_PROG_CGROUP_INET_EGRESS_RUN_ARRAY",
          "args": [
            "cgrp->bpf.effective[atype]",
            "skb",
            "__bpf_prog_run_save_cb"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_compute_and_save_data_end",
          "args": [
            "skb",
            "&saved_data_end"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__skb_push",
          "args": [
            "skb",
            "offset"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "&sk->sk_cgrp_data"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_fullsock",
          "args": [
            "sk"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_network_header",
          "args": [
            "skb"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_skb(struct sock *sk,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tenum cgroup_bpf_attach_type atype)\n{\n\tunsigned int offset = skb->data - skb_network_header(skb);\n\tstruct sock *save_sk;\n\tvoid *saved_data_end;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tif (!sk || !sk_fullsock(sk))\n\t\treturn 0;\n\n\tif (sk->sk_family != AF_INET && sk->sk_family != AF_INET6)\n\t\treturn 0;\n\n\tcgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tsave_sk = skb->sk;\n\tskb->sk = sk;\n\t__skb_push(skb, offset);\n\n\t/* compute pointers for the bpf prog */\n\tbpf_compute_and_save_data_end(skb, &saved_data_end);\n\n\tif (atype == CGROUP_INET_EGRESS) {\n\t\tret = BPF_PROG_CGROUP_INET_EGRESS_RUN_ARRAY(\n\t\t\tcgrp->bpf.effective[atype], skb, __bpf_prog_run_save_cb);\n\t} else {\n\t\tret = BPF_PROG_RUN_ARRAY_CG(cgrp->bpf.effective[atype], skb,\n\t\t\t\t\t    __bpf_prog_run_save_cb);\n\t\tret = (ret == 1 ? 0 : -EPERM);\n\t}\n\tbpf_restore_data_end(skb, saved_data_end);\n\t__skb_pull(skb, offset);\n\tskb->sk = save_sk;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_bpf_prog_query",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "1014-1028",
    "snippet": "int cgroup_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->query.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_query(cgrp, attr, uattr);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_query",
          "args": [
            "cgrp",
            "attr",
            "uattr"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_query",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "817-826",
          "snippet": "static int cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t\t    union bpf_attr __user *uattr)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_query(cgrp, attr, uattr);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t\t    union bpf_attr __user *uattr)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_query(cgrp, attr, uattr);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cgrp"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cgrp"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_from_fd",
          "args": [
            "attr->query.target_fd"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "6577-6589",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->query.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_query(cgrp, attr, uattr);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_bpf_link_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "970-1012",
    "snippet": "int cgroup_bpf_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_cgroup_link *link;\n\tstruct cgroup *cgrp;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tcgrp = cgroup_get_from_fd(attr->link_create.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_cgroup;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_CGROUP, &bpf_cgroup_link_lops,\n\t\t      prog);\n\tlink->cgroup = cgrp;\n\tlink->type = attr->link_create.attach_type;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_cgroup;\n\t}\n\n\terr = cgroup_bpf_attach(cgrp, NULL, NULL, link,\n\t\t\t\tlink->type, BPF_F_ALLOW_MULTI);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_cgroup;\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_cgroup:\n\tcgroup_put(cgrp);\n\treturn err;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_link_ops bpf_cgroup_link_lops = {\n\t.release = bpf_cgroup_link_release,\n\t.dealloc = bpf_cgroup_link_dealloc,\n\t.detach = bpf_cgroup_link_detach,\n\t.update_prog = cgroup_bpf_replace,\n\t.show_fdinfo = bpf_cgroup_link_show_fdinfo,\n\t.fill_link_info = bpf_cgroup_link_fill_link_info,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_settle",
          "args": [
            "&link_primer"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_settle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2598-2608",
          "snippet": "int bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nint bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_cleanup",
          "args": [
            "&link_primer"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2443-2449",
          "snippet": "void bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_attach",
          "args": [
            "cgrp",
            "NULL",
            "NULL",
            "link",
            "link->type",
            "BPF_F_ALLOW_MULTI"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "526-538",
          "snippet": "static int cgroup_bpf_attach(struct cgroup *cgrp,\n\t\t\t     struct bpf_prog *prog, struct bpf_prog *replace_prog,\n\t\t\t     struct bpf_cgroup_link *link,\n\t\t\t     enum bpf_attach_type type,\n\t\t\t     u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_attach(cgrp, prog, replace_prog, link, type, flags);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int cgroup_bpf_attach(struct cgroup *cgrp,\n\t\t\t     struct bpf_prog *prog, struct bpf_prog *replace_prog,\n\t\t\t     struct bpf_cgroup_link *link,\n\t\t\t     enum bpf_attach_type type,\n\t\t\t     u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_attach(cgrp, prog, replace_prog, link, type, flags);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_prime",
          "args": [
            "&link->link",
            "&link_primer"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_prime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2568-2596",
          "snippet": "int bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_init",
          "args": [
            "&link->link",
            "BPF_LINK_TYPE_CGROUP",
            "&bpf_cgroup_link_lops",
            "prog"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2416-2424",
          "snippet": "void bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*link)",
            "GFP_USER"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cgrp"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cgrp"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_from_fd",
          "args": [
            "attr->link_create.target_fd"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "6577-6589",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_link_ops bpf_cgroup_link_lops = {\n\t.release = bpf_cgroup_link_release,\n\t.dealloc = bpf_cgroup_link_dealloc,\n\t.detach = bpf_cgroup_link_detach,\n\t.update_prog = cgroup_bpf_replace,\n\t.show_fdinfo = bpf_cgroup_link_show_fdinfo,\n\t.fill_link_info = bpf_cgroup_link_fill_link_info,\n};\n\nint cgroup_bpf_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_cgroup_link *link;\n\tstruct cgroup *cgrp;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tcgrp = cgroup_get_from_fd(attr->link_create.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_cgroup;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_CGROUP, &bpf_cgroup_link_lops,\n\t\t      prog);\n\tlink->cgroup = cgrp;\n\tlink->type = attr->link_create.attach_type;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_cgroup;\n\t}\n\n\terr = cgroup_bpf_attach(cgrp, NULL, NULL, link,\n\t\t\t\tlink->type, BPF_F_ALLOW_MULTI);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_cgroup;\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_cgroup:\n\tcgroup_put(cgrp);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_cgroup_link_fill_link_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "944-959",
    "snippet": "static int bpf_cgroup_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t\t  struct bpf_link_info *info)\n{\n\tstruct bpf_cgroup_link *cg_link =\n\t\tcontainer_of(link, struct bpf_cgroup_link, link);\n\tu64 cg_id = 0;\n\n\tmutex_lock(&cgroup_mutex);\n\tif (cg_link->cgroup)\n\t\tcg_id = cgroup_id(cg_link->cgroup);\n\tmutex_unlock(&cgroup_mutex);\n\n\tinfo->cgroup.cgroup_id = cg_id;\n\tinfo->cgroup.attach_type = cg_link->type;\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_id",
          "args": [
            "cg_link->cgroup"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_cgroup_link",
            "link"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int bpf_cgroup_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t\t  struct bpf_link_info *info)\n{\n\tstruct bpf_cgroup_link *cg_link =\n\t\tcontainer_of(link, struct bpf_cgroup_link, link);\n\tu64 cg_id = 0;\n\n\tmutex_lock(&cgroup_mutex);\n\tif (cg_link->cgroup)\n\t\tcg_id = cgroup_id(cg_link->cgroup);\n\tmutex_unlock(&cgroup_mutex);\n\n\tinfo->cgroup.cgroup_id = cg_id;\n\tinfo->cgroup.attach_type = cg_link->type;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_cgroup_link_show_fdinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "925-942",
    "snippet": "static void bpf_cgroup_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t\tstruct seq_file *seq)\n{\n\tstruct bpf_cgroup_link *cg_link =\n\t\tcontainer_of(link, struct bpf_cgroup_link, link);\n\tu64 cg_id = 0;\n\n\tmutex_lock(&cgroup_mutex);\n\tif (cg_link->cgroup)\n\t\tcg_id = cgroup_id(cg_link->cgroup);\n\tmutex_unlock(&cgroup_mutex);\n\n\tseq_printf(seq,\n\t\t   \"cgroup_id:\\t%llu\\n\"\n\t\t   \"attach_type:\\t%d\\n\",\n\t\t   cg_id,\n\t\t   cg_link->type);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"cgroup_id:\\t%llu\\n\"\n\t\t   \"attach_type:\\t%d\\n\"",
            "cg_id",
            "cg_link->type"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_id",
          "args": [
            "cg_link->cgroup"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_cgroup_link",
            "link"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t\tstruct seq_file *seq)\n{\n\tstruct bpf_cgroup_link *cg_link =\n\t\tcontainer_of(link, struct bpf_cgroup_link, link);\n\tu64 cg_id = 0;\n\n\tmutex_lock(&cgroup_mutex);\n\tif (cg_link->cgroup)\n\t\tcg_id = cgroup_id(cg_link->cgroup);\n\tmutex_unlock(&cgroup_mutex);\n\n\tseq_printf(seq,\n\t\t   \"cgroup_id:\\t%llu\\n\"\n\t\t   \"attach_type:\\t%d\\n\",\n\t\t   cg_id,\n\t\t   cg_link->type);\n}"
  },
  {
    "function_name": "bpf_cgroup_link_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "918-923",
    "snippet": "static int bpf_cgroup_link_detach(struct bpf_link *link)\n{\n\tbpf_cgroup_link_release(link);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_cgroup_link_release",
          "args": [
            "link"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_link_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "879-908",
          "snippet": "static void bpf_cgroup_link_release(struct bpf_link *link)\n{\n\tstruct bpf_cgroup_link *cg_link =\n\t\tcontainer_of(link, struct bpf_cgroup_link, link);\n\tstruct cgroup *cg;\n\n\t/* link might have been auto-detached by dying cgroup already,\n\t * in that case our work is done here\n\t */\n\tif (!cg_link->cgroup)\n\t\treturn;\n\n\tmutex_lock(&cgroup_mutex);\n\n\t/* re-check cgroup under lock again */\n\tif (!cg_link->cgroup) {\n\t\tmutex_unlock(&cgroup_mutex);\n\t\treturn;\n\t}\n\n\tWARN_ON(__cgroup_bpf_detach(cg_link->cgroup, NULL, cg_link,\n\t\t\t\t    cg_link->type));\n\n\tcg = cg_link->cgroup;\n\tcg_link->cgroup = NULL;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tcgroup_put(cg);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_link_release(struct bpf_link *link)\n{\n\tstruct bpf_cgroup_link *cg_link =\n\t\tcontainer_of(link, struct bpf_cgroup_link, link);\n\tstruct cgroup *cg;\n\n\t/* link might have been auto-detached by dying cgroup already,\n\t * in that case our work is done here\n\t */\n\tif (!cg_link->cgroup)\n\t\treturn;\n\n\tmutex_lock(&cgroup_mutex);\n\n\t/* re-check cgroup under lock again */\n\tif (!cg_link->cgroup) {\n\t\tmutex_unlock(&cgroup_mutex);\n\t\treturn;\n\t}\n\n\tWARN_ON(__cgroup_bpf_detach(cg_link->cgroup, NULL, cg_link,\n\t\t\t\t    cg_link->type));\n\n\tcg = cg_link->cgroup;\n\tcg_link->cgroup = NULL;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tcgroup_put(cg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int bpf_cgroup_link_detach(struct bpf_link *link)\n{\n\tbpf_cgroup_link_release(link);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_cgroup_link_dealloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "910-916",
    "snippet": "static void bpf_cgroup_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_cgroup_link *cg_link =\n\t\tcontainer_of(link, struct bpf_cgroup_link, link);\n\n\tkfree(cg_link);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cg_link"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_cgroup_link",
            "link"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_cgroup_link *cg_link =\n\t\tcontainer_of(link, struct bpf_cgroup_link, link);\n\n\tkfree(cg_link);\n}"
  },
  {
    "function_name": "bpf_cgroup_link_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "879-908",
    "snippet": "static void bpf_cgroup_link_release(struct bpf_link *link)\n{\n\tstruct bpf_cgroup_link *cg_link =\n\t\tcontainer_of(link, struct bpf_cgroup_link, link);\n\tstruct cgroup *cg;\n\n\t/* link might have been auto-detached by dying cgroup already,\n\t * in that case our work is done here\n\t */\n\tif (!cg_link->cgroup)\n\t\treturn;\n\n\tmutex_lock(&cgroup_mutex);\n\n\t/* re-check cgroup under lock again */\n\tif (!cg_link->cgroup) {\n\t\tmutex_unlock(&cgroup_mutex);\n\t\treturn;\n\t}\n\n\tWARN_ON(__cgroup_bpf_detach(cg_link->cgroup, NULL, cg_link,\n\t\t\t\t    cg_link->type));\n\n\tcg = cg_link->cgroup;\n\tcg_link->cgroup = NULL;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tcgroup_put(cg);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cg"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "__cgroup_bpf_detach(cg_link->cgroup, NULL, cg_link,\n\t\t\t\t    cg_link->type)"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cgroup_bpf_detach",
          "args": [
            "cg_link->cgroup",
            "NULL",
            "cg_link",
            "cg_link->type"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "695-745",
          "snippet": "static int __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\t       struct bpf_cgroup_link *link, enum bpf_attach_type type)\n{\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog *old_prog;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tu32 flags;\n\tint err;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\tflags = cgrp->bpf.flags[atype];\n\n\tif (prog && link)\n\t\t/* only one of prog or link can be specified */\n\t\treturn -EINVAL;\n\n\tpl = find_detach_entry(progs, prog, link, flags & BPF_F_ALLOW_MULTI);\n\tif (IS_ERR(pl))\n\t\treturn PTR_ERR(pl);\n\n\t/* mark it deleted, so it's ignored while recomputing effective */\n\told_prog = pl->prog;\n\tpl->prog = NULL;\n\tpl->link = NULL;\n\n\terr = update_effective_progs(cgrp, atype);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[atype] = 0;\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key[atype]);\n\treturn 0;\n\ncleanup:\n\t/* restore back prog or link */\n\tpl->prog = old_prog;\n\tpl->link = link;\n\treturn err;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\t       struct bpf_cgroup_link *link, enum bpf_attach_type type)\n{\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog *old_prog;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tu32 flags;\n\tint err;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\tflags = cgrp->bpf.flags[atype];\n\n\tif (prog && link)\n\t\t/* only one of prog or link can be specified */\n\t\treturn -EINVAL;\n\n\tpl = find_detach_entry(progs, prog, link, flags & BPF_F_ALLOW_MULTI);\n\tif (IS_ERR(pl))\n\t\treturn PTR_ERR(pl);\n\n\t/* mark it deleted, so it's ignored while recomputing effective */\n\told_prog = pl->prog;\n\tpl->prog = NULL;\n\tpl->link = NULL;\n\n\terr = update_effective_progs(cgrp, atype);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[atype] = 0;\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key[atype]);\n\treturn 0;\n\ncleanup:\n\t/* restore back prog or link */\n\tpl->prog = old_prog;\n\tpl->link = link;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_cgroup_link",
            "link"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_link_release(struct bpf_link *link)\n{\n\tstruct bpf_cgroup_link *cg_link =\n\t\tcontainer_of(link, struct bpf_cgroup_link, link);\n\tstruct cgroup *cg;\n\n\t/* link might have been auto-detached by dying cgroup already,\n\t * in that case our work is done here\n\t */\n\tif (!cg_link->cgroup)\n\t\treturn;\n\n\tmutex_lock(&cgroup_mutex);\n\n\t/* re-check cgroup under lock again */\n\tif (!cg_link->cgroup) {\n\t\tmutex_unlock(&cgroup_mutex);\n\t\treturn;\n\t}\n\n\tWARN_ON(__cgroup_bpf_detach(cg_link->cgroup, NULL, cg_link,\n\t\t\t\t    cg_link->type));\n\n\tcg = cg_link->cgroup;\n\tcg_link->cgroup = NULL;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tcgroup_put(cg);\n}"
  },
  {
    "function_name": "cgroup_bpf_prog_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "857-877",
    "snippet": "int cgroup_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tstruct bpf_prog *prog;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\tprog = NULL;\n\n\tret = cgroup_bpf_detach(cgrp, prog, attr->attach_type);\n\tif (prog)\n\t\tbpf_prog_put(prog);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_detach",
          "args": [
            "cgrp",
            "prog",
            "attr->attach_type"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "747-756",
          "snippet": "static int cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\t     enum bpf_attach_type type)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_detach(cgrp, prog, NULL, type);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\t     enum bpf_attach_type type)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_detach(cgrp, prog, NULL, type);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_type",
          "args": [
            "attr->attach_bpf_fd",
            "ptype"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_type_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "586-598",
          "snippet": "struct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cgrp"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cgrp"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_from_fd",
          "args": [
            "attr->target_fd"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "6577-6589",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tstruct bpf_prog *prog;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\tprog = NULL;\n\n\tret = cgroup_bpf_detach(cgrp, prog, attr->attach_type);\n\tif (prog)\n\t\tbpf_prog_put(prog);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_bpf_prog_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "828-855",
    "snippet": "int cgroup_bpf_prog_attach(const union bpf_attr *attr,\n\t\t\t   enum bpf_prog_type ptype, struct bpf_prog *prog)\n{\n\tstruct bpf_prog *replace_prog = NULL;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tif ((attr->attach_flags & BPF_F_ALLOW_MULTI) &&\n\t    (attr->attach_flags & BPF_F_REPLACE)) {\n\t\treplace_prog = bpf_prog_get_type(attr->replace_bpf_fd, ptype);\n\t\tif (IS_ERR(replace_prog)) {\n\t\t\tcgroup_put(cgrp);\n\t\t\treturn PTR_ERR(replace_prog);\n\t\t}\n\t}\n\n\tret = cgroup_bpf_attach(cgrp, prog, replace_prog, NULL,\n\t\t\t\tattr->attach_type, attr->attach_flags);\n\n\tif (replace_prog)\n\t\tbpf_prog_put(replace_prog);\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "replace_prog"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_attach",
          "args": [
            "cgrp",
            "prog",
            "replace_prog",
            "NULL",
            "attr->attach_type",
            "attr->attach_flags"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "526-538",
          "snippet": "static int cgroup_bpf_attach(struct cgroup *cgrp,\n\t\t\t     struct bpf_prog *prog, struct bpf_prog *replace_prog,\n\t\t\t     struct bpf_cgroup_link *link,\n\t\t\t     enum bpf_attach_type type,\n\t\t\t     u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_attach(cgrp, prog, replace_prog, link, type, flags);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int cgroup_bpf_attach(struct cgroup *cgrp,\n\t\t\t     struct bpf_prog *prog, struct bpf_prog *replace_prog,\n\t\t\t     struct bpf_cgroup_link *link,\n\t\t\t     enum bpf_attach_type type,\n\t\t\t     u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_attach(cgrp, prog, replace_prog, link, type, flags);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "replace_prog"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "replace_prog"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_type",
          "args": [
            "attr->replace_bpf_fd",
            "ptype"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_type_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "586-598",
          "snippet": "struct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cgrp"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cgrp"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_from_fd",
          "args": [
            "attr->target_fd"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "6577-6589",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_attach(const union bpf_attr *attr,\n\t\t\t   enum bpf_prog_type ptype, struct bpf_prog *prog)\n{\n\tstruct bpf_prog *replace_prog = NULL;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tif ((attr->attach_flags & BPF_F_ALLOW_MULTI) &&\n\t    (attr->attach_flags & BPF_F_REPLACE)) {\n\t\treplace_prog = bpf_prog_get_type(attr->replace_bpf_fd, ptype);\n\t\tif (IS_ERR(replace_prog)) {\n\t\t\tcgroup_put(cgrp);\n\t\t\treturn PTR_ERR(replace_prog);\n\t\t}\n\t}\n\n\tret = cgroup_bpf_attach(cgrp, prog, replace_prog, NULL,\n\t\t\t\tattr->attach_type, attr->attach_flags);\n\n\tif (replace_prog)\n\t\tbpf_prog_put(replace_prog);\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_bpf_query",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "817-826",
    "snippet": "static int cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t\t    union bpf_attr __user *uattr)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_query(cgrp, attr, uattr);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cgroup_bpf_query",
          "args": [
            "cgrp",
            "attr",
            "uattr"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_query",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "759-815",
          "snippet": "static int __cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t\t      union bpf_attr __user *uattr)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tenum bpf_attach_type type = attr->query.attach_type;\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog_array *effective;\n\tstruct list_head *progs;\n\tstruct bpf_prog *prog;\n\tint cnt, ret = 0, i;\n\tu32 flags;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\tflags = cgrp->bpf.flags[atype];\n\n\teffective = rcu_dereference_protected(cgrp->bpf.effective[atype],\n\t\t\t\t\t      lockdep_is_held(&cgroup_mutex));\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tcnt = bpf_prog_array_length(effective);\n\telse\n\t\tcnt = prog_list_length(progs);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &cnt, sizeof(cnt)))\n\t\treturn -EFAULT;\n\tif (attr->query.prog_cnt == 0 || !prog_ids || !cnt)\n\t\t/* return early if user requested only program count + flags */\n\t\treturn 0;\n\tif (attr->query.prog_cnt < cnt) {\n\t\tcnt = attr->query.prog_cnt;\n\t\tret = -ENOSPC;\n\t}\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\treturn bpf_prog_array_copy_to_user(effective, prog_ids, cnt);\n\t} else {\n\t\tstruct bpf_prog_list *pl;\n\t\tu32 id;\n\n\t\ti = 0;\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tprog = prog_list_prog(pl);\n\t\t\tid = prog->aux->id;\n\t\t\tif (copy_to_user(prog_ids + i, &id, sizeof(id)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (++i == cnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int __cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t\t      union bpf_attr __user *uattr)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tenum bpf_attach_type type = attr->query.attach_type;\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog_array *effective;\n\tstruct list_head *progs;\n\tstruct bpf_prog *prog;\n\tint cnt, ret = 0, i;\n\tu32 flags;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\tflags = cgrp->bpf.flags[atype];\n\n\teffective = rcu_dereference_protected(cgrp->bpf.effective[atype],\n\t\t\t\t\t      lockdep_is_held(&cgroup_mutex));\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tcnt = bpf_prog_array_length(effective);\n\telse\n\t\tcnt = prog_list_length(progs);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &cnt, sizeof(cnt)))\n\t\treturn -EFAULT;\n\tif (attr->query.prog_cnt == 0 || !prog_ids || !cnt)\n\t\t/* return early if user requested only program count + flags */\n\t\treturn 0;\n\tif (attr->query.prog_cnt < cnt) {\n\t\tcnt = attr->query.prog_cnt;\n\t\tret = -ENOSPC;\n\t}\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\treturn bpf_prog_array_copy_to_user(effective, prog_ids, cnt);\n\t} else {\n\t\tstruct bpf_prog_list *pl;\n\t\tu32 id;\n\n\t\ti = 0;\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tprog = prog_list_prog(pl);\n\t\t\tid = prog->aux->id;\n\t\t\tif (copy_to_user(prog_ids + i, &id, sizeof(id)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (++i == cnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t\t    union bpf_attr __user *uattr)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_query(cgrp, attr, uattr);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__cgroup_bpf_query",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "759-815",
    "snippet": "static int __cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t\t      union bpf_attr __user *uattr)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tenum bpf_attach_type type = attr->query.attach_type;\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog_array *effective;\n\tstruct list_head *progs;\n\tstruct bpf_prog *prog;\n\tint cnt, ret = 0, i;\n\tu32 flags;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\tflags = cgrp->bpf.flags[atype];\n\n\teffective = rcu_dereference_protected(cgrp->bpf.effective[atype],\n\t\t\t\t\t      lockdep_is_held(&cgroup_mutex));\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tcnt = bpf_prog_array_length(effective);\n\telse\n\t\tcnt = prog_list_length(progs);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &cnt, sizeof(cnt)))\n\t\treturn -EFAULT;\n\tif (attr->query.prog_cnt == 0 || !prog_ids || !cnt)\n\t\t/* return early if user requested only program count + flags */\n\t\treturn 0;\n\tif (attr->query.prog_cnt < cnt) {\n\t\tcnt = attr->query.prog_cnt;\n\t\tret = -ENOSPC;\n\t}\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\treturn bpf_prog_array_copy_to_user(effective, prog_ids, cnt);\n\t} else {\n\t\tstruct bpf_prog_list *pl;\n\t\tu32 id;\n\n\t\ti = 0;\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tprog = prog_list_prog(pl);\n\t\t\tid = prog->aux->id;\n\t\t\tif (copy_to_user(prog_ids + i, &id, sizeof(id)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (++i == cnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "prog_ids + i",
            "&id",
            "sizeof(id)"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prog_list_prog",
          "args": [
            "pl"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "169-176",
          "snippet": "static struct bpf_prog *prog_list_prog(struct bpf_prog_list *pl)\n{\n\tif (pl->prog)\n\t\treturn pl->prog;\n\tif (pl->link)\n\t\treturn pl->link->link.prog;\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic struct bpf_prog *prog_list_prog(struct bpf_prog_list *pl)\n{\n\tif (pl->prog)\n\t\treturn pl->prog;\n\tif (pl->link)\n\t\treturn pl->link->link.prog;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "progs",
            "node"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prog_list_length",
          "args": [
            "progs"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_length",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "181-192",
          "snippet": "static u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!prog_list_prog(pl))\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!prog_list_prog(pl))\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_length",
          "args": [
            "effective"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_length",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2002-2011",
          "snippet": "int bpf_prog_array_length(struct bpf_prog_array *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\tfor (item = array->items; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\treturn cnt;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nint bpf_prog_array_length(struct bpf_prog_array *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\tfor (item = array->items; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "cgrp->bpf.effective[atype]",
            "lockdep_is_held(&cgroup_mutex)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_cgroup_bpf_attach_type",
          "args": [
            "type"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->query.prog_ids"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int __cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t\t      union bpf_attr __user *uattr)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tenum bpf_attach_type type = attr->query.attach_type;\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog_array *effective;\n\tstruct list_head *progs;\n\tstruct bpf_prog *prog;\n\tint cnt, ret = 0, i;\n\tu32 flags;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\tflags = cgrp->bpf.flags[atype];\n\n\teffective = rcu_dereference_protected(cgrp->bpf.effective[atype],\n\t\t\t\t\t      lockdep_is_held(&cgroup_mutex));\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tcnt = bpf_prog_array_length(effective);\n\telse\n\t\tcnt = prog_list_length(progs);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &cnt, sizeof(cnt)))\n\t\treturn -EFAULT;\n\tif (attr->query.prog_cnt == 0 || !prog_ids || !cnt)\n\t\t/* return early if user requested only program count + flags */\n\t\treturn 0;\n\tif (attr->query.prog_cnt < cnt) {\n\t\tcnt = attr->query.prog_cnt;\n\t\tret = -ENOSPC;\n\t}\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\treturn bpf_prog_array_copy_to_user(effective, prog_ids, cnt);\n\t} else {\n\t\tstruct bpf_prog_list *pl;\n\t\tu32 id;\n\n\t\ti = 0;\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tprog = prog_list_prog(pl);\n\t\t\tid = prog->aux->id;\n\t\t\tif (copy_to_user(prog_ids + i, &id, sizeof(id)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (++i == cnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_bpf_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "747-756",
    "snippet": "static int cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\t     enum bpf_attach_type type)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_detach(cgrp, prog, NULL, type);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cgroup_bpf_detach",
          "args": [
            "cgrp",
            "prog",
            "NULL",
            "type"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "695-745",
          "snippet": "static int __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\t       struct bpf_cgroup_link *link, enum bpf_attach_type type)\n{\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog *old_prog;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tu32 flags;\n\tint err;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\tflags = cgrp->bpf.flags[atype];\n\n\tif (prog && link)\n\t\t/* only one of prog or link can be specified */\n\t\treturn -EINVAL;\n\n\tpl = find_detach_entry(progs, prog, link, flags & BPF_F_ALLOW_MULTI);\n\tif (IS_ERR(pl))\n\t\treturn PTR_ERR(pl);\n\n\t/* mark it deleted, so it's ignored while recomputing effective */\n\told_prog = pl->prog;\n\tpl->prog = NULL;\n\tpl->link = NULL;\n\n\terr = update_effective_progs(cgrp, atype);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[atype] = 0;\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key[atype]);\n\treturn 0;\n\ncleanup:\n\t/* restore back prog or link */\n\tpl->prog = old_prog;\n\tpl->link = link;\n\treturn err;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\t       struct bpf_cgroup_link *link, enum bpf_attach_type type)\n{\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog *old_prog;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tu32 flags;\n\tint err;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\tflags = cgrp->bpf.flags[atype];\n\n\tif (prog && link)\n\t\t/* only one of prog or link can be specified */\n\t\treturn -EINVAL;\n\n\tpl = find_detach_entry(progs, prog, link, flags & BPF_F_ALLOW_MULTI);\n\tif (IS_ERR(pl))\n\t\treturn PTR_ERR(pl);\n\n\t/* mark it deleted, so it's ignored while recomputing effective */\n\told_prog = pl->prog;\n\tpl->prog = NULL;\n\tpl->link = NULL;\n\n\terr = update_effective_progs(cgrp, atype);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[atype] = 0;\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key[atype]);\n\treturn 0;\n\ncleanup:\n\t/* restore back prog or link */\n\tpl->prog = old_prog;\n\tpl->link = link;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\t     enum bpf_attach_type type)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_detach(cgrp, prog, NULL, type);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__cgroup_bpf_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "695-745",
    "snippet": "static int __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\t       struct bpf_cgroup_link *link, enum bpf_attach_type type)\n{\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog *old_prog;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tu32 flags;\n\tint err;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\tflags = cgrp->bpf.flags[atype];\n\n\tif (prog && link)\n\t\t/* only one of prog or link can be specified */\n\t\treturn -EINVAL;\n\n\tpl = find_detach_entry(progs, prog, link, flags & BPF_F_ALLOW_MULTI);\n\tif (IS_ERR(pl))\n\t\treturn PTR_ERR(pl);\n\n\t/* mark it deleted, so it's ignored while recomputing effective */\n\told_prog = pl->prog;\n\tpl->prog = NULL;\n\tpl->link = NULL;\n\n\terr = update_effective_progs(cgrp, atype);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[atype] = 0;\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key[atype]);\n\treturn 0;\n\ncleanup:\n\t/* restore back prog or link */\n\tpl->prog = old_prog;\n\tpl->link = link;\n\treturn err;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_dec",
          "args": [
            "&cgroup_bpf_enabled_key[atype]"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "old_prog"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "progs"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pl"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pl->node"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_effective_progs",
          "args": [
            "cgrp",
            "atype"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "update_effective_progs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "330-378",
          "snippet": "static int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt))\n\t\t\tcontinue;\n\n\t\terr = compute_effective_progs(desc, atype, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt)) {\n\t\t\tif (unlikely(desc->bpf.inactive)) {\n\t\t\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\t\t\tdesc->bpf.inactive = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tactivate_effective_progs(desc, atype, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt))\n\t\t\tcontinue;\n\n\t\terr = compute_effective_progs(desc, atype, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt)) {\n\t\t\tif (unlikely(desc->bpf.inactive)) {\n\t\t\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\t\t\tdesc->bpf.inactive = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tactivate_effective_progs(desc, atype, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pl"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pl"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_detach_entry",
          "args": [
            "progs",
            "prog",
            "link",
            "flags & BPF_F_ALLOW_MULTI"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "find_detach_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "652-682",
          "snippet": "static struct bpf_prog_list *find_detach_entry(struct list_head *progs,\n\t\t\t\t\t       struct bpf_prog *prog,\n\t\t\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t\t\t       bool allow_multi)\n{\n\tstruct bpf_prog_list *pl;\n\n\tif (!allow_multi) {\n\t\tif (list_empty(progs))\n\t\t\t/* report error when trying to detach and nothing is attached */\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\t/* to maintain backward compatibility NONE and OVERRIDE cgroups\n\t\t * allow detaching with invalid FD (prog==NULL) in legacy mode\n\t\t */\n\t\treturn list_first_entry(progs, typeof(*pl), node);\n\t}\n\n\tif (!prog && !link)\n\t\t/* to detach MULTI prog the user has to specify valid FD\n\t\t * of the program or link to be detached\n\t\t */\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* find the prog or link and detach it */\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (pl->prog == prog && pl->link == link)\n\t\t\treturn pl;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic struct bpf_prog_list *find_detach_entry(struct list_head *progs,\n\t\t\t\t\t       struct bpf_prog *prog,\n\t\t\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t\t\t       bool allow_multi)\n{\n\tstruct bpf_prog_list *pl;\n\n\tif (!allow_multi) {\n\t\tif (list_empty(progs))\n\t\t\t/* report error when trying to detach and nothing is attached */\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\t/* to maintain backward compatibility NONE and OVERRIDE cgroups\n\t\t * allow detaching with invalid FD (prog==NULL) in legacy mode\n\t\t */\n\t\treturn list_first_entry(progs, typeof(*pl), node);\n\t}\n\n\tif (!prog && !link)\n\t\t/* to detach MULTI prog the user has to specify valid FD\n\t\t * of the program or link to be detached\n\t\t */\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* find the prog or link and detach it */\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (pl->prog == prog && pl->link == link)\n\t\t\treturn pl;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_cgroup_bpf_attach_type",
          "args": [
            "type"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\t       struct bpf_cgroup_link *link, enum bpf_attach_type type)\n{\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog *old_prog;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tu32 flags;\n\tint err;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\tflags = cgrp->bpf.flags[atype];\n\n\tif (prog && link)\n\t\t/* only one of prog or link can be specified */\n\t\treturn -EINVAL;\n\n\tpl = find_detach_entry(progs, prog, link, flags & BPF_F_ALLOW_MULTI);\n\tif (IS_ERR(pl))\n\t\treturn PTR_ERR(pl);\n\n\t/* mark it deleted, so it's ignored while recomputing effective */\n\told_prog = pl->prog;\n\tpl->prog = NULL;\n\tpl->link = NULL;\n\n\terr = update_effective_progs(cgrp, atype);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[atype] = 0;\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key[atype]);\n\treturn 0;\n\ncleanup:\n\t/* restore back prog or link */\n\tpl->prog = old_prog;\n\tpl->link = link;\n\treturn err;\n}"
  },
  {
    "function_name": "find_detach_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "652-682",
    "snippet": "static struct bpf_prog_list *find_detach_entry(struct list_head *progs,\n\t\t\t\t\t       struct bpf_prog *prog,\n\t\t\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t\t\t       bool allow_multi)\n{\n\tstruct bpf_prog_list *pl;\n\n\tif (!allow_multi) {\n\t\tif (list_empty(progs))\n\t\t\t/* report error when trying to detach and nothing is attached */\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\t/* to maintain backward compatibility NONE and OVERRIDE cgroups\n\t\t * allow detaching with invalid FD (prog==NULL) in legacy mode\n\t\t */\n\t\treturn list_first_entry(progs, typeof(*pl), node);\n\t}\n\n\tif (!prog && !link)\n\t\t/* to detach MULTI prog the user has to specify valid FD\n\t\t * of the program or link to be detached\n\t\t */\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* find the prog or link and detach it */\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (pl->prog == prog && pl->link == link)\n\t\t\treturn pl;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "progs",
            "node"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "progs",
            "typeof(*pl)",
            "node"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*pl"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "progs"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic struct bpf_prog_list *find_detach_entry(struct list_head *progs,\n\t\t\t\t\t       struct bpf_prog *prog,\n\t\t\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t\t\t       bool allow_multi)\n{\n\tstruct bpf_prog_list *pl;\n\n\tif (!allow_multi) {\n\t\tif (list_empty(progs))\n\t\t\t/* report error when trying to detach and nothing is attached */\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\t/* to maintain backward compatibility NONE and OVERRIDE cgroups\n\t\t * allow detaching with invalid FD (prog==NULL) in legacy mode\n\t\t */\n\t\treturn list_first_entry(progs, typeof(*pl), node);\n\t}\n\n\tif (!prog && !link)\n\t\t/* to detach MULTI prog the user has to specify valid FD\n\t\t * of the program or link to be detached\n\t\t */\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* find the prog or link and detach it */\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (pl->prog == prog && pl->link == link)\n\t\t\treturn pl;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}"
  },
  {
    "function_name": "cgroup_bpf_replace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "628-650",
    "snippet": "static int cgroup_bpf_replace(struct bpf_link *link, struct bpf_prog *new_prog,\n\t\t\t      struct bpf_prog *old_prog)\n{\n\tstruct bpf_cgroup_link *cg_link;\n\tint ret;\n\n\tcg_link = container_of(link, struct bpf_cgroup_link, link);\n\n\tmutex_lock(&cgroup_mutex);\n\t/* link might have been auto-released by dying cgroup, so fail */\n\tif (!cg_link->cgroup) {\n\t\tret = -ENOLINK;\n\t\tgoto out_unlock;\n\t}\n\tif (old_prog && link->prog != old_prog) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = __cgroup_bpf_replace(cg_link->cgroup, cg_link, new_prog);\nout_unlock:\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cgroup_bpf_replace",
          "args": [
            "cg_link->cgroup",
            "cg_link",
            "new_prog"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_replace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "594-626",
          "snippet": "static int __cgroup_bpf_replace(struct cgroup *cgrp,\n\t\t\t\tstruct bpf_cgroup_link *link,\n\t\t\t\tstruct bpf_prog *new_prog)\n{\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog *old_prog;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tbool found = false;\n\n\tatype = to_cgroup_bpf_attach_type(link->type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\n\tif (link->link.prog->type != new_prog->type)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (pl->link == link) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -ENOENT;\n\n\told_prog = xchg(&link->link.prog, new_prog);\n\treplace_effective_prog(cgrp, atype, link);\n\tbpf_prog_put(old_prog);\n\treturn 0;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int __cgroup_bpf_replace(struct cgroup *cgrp,\n\t\t\t\tstruct bpf_cgroup_link *link,\n\t\t\t\tstruct bpf_prog *new_prog)\n{\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog *old_prog;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tbool found = false;\n\n\tatype = to_cgroup_bpf_attach_type(link->type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\n\tif (link->link.prog->type != new_prog->type)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (pl->link == link) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -ENOENT;\n\n\told_prog = xchg(&link->link.prog, new_prog);\n\treplace_effective_prog(cgrp, atype, link);\n\tbpf_prog_put(old_prog);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_cgroup_link",
            "link"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int cgroup_bpf_replace(struct bpf_link *link, struct bpf_prog *new_prog,\n\t\t\t      struct bpf_prog *old_prog)\n{\n\tstruct bpf_cgroup_link *cg_link;\n\tint ret;\n\n\tcg_link = container_of(link, struct bpf_cgroup_link, link);\n\n\tmutex_lock(&cgroup_mutex);\n\t/* link might have been auto-released by dying cgroup, so fail */\n\tif (!cg_link->cgroup) {\n\t\tret = -ENOLINK;\n\t\tgoto out_unlock;\n\t}\n\tif (old_prog && link->prog != old_prog) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = __cgroup_bpf_replace(cg_link->cgroup, cg_link, new_prog);\nout_unlock:\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__cgroup_bpf_replace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "594-626",
    "snippet": "static int __cgroup_bpf_replace(struct cgroup *cgrp,\n\t\t\t\tstruct bpf_cgroup_link *link,\n\t\t\t\tstruct bpf_prog *new_prog)\n{\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog *old_prog;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tbool found = false;\n\n\tatype = to_cgroup_bpf_attach_type(link->type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\n\tif (link->link.prog->type != new_prog->type)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (pl->link == link) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -ENOENT;\n\n\told_prog = xchg(&link->link.prog, new_prog);\n\treplace_effective_prog(cgrp, atype, link);\n\tbpf_prog_put(old_prog);\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "old_prog"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_effective_prog",
          "args": [
            "cgrp",
            "atype",
            "link"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "replace_effective_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "543-583",
          "snippet": "static void replace_effective_prog(struct cgroup *cgrp,\n\t\t\t\t   enum cgroup_bpf_attach_type atype,\n\t\t\t\t   struct bpf_cgroup_link *link)\n{\n\tstruct bpf_prog_array_item *item;\n\tstruct cgroup_subsys_state *css;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *head;\n\tstruct cgroup *cg;\n\tint pos;\n\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt))\n\t\t\tcontinue;\n\n\t\t/* find position of link in effective progs array */\n\t\tfor (pos = 0, cg = desc; cg; cg = cgroup_parent(cg)) {\n\t\t\tif (pos && !(cg->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\t\tcontinue;\n\n\t\t\thead = &cg->bpf.progs[atype];\n\t\t\tlist_for_each_entry(pl, head, node) {\n\t\t\t\tif (!prog_list_prog(pl))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (pl->link == link)\n\t\t\t\t\tgoto found;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\nfound:\n\t\tBUG_ON(!cg);\n\t\tprogs = rcu_dereference_protected(\n\t\t\t\tdesc->bpf.effective[atype],\n\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t\titem = &progs->items[pos];\n\t\tWRITE_ONCE(item->prog, link->link.prog);\n\t}\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void replace_effective_prog(struct cgroup *cgrp,\n\t\t\t\t   enum cgroup_bpf_attach_type atype,\n\t\t\t\t   struct bpf_cgroup_link *link)\n{\n\tstruct bpf_prog_array_item *item;\n\tstruct cgroup_subsys_state *css;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *head;\n\tstruct cgroup *cg;\n\tint pos;\n\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt))\n\t\t\tcontinue;\n\n\t\t/* find position of link in effective progs array */\n\t\tfor (pos = 0, cg = desc; cg; cg = cgroup_parent(cg)) {\n\t\t\tif (pos && !(cg->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\t\tcontinue;\n\n\t\t\thead = &cg->bpf.progs[atype];\n\t\t\tlist_for_each_entry(pl, head, node) {\n\t\t\t\tif (!prog_list_prog(pl))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (pl->link == link)\n\t\t\t\t\tgoto found;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\nfound:\n\t\tBUG_ON(!cg);\n\t\tprogs = rcu_dereference_protected(\n\t\t\t\tdesc->bpf.effective[atype],\n\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t\titem = &progs->items[pos];\n\t\tWRITE_ONCE(item->prog, link->link.prog);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&link->link.prog",
            "new_prog"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "progs",
            "node"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cgroup_bpf_attach_type",
          "args": [
            "link->type"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int __cgroup_bpf_replace(struct cgroup *cgrp,\n\t\t\t\tstruct bpf_cgroup_link *link,\n\t\t\t\tstruct bpf_prog *new_prog)\n{\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog *old_prog;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tbool found = false;\n\n\tatype = to_cgroup_bpf_attach_type(link->type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\n\tif (link->link.prog->type != new_prog->type)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (pl->link == link) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -ENOENT;\n\n\told_prog = xchg(&link->link.prog, new_prog);\n\treplace_effective_prog(cgrp, atype, link);\n\tbpf_prog_put(old_prog);\n\treturn 0;\n}"
  },
  {
    "function_name": "replace_effective_prog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "543-583",
    "snippet": "static void replace_effective_prog(struct cgroup *cgrp,\n\t\t\t\t   enum cgroup_bpf_attach_type atype,\n\t\t\t\t   struct bpf_cgroup_link *link)\n{\n\tstruct bpf_prog_array_item *item;\n\tstruct cgroup_subsys_state *css;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *head;\n\tstruct cgroup *cg;\n\tint pos;\n\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt))\n\t\t\tcontinue;\n\n\t\t/* find position of link in effective progs array */\n\t\tfor (pos = 0, cg = desc; cg; cg = cgroup_parent(cg)) {\n\t\t\tif (pos && !(cg->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\t\tcontinue;\n\n\t\t\thead = &cg->bpf.progs[atype];\n\t\t\tlist_for_each_entry(pl, head, node) {\n\t\t\t\tif (!prog_list_prog(pl))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (pl->link == link)\n\t\t\t\t\tgoto found;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\nfound:\n\t\tBUG_ON(!cg);\n\t\tprogs = rcu_dereference_protected(\n\t\t\t\tdesc->bpf.effective[atype],\n\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t\titem = &progs->items[pos];\n\t\tWRITE_ONCE(item->prog, link->link.prog);\n\t}\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "item->prog",
            "link->link.prog"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "desc->bpf.effective[atype]",
            "lockdep_is_held(&cgroup_mutex)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cg"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prog_list_prog",
          "args": [
            "pl"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "169-176",
          "snippet": "static struct bpf_prog *prog_list_prog(struct bpf_prog_list *pl)\n{\n\tif (pl->prog)\n\t\treturn pl->prog;\n\tif (pl->link)\n\t\treturn pl->link->link.prog;\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic struct bpf_prog *prog_list_prog(struct bpf_prog_list *pl)\n{\n\tif (pl->prog)\n\t\treturn pl->prog;\n\tif (pl->link)\n\t\treturn pl->link->link.prog;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "head",
            "node"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cg"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_is_zero",
          "args": [
            "&desc->bpf.refcnt"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structcgroup",
            "self"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "&cgrp->self"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void replace_effective_prog(struct cgroup *cgrp,\n\t\t\t\t   enum cgroup_bpf_attach_type atype,\n\t\t\t\t   struct bpf_cgroup_link *link)\n{\n\tstruct bpf_prog_array_item *item;\n\tstruct cgroup_subsys_state *css;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *head;\n\tstruct cgroup *cg;\n\tint pos;\n\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt))\n\t\t\tcontinue;\n\n\t\t/* find position of link in effective progs array */\n\t\tfor (pos = 0, cg = desc; cg; cg = cgroup_parent(cg)) {\n\t\t\tif (pos && !(cg->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\t\tcontinue;\n\n\t\t\thead = &cg->bpf.progs[atype];\n\t\t\tlist_for_each_entry(pl, head, node) {\n\t\t\t\tif (!prog_list_prog(pl))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (pl->link == link)\n\t\t\t\t\tgoto found;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\nfound:\n\t\tBUG_ON(!cg);\n\t\tprogs = rcu_dereference_protected(\n\t\t\t\tdesc->bpf.effective[atype],\n\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t\titem = &progs->items[pos];\n\t\tWRITE_ONCE(item->prog, link->link.prog);\n\t}\n}"
  },
  {
    "function_name": "cgroup_bpf_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "526-538",
    "snippet": "static int cgroup_bpf_attach(struct cgroup *cgrp,\n\t\t\t     struct bpf_prog *prog, struct bpf_prog *replace_prog,\n\t\t\t     struct bpf_cgroup_link *link,\n\t\t\t     enum bpf_attach_type type,\n\t\t\t     u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_attach(cgrp, prog, replace_prog, link, type, flags);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cgroup_bpf_attach",
          "args": [
            "cgrp",
            "prog",
            "replace_prog",
            "link",
            "type",
            "flags"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "433-524",
          "snippet": "static int __cgroup_bpf_attach(struct cgroup *cgrp,\n\t\t\t       struct bpf_prog *prog, struct bpf_prog *replace_prog,\n\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t       enum bpf_attach_type type, u32 flags)\n{\n\tu32 saved_flags = (flags & (BPF_F_ALLOW_OVERRIDE | BPF_F_ALLOW_MULTI));\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_cgroup_storage *storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {};\n\tstruct bpf_cgroup_storage *new_storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {};\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tint err;\n\n\tif (((flags & BPF_F_ALLOW_OVERRIDE) && (flags & BPF_F_ALLOW_MULTI)) ||\n\t    ((flags & BPF_F_REPLACE) && !(flags & BPF_F_ALLOW_MULTI)))\n\t\t/* invalid combination */\n\t\treturn -EINVAL;\n\tif (link && (prog || replace_prog))\n\t\t/* only either link or prog/replace_prog can be specified */\n\t\treturn -EINVAL;\n\tif (!!replace_prog != !!(flags & BPF_F_REPLACE))\n\t\t/* replace_prog implies BPF_F_REPLACE, and vice versa */\n\t\treturn -EINVAL;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\n\tif (!hierarchy_allows_attach(cgrp, atype))\n\t\treturn -EPERM;\n\n\tif (!list_empty(progs) && cgrp->bpf.flags[atype] != saved_flags)\n\t\t/* Disallow attaching non-overridable on top\n\t\t * of existing overridable in this cgroup.\n\t\t * Disallow attaching multi-prog if overridable or none\n\t\t */\n\t\treturn -EPERM;\n\n\tif (prog_list_length(progs) >= BPF_CGROUP_MAX_PROGS)\n\t\treturn -E2BIG;\n\n\tpl = find_attach_entry(progs, prog, link, replace_prog,\n\t\t\t       flags & BPF_F_ALLOW_MULTI);\n\tif (IS_ERR(pl))\n\t\treturn PTR_ERR(pl);\n\n\tif (bpf_cgroup_storages_alloc(storage, new_storage, type,\n\t\t\t\t      prog ? : link->link.prog, cgrp))\n\t\treturn -ENOMEM;\n\n\tif (pl) {\n\t\told_prog = pl->prog;\n\t} else {\n\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\tif (!pl) {\n\t\t\tbpf_cgroup_storages_free(new_storage);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add_tail(&pl->node, progs);\n\t}\n\n\tpl->prog = prog;\n\tpl->link = link;\n\tbpf_cgroup_storages_assign(pl->storage, storage);\n\tcgrp->bpf.flags[atype] = saved_flags;\n\n\terr = update_effective_progs(cgrp, atype);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\telse\n\t\tstatic_branch_inc(&cgroup_bpf_enabled_key[atype]);\n\tbpf_cgroup_storages_link(new_storage, cgrp, type);\n\treturn 0;\n\ncleanup:\n\tif (old_prog) {\n\t\tpl->prog = old_prog;\n\t\tpl->link = NULL;\n\t}\n\tbpf_cgroup_storages_free(new_storage);\n\tif (!old_prog) {\n\t\tlist_del(&pl->node);\n\t\tkfree(pl);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BPF_CGROUP_MAX_PROGS 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\n#define BPF_CGROUP_MAX_PROGS 64\n\nstatic int __cgroup_bpf_attach(struct cgroup *cgrp,\n\t\t\t       struct bpf_prog *prog, struct bpf_prog *replace_prog,\n\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t       enum bpf_attach_type type, u32 flags)\n{\n\tu32 saved_flags = (flags & (BPF_F_ALLOW_OVERRIDE | BPF_F_ALLOW_MULTI));\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_cgroup_storage *storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {};\n\tstruct bpf_cgroup_storage *new_storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {};\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tint err;\n\n\tif (((flags & BPF_F_ALLOW_OVERRIDE) && (flags & BPF_F_ALLOW_MULTI)) ||\n\t    ((flags & BPF_F_REPLACE) && !(flags & BPF_F_ALLOW_MULTI)))\n\t\t/* invalid combination */\n\t\treturn -EINVAL;\n\tif (link && (prog || replace_prog))\n\t\t/* only either link or prog/replace_prog can be specified */\n\t\treturn -EINVAL;\n\tif (!!replace_prog != !!(flags & BPF_F_REPLACE))\n\t\t/* replace_prog implies BPF_F_REPLACE, and vice versa */\n\t\treturn -EINVAL;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\n\tif (!hierarchy_allows_attach(cgrp, atype))\n\t\treturn -EPERM;\n\n\tif (!list_empty(progs) && cgrp->bpf.flags[atype] != saved_flags)\n\t\t/* Disallow attaching non-overridable on top\n\t\t * of existing overridable in this cgroup.\n\t\t * Disallow attaching multi-prog if overridable or none\n\t\t */\n\t\treturn -EPERM;\n\n\tif (prog_list_length(progs) >= BPF_CGROUP_MAX_PROGS)\n\t\treturn -E2BIG;\n\n\tpl = find_attach_entry(progs, prog, link, replace_prog,\n\t\t\t       flags & BPF_F_ALLOW_MULTI);\n\tif (IS_ERR(pl))\n\t\treturn PTR_ERR(pl);\n\n\tif (bpf_cgroup_storages_alloc(storage, new_storage, type,\n\t\t\t\t      prog ? : link->link.prog, cgrp))\n\t\treturn -ENOMEM;\n\n\tif (pl) {\n\t\told_prog = pl->prog;\n\t} else {\n\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\tif (!pl) {\n\t\t\tbpf_cgroup_storages_free(new_storage);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add_tail(&pl->node, progs);\n\t}\n\n\tpl->prog = prog;\n\tpl->link = link;\n\tbpf_cgroup_storages_assign(pl->storage, storage);\n\tcgrp->bpf.flags[atype] = saved_flags;\n\n\terr = update_effective_progs(cgrp, atype);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\telse\n\t\tstatic_branch_inc(&cgroup_bpf_enabled_key[atype]);\n\tbpf_cgroup_storages_link(new_storage, cgrp, type);\n\treturn 0;\n\ncleanup:\n\tif (old_prog) {\n\t\tpl->prog = old_prog;\n\t\tpl->link = NULL;\n\t}\n\tbpf_cgroup_storages_free(new_storage);\n\tif (!old_prog) {\n\t\tlist_del(&pl->node);\n\t\tkfree(pl);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int cgroup_bpf_attach(struct cgroup *cgrp,\n\t\t\t     struct bpf_prog *prog, struct bpf_prog *replace_prog,\n\t\t\t     struct bpf_cgroup_link *link,\n\t\t\t     enum bpf_attach_type type,\n\t\t\t     u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_attach(cgrp, prog, replace_prog, link, type, flags);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__cgroup_bpf_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "433-524",
    "snippet": "static int __cgroup_bpf_attach(struct cgroup *cgrp,\n\t\t\t       struct bpf_prog *prog, struct bpf_prog *replace_prog,\n\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t       enum bpf_attach_type type, u32 flags)\n{\n\tu32 saved_flags = (flags & (BPF_F_ALLOW_OVERRIDE | BPF_F_ALLOW_MULTI));\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_cgroup_storage *storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {};\n\tstruct bpf_cgroup_storage *new_storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {};\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tint err;\n\n\tif (((flags & BPF_F_ALLOW_OVERRIDE) && (flags & BPF_F_ALLOW_MULTI)) ||\n\t    ((flags & BPF_F_REPLACE) && !(flags & BPF_F_ALLOW_MULTI)))\n\t\t/* invalid combination */\n\t\treturn -EINVAL;\n\tif (link && (prog || replace_prog))\n\t\t/* only either link or prog/replace_prog can be specified */\n\t\treturn -EINVAL;\n\tif (!!replace_prog != !!(flags & BPF_F_REPLACE))\n\t\t/* replace_prog implies BPF_F_REPLACE, and vice versa */\n\t\treturn -EINVAL;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\n\tif (!hierarchy_allows_attach(cgrp, atype))\n\t\treturn -EPERM;\n\n\tif (!list_empty(progs) && cgrp->bpf.flags[atype] != saved_flags)\n\t\t/* Disallow attaching non-overridable on top\n\t\t * of existing overridable in this cgroup.\n\t\t * Disallow attaching multi-prog if overridable or none\n\t\t */\n\t\treturn -EPERM;\n\n\tif (prog_list_length(progs) >= BPF_CGROUP_MAX_PROGS)\n\t\treturn -E2BIG;\n\n\tpl = find_attach_entry(progs, prog, link, replace_prog,\n\t\t\t       flags & BPF_F_ALLOW_MULTI);\n\tif (IS_ERR(pl))\n\t\treturn PTR_ERR(pl);\n\n\tif (bpf_cgroup_storages_alloc(storage, new_storage, type,\n\t\t\t\t      prog ? : link->link.prog, cgrp))\n\t\treturn -ENOMEM;\n\n\tif (pl) {\n\t\told_prog = pl->prog;\n\t} else {\n\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\tif (!pl) {\n\t\t\tbpf_cgroup_storages_free(new_storage);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add_tail(&pl->node, progs);\n\t}\n\n\tpl->prog = prog;\n\tpl->link = link;\n\tbpf_cgroup_storages_assign(pl->storage, storage);\n\tcgrp->bpf.flags[atype] = saved_flags;\n\n\terr = update_effective_progs(cgrp, atype);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\telse\n\t\tstatic_branch_inc(&cgroup_bpf_enabled_key[atype]);\n\tbpf_cgroup_storages_link(new_storage, cgrp, type);\n\treturn 0;\n\ncleanup:\n\tif (old_prog) {\n\t\tpl->prog = old_prog;\n\t\tpl->link = NULL;\n\t}\n\tbpf_cgroup_storages_free(new_storage);\n\tif (!old_prog) {\n\t\tlist_del(&pl->node);\n\t\tkfree(pl);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BPF_CGROUP_MAX_PROGS 64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pl"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pl->node"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storages_free",
          "args": [
            "new_storage"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storages_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "31-37",
          "snippet": "static void bpf_cgroup_storages_free(struct bpf_cgroup_storage *storages[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_free(storages[stype]);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_storages_free(struct bpf_cgroup_storage *storages[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_free(storages[stype]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storages_link",
          "args": [
            "new_storage",
            "cgrp",
            "type"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storages_link",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "82-90",
          "snippet": "static void bpf_cgroup_storages_link(struct bpf_cgroup_storage *storages[],\n\t\t\t\t     struct cgroup *cgrp,\n\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_link(storages[stype], cgrp, attach_type);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_storages_link(struct bpf_cgroup_storage *storages[],\n\t\t\t\t     struct cgroup *cgrp,\n\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_link(storages[stype], cgrp, attach_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&cgroup_bpf_enabled_key[atype]"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "old_prog"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_effective_progs",
          "args": [
            "cgrp",
            "atype"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "update_effective_progs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "330-378",
          "snippet": "static int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt))\n\t\t\tcontinue;\n\n\t\terr = compute_effective_progs(desc, atype, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt)) {\n\t\t\tif (unlikely(desc->bpf.inactive)) {\n\t\t\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\t\t\tdesc->bpf.inactive = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tactivate_effective_progs(desc, atype, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt))\n\t\t\tcontinue;\n\n\t\terr = compute_effective_progs(desc, atype, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt)) {\n\t\t\tif (unlikely(desc->bpf.inactive)) {\n\t\t\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\t\t\tdesc->bpf.inactive = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tactivate_effective_progs(desc, atype, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storages_assign",
          "args": [
            "pl->storage",
            "storage"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storages_assign",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "73-80",
          "snippet": "static void bpf_cgroup_storages_assign(struct bpf_cgroup_storage *dst[],\n\t\t\t\t       struct bpf_cgroup_storage *src[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tdst[stype] = src[stype];\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_storages_assign(struct bpf_cgroup_storage *dst[],\n\t\t\t\t       struct bpf_cgroup_storage *src[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tdst[stype] = src[stype];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pl->node",
            "progs"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*pl)",
            "GFP_KERNEL"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storages_alloc",
          "args": [
            "storage",
            "new_storage",
            "type",
            "prog ? : link->link.prog",
            "cgrp"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storages_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "39-71",
          "snippet": "static int bpf_cgroup_storages_alloc(struct bpf_cgroup_storage *storages[],\n\t\t\t\t     struct bpf_cgroup_storage *new_storages[],\n\t\t\t\t     enum bpf_attach_type type,\n\t\t\t\t     struct bpf_prog *prog,\n\t\t\t\t     struct cgroup *cgrp)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_cgroup_storage_key key;\n\tstruct bpf_map *map;\n\n\tkey.cgroup_inode_id = cgroup_id(cgrp);\n\tkey.attach_type = type;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tmap = prog->aux->cgroup_storage[stype];\n\t\tif (!map)\n\t\t\tcontinue;\n\n\t\tstorages[stype] = cgroup_storage_lookup((void *)map, &key, false);\n\t\tif (storages[stype])\n\t\t\tcontinue;\n\n\t\tstorages[stype] = bpf_cgroup_storage_alloc(prog, stype);\n\t\tif (IS_ERR(storages[stype])) {\n\t\t\tbpf_cgroup_storages_free(new_storages);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnew_storages[stype] = storages[stype];\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int bpf_cgroup_storages_alloc(struct bpf_cgroup_storage *storages[],\n\t\t\t\t     struct bpf_cgroup_storage *new_storages[],\n\t\t\t\t     enum bpf_attach_type type,\n\t\t\t\t     struct bpf_prog *prog,\n\t\t\t\t     struct cgroup *cgrp)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_cgroup_storage_key key;\n\tstruct bpf_map *map;\n\n\tkey.cgroup_inode_id = cgroup_id(cgrp);\n\tkey.attach_type = type;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tmap = prog->aux->cgroup_storage[stype];\n\t\tif (!map)\n\t\t\tcontinue;\n\n\t\tstorages[stype] = cgroup_storage_lookup((void *)map, &key, false);\n\t\tif (storages[stype])\n\t\t\tcontinue;\n\n\t\tstorages[stype] = bpf_cgroup_storage_alloc(prog, stype);\n\t\tif (IS_ERR(storages[stype])) {\n\t\t\tbpf_cgroup_storages_free(new_storages);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnew_storages[stype] = storages[stype];\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pl"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pl"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_attach_entry",
          "args": [
            "progs",
            "prog",
            "link",
            "replace_prog",
            "flags & BPF_F_ALLOW_MULTI"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "find_attach_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "382-418",
          "snippet": "static struct bpf_prog_list *find_attach_entry(struct list_head *progs,\n\t\t\t\t\t       struct bpf_prog *prog,\n\t\t\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t\t\t       struct bpf_prog *replace_prog,\n\t\t\t\t\t       bool allow_multi)\n{\n\tstruct bpf_prog_list *pl;\n\n\t/* single-attach case */\n\tif (!allow_multi) {\n\t\tif (list_empty(progs))\n\t\t\treturn NULL;\n\t\treturn list_first_entry(progs, typeof(*pl), node);\n\t}\n\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (prog && pl->prog == prog && prog != replace_prog)\n\t\t\t/* disallow attaching the same prog twice */\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tif (link && pl->link == link)\n\t\t\t/* disallow attaching the same link twice */\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* direct prog multi-attach w/ replacement case */\n\tif (replace_prog) {\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog == replace_prog)\n\t\t\t\t/* a match found */\n\t\t\t\treturn pl;\n\t\t}\n\t\t/* prog to replace not found for cgroup */\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic struct bpf_prog_list *find_attach_entry(struct list_head *progs,\n\t\t\t\t\t       struct bpf_prog *prog,\n\t\t\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t\t\t       struct bpf_prog *replace_prog,\n\t\t\t\t\t       bool allow_multi)\n{\n\tstruct bpf_prog_list *pl;\n\n\t/* single-attach case */\n\tif (!allow_multi) {\n\t\tif (list_empty(progs))\n\t\t\treturn NULL;\n\t\treturn list_first_entry(progs, typeof(*pl), node);\n\t}\n\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (prog && pl->prog == prog && prog != replace_prog)\n\t\t\t/* disallow attaching the same prog twice */\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tif (link && pl->link == link)\n\t\t\t/* disallow attaching the same link twice */\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* direct prog multi-attach w/ replacement case */\n\tif (replace_prog) {\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog == replace_prog)\n\t\t\t\t/* a match found */\n\t\t\t\treturn pl;\n\t\t}\n\t\t/* prog to replace not found for cgroup */\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prog_list_length",
          "args": [
            "progs"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_length",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "181-192",
          "snippet": "static u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!prog_list_prog(pl))\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!prog_list_prog(pl))\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "progs"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hierarchy_allows_attach",
          "args": [
            "cgrp",
            "atype"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "hierarchy_allows_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "198-219",
          "snippet": "static bool hierarchy_allows_attach(struct cgroup *cgrp,\n\t\t\t\t    enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup *p;\n\n\tp = cgroup_parent(cgrp);\n\tif (!p)\n\t\treturn true;\n\tdo {\n\t\tu32 flags = p->bpf.flags[atype];\n\t\tu32 cnt;\n\n\t\tif (flags & BPF_F_ALLOW_MULTI)\n\t\t\treturn true;\n\t\tcnt = prog_list_length(&p->bpf.progs[atype]);\n\t\tWARN_ON_ONCE(cnt > 1);\n\t\tif (cnt == 1)\n\t\t\treturn !!(flags & BPF_F_ALLOW_OVERRIDE);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\treturn true;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool hierarchy_allows_attach(struct cgroup *cgrp,\n\t\t\t\t    enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup *p;\n\n\tp = cgroup_parent(cgrp);\n\tif (!p)\n\t\treturn true;\n\tdo {\n\t\tu32 flags = p->bpf.flags[atype];\n\t\tu32 cnt;\n\n\t\tif (flags & BPF_F_ALLOW_MULTI)\n\t\t\treturn true;\n\t\tcnt = prog_list_length(&p->bpf.progs[atype]);\n\t\tWARN_ON_ONCE(cnt > 1);\n\t\tif (cnt == 1)\n\t\t\treturn !!(flags & BPF_F_ALLOW_OVERRIDE);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_cgroup_bpf_attach_type",
          "args": [
            "type"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\n#define BPF_CGROUP_MAX_PROGS 64\n\nstatic int __cgroup_bpf_attach(struct cgroup *cgrp,\n\t\t\t       struct bpf_prog *prog, struct bpf_prog *replace_prog,\n\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t       enum bpf_attach_type type, u32 flags)\n{\n\tu32 saved_flags = (flags & (BPF_F_ALLOW_OVERRIDE | BPF_F_ALLOW_MULTI));\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_cgroup_storage *storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {};\n\tstruct bpf_cgroup_storage *new_storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {};\n\tenum cgroup_bpf_attach_type atype;\n\tstruct bpf_prog_list *pl;\n\tstruct list_head *progs;\n\tint err;\n\n\tif (((flags & BPF_F_ALLOW_OVERRIDE) && (flags & BPF_F_ALLOW_MULTI)) ||\n\t    ((flags & BPF_F_REPLACE) && !(flags & BPF_F_ALLOW_MULTI)))\n\t\t/* invalid combination */\n\t\treturn -EINVAL;\n\tif (link && (prog || replace_prog))\n\t\t/* only either link or prog/replace_prog can be specified */\n\t\treturn -EINVAL;\n\tif (!!replace_prog != !!(flags & BPF_F_REPLACE))\n\t\t/* replace_prog implies BPF_F_REPLACE, and vice versa */\n\t\treturn -EINVAL;\n\n\tatype = to_cgroup_bpf_attach_type(type);\n\tif (atype < 0)\n\t\treturn -EINVAL;\n\n\tprogs = &cgrp->bpf.progs[atype];\n\n\tif (!hierarchy_allows_attach(cgrp, atype))\n\t\treturn -EPERM;\n\n\tif (!list_empty(progs) && cgrp->bpf.flags[atype] != saved_flags)\n\t\t/* Disallow attaching non-overridable on top\n\t\t * of existing overridable in this cgroup.\n\t\t * Disallow attaching multi-prog if overridable or none\n\t\t */\n\t\treturn -EPERM;\n\n\tif (prog_list_length(progs) >= BPF_CGROUP_MAX_PROGS)\n\t\treturn -E2BIG;\n\n\tpl = find_attach_entry(progs, prog, link, replace_prog,\n\t\t\t       flags & BPF_F_ALLOW_MULTI);\n\tif (IS_ERR(pl))\n\t\treturn PTR_ERR(pl);\n\n\tif (bpf_cgroup_storages_alloc(storage, new_storage, type,\n\t\t\t\t      prog ? : link->link.prog, cgrp))\n\t\treturn -ENOMEM;\n\n\tif (pl) {\n\t\told_prog = pl->prog;\n\t} else {\n\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\tif (!pl) {\n\t\t\tbpf_cgroup_storages_free(new_storage);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add_tail(&pl->node, progs);\n\t}\n\n\tpl->prog = prog;\n\tpl->link = link;\n\tbpf_cgroup_storages_assign(pl->storage, storage);\n\tcgrp->bpf.flags[atype] = saved_flags;\n\n\terr = update_effective_progs(cgrp, atype);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\telse\n\t\tstatic_branch_inc(&cgroup_bpf_enabled_key[atype]);\n\tbpf_cgroup_storages_link(new_storage, cgrp, type);\n\treturn 0;\n\ncleanup:\n\tif (old_prog) {\n\t\tpl->prog = old_prog;\n\t\tpl->link = NULL;\n\t}\n\tbpf_cgroup_storages_free(new_storage);\n\tif (!old_prog) {\n\t\tlist_del(&pl->node);\n\t\tkfree(pl);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "find_attach_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "382-418",
    "snippet": "static struct bpf_prog_list *find_attach_entry(struct list_head *progs,\n\t\t\t\t\t       struct bpf_prog *prog,\n\t\t\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t\t\t       struct bpf_prog *replace_prog,\n\t\t\t\t\t       bool allow_multi)\n{\n\tstruct bpf_prog_list *pl;\n\n\t/* single-attach case */\n\tif (!allow_multi) {\n\t\tif (list_empty(progs))\n\t\t\treturn NULL;\n\t\treturn list_first_entry(progs, typeof(*pl), node);\n\t}\n\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (prog && pl->prog == prog && prog != replace_prog)\n\t\t\t/* disallow attaching the same prog twice */\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tif (link && pl->link == link)\n\t\t\t/* disallow attaching the same link twice */\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* direct prog multi-attach w/ replacement case */\n\tif (replace_prog) {\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog == replace_prog)\n\t\t\t\t/* a match found */\n\t\t\t\treturn pl;\n\t\t}\n\t\t/* prog to replace not found for cgroup */\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "progs",
            "node"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "progs",
            "node"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "progs",
            "typeof(*pl)",
            "node"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*pl"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "progs"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic struct bpf_prog_list *find_attach_entry(struct list_head *progs,\n\t\t\t\t\t       struct bpf_prog *prog,\n\t\t\t\t\t       struct bpf_cgroup_link *link,\n\t\t\t\t\t       struct bpf_prog *replace_prog,\n\t\t\t\t\t       bool allow_multi)\n{\n\tstruct bpf_prog_list *pl;\n\n\t/* single-attach case */\n\tif (!allow_multi) {\n\t\tif (list_empty(progs))\n\t\t\treturn NULL;\n\t\treturn list_first_entry(progs, typeof(*pl), node);\n\t}\n\n\tlist_for_each_entry(pl, progs, node) {\n\t\tif (prog && pl->prog == prog && prog != replace_prog)\n\t\t\t/* disallow attaching the same prog twice */\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tif (link && pl->link == link)\n\t\t\t/* disallow attaching the same link twice */\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* direct prog multi-attach w/ replacement case */\n\tif (replace_prog) {\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog == replace_prog)\n\t\t\t\t/* a match found */\n\t\t\t\treturn pl;\n\t\t}\n\t\t/* prog to replace not found for cgroup */\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "update_effective_progs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "330-378",
    "snippet": "static int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt))\n\t\t\tcontinue;\n\n\t\terr = compute_effective_progs(desc, atype, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt)) {\n\t\t\tif (unlikely(desc->bpf.inactive)) {\n\t\t\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\t\t\tdesc->bpf.inactive = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tactivate_effective_progs(desc, atype, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "desc->bpf.inactive"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1995-2000",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structcgroup",
            "self"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "&cgrp->self"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "activate_effective_progs",
          "args": [
            "desc",
            "atype",
            "desc->bpf.inactive"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "activate_effective_progs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "271-281",
          "snippet": "static void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum cgroup_bpf_attach_type atype,\n\t\t\t\t     struct bpf_prog_array *old_array)\n{\n\told_array = rcu_replace_pointer(cgrp->bpf.effective[atype], old_array,\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum cgroup_bpf_attach_type atype,\n\t\t\t\t     struct bpf_prog_array *old_array)\n{\n\told_array = rcu_replace_pointer(cgrp->bpf.effective[atype], old_array,\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "desc->bpf.inactive"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_is_zero",
          "args": [
            "&desc->bpf.refcnt"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structcgroup",
            "self"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "&cgrp->self"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compute_effective_progs",
          "args": [
            "desc",
            "atype",
            "&desc->bpf.inactive"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "compute_effective_progs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "227-269",
          "snippet": "static int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum cgroup_bpf_attach_type atype,\n\t\t\t\t   struct bpf_prog_array **array)\n{\n\tstruct bpf_prog_array_item *item;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[atype]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[atype], node) {\n\t\t\tif (!prog_list_prog(pl))\n\t\t\t\tcontinue;\n\n\t\t\titem = &progs->items[cnt];\n\t\t\titem->prog = prog_list_prog(pl);\n\t\t\tbpf_cgroup_storages_assign(item->cgroup_storage,\n\t\t\t\t\t\t   pl->storage);\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\t*array = progs;\n\treturn 0;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum cgroup_bpf_attach_type atype,\n\t\t\t\t   struct bpf_prog_array **array)\n{\n\tstruct bpf_prog_array_item *item;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[atype]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[atype], node) {\n\t\t\tif (!prog_list_prog(pl))\n\t\t\t\tcontinue;\n\n\t\t\titem = &progs->items[cnt];\n\t\t\titem->prog = prog_list_prog(pl);\n\t\t\tbpf_cgroup_storages_assign(item->cgroup_storage,\n\t\t\t\t\t\t   pl->storage);\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\t*array = progs;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_is_zero",
          "args": [
            "&desc->bpf.refcnt"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structcgroup",
            "self"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "&cgrp->self"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt))\n\t\t\tcontinue;\n\n\t\terr = compute_effective_progs(desc, atype, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tif (percpu_ref_is_zero(&desc->bpf.refcnt)) {\n\t\t\tif (unlikely(desc->bpf.inactive)) {\n\t\t\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\t\t\tdesc->bpf.inactive = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tactivate_effective_progs(desc, atype, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "cgroup_bpf_inherit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "287-328",
    "snippet": "int cgroup_bpf_inherit(struct cgroup *cgrp)\n{\n/* has to use marco instead of const int, since compiler thinks\n * that array below is variable length\n */\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\tstruct bpf_prog_array *arrays[NR] = {};\n\tstruct cgroup *p;\n\tint ret, i;\n\n\tret = percpu_ref_init(&cgrp->bpf.refcnt, cgroup_bpf_release_fn, 0,\n\t\t\t      GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (p = cgroup_parent(cgrp); p; p = cgroup_parent(p))\n\t\tcgroup_bpf_get(p);\n\n\tfor (i = 0; i < NR; i++)\n\t\tINIT_LIST_HEAD(&cgrp->bpf.progs[i]);\n\n\tINIT_LIST_HEAD(&cgrp->bpf.storages);\n\n\tfor (i = 0; i < NR; i++)\n\t\tif (compute_effective_progs(cgrp, i, &arrays[i]))\n\t\t\tgoto cleanup;\n\n\tfor (i = 0; i < NR; i++)\n\t\tactivate_effective_progs(cgrp, i, arrays[i]);\n\n\treturn 0;\ncleanup:\n\tfor (i = 0; i < NR; i++)\n\t\tbpf_prog_array_free(arrays[i]);\n\n\tfor (p = cgroup_parent(cgrp); p; p = cgroup_parent(p))\n\t\tcgroup_bpf_put(p);\n\n\tpercpu_ref_exit(&cgrp->bpf.refcnt);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define\tNR ARRAY_SIZE(cgrp->bpf.effective)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&cgrp->bpf.refcnt"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_put",
          "args": [
            "p"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "p"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "arrays[i]"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1995-2000",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "activate_effective_progs",
          "args": [
            "cgrp",
            "i",
            "arrays[i]"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "activate_effective_progs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "271-281",
          "snippet": "static void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum cgroup_bpf_attach_type atype,\n\t\t\t\t     struct bpf_prog_array *old_array)\n{\n\told_array = rcu_replace_pointer(cgrp->bpf.effective[atype], old_array,\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum cgroup_bpf_attach_type atype,\n\t\t\t\t     struct bpf_prog_array *old_array)\n{\n\told_array = rcu_replace_pointer(cgrp->bpf.effective[atype], old_array,\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compute_effective_progs",
          "args": [
            "cgrp",
            "i",
            "&arrays[i]"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "compute_effective_progs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "227-269",
          "snippet": "static int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum cgroup_bpf_attach_type atype,\n\t\t\t\t   struct bpf_prog_array **array)\n{\n\tstruct bpf_prog_array_item *item;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[atype]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[atype], node) {\n\t\t\tif (!prog_list_prog(pl))\n\t\t\t\tcontinue;\n\n\t\t\titem = &progs->items[cnt];\n\t\t\titem->prog = prog_list_prog(pl);\n\t\t\tbpf_cgroup_storages_assign(item->cgroup_storage,\n\t\t\t\t\t\t   pl->storage);\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\t*array = progs;\n\treturn 0;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum cgroup_bpf_attach_type atype,\n\t\t\t\t   struct bpf_prog_array **array)\n{\n\tstruct bpf_prog_array_item *item;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[atype]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[atype], node) {\n\t\t\tif (!prog_list_prog(pl))\n\t\t\t\tcontinue;\n\n\t\t\titem = &progs->items[cnt];\n\t\t\titem->prog = prog_list_prog(pl);\n\t\t\tbpf_cgroup_storages_assign(item->cgroup_storage,\n\t\t\t\t\t\t   pl->storage);\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\t*array = progs;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->bpf.storages"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->bpf.progs[i]"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_get",
          "args": [
            "p"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "p"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&cgrp->bpf.refcnt",
            "cgroup_bpf_release_fn",
            "0",
            "GFP_KERNEL"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\nint cgroup_bpf_inherit(struct cgroup *cgrp)\n{\n/* has to use marco instead of const int, since compiler thinks\n * that array below is variable length\n */\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\tstruct bpf_prog_array *arrays[NR] = {};\n\tstruct cgroup *p;\n\tint ret, i;\n\n\tret = percpu_ref_init(&cgrp->bpf.refcnt, cgroup_bpf_release_fn, 0,\n\t\t\t      GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (p = cgroup_parent(cgrp); p; p = cgroup_parent(p))\n\t\tcgroup_bpf_get(p);\n\n\tfor (i = 0; i < NR; i++)\n\t\tINIT_LIST_HEAD(&cgrp->bpf.progs[i]);\n\n\tINIT_LIST_HEAD(&cgrp->bpf.storages);\n\n\tfor (i = 0; i < NR; i++)\n\t\tif (compute_effective_progs(cgrp, i, &arrays[i]))\n\t\t\tgoto cleanup;\n\n\tfor (i = 0; i < NR; i++)\n\t\tactivate_effective_progs(cgrp, i, arrays[i]);\n\n\treturn 0;\ncleanup:\n\tfor (i = 0; i < NR; i++)\n\t\tbpf_prog_array_free(arrays[i]);\n\n\tfor (p = cgroup_parent(cgrp); p; p = cgroup_parent(p))\n\t\tcgroup_bpf_put(p);\n\n\tpercpu_ref_exit(&cgrp->bpf.refcnt);\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "activate_effective_progs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "271-281",
    "snippet": "static void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum cgroup_bpf_attach_type atype,\n\t\t\t\t     struct bpf_prog_array *old_array)\n{\n\told_array = rcu_replace_pointer(cgrp->bpf.effective[atype], old_array,\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "old_array"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1995-2000",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_replace_pointer",
          "args": [
            "cgrp->bpf.effective[atype]",
            "old_array",
            "lockdep_is_held(&cgroup_mutex)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum cgroup_bpf_attach_type atype,\n\t\t\t\t     struct bpf_prog_array *old_array)\n{\n\told_array = rcu_replace_pointer(cgrp->bpf.effective[atype], old_array,\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}"
  },
  {
    "function_name": "compute_effective_progs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "227-269",
    "snippet": "static int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum cgroup_bpf_attach_type atype,\n\t\t\t\t   struct bpf_prog_array **array)\n{\n\tstruct bpf_prog_array_item *item;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[atype]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[atype], node) {\n\t\t\tif (!prog_list_prog(pl))\n\t\t\t\tcontinue;\n\n\t\t\titem = &progs->items[cnt];\n\t\t\titem->prog = prog_list_prog(pl);\n\t\t\tbpf_cgroup_storages_assign(item->cgroup_storage,\n\t\t\t\t\t\t   pl->storage);\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\t*array = progs;\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "p"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storages_assign",
          "args": [
            "item->cgroup_storage",
            "pl->storage"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storages_assign",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "73-80",
          "snippet": "static void bpf_cgroup_storages_assign(struct bpf_cgroup_storage *dst[],\n\t\t\t\t       struct bpf_cgroup_storage *src[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tdst[stype] = src[stype];\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_storages_assign(struct bpf_cgroup_storage *dst[],\n\t\t\t\t       struct bpf_cgroup_storage *src[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tdst[stype] = src[stype];\n}"
        }
      },
      {
        "call_info": {
          "callee": "prog_list_prog",
          "args": [
            "pl"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "169-176",
          "snippet": "static struct bpf_prog *prog_list_prog(struct bpf_prog_list *pl)\n{\n\tif (pl->prog)\n\t\treturn pl->prog;\n\tif (pl->link)\n\t\treturn pl->link->link.prog;\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic struct bpf_prog *prog_list_prog(struct bpf_prog_list *pl)\n{\n\tif (pl->prog)\n\t\treturn pl->prog;\n\tif (pl->link)\n\t\treturn pl->link->link.prog;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "&p->bpf.progs[atype]",
            "node"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_alloc",
          "args": [
            "cnt",
            "GFP_KERNEL"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1984-1993",
          "snippet": "struct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nstruct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "p"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prog_list_length",
          "args": [
            "&p->bpf.progs[atype]"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_length",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "181-192",
          "snippet": "static u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!prog_list_prog(pl))\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!prog_list_prog(pl))\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum cgroup_bpf_attach_type atype,\n\t\t\t\t   struct bpf_prog_array **array)\n{\n\tstruct bpf_prog_array_item *item;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[atype]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[atype] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[atype], node) {\n\t\t\tif (!prog_list_prog(pl))\n\t\t\t\tcontinue;\n\n\t\t\titem = &progs->items[cnt];\n\t\t\titem->prog = prog_list_prog(pl);\n\t\t\tbpf_cgroup_storages_assign(item->cgroup_storage,\n\t\t\t\t\t\t   pl->storage);\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\t*array = progs;\n\treturn 0;\n}"
  },
  {
    "function_name": "hierarchy_allows_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "198-219",
    "snippet": "static bool hierarchy_allows_attach(struct cgroup *cgrp,\n\t\t\t\t    enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup *p;\n\n\tp = cgroup_parent(cgrp);\n\tif (!p)\n\t\treturn true;\n\tdo {\n\t\tu32 flags = p->bpf.flags[atype];\n\t\tu32 cnt;\n\n\t\tif (flags & BPF_F_ALLOW_MULTI)\n\t\t\treturn true;\n\t\tcnt = prog_list_length(&p->bpf.progs[atype]);\n\t\tWARN_ON_ONCE(cnt > 1);\n\t\tif (cnt == 1)\n\t\t\treturn !!(flags & BPF_F_ALLOW_OVERRIDE);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\treturn true;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "p"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cnt > 1"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prog_list_length",
          "args": [
            "&p->bpf.progs[atype]"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_length",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "181-192",
          "snippet": "static u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!prog_list_prog(pl))\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!prog_list_prog(pl))\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool hierarchy_allows_attach(struct cgroup *cgrp,\n\t\t\t\t    enum cgroup_bpf_attach_type atype)\n{\n\tstruct cgroup *p;\n\n\tp = cgroup_parent(cgrp);\n\tif (!p)\n\t\treturn true;\n\tdo {\n\t\tu32 flags = p->bpf.flags[atype];\n\t\tu32 cnt;\n\n\t\tif (flags & BPF_F_ALLOW_MULTI)\n\t\t\treturn true;\n\t\tcnt = prog_list_length(&p->bpf.progs[atype]);\n\t\tWARN_ON_ONCE(cnt > 1);\n\t\tif (cnt == 1)\n\t\t\treturn !!(flags & BPF_F_ALLOW_OVERRIDE);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\treturn true;\n}"
  },
  {
    "function_name": "prog_list_length",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "181-192",
    "snippet": "static u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!prog_list_prog(pl))\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prog_list_prog",
          "args": [
            "pl"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "169-176",
          "snippet": "static struct bpf_prog *prog_list_prog(struct bpf_prog_list *pl)\n{\n\tif (pl->prog)\n\t\treturn pl->prog;\n\tif (pl->link)\n\t\treturn pl->link->link.prog;\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic struct bpf_prog *prog_list_prog(struct bpf_prog_list *pl)\n{\n\tif (pl->prog)\n\t\treturn pl->prog;\n\tif (pl->link)\n\t\treturn pl->link->link.prog;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "head",
            "node"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!prog_list_prog(pl))\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}"
  },
  {
    "function_name": "prog_list_prog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "169-176",
    "snippet": "static struct bpf_prog *prog_list_prog(struct bpf_prog_list *pl)\n{\n\tif (pl->prog)\n\t\treturn pl->prog;\n\tif (pl->link)\n\t\treturn pl->link->link.prog;\n\treturn NULL;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic struct bpf_prog *prog_list_prog(struct bpf_prog_list *pl)\n{\n\tif (pl->prog)\n\t\treturn pl->prog;\n\tif (pl->link)\n\t\treturn pl->link->link.prog;\n\treturn NULL;\n}"
  },
  {
    "function_name": "cgroup_bpf_release_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "158-164",
    "snippet": "static void cgroup_bpf_release_fn(struct percpu_ref *ref)\n{\n\tstruct cgroup *cgrp = container_of(ref, struct cgroup, bpf.refcnt);\n\n\tINIT_WORK(&cgrp->bpf.release_work, cgroup_bpf_release);\n\tqueue_work(system_wq, &cgrp->bpf.release_work);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "system_wq",
            "&cgrp->bpf.release_work"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&cgrp->bpf.release_work",
            "cgroup_bpf_release"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structcgroup",
            "bpf.refcnt"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void cgroup_bpf_release_fn(struct percpu_ref *ref)\n{\n\tstruct cgroup *cgrp = container_of(ref, struct cgroup, bpf.refcnt);\n\n\tINIT_WORK(&cgrp->bpf.release_work, cgroup_bpf_release);\n\tqueue_work(system_wq, &cgrp->bpf.release_work);\n}"
  },
  {
    "function_name": "cgroup_bpf_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "108-151",
    "snippet": "static void cgroup_bpf_release(struct work_struct *work)\n{\n\tstruct cgroup *p, *cgrp = container_of(work, struct cgroup,\n\t\t\t\t\t       bpf.release_work);\n\tstruct bpf_prog_array *old_array;\n\tstruct list_head *storages = &cgrp->bpf.storages;\n\tstruct bpf_cgroup_storage *storage, *stmp;\n\n\tunsigned int atype;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tfor (atype = 0; atype < ARRAY_SIZE(cgrp->bpf.progs); atype++) {\n\t\tstruct list_head *progs = &cgrp->bpf.progs[atype];\n\t\tstruct bpf_prog_list *pl, *pltmp;\n\n\t\tlist_for_each_entry_safe(pl, pltmp, progs, node) {\n\t\t\tlist_del(&pl->node);\n\t\t\tif (pl->prog)\n\t\t\t\tbpf_prog_put(pl->prog);\n\t\t\tif (pl->link)\n\t\t\t\tbpf_cgroup_link_auto_detach(pl->link);\n\t\t\tkfree(pl);\n\t\t\tstatic_branch_dec(&cgroup_bpf_enabled_key[atype]);\n\t\t}\n\t\told_array = rcu_dereference_protected(\n\t\t\t\tcgrp->bpf.effective[atype],\n\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t\tbpf_prog_array_free(old_array);\n\t}\n\n\tlist_for_each_entry_safe(storage, stmp, storages, list_cg) {\n\t\tbpf_cgroup_storage_unlink(storage);\n\t\tbpf_cgroup_storage_free(storage);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tfor (p = cgroup_parent(cgrp); p; p = cgroup_parent(p))\n\t\tcgroup_bpf_put(p);\n\n\tpercpu_ref_exit(&cgrp->bpf.refcnt);\n\tcgroup_put(cgrp);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&cgrp->bpf.refcnt"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_put",
          "args": [
            "p"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "p"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_free",
          "args": [
            "storage"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "551-565",
          "snippet": "void bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_unlink",
          "args": [
            "storage"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_unlink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "588-605",
          "snippet": "void bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list_map);\n\tlist_del(&storage->list_cg);\n\tspin_unlock_bh(&map->lock);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list_map);\n\tlist_del(&storage->list_cg);\n\tspin_unlock_bh(&map->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "storage",
            "stmp",
            "storages",
            "list_cg"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "old_array"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1995-2000",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "cgrp->bpf.effective[atype]",
            "lockdep_is_held(&cgroup_mutex)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_dec",
          "args": [
            "&cgroup_bpf_enabled_key[atype]"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pl"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_link_auto_detach",
          "args": [
            "pl->link"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_link_auto_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "97-101",
          "snippet": "static void bpf_cgroup_link_auto_detach(struct bpf_cgroup_link *link)\n{\n\tcgroup_put(link->cgroup);\n\tlink->cgroup = NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_link_auto_detach(struct bpf_cgroup_link *link)\n{\n\tcgroup_put(link->cgroup);\n\tlink->cgroup = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "pl->prog"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pl->node"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "pl",
            "pltmp",
            "progs",
            "node"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cgrp->bpf.progs"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structcgroup",
            "bpf.release_work"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void cgroup_bpf_release(struct work_struct *work)\n{\n\tstruct cgroup *p, *cgrp = container_of(work, struct cgroup,\n\t\t\t\t\t       bpf.release_work);\n\tstruct bpf_prog_array *old_array;\n\tstruct list_head *storages = &cgrp->bpf.storages;\n\tstruct bpf_cgroup_storage *storage, *stmp;\n\n\tunsigned int atype;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tfor (atype = 0; atype < ARRAY_SIZE(cgrp->bpf.progs); atype++) {\n\t\tstruct list_head *progs = &cgrp->bpf.progs[atype];\n\t\tstruct bpf_prog_list *pl, *pltmp;\n\n\t\tlist_for_each_entry_safe(pl, pltmp, progs, node) {\n\t\t\tlist_del(&pl->node);\n\t\t\tif (pl->prog)\n\t\t\t\tbpf_prog_put(pl->prog);\n\t\t\tif (pl->link)\n\t\t\t\tbpf_cgroup_link_auto_detach(pl->link);\n\t\t\tkfree(pl);\n\t\t\tstatic_branch_dec(&cgroup_bpf_enabled_key[atype]);\n\t\t}\n\t\told_array = rcu_dereference_protected(\n\t\t\t\tcgrp->bpf.effective[atype],\n\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\t\tbpf_prog_array_free(old_array);\n\t}\n\n\tlist_for_each_entry_safe(storage, stmp, storages, list_cg) {\n\t\tbpf_cgroup_storage_unlink(storage);\n\t\tbpf_cgroup_storage_free(storage);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tfor (p = cgroup_parent(cgrp); p; p = cgroup_parent(p))\n\t\tcgroup_bpf_put(p);\n\n\tpercpu_ref_exit(&cgrp->bpf.refcnt);\n\tcgroup_put(cgrp);\n}"
  },
  {
    "function_name": "bpf_cgroup_link_auto_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "97-101",
    "snippet": "static void bpf_cgroup_link_auto_detach(struct bpf_cgroup_link *link)\n{\n\tcgroup_put(link->cgroup);\n\tlink->cgroup = NULL;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "link->cgroup"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_link_auto_detach(struct bpf_cgroup_link *link)\n{\n\tcgroup_put(link->cgroup);\n\tlink->cgroup = NULL;\n}"
  },
  {
    "function_name": "bpf_cgroup_storages_link",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "82-90",
    "snippet": "static void bpf_cgroup_storages_link(struct bpf_cgroup_storage *storages[],\n\t\t\t\t     struct cgroup *cgrp,\n\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_link(storages[stype], cgrp, attach_type);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_storages_link(struct bpf_cgroup_storage *storages[],\n\t\t\t\t     struct cgroup *cgrp,\n\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_link(storages[stype], cgrp, attach_type);\n}"
  },
  {
    "function_name": "bpf_cgroup_storages_assign",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "73-80",
    "snippet": "static void bpf_cgroup_storages_assign(struct bpf_cgroup_storage *dst[],\n\t\t\t\t       struct bpf_cgroup_storage *src[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tdst[stype] = src[stype];\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_storages_assign(struct bpf_cgroup_storage *dst[],\n\t\t\t\t       struct bpf_cgroup_storage *src[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tdst[stype] = src[stype];\n}"
  },
  {
    "function_name": "bpf_cgroup_storages_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "39-71",
    "snippet": "static int bpf_cgroup_storages_alloc(struct bpf_cgroup_storage *storages[],\n\t\t\t\t     struct bpf_cgroup_storage *new_storages[],\n\t\t\t\t     enum bpf_attach_type type,\n\t\t\t\t     struct bpf_prog *prog,\n\t\t\t\t     struct cgroup *cgrp)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_cgroup_storage_key key;\n\tstruct bpf_map *map;\n\n\tkey.cgroup_inode_id = cgroup_id(cgrp);\n\tkey.attach_type = type;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tmap = prog->aux->cgroup_storage[stype];\n\t\tif (!map)\n\t\t\tcontinue;\n\n\t\tstorages[stype] = cgroup_storage_lookup((void *)map, &key, false);\n\t\tif (storages[stype])\n\t\t\tcontinue;\n\n\t\tstorages[stype] = bpf_cgroup_storage_alloc(prog, stype);\n\t\tif (IS_ERR(storages[stype])) {\n\t\t\tbpf_cgroup_storages_free(new_storages);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnew_storages[stype] = storages[stype];\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_cgroup_storages_free",
          "args": [
            "new_storages"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storages_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "31-37",
          "snippet": "static void bpf_cgroup_storages_free(struct bpf_cgroup_storage *storages[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_free(storages[stype]);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_storages_free(struct bpf_cgroup_storage *storages[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_free(storages[stype]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "storages[stype]"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_alloc",
          "args": [
            "prog",
            "stype"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "492-531",
          "snippet": "struct bpf_cgroup_storage *bpf_cgroup_storage_alloc(struct bpf_prog *prog,\n\t\t\t\t\tenum bpf_cgroup_storage_type stype)\n{\n\tconst gfp_t gfp = __GFP_ZERO | GFP_USER;\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_map *map;\n\tsize_t size;\n\tu32 pages;\n\n\tmap = prog->aux->cgroup_storage[stype];\n\tif (!map)\n\t\treturn NULL;\n\n\tsize = bpf_cgroup_storage_calculate_size(map, &pages);\n\n\tstorage = bpf_map_kmalloc_node(map, sizeof(struct bpf_cgroup_storage),\n\t\t\t\t       gfp, map->numa_node);\n\tif (!storage)\n\t\tgoto enomem;\n\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tstorage->buf = bpf_map_kmalloc_node(map, size, gfp,\n\t\t\t\t\t\t    map->numa_node);\n\t\tif (!storage->buf)\n\t\t\tgoto enomem;\n\t\tcheck_and_init_map_value(map, storage->buf->data);\n\t} else {\n\t\tstorage->percpu_buf = bpf_map_alloc_percpu(map, size, 8, gfp);\n\t\tif (!storage->percpu_buf)\n\t\t\tgoto enomem;\n\t}\n\n\tstorage->map = (struct bpf_cgroup_storage_map *)map;\n\n\treturn storage;\n\nenomem:\n\tkfree(storage);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *bpf_cgroup_storage_alloc(struct bpf_prog *prog,\n\t\t\t\t\tenum bpf_cgroup_storage_type stype)\n{\n\tconst gfp_t gfp = __GFP_ZERO | GFP_USER;\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_map *map;\n\tsize_t size;\n\tu32 pages;\n\n\tmap = prog->aux->cgroup_storage[stype];\n\tif (!map)\n\t\treturn NULL;\n\n\tsize = bpf_cgroup_storage_calculate_size(map, &pages);\n\n\tstorage = bpf_map_kmalloc_node(map, sizeof(struct bpf_cgroup_storage),\n\t\t\t\t       gfp, map->numa_node);\n\tif (!storage)\n\t\tgoto enomem;\n\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tstorage->buf = bpf_map_kmalloc_node(map, size, gfp,\n\t\t\t\t\t\t    map->numa_node);\n\t\tif (!storage->buf)\n\t\t\tgoto enomem;\n\t\tcheck_and_init_map_value(map, storage->buf->data);\n\t} else {\n\t\tstorage->percpu_buf = bpf_map_alloc_percpu(map, size, 8, gfp);\n\t\tif (!storage->percpu_buf)\n\t\t\tgoto enomem;\n\t}\n\n\tstorage->map = (struct bpf_cgroup_storage_map *)map;\n\n\treturn storage;\n\nenomem:\n\tkfree(storage);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "(void *)map",
            "&key",
            "false"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "65-99",
          "snippet": "struct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_id",
          "args": [
            "cgrp"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int bpf_cgroup_storages_alloc(struct bpf_cgroup_storage *storages[],\n\t\t\t\t     struct bpf_cgroup_storage *new_storages[],\n\t\t\t\t     enum bpf_attach_type type,\n\t\t\t\t     struct bpf_prog *prog,\n\t\t\t\t     struct cgroup *cgrp)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_cgroup_storage_key key;\n\tstruct bpf_map *map;\n\n\tkey.cgroup_inode_id = cgroup_id(cgrp);\n\tkey.attach_type = type;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tmap = prog->aux->cgroup_storage[stype];\n\t\tif (!map)\n\t\t\tcontinue;\n\n\t\tstorages[stype] = cgroup_storage_lookup((void *)map, &key, false);\n\t\tif (storages[stype])\n\t\t\tcontinue;\n\n\t\tstorages[stype] = bpf_cgroup_storage_alloc(prog, stype);\n\t\tif (IS_ERR(storages[stype])) {\n\t\t\tbpf_cgroup_storages_free(new_storages);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnew_storages[stype] = storages[stype];\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_cgroup_storages_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "31-37",
    "snippet": "static void bpf_cgroup_storages_free(struct bpf_cgroup_storage *storages[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_free(storages[stype]);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void bpf_cgroup_storages_free(struct bpf_cgroup_storage *storages[])\n{\n\tenum bpf_cgroup_storage_type stype;\n\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_free(storages[stype]);\n}"
  },
  {
    "function_name": "cgroup_bpf_offline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
    "lines": "25-29",
    "snippet": "void cgroup_bpf_offline(struct cgroup *cgrp)\n{\n\tcgroup_get(cgrp);\n\tpercpu_ref_kill(&cgrp->bpf.refcnt);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <net/bpf_sk_storage.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/string.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "&cgrp->bpf.refcnt"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get",
          "args": [
            "cgrp"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "6577-6589",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nvoid cgroup_bpf_offline(struct cgroup *cgrp)\n{\n\tcgroup_get(cgrp);\n\tpercpu_ref_kill(&cgrp->bpf.refcnt);\n}"
  }
]