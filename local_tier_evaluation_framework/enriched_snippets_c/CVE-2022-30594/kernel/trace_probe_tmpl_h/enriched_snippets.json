[
  {
    "function_name": "print_probe_args",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
    "lines": "216-242",
    "snippet": "static inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
      "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "j == a->count - 1 ? '}' : ','"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "a->type->print",
          "args": [
            "s",
            "p",
            "field"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a->type->print",
          "args": [
            "s",
            "data + a->offset",
            "field"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!a->count"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" %s=\"",
            "a->name"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "store_trace_args",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
    "lines": "190-214",
    "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
      "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
      "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
      "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
      "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_data_loc",
          "args": [
            "0",
            "dyndata - base"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0 && arg->dynamic"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_fetch_insn",
          "args": [
            "arg->code",
            "rec",
            "dl",
            "base"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "process_fetch_insn_bottom",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "71-168",
          "snippet": "static nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_data_loc",
          "args": [
            "maxlen",
            "dyndata - base"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "arg->dynamic"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__get_data_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
    "lines": "171-187",
    "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_fetch_insn",
          "args": [
            "arg->code",
            "regs",
            "NULL",
            "NULL"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "process_fetch_insn_bottom",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "71-168",
          "snippet": "static nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "arg->dynamic"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "process_fetch_insn_bottom",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
    "lines": "71-168",
    "snippet": "static nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
      "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
      "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
      "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
      "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_data_loc",
          "args": [
            "loc",
            "ret"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "update_data_loc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "70-76",
          "snippet": "static nokprobe_inline u32 update_data_loc(u32 loc, int consumed)\n{\n\tu32 maxlen = get_loc_len(loc);\n\tu32 offset = get_loc_offs(loc);\n\n\treturn make_data_loc(maxlen - consumed, offset + consumed);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int traceprobe_split_symbol_offset(char *symbol, long *offset);",
            "int traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nextern int traceprobe_split_symbol_offset(char *symbol, long *offset);\nint traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset);\n\nstatic nokprobe_inline u32 update_data_loc(u32 loc, int consumed)\n{\n\tu32 maxlen = get_loc_len(loc);\n\tu32 offset = get_loc_offs(loc);\n\n\treturn make_data_loc(maxlen - consumed, offset + consumed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_apply_bitfield",
          "args": [
            "code",
            "dest"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_apply_bitfield",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "28-49",
          "snippet": "static nokprobe_inline void\nfetch_apply_bitfield(struct fetch_insn *code, void *buf)\n{\n\tswitch (code->basesize) {\n\tcase 1:\n\t\t*(u8 *)buf <<= code->lshift;\n\t\t*(u8 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)buf <<= code->lshift;\n\t\t*(u16 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)buf <<= code->lshift;\n\t\t*(u32 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 8:\n\t\t*(u64 *)buf <<= code->lshift;\n\t\t*(u64 *)buf >>= code->rshift;\n\t\tbreak;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline void\nfetch_apply_bitfield(struct fetch_insn *code, void *buf)\n{\n\tswitch (code->basesize) {\n\tcase 1:\n\t\t*(u8 *)buf <<= code->lshift;\n\t\t*(u8 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)buf <<= code->lshift;\n\t\t*(u16 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)buf <<= code->lshift;\n\t\t*(u32 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 8:\n\t\t*(u64 *)buf <<= code->lshift;\n\t\t*(u64 *)buf >>= code->rshift;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_store_string_user",
          "args": [
            "val + code->offset",
            "dest",
            "base"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_string_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "407-425",
          "snippet": "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\tret = strncpy_from_user_nofault(__dest, uaddr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\tret = strncpy_from_user_nofault(__dest, uaddr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_store_string",
          "args": [
            "val + code->offset",
            "dest",
            "base"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "431-457",
          "snippet": "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)addr < TASK_SIZE)\n\t\treturn fetch_store_string_user(addr, dest, base);\n#endif\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\t/*\n\t * Try to get string again, since the string can be changed while\n\t * probing.\n\t */\n\tret = strncpy_from_kernel_nofault(__dest, (void *)addr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)addr < TASK_SIZE)\n\t\treturn fetch_store_string_user(addr, dest, base);\n#endif\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\t/*\n\t * Try to get string again, since the string can be changed while\n\t * probing.\n\t */\n\tret = strncpy_from_kernel_nofault(__dest, (void *)addr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_mem_read_user",
          "args": [
            "dest",
            "(void *)val + code->offset",
            "code->size"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "probe_mem_read_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "459-465",
          "snippet": "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\tconst void __user *uaddr =  (__force const void __user *)src;\n\n\treturn copy_from_user_nofault(dest, uaddr, size);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\tconst void __user *uaddr =  (__force const void __user *)src;\n\n\treturn copy_from_user_nofault(dest, uaddr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_mem_read",
          "args": [
            "dest",
            "(void *)val + code->offset",
            "code->size"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "probe_mem_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "467-475",
          "snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)src < TASK_SIZE)\n\t\treturn probe_mem_read_user(dest, src, size);\n#endif\n\treturn copy_from_kernel_nofault(dest, src, size);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)src < TASK_SIZE)\n\t\treturn probe_mem_read_user(dest, src, size);\n#endif\n\treturn copy_from_kernel_nofault(dest, src, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_store_raw",
          "args": [
            "val",
            "code",
            "dest"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_raw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "6-26",
          "snippet": "static nokprobe_inline void\nfetch_store_raw(unsigned long val, struct fetch_insn *code, void *buf)\n{\n\tswitch (code->size) {\n\tcase 1:\n\t\t*(u8 *)buf = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)buf = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)buf = (u32)val;\n\t\tbreak;\n\tcase 8:\n\t\t//TBD: 32bit signed\n\t\t*(u64 *)buf = (u64)val;\n\t\tbreak;\n\tdefault:\n\t\t*(unsigned long *)buf = val;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nfetch_store_raw(unsigned long val, struct fetch_insn *code, void *buf)\n{\n\tswitch (code->size) {\n\tcase 1:\n\t\t*(u8 *)buf = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)buf = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)buf = (u32)val;\n\t\tbreak;\n\tcase 8:\n\t\t//TBD: 32bit signed\n\t\t*(u64 *)buf = (u64)val;\n\t\tbreak;\n\tdefault:\n\t\t*(unsigned long *)buf = val;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_store_strlen_user",
          "args": [
            "val + code->offset"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "375-381",
          "snippet": "int\nfetch_store_strlen_user(unsigned long addr)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\n\treturn strnlen_user_nofault(uaddr, MAX_STRING_SIZE);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nfetch_store_strlen_user(unsigned long addr)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\n\treturn strnlen_user_nofault(uaddr, MAX_STRING_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_store_strlen",
          "args": [
            "val + code->offset"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dest"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}"
  },
  {
    "function_name": "fetch_apply_bitfield",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
    "lines": "28-49",
    "snippet": "static nokprobe_inline void\nfetch_apply_bitfield(struct fetch_insn *code, void *buf)\n{\n\tswitch (code->basesize) {\n\tcase 1:\n\t\t*(u8 *)buf <<= code->lshift;\n\t\t*(u8 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)buf <<= code->lshift;\n\t\t*(u16 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)buf <<= code->lshift;\n\t\t*(u32 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 8:\n\t\t*(u64 *)buf <<= code->lshift;\n\t\t*(u64 *)buf >>= code->rshift;\n\t\tbreak;\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static nokprobe_inline void\nfetch_apply_bitfield(struct fetch_insn *code, void *buf)\n{\n\tswitch (code->basesize) {\n\tcase 1:\n\t\t*(u8 *)buf <<= code->lshift;\n\t\t*(u8 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)buf <<= code->lshift;\n\t\t*(u16 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)buf <<= code->lshift;\n\t\t*(u32 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 8:\n\t\t*(u64 *)buf <<= code->lshift;\n\t\t*(u64 *)buf >>= code->rshift;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "fetch_store_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
    "lines": "6-26",
    "snippet": "static nokprobe_inline void\nfetch_store_raw(unsigned long val, struct fetch_insn *code, void *buf)\n{\n\tswitch (code->size) {\n\tcase 1:\n\t\t*(u8 *)buf = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)buf = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)buf = (u32)val;\n\t\tbreak;\n\tcase 8:\n\t\t//TBD: 32bit signed\n\t\t*(u64 *)buf = (u64)val;\n\t\tbreak;\n\tdefault:\n\t\t*(unsigned long *)buf = val;\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
      "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
    ],
    "called_functions": [],
    "contextual_snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nfetch_store_raw(unsigned long val, struct fetch_insn *code, void *buf)\n{\n\tswitch (code->size) {\n\tcase 1:\n\t\t*(u8 *)buf = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)buf = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)buf = (u32)val;\n\t\tbreak;\n\tcase 8:\n\t\t//TBD: 32bit signed\n\t\t*(u64 *)buf = (u64)val;\n\t\tbreak;\n\tdefault:\n\t\t*(unsigned long *)buf = val;\n\t}\n}"
  }
]