[
  {
    "function_name": "audit_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2424-2437",
    "snippet": "void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,\n\t       const char *fmt, ...)\n{\n\tstruct audit_buffer *ab;\n\tva_list args;\n\n\tab = audit_log_start(ctx, gfp_mask, type);\n\tif (ab) {\n\t\tva_start(args, fmt);\n\t\taudit_log_vformat(ab, fmt, args);\n\t\tva_end(args);\n\t\taudit_log_end(ab);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_vformat",
          "args": [
            "ab",
            "fmt",
            "args"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_vformat",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1922-1958",
          "snippet": "static void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nstatic void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "ctx",
            "gfp_mask",
            "type"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,\n\t       const char *fmt, ...)\n{\n\tstruct audit_buffer *ab;\n\tva_list args;\n\n\tab = audit_log_start(ctx, gfp_mask, type);\n\tif (ab) {\n\t\tva_start(args, fmt);\n\t\taudit_log_vformat(ab, fmt, args);\n\t\tva_end(args);\n\t\taudit_log_end(ab);\n\t}\n}"
  },
  {
    "function_name": "audit_log_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2386-2410",
    "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sk_buff_head audit_queue;",
      "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_buffer_free",
          "args": [
            "ab"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "audit_buffer_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1740-1747",
          "snippet": "static void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *audit_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *audit_buffer_cache;\n\nstatic void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"rate limit exceeded\""
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "354-384",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&kauditd_wait"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "&audit_queue",
            "skb"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "skb"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_rate_check",
          "args": [],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "audit_rate_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "317-344",
          "snippet": "static inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_rate_limit;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_rate_limit;\n\nstatic inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
  },
  {
    "function_name": "audit_signal_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2358-2375",
    "snippet": "int audit_signal_info(int sig, struct task_struct *t)\n{\n\tkuid_t uid = current_uid(), auid;\n\n\tif (auditd_test_task(t) &&\n\t    (sig == SIGTERM || sig == SIGHUP ||\n\t     sig == SIGUSR1 || sig == SIGUSR2)) {\n\t\taudit_sig_pid = task_tgid_nr(current);\n\t\tauid = audit_get_loginuid(current);\n\t\tif (uid_valid(auid))\n\t\t\taudit_sig_uid = auid;\n\t\telse\n\t\t\taudit_sig_uid = uid;\n\t\tsecurity_current_getsecid_subj(&audit_sig_sid);\n\t}\n\n\treturn audit_signal_info_syscall(t);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static kuid_t\t\taudit_sig_uid = INVALID_UID;",
      "static pid_t\t\taudit_sig_pid = -1;",
      "static u32\t\taudit_sig_sid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_signal_info_syscall",
          "args": [
            "t"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "audit_signal_info_syscall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.h",
          "lines": "330-333",
          "snippet": "static inline int audit_signal_info_syscall(struct task_struct *t)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <linux/tty.h>",
            "#include <uapi/linux/mqueue.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/audit.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/openat2.h> // struct open_how\n#include <linux/tty.h>\n#include <uapi/linux/mqueue.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <linux/fs.h>\n\nstatic inline int audit_signal_info_syscall(struct task_struct *t)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_current_getsecid_subj",
          "args": [
            "&audit_sig_sid"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "auid"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auditd_test_task",
          "args": [
            "t"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_test_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "218-229",
          "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic kuid_t\t\taudit_sig_uid = INVALID_UID;\nstatic pid_t\t\taudit_sig_pid = -1;\nstatic u32\t\taudit_sig_sid;\n\nint audit_signal_info(int sig, struct task_struct *t)\n{\n\tkuid_t uid = current_uid(), auid;\n\n\tif (auditd_test_task(t) &&\n\t    (sig == SIGTERM || sig == SIGHUP ||\n\t     sig == SIGUSR1 || sig == SIGUSR2)) {\n\t\taudit_sig_pid = task_tgid_nr(current);\n\t\tauid = audit_get_loginuid(current);\n\t\tif (uid_valid(auid))\n\t\t\taudit_sig_uid = auid;\n\t\telse\n\t\t\taudit_sig_uid = uid;\n\t\tsecurity_current_getsecid_subj(&audit_sig_sid);\n\t}\n\n\treturn audit_signal_info_syscall(t);\n}"
  },
  {
    "function_name": "audit_set_loginuid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2323-2348",
    "snippet": "int audit_set_loginuid(kuid_t loginuid)\n{\n\tunsigned int oldsessionid, sessionid = AUDIT_SID_UNSET;\n\tkuid_t oldloginuid;\n\tint rc;\n\n\toldloginuid = audit_get_loginuid(current);\n\toldsessionid = audit_get_sessionid(current);\n\n\trc = audit_set_loginuid_perm(loginuid);\n\tif (rc)\n\t\tgoto out;\n\n\t/* are we setting or clearing? */\n\tif (uid_valid(loginuid)) {\n\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\t\tif (unlikely(sessionid == AUDIT_SID_UNSET))\n\t\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\t}\n\n\tcurrent->sessionid = sessionid;\n\tcurrent->loginuid = loginuid;\nout:\n\taudit_log_set_loginuid(oldloginuid, loginuid, oldsessionid, sessionid, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t session_id = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_set_loginuid",
          "args": [
            "oldloginuid",
            "loginuid",
            "oldsessionid",
            "sessionid",
            "rc"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_set_loginuid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2286-2313",
          "snippet": "static void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid,\n\t\t\t\t   unsigned int sessionid, int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\tstruct tty_struct *tty;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid);\n\ttty = audit_get_tty();\n\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",\n\t\t\t oldsessionid, sessionid, !rc);\n\taudit_put_tty(tty);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid,\n\t\t\t\t   unsigned int sessionid, int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\tstruct tty_struct *tty;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid);\n\ttty = audit_get_tty();\n\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",\n\t\t\t oldsessionid, sessionid, !rc);\n\taudit_put_tty(tty);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&session_id"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sessionid == AUDIT_SID_UNSET"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&session_id"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "loginuid"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_set_loginuid_perm",
          "args": [
            "loginuid"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_loginuid_perm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2268-2284",
          "snippet": "static int audit_set_loginuid_perm(kuid_t loginuid)\n{\n\t/* if we are unset, we don't need privs */\n\tif (!audit_loginuid_set(current))\n\t\treturn 0;\n\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/\n\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))\n\t\treturn -EPERM;\n\t/* it is set, you need permission */\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\t/* reject if this is not an unset and we don't allow that */\n\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID)\n\t\t\t\t && uid_valid(loginuid))\n\t\treturn -EPERM;\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_set_loginuid_perm(kuid_t loginuid)\n{\n\t/* if we are unset, we don't need privs */\n\tif (!audit_loginuid_set(current))\n\t\treturn 0;\n\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/\n\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))\n\t\treturn -EPERM;\n\t/* it is set, you need permission */\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\t/* reject if this is not an unset and we don't allow that */\n\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID)\n\t\t\t\t && uid_valid(loginuid))\n\t\treturn -EPERM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic atomic_t session_id = ATOMIC_INIT(0);\n\nint audit_set_loginuid(kuid_t loginuid)\n{\n\tunsigned int oldsessionid, sessionid = AUDIT_SID_UNSET;\n\tkuid_t oldloginuid;\n\tint rc;\n\n\toldloginuid = audit_get_loginuid(current);\n\toldsessionid = audit_get_sessionid(current);\n\n\trc = audit_set_loginuid_perm(loginuid);\n\tif (rc)\n\t\tgoto out;\n\n\t/* are we setting or clearing? */\n\tif (uid_valid(loginuid)) {\n\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\t\tif (unlikely(sessionid == AUDIT_SID_UNSET))\n\t\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\t}\n\n\tcurrent->sessionid = sessionid;\n\tcurrent->loginuid = loginuid;\nout:\n\taudit_log_set_loginuid(oldloginuid, loginuid, oldsessionid, sessionid, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "audit_log_set_loginuid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2286-2313",
    "snippet": "static void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid,\n\t\t\t\t   unsigned int sessionid, int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\tstruct tty_struct *tty;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid);\n\ttty = audit_get_tty();\n\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",\n\t\t\t oldsessionid, sessionid, !rc);\n\taudit_put_tty(tty);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_tty",
          "args": [
            "tty"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2202-2205",
          "snippet": "void audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\"",
            "oldloginuid",
            "loginuid",
            "tty ? tty_name(tty) : \"(none)\"",
            "oldsessionid",
            "sessionid",
            "!rc"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tty_name",
          "args": [
            "tty"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2143-2168",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_tty",
          "args": [],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_tty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2190-2200",
          "snippet": "struct tty_struct *audit_get_tty(void)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tif (current->signal)\n\t\ttty = tty_kref_get(current->signal->tty);\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\treturn tty;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct tty_struct *audit_get_tty(void)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tif (current->signal)\n\t\ttty = tty_kref_get(current->signal->tty);\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\treturn tty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "kloginuid"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "current"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_LOGIN"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid,\n\t\t\t\t   unsigned int sessionid, int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\tstruct tty_struct *tty;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid);\n\ttty = audit_get_tty();\n\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",\n\t\t\t oldsessionid, sessionid, !rc);\n\taudit_put_tty(tty);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_set_loginuid_perm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2268-2284",
    "snippet": "static int audit_set_loginuid_perm(kuid_t loginuid)\n{\n\t/* if we are unset, we don't need privs */\n\tif (!audit_loginuid_set(current))\n\t\treturn 0;\n\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/\n\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))\n\t\treturn -EPERM;\n\t/* it is set, you need permission */\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\t/* reject if this is not an unset and we don't allow that */\n\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID)\n\t\t\t\t && uid_valid(loginuid))\n\t\treturn -EPERM;\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "loginuid"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_audit_feature_set",
          "args": [
            "AUDIT_FEATURE_ONLY_UNSET_LOGINUID"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "is_audit_feature_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1079-1082",
          "snippet": "int is_audit_feature_set(int i)\n{\n\treturn af.features & AUDIT_FEATURE_TO_MASK(i);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\n\nint is_audit_feature_set(int i)\n{\n\treturn af.features & AUDIT_FEATURE_TO_MASK(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_AUDIT_CONTROL"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_loginuid_set",
          "args": [
            "current"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_set_loginuid_perm(kuid_t loginuid)\n{\n\t/* if we are unset, we don't need privs */\n\tif (!audit_loginuid_set(current))\n\t\treturn 0;\n\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/\n\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))\n\t\treturn -EPERM;\n\t/* it is set, you need permission */\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\t/* reject if this is not an unset and we don't allow that */\n\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID)\n\t\t\t\t && uid_valid(loginuid))\n\t\treturn -EPERM;\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_log_path_denied",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2248-2263",
    "snippet": "void audit_log_path_denied(int type, const char *operation)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled || audit_dummy_context())\n\t\treturn;\n\n\t/* Generate log with subject, operation, outcome. */\n\tab = audit_log_start(audit_context(), GFP_KERNEL, type);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"op=%s\", operation);\n\taudit_log_task_info(ab);\n\taudit_log_format(ab, \" res=0\");\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" res=0\""
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_info",
          "args": [
            "ab"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2207-2240",
          "snippet": "void audit_log_task_info(struct audit_buffer *ab)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(current->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(current),\n\t\t\t task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n\taudit_log_task_context(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_task_info(struct audit_buffer *ab)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(current->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(current),\n\t\t\t task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n\taudit_log_task_context(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "type"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dummy_context",
          "args": [],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nvoid audit_log_path_denied(int type, const char *operation)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled || audit_dummy_context())\n\t\treturn;\n\n\t/* Generate log with subject, operation, outcome. */\n\tab = audit_log_start(audit_context(), GFP_KERNEL, type);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"op=%s\", operation);\n\taudit_log_task_info(ab);\n\taudit_log_format(ab, \" res=0\");\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_log_task_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2207-2240",
    "snippet": "void audit_log_task_info(struct audit_buffer *ab)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(current->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(current),\n\t\t\t task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n\taudit_log_task_context(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2143-2168",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_d_path_exe",
          "args": [
            "ab",
            "current->mm"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path_exe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2171-2188",
          "snippet": "void audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "get_task_comm(comm, current)"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "comm",
            "current"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" comm=\""
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_tty",
          "args": [
            "tty"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2202-2205",
          "snippet": "void audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tty_name",
          "args": [
            "tty"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "cred->fsgid"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "502-510",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "cred->fsuid"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_ppid_nr",
          "args": [
            "current"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_tty",
          "args": [],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_tty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2190-2200",
          "snippet": "struct tty_struct *audit_get_tty(void)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tif (current->signal)\n\t\ttty = tty_kref_get(current->signal->tty);\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\treturn tty;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct tty_struct *audit_get_tty(void)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tif (current->signal)\n\t\ttty = tty_kref_get(current->signal->tty);\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\treturn tty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_task_info(struct audit_buffer *ab)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(current->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(current),\n\t\t\t task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n\taudit_log_task_context(ab);\n}"
  },
  {
    "function_name": "audit_put_tty",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2202-2205",
    "snippet": "void audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tty_kref_put",
          "args": [
            "tty"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}"
  },
  {
    "function_name": "audit_get_tty",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2190-2200",
    "snippet": "struct tty_struct *audit_get_tty(void)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tif (current->signal)\n\t\ttty = tty_kref_get(current->signal->tty);\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\treturn tty;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&current->sighand->siglock",
            "flags"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tty_kref_get",
          "args": [
            "current->signal->tty"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&current->sighand->siglock",
            "flags"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct tty_struct *audit_get_tty(void)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tif (current->signal)\n\t\ttty = tty_kref_get(current->signal->tty);\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\treturn tty;\n}"
  },
  {
    "function_name": "audit_log_d_path_exe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2171-2188",
    "snippet": "void audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" exe=(null)\""
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "exe_file"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_d_path",
          "args": [
            "ab",
            "\" exe=\"",
            "&exe_file->f_path"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2103-2124",
          "snippet": "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mm_exe_file",
          "args": [
            "mm"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "get_mm_exe_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1254-1264",
          "snippet": "struct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\trcu_read_lock();\n\texe_file = rcu_dereference(mm->exe_file);\n\tif (exe_file && !get_file_rcu(exe_file))\n\t\texe_file = NULL;\n\trcu_read_unlock();\n\treturn exe_file;\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstruct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\trcu_read_lock();\n\texe_file = rcu_dereference(mm->exe_file);\n\tif (exe_file && !get_file_rcu(exe_file))\n\t\texe_file = NULL;\n\trcu_read_unlock();\n\treturn exe_file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}"
  },
  {
    "function_name": "audit_log_task_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2143-2168",
    "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"error in audit_log_task_context\""
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "302-315",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" subj=%s\"",
            "ctx"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_secid_to_secctx",
          "args": [
            "sid",
            "&ctx",
            "&len"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_current_getsecid_subj",
          "args": [
            "&sid"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
  },
  {
    "function_name": "audit_log_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2134-2141",
    "snippet": "void audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"(null)\""
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "key"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}"
  },
  {
    "function_name": "audit_log_session_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2126-2132",
    "snippet": "void audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"auid=%u ses=%u\"",
            "auid",
            "sessionid"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "audit_get_loginuid(current)"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);\n}"
  },
  {
    "function_name": "audit_log_d_path",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2103-2124",
    "snippet": "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pathname"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "p"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"\\\"<too_long>\\\"\""
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_path",
          "args": [
            "path",
            "pathname",
            "PATH_MAX+11"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2103-2124",
          "snippet": "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PATH_MAX+11",
            "ab->gfp_mask"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}"
  },
  {
    "function_name": "audit_log_untrustedstring",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2097-2100",
    "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_n_untrustedstring",
          "args": [
            "ab",
            "string",
            "strlen(string)"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2080-2087",
          "snippet": "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "string"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
  },
  {
    "function_name": "audit_log_n_untrustedstring",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2080-2087",
    "snippet": "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_n_string",
          "args": [
            "ab",
            "string",
            "len"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2023-2049",
          "snippet": "void audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_n_hex",
          "args": [
            "ab",
            "string",
            "len"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_hex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1990-2017",
          "snippet": "void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nvoid audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_string_contains_control",
          "args": [
            "string",
            "len"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "audit_string_contains_control",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2056-2064",
          "snippet": "bool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nbool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}"
  },
  {
    "function_name": "audit_string_contains_control",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2056-2064",
    "snippet": "bool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nbool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "audit_log_n_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "2023-2049",
    "snippet": "void audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_put",
          "args": [
            "skb",
            "slen + 2"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "string",
            "slen"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_tail_pointer",
          "args": [
            "skb"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_expand",
          "args": [
            "ab",
            "new_len"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "audit_expand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1900-1914",
          "snippet": "static inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_tailroom",
          "args": [
            "skb"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ab->skb"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}"
  },
  {
    "function_name": "audit_log_n_hex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1990-2017",
    "snippet": "void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_BUFSIZ 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_put",
          "args": [
            "skb",
            "len << 1"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_byte_pack_upper",
          "args": [
            "ptr",
            "buf[i]"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_tail_pointer",
          "args": [
            "skb"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_expand",
          "args": [
            "ab",
            "new_len"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "audit_expand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1900-1914",
          "snippet": "static inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_tailroom",
          "args": [
            "skb"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ab->skb"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nvoid audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}"
  },
  {
    "function_name": "audit_log_format",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1968-1977",
    "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_vformat",
          "args": [
            "ab",
            "fmt",
            "args"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_vformat",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1922-1958",
          "snippet": "static void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nstatic void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
  },
  {
    "function_name": "audit_log_vformat",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1922-1958",
    "snippet": "static void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_BUFSIZ 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args2"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_put",
          "args": [
            "skb",
            "len"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "skb_tail_pointer(skb)",
            "avail",
            "fmt",
            "args2"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_tail_pointer",
          "args": [
            "skb"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_expand",
          "args": [
            "ab",
            "max_t(unsigned, AUDIT_BUFSIZ, 1+len-avail)"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "audit_expand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1900-1914",
          "snippet": "static inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsigned",
            "AUDIT_BUFSIZ",
            "1+len-avail"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1831-1865",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "skb_tail_pointer(skb)",
            "avail",
            "fmt",
            "args"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_tail_pointer",
          "args": [
            "skb"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_copy",
          "args": [
            "args2",
            "args"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_tailroom",
          "args": [
            "skb"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ab->skb"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nstatic void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}"
  },
  {
    "function_name": "audit_expand",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1900-1914",
    "snippet": "static inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"out of memory in audit_expand\""
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "354-384",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_tailroom",
          "args": [
            "skb"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pskb_expand_head",
          "args": [
            "skb",
            "0",
            "extra",
            "ab->gfp_mask"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_tailroom",
          "args": [
            "skb"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}"
  },
  {
    "function_name": "audit_log_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1822-1890",
    "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_INITIALIZED\t1"
    ],
    "globals_used": [
      "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
      "static u32\taudit_backlog_limit = 64;",
      "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
      "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
      "static struct sk_buff_head audit_queue;",
      "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
      "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
      "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"audit(%llu.%03lu:%u): \"",
            "(unsigned long long)t.tv_sec",
            "t.tv_nsec/1000000",
            "serial"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_stamp",
          "args": [
            "ab->ctx",
            "&t",
            "&serial"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_stamp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1798-1805",
          "snippet": "static inline void audit_get_stamp(struct audit_context *ctx,\n\t\t\t\t   struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx || !auditsc_get_stamp(ctx, t, serial)) {\n\t\tktime_get_coarse_real_ts64(t);\n\t\t*serial = audit_serial();\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline void audit_get_stamp(struct audit_context *ctx,\n\t\t\t\t   struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx || !auditsc_get_stamp(ctx, t, serial)) {\n\t\tktime_get_coarse_real_ts64(t);\n\t\t*serial = audit_serial();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"out of memory in audit_log_start\""
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "354-384",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_buffer_alloc",
          "args": [
            "ctx",
            "gfp_mask",
            "type"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "audit_buffer_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1749-1772",
          "snippet": "static struct audit_buffer *audit_buffer_alloc(struct audit_context *ctx,\n\t\t\t\t\t       gfp_t gfp_mask, int type)\n{\n\tstruct audit_buffer *ab;\n\n\tab = kmem_cache_alloc(audit_buffer_cache, gfp_mask);\n\tif (!ab)\n\t\treturn NULL;\n\n\tab->skb = nlmsg_new(AUDIT_BUFSIZ, gfp_mask);\n\tif (!ab->skb)\n\t\tgoto err;\n\tif (!nlmsg_put(ab->skb, 0, 0, type, 0, 0))\n\t\tgoto err;\n\n\tab->ctx = ctx;\n\tab->gfp_mask = gfp_mask;\n\n\treturn ab;\n\nerr:\n\taudit_buffer_free(ab);\n\treturn NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [
            "static struct kmem_cache *audit_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nstatic struct kmem_cache *audit_buffer_cache;\n\nstatic struct audit_buffer *audit_buffer_alloc(struct audit_context *ctx,\n\t\t\t\t\t       gfp_t gfp_mask, int type)\n{\n\tstruct audit_buffer *ab;\n\n\tab = kmem_cache_alloc(audit_buffer_cache, gfp_mask);\n\tif (!ab)\n\t\treturn NULL;\n\n\tab->skb = nlmsg_new(AUDIT_BUFSIZ, gfp_mask);\n\tif (!ab->skb)\n\t\tgoto err;\n\tif (!nlmsg_put(ab->skb, 0, 0, type, 0, 0))\n\t\tgoto err;\n\n\tab->ctx = ctx;\n\tab->gfp_mask = gfp_mask;\n\n\treturn ab;\n\nerr:\n\taudit_buffer_free(ab);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"audit_backlog=%d > audit_backlog_limit=%d\\n\"",
            "skb_queue_len(&audit_queue)",
            "audit_backlog_limit"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_len",
          "args": [
            "&audit_queue"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_rate_check",
          "args": [],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "audit_rate_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "317-344",
          "snippet": "static inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_rate_limit;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_rate_limit;\n\nstatic inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&audit_backlog_wait",
            "&wait"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "remove_wait_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "51-58",
          "snippet": "void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "rtime - stime",
            "&audit_backlog_wait_time_actual"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "rtime"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_timeout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8396-8406",
          "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue_exclusive",
          "args": [
            "&audit_backlog_wait",
            "&wait"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "add_wait_queue_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "29-37",
          "snippet": "void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "gfp_mask"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&kauditd_wait"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_len",
          "args": [
            "&audit_queue"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ctl_owner_current",
          "args": [],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_owner_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "256-259",
          "snippet": "static bool audit_ctl_owner_current(void)\n{\n\treturn (current == audit_cmd_mutex.owner);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstatic bool audit_ctl_owner_current(void)\n{\n\treturn (current == audit_cmd_mutex.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditd_test_task",
          "args": [
            "current"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_test_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "218-229",
          "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!audit_filter(type, AUDIT_FILTER_EXCLUDE)"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_filter",
          "args": [
            "type",
            "AUDIT_FILTER_EXCLUDE"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1329-1398",
          "snippet": "int audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t   f->type, f->op, f->lsm_rule);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nint audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t   f->type, f->op, f->lsm_rule);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
  },
  {
    "function_name": "audit_get_stamp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1798-1805",
    "snippet": "static inline void audit_get_stamp(struct audit_context *ctx,\n\t\t\t\t   struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx || !auditsc_get_stamp(ctx, t, serial)) {\n\t\tktime_get_coarse_real_ts64(t);\n\t\t*serial = audit_serial();\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_serial",
          "args": [],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "audit_serial",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1791-1796",
          "snippet": "unsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_inc_return(&serial);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nunsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_inc_return(&serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_coarse_real_ts64",
          "args": [
            "t"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_coarse_real_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2234-2244",
          "snippet": "void ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditsc_get_stamp",
          "args": [
            "ctx",
            "t",
            "serial"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "auditsc_get_stamp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2483-2498",
          "snippet": "int auditsc_get_stamp(struct audit_context *ctx,\n\t\t       struct timespec64 *t, unsigned int *serial)\n{\n\tif (ctx->context == AUDIT_CTX_UNUSED)\n\t\treturn 0;\n\tif (!ctx->serial)\n\t\tctx->serial = audit_serial();\n\tt->tv_sec  = ctx->ctime.tv_sec;\n\tt->tv_nsec = ctx->ctime.tv_nsec;\n\t*serial    = ctx->serial;\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint auditsc_get_stamp(struct audit_context *ctx,\n\t\t       struct timespec64 *t, unsigned int *serial)\n{\n\tif (ctx->context == AUDIT_CTX_UNUSED)\n\t\treturn 0;\n\tif (!ctx->serial)\n\t\tctx->serial = audit_serial();\n\tt->tv_sec  = ctx->ctime.tv_sec;\n\tt->tv_nsec = ctx->ctime.tv_nsec;\n\t*serial    = ctx->serial;\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline void audit_get_stamp(struct audit_context *ctx,\n\t\t\t\t   struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx || !auditsc_get_stamp(ctx, t, serial)) {\n\t\tktime_get_coarse_real_ts64(t);\n\t\t*serial = audit_serial();\n\t}\n}"
  },
  {
    "function_name": "audit_serial",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1791-1796",
    "snippet": "unsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_inc_return(&serial);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&serial"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATOMIC_INIT",
          "args": [
            "0"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nunsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_inc_return(&serial);\n}"
  },
  {
    "function_name": "audit_buffer_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1749-1772",
    "snippet": "static struct audit_buffer *audit_buffer_alloc(struct audit_context *ctx,\n\t\t\t\t\t       gfp_t gfp_mask, int type)\n{\n\tstruct audit_buffer *ab;\n\n\tab = kmem_cache_alloc(audit_buffer_cache, gfp_mask);\n\tif (!ab)\n\t\treturn NULL;\n\n\tab->skb = nlmsg_new(AUDIT_BUFSIZ, gfp_mask);\n\tif (!ab->skb)\n\t\tgoto err;\n\tif (!nlmsg_put(ab->skb, 0, 0, type, 0, 0))\n\t\tgoto err;\n\n\tab->ctx = ctx;\n\tab->gfp_mask = gfp_mask;\n\n\treturn ab;\n\nerr:\n\taudit_buffer_free(ab);\n\treturn NULL;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_BUFSIZ 1024"
    ],
    "globals_used": [
      "static struct kmem_cache *audit_buffer_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_buffer_free",
          "args": [
            "ab"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "audit_buffer_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1740-1747",
          "snippet": "static void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *audit_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *audit_buffer_cache;\n\nstatic void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_put",
          "args": [
            "ab->skb",
            "0",
            "0",
            "type",
            "0",
            "0"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_new",
          "args": [
            "AUDIT_BUFSIZ",
            "gfp_mask"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "audit_buffer_cache",
            "gfp_mask"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nstatic struct kmem_cache *audit_buffer_cache;\n\nstatic struct audit_buffer *audit_buffer_alloc(struct audit_context *ctx,\n\t\t\t\t\t       gfp_t gfp_mask, int type)\n{\n\tstruct audit_buffer *ab;\n\n\tab = kmem_cache_alloc(audit_buffer_cache, gfp_mask);\n\tif (!ab)\n\t\treturn NULL;\n\n\tab->skb = nlmsg_new(AUDIT_BUFSIZ, gfp_mask);\n\tif (!ab->skb)\n\t\tgoto err;\n\tif (!nlmsg_put(ab->skb, 0, 0, type, 0, 0))\n\t\tgoto err;\n\n\tab->ctx = ctx;\n\tab->gfp_mask = gfp_mask;\n\n\treturn ab;\n\nerr:\n\taudit_buffer_free(ab);\n\treturn NULL;\n}"
  },
  {
    "function_name": "audit_buffer_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1740-1747",
    "snippet": "static void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *audit_buffer_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "audit_buffer_cache",
            "ab"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "ab->skb"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *audit_buffer_cache;\n\nstatic void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}"
  },
  {
    "function_name": "audit_backlog_limit_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1722-1737",
    "snippet": "static int __init audit_backlog_limit_set(char *str)\n{\n\tu32 audit_backlog_limit_arg;\n\n\tpr_info(\"audit_backlog_limit: \");\n\tif (kstrtouint(str, 0, &audit_backlog_limit_arg)) {\n\t\tpr_cont(\"using default of %u, unable to parse %s\\n\",\n\t\t\taudit_backlog_limit, str);\n\t\treturn 1;\n\t}\n\n\taudit_backlog_limit = audit_backlog_limit_arg;\n\tpr_cont(\"%d\\n\", audit_backlog_limit);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_backlog_limit = 64;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%d\\n\"",
            "audit_backlog_limit"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"using default of %u, unable to parse %s\\n\"",
            "audit_backlog_limit",
            "str"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "str",
            "0",
            "&audit_backlog_limit_arg"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"audit_backlog_limit: \""
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_backlog_limit = 64;\n\nstatic int __init audit_backlog_limit_set(char *str)\n{\n\tu32 audit_backlog_limit_arg;\n\n\tpr_info(\"audit_backlog_limit: \");\n\tif (kstrtouint(str, 0, &audit_backlog_limit_arg)) {\n\t\tpr_cont(\"using default of %u, unable to parse %s\\n\",\n\t\t\taudit_backlog_limit, str);\n\t\treturn 1;\n\t}\n\n\taudit_backlog_limit = audit_backlog_limit_arg;\n\tpr_cont(\"%d\\n\", audit_backlog_limit);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "audit_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1696-1717",
    "snippet": "static int __init audit_enable(char *str)\n{\n\tif (!strcasecmp(str, \"off\") || !strcmp(str, \"0\"))\n\t\taudit_default = AUDIT_OFF;\n\telse if (!strcasecmp(str, \"on\") || !strcmp(str, \"1\"))\n\t\taudit_default = AUDIT_ON;\n\telse {\n\t\tpr_err(\"audit: invalid 'audit' parameter value (%s)\\n\", str);\n\t\taudit_default = AUDIT_ON;\n\t}\n\n\tif (audit_default == AUDIT_OFF)\n\t\taudit_initialized = AUDIT_DISABLED;\n\tif (audit_set_enabled(audit_default))\n\t\tpr_err(\"audit: error setting audit state (%d)\\n\",\n\t\t       audit_default);\n\n\tpr_info(\"%s\\n\", audit_default ?\n\t\t\"enabled (after initialization)\" : \"disabled (until reboot)\");\n\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_DISABLED\t\t-1"
    ],
    "globals_used": [
      "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
      "static u32\taudit_default = AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s\\n\"",
            "audit_default ?\n\t\t\"enabled (after initialization)\" : \"disabled (until reboot)\""
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"audit: error setting audit state (%d)\\n\"",
            "audit_default"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_set_enabled",
          "args": [
            "audit_default"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "447-458",
          "snippet": "static int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;",
            "bool\t\taudit_ever_enabled = !!AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\nbool\t\taudit_ever_enabled = !!AUDIT_OFF;\n\nstatic int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"audit: invalid 'audit' parameter value (%s)\\n\"",
            "str"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"1\""
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "str",
            "\"on\""
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "str",
            "\"off\""
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_DISABLED\t\t-1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_default = AUDIT_OFF;\n\nstatic int __init audit_enable(char *str)\n{\n\tif (!strcasecmp(str, \"off\") || !strcmp(str, \"0\"))\n\t\taudit_default = AUDIT_OFF;\n\telse if (!strcasecmp(str, \"on\") || !strcmp(str, \"1\"))\n\t\taudit_default = AUDIT_ON;\n\telse {\n\t\tpr_err(\"audit: invalid 'audit' parameter value (%s)\\n\", str);\n\t\taudit_default = AUDIT_ON;\n\t}\n\n\tif (audit_default == AUDIT_OFF)\n\t\taudit_initialized = AUDIT_DISABLED;\n\tif (audit_set_enabled(audit_default))\n\t\tpr_err(\"audit: error setting audit state (%d)\\n\",\n\t\t       audit_default);\n\n\tpr_info(\"%s\\n\", audit_default ?\n\t\t\"enabled (after initialization)\" : \"disabled (until reboot)\");\n\n\treturn 1;\n}"
  },
  {
    "function_name": "audit_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1651-1689",
    "snippet": "static int __init audit_init(void)\n{\n\tint i;\n\n\tif (audit_initialized == AUDIT_DISABLED)\n\t\treturn 0;\n\n\taudit_buffer_cache = kmem_cache_create(\"audit_buffer\",\n\t\t\t\t\t       sizeof(struct audit_buffer),\n\t\t\t\t\t       0, SLAB_PANIC, NULL);\n\n\tskb_queue_head_init(&audit_queue);\n\tskb_queue_head_init(&audit_retry_queue);\n\tskb_queue_head_init(&audit_hold_queue);\n\n\tfor (i = 0; i < AUDIT_INODE_BUCKETS; i++)\n\t\tINIT_LIST_HEAD(&audit_inode_hash[i]);\n\n\tmutex_init(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = NULL;\n\n\tpr_info(\"initializing netlink subsys (%s)\\n\",\n\t\taudit_default ? \"enabled\" : \"disabled\");\n\tregister_pernet_subsys(&audit_net_ops);\n\n\taudit_initialized = AUDIT_INITIALIZED;\n\n\tkauditd_task = kthread_run(kauditd_thread, NULL, \"kauditd\");\n\tif (IS_ERR(kauditd_task)) {\n\t\tint err = PTR_ERR(kauditd_task);\n\t\tpanic(\"audit: failed to start the kauditd thread (%d)\\n\", err);\n\t}\n\n\taudit_log(NULL, GFP_KERNEL, AUDIT_KERNEL,\n\t\t\"state=initialized audit_enabled=%u res=1\",\n\t\t audit_enabled);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_INITIALIZED\t1",
      "#define AUDIT_DISABLED\t\t-1"
    ],
    "globals_used": [
      "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
      "u32\t\taudit_enabled = AUDIT_OFF;",
      "static u32\taudit_default = AUDIT_OFF;",
      "struct list_head audit_inode_hash[AUDIT_INODE_BUCKETS];",
      "static struct kmem_cache *audit_buffer_cache;",
      "static struct sk_buff_head audit_queue;",
      "static struct sk_buff_head audit_retry_queue;",
      "static struct sk_buff_head audit_hold_queue;",
      "static struct task_struct *kauditd_task;",
      "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "NULL",
            "GFP_KERNEL",
            "AUDIT_KERNEL",
            "\"state=initialized audit_enabled=%u res=1\"",
            "audit_enabled"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"audit: failed to start the kauditd thread (%d)\\n\"",
            "err"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "179-361",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kauditd_task"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kauditd_task"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "kauditd_thread",
            "NULL",
            "\"kauditd\""
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_pernet_subsys",
          "args": [
            "&audit_net_ops"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"initializing netlink subsys (%s)\\n\"",
            "audit_default ? \"enabled\" : \"disabled\""
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&audit_cmd_mutex.lock"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&audit_inode_hash[i]"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_head_init",
          "args": [
            "&audit_hold_queue"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_head_init",
          "args": [
            "&audit_retry_queue"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_head_init",
          "args": [
            "&audit_queue"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"audit_buffer\"",
            "sizeof(struct audit_buffer)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n#define AUDIT_DISABLED\t\t-1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nu32\t\taudit_enabled = AUDIT_OFF;\nstatic u32\taudit_default = AUDIT_OFF;\nstruct list_head audit_inode_hash[AUDIT_INODE_BUCKETS];\nstatic struct kmem_cache *audit_buffer_cache;\nstatic struct sk_buff_head audit_queue;\nstatic struct sk_buff_head audit_retry_queue;\nstatic struct sk_buff_head audit_hold_queue;\nstatic struct task_struct *kauditd_task;\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstatic int __init audit_init(void)\n{\n\tint i;\n\n\tif (audit_initialized == AUDIT_DISABLED)\n\t\treturn 0;\n\n\taudit_buffer_cache = kmem_cache_create(\"audit_buffer\",\n\t\t\t\t\t       sizeof(struct audit_buffer),\n\t\t\t\t\t       0, SLAB_PANIC, NULL);\n\n\tskb_queue_head_init(&audit_queue);\n\tskb_queue_head_init(&audit_retry_queue);\n\tskb_queue_head_init(&audit_hold_queue);\n\n\tfor (i = 0; i < AUDIT_INODE_BUCKETS; i++)\n\t\tINIT_LIST_HEAD(&audit_inode_hash[i]);\n\n\tmutex_init(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = NULL;\n\n\tpr_info(\"initializing netlink subsys (%s)\\n\",\n\t\taudit_default ? \"enabled\" : \"disabled\");\n\tregister_pernet_subsys(&audit_net_ops);\n\n\taudit_initialized = AUDIT_INITIALIZED;\n\n\tkauditd_task = kthread_run(kauditd_thread, NULL, \"kauditd\");\n\tif (IS_ERR(kauditd_task)) {\n\t\tint err = PTR_ERR(kauditd_task);\n\t\tpanic(\"audit: failed to start the kauditd thread (%d)\\n\", err);\n\t}\n\n\taudit_log(NULL, GFP_KERNEL, AUDIT_KERNEL,\n\t\t\"state=initialized audit_enabled=%u res=1\",\n\t\t audit_enabled);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_net_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1630-1641",
    "snippet": "static void __net_exit audit_net_exit(struct net *net)\n{\n\tstruct audit_net *aunet = net_generic(net, audit_net_id);\n\n\t/* NOTE: you would think that we would want to check the auditd\n\t * connection and potentially reset it here if it lives in this\n\t * namespace, but since the auditd connection tracking struct holds a\n\t * reference to this namespace (see auditd_set()) we are only ever\n\t * going to get here after that connection has been released */\n\n\tnetlink_kernel_release(aunet->sk);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int audit_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlink_kernel_release",
          "args": [
            "aunet->sk"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "audit_net_id"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic void __net_exit audit_net_exit(struct net *net)\n{\n\tstruct audit_net *aunet = net_generic(net, audit_net_id);\n\n\t/* NOTE: you would think that we would want to check the auditd\n\t * connection and potentially reset it here if it lives in this\n\t * namespace, but since the auditd connection tracking struct holds a\n\t * reference to this namespace (see auditd_set()) we are only ever\n\t * going to get here after that connection has been released */\n\n\tnetlink_kernel_release(aunet->sk);\n}"
  },
  {
    "function_name": "audit_net_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1607-1628",
    "snippet": "static int __net_init audit_net_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= audit_receive,\n\t\t.bind\t= audit_multicast_bind,\n\t\t.unbind\t= audit_multicast_unbind,\n\t\t.flags\t= NL_CFG_F_NONROOT_RECV,\n\t\t.groups\t= AUDIT_NLGRP_MAX,\n\t};\n\n\tstruct audit_net *aunet = net_generic(net, audit_net_id);\n\n\taunet->sk = netlink_kernel_create(net, NETLINK_AUDIT, &cfg);\n\tif (aunet->sk == NULL) {\n\t\taudit_panic(\"cannot initialize netlink socket in namespace\");\n\t\treturn -ENOMEM;\n\t}\n\t/* limit the timeout in case auditd is blocked/stopped */\n\taunet->sk->sk_sndtimeo = HZ / 10;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int audit_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"cannot initialize netlink socket in namespace\""
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "302-315",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_kernel_create",
          "args": [
            "net",
            "NETLINK_AUDIT",
            "&cfg"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "audit_net_id"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic int __net_init audit_net_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= audit_receive,\n\t\t.bind\t= audit_multicast_bind,\n\t\t.unbind\t= audit_multicast_unbind,\n\t\t.flags\t= NL_CFG_F_NONROOT_RECV,\n\t\t.groups\t= AUDIT_NLGRP_MAX,\n\t};\n\n\tstruct audit_net *aunet = net_generic(net, audit_net_id);\n\n\taunet->sk = netlink_kernel_create(net, NETLINK_AUDIT, &cfg);\n\tif (aunet->sk == NULL) {\n\t\taudit_panic(\"cannot initialize netlink socket in namespace\");\n\t\treturn -ENOMEM;\n\t}\n\t/* limit the timeout in case auditd is blocked/stopped */\n\taunet->sk->sk_sndtimeo = HZ / 10;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_multicast_unbind",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1602-1605",
    "snippet": "static void audit_multicast_unbind(struct net *net, int group)\n{\n\taudit_log_multicast(group, \"disconnect\", 0);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_multicast",
          "args": [
            "group",
            "\"disconnect\"",
            "0"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_multicast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1560-1589",
          "snippet": "static void audit_log_multicast(int group, const char *op, int err)\n{\n\tconst struct cred *cred;\n\tstruct tty_struct *tty;\n\tchar comm[sizeof(current->comm)];\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_EVENT_LISTENER);\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab, \"pid=%u uid=%u auid=%u tty=%s ses=%u\",\n\t\t\t task_pid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_task_context(ab); /* subj= */\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm); /* exe= */\n\taudit_log_format(ab, \" nl-mcgrp=%d op=%s res=%d\", group, op, !err);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic void audit_log_multicast(int group, const char *op, int err)\n{\n\tconst struct cred *cred;\n\tstruct tty_struct *tty;\n\tchar comm[sizeof(current->comm)];\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_EVENT_LISTENER);\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab, \"pid=%u uid=%u auid=%u tty=%s ses=%u\",\n\t\t\t task_pid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_task_context(ab); /* subj= */\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm); /* exe= */\n\taudit_log_format(ab, \" nl-mcgrp=%d op=%s res=%d\", group, op, !err);\n\taudit_log_end(ab);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_multicast_unbind(struct net *net, int group)\n{\n\taudit_log_multicast(group, \"disconnect\", 0);\n}"
  },
  {
    "function_name": "audit_multicast_bind",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1592-1600",
    "snippet": "static int audit_multicast_bind(struct net *net, int group)\n{\n\tint err = 0;\n\n\tif (!capable(CAP_AUDIT_READ))\n\t\terr = -EPERM;\n\taudit_log_multicast(group, \"connect\", err);\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_multicast",
          "args": [
            "group",
            "\"connect\"",
            "err"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_multicast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1560-1589",
          "snippet": "static void audit_log_multicast(int group, const char *op, int err)\n{\n\tconst struct cred *cred;\n\tstruct tty_struct *tty;\n\tchar comm[sizeof(current->comm)];\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_EVENT_LISTENER);\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab, \"pid=%u uid=%u auid=%u tty=%s ses=%u\",\n\t\t\t task_pid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_task_context(ab); /* subj= */\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm); /* exe= */\n\taudit_log_format(ab, \" nl-mcgrp=%d op=%s res=%d\", group, op, !err);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic void audit_log_multicast(int group, const char *op, int err)\n{\n\tconst struct cred *cred;\n\tstruct tty_struct *tty;\n\tchar comm[sizeof(current->comm)];\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_EVENT_LISTENER);\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab, \"pid=%u uid=%u auid=%u tty=%s ses=%u\",\n\t\t\t task_pid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_task_context(ab); /* subj= */\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm); /* exe= */\n\taudit_log_format(ab, \" nl-mcgrp=%d op=%s res=%d\", group, op, !err);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_AUDIT_READ"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_multicast_bind(struct net *net, int group)\n{\n\tint err = 0;\n\n\tif (!capable(CAP_AUDIT_READ))\n\t\terr = -EPERM;\n\taudit_log_multicast(group, \"connect\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "audit_log_multicast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1560-1589",
    "snippet": "static void audit_log_multicast(int group, const char *op, int err)\n{\n\tconst struct cred *cred;\n\tstruct tty_struct *tty;\n\tchar comm[sizeof(current->comm)];\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_EVENT_LISTENER);\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab, \"pid=%u uid=%u auid=%u tty=%s ses=%u\",\n\t\t\t task_pid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_task_context(ab); /* subj= */\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm); /* exe= */\n\taudit_log_format(ab, \" nl-mcgrp=%d op=%s res=%d\", group, op, !err);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" nl-mcgrp=%d op=%s res=%d\"",
            "group",
            "op",
            "!err"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_d_path_exe",
          "args": [
            "ab",
            "current->mm"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path_exe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2171-2188",
          "snippet": "void audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "get_task_comm(comm, current)"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "comm",
            "current"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2143-2168",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_tty",
          "args": [
            "tty"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2202-2205",
          "snippet": "void audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tty_name",
          "args": [
            "tty"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "audit_get_loginuid(current)"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_tty",
          "args": [],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_tty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2190-2200",
          "snippet": "struct tty_struct *audit_get_tty(void)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tif (current->signal)\n\t\ttty = tty_kref_get(current->signal->tty);\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\treturn tty;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct tty_struct *audit_get_tty(void)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tif (current->signal)\n\t\ttty = tty_kref_get(current->signal->tty);\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\treturn tty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_EVENT_LISTENER"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic void audit_log_multicast(int group, const char *op, int err)\n{\n\tconst struct cred *cred;\n\tstruct tty_struct *tty;\n\tchar comm[sizeof(current->comm)];\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_EVENT_LISTENER);\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab, \"pid=%u uid=%u auid=%u tty=%s ses=%u\",\n\t\t\t task_pid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_task_context(ab); /* subj= */\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm); /* exe= */\n\taudit_log_format(ab, \" nl-mcgrp=%d op=%s res=%d\", group, op, !err);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_receive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1520-1557",
    "snippet": "static void audit_receive(struct sk_buff  *skb)\n{\n\tstruct nlmsghdr *nlh;\n\t/*\n\t * len MUST be signed for nlmsg_next to be able to dec it below 0\n\t * if the nlmsg_len was not aligned\n\t */\n\tint len;\n\tint err;\n\n\tnlh = nlmsg_hdr(skb);\n\tlen = skb->len;\n\n\taudit_ctl_lock();\n\twhile (nlmsg_ok(nlh, len)) {\n\t\terr = audit_receive_msg(skb, nlh);\n\t\t/* if err or if this message says it wants a response */\n\t\tif (err || (nlh->nlmsg_flags & NLM_F_ACK))\n\t\t\tnetlink_ack(skb, nlh, err, NULL);\n\n\t\tnlh = nlmsg_next(nlh, &len);\n\t}\n\taudit_ctl_unlock();\n\n\t/* can't block with the ctrl lock, so penalize the sender now */\n\tif (audit_backlog_limit &&\n\t    (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t/* wake kauditd to try and flush the queue */\n\t\twake_up_interruptible(&kauditd_wait);\n\n\t\tadd_wait_queue_exclusive(&audit_backlog_wait, &wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(audit_backlog_wait_time);\n\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_backlog_limit = 64;",
      "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
      "static struct sk_buff_head audit_queue;",
      "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
      "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&audit_backlog_wait",
            "&wait"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "remove_wait_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "51-58",
          "snippet": "void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "audit_backlog_wait_time"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_timeout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8396-8406",
          "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue_exclusive",
          "args": [
            "&audit_backlog_wait",
            "&wait"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "add_wait_queue_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "29-37",
          "snippet": "void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&kauditd_wait"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_len",
          "args": [
            "&audit_queue"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ctl_unlock",
          "args": [],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "243-247",
          "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_next",
          "args": [
            "nlh",
            "&len"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_ack",
          "args": [
            "skb",
            "nlh",
            "err",
            "NULL"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_receive_msg",
          "args": [
            "skb",
            "nlh"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "audit_receive_msg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1182-1511",
          "snippet": "static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tu32\t\t\tseq;\n\tvoid\t\t\t*data;\n\tint\t\t\tdata_len;\n\tint\t\t\terr;\n\tstruct audit_buffer\t*ab;\n\tu16\t\t\tmsg_type = nlh->nlmsg_type;\n\tstruct audit_sig_info   *sig_data;\n\tchar\t\t\t*ctx = NULL;\n\tu32\t\t\tlen;\n\n\terr = audit_netlink_ok(skb, msg_type);\n\tif (err)\n\t\treturn err;\n\n\tseq  = nlh->nlmsg_seq;\n\tdata = nlmsg_data(nlh);\n\tdata_len = nlmsg_len(nlh);\n\n\tswitch (msg_type) {\n\tcase AUDIT_GET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\ts.enabled\t\t   = audit_enabled;\n\t\ts.failure\t\t   = audit_failure;\n\t\t/* NOTE: use pid_vnr() so the PID is relative to the current\n\t\t *       namespace */\n\t\ts.pid\t\t\t   = auditd_pid_vnr();\n\t\ts.rate_limit\t\t   = audit_rate_limit;\n\t\ts.backlog_limit\t\t   = audit_backlog_limit;\n\t\ts.lost\t\t\t   = atomic_read(&audit_lost);\n\t\ts.backlog\t\t   = skb_queue_len(&audit_queue);\n\t\ts.feature_bitmap\t   = AUDIT_FEATURE_BITMAP_ALL;\n\t\ts.backlog_wait_time\t   = audit_backlog_wait_time;\n\t\ts.backlog_wait_time_actual = atomic_read(&audit_backlog_wait_time_actual);\n\t\taudit_send_reply(skb, seq, AUDIT_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_SET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), data_len));\n\t\tif (s.mask & AUDIT_STATUS_ENABLED) {\n\t\t\terr = audit_set_enabled(s.enabled);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_FAILURE) {\n\t\t\terr = audit_set_failure(s.failure);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_PID) {\n\t\t\t/* NOTE: we are using the vnr PID functions below\n\t\t\t *       because the s.pid value is relative to the\n\t\t\t *       namespace of the caller; at present this\n\t\t\t *       doesn't matter much since you can really only\n\t\t\t *       run auditd from the initial pid namespace, but\n\t\t\t *       something to keep in mind if this changes */\n\t\t\tpid_t new_pid = s.pid;\n\t\t\tpid_t auditd_pid;\n\t\t\tstruct pid *req_pid = task_tgid(current);\n\n\t\t\t/* Sanity check - PID values must match. Setting\n\t\t\t * pid to 0 is how auditd ends auditing. */\n\t\t\tif (new_pid && (new_pid != pid_vnr(req_pid)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* test the auditd connection */\n\t\t\taudit_replace(req_pid);\n\n\t\t\tauditd_pid = auditd_pid_vnr();\n\t\t\tif (auditd_pid) {\n\t\t\t\t/* replacing a healthy auditd is not allowed */\n\t\t\t\tif (new_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\t/* only current auditd can unregister itself */\n\t\t\t\tif (pid_vnr(req_pid) != auditd_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (new_pid) {\n\t\t\t\t/* register a new auditd connection */\n\t\t\t\terr = auditd_set(req_pid,\n\t\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t\t sock_net(NETLINK_CB(skb).sk));\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid,\n\t\t\t\t\t\t\t\terr ? 0 : 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* try to process any backlog */\n\t\t\t\twake_up_interruptible(&kauditd_wait);\n\t\t\t} else {\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid, 1);\n\n\t\t\t\t/* unregister the auditd connection */\n\t\t\t\tauditd_reset(NULL);\n\t\t\t}\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_RATE_LIMIT) {\n\t\t\terr = audit_set_rate_limit(s.rate_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_LIMIT) {\n\t\t\terr = audit_set_backlog_limit(s.backlog_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_WAIT_TIME) {\n\t\t\tif (sizeof(s) > (size_t)nlh->nlmsg_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (s.backlog_wait_time > 10*AUDIT_BACKLOG_WAIT_TIME)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = audit_set_backlog_wait_time(s.backlog_wait_time);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_LOST) {\n\t\t\tu32 lost = atomic_xchg(&audit_lost, 0);\n\n\t\t\taudit_log_config_change(\"lost\", 0, lost, 1);\n\t\t\treturn lost;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_BACKLOG_WAIT_TIME_ACTUAL) {\n\t\t\tu32 actual = atomic_xchg(&audit_backlog_wait_time_actual, 0);\n\n\t\t\taudit_log_config_change(\"backlog_wait_time_actual\", 0, actual, 1);\n\t\t\treturn actual;\n\t\t}\n\t\tbreak;\n\t}\n\tcase AUDIT_GET_FEATURE:\n\t\terr = audit_get_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_SET_FEATURE:\n\t\tif (data_len < sizeof(struct audit_features))\n\t\t\treturn -EINVAL;\n\t\terr = audit_set_feature(data);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!audit_enabled && msg_type != AUDIT_USER_AVC)\n\t\t\treturn 0;\n\t\t/* exit early if there isn't at least one character to print */\n\t\tif (data_len < 2)\n\t\t\treturn -EINVAL;\n\n\t\terr = audit_filter(msg_type, AUDIT_FILTER_USER);\n\t\tif (err == 1) { /* match or error */\n\t\t\tchar *str = data;\n\n\t\t\terr = 0;\n\t\t\tif (msg_type == AUDIT_USER_TTY) {\n\t\t\t\terr = tty_audit_push();\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\taudit_log_user_recv_msg(&ab, msg_type);\n\t\t\tif (msg_type != AUDIT_USER_TTY) {\n\t\t\t\t/* ensure NULL termination */\n\t\t\t\tstr[data_len - 1] = '\\0';\n\t\t\t\taudit_log_format(ab, \" msg='%.*s'\",\n\t\t\t\t\t\t AUDIT_MESSAGE_TEXT_MAX,\n\t\t\t\t\t\t str);\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" data=\");\n\t\t\t\tif (data_len > 0 && str[data_len - 1] == '\\0')\n\t\t\t\t\tdata_len--;\n\t\t\t\taudit_log_n_untrustedstring(ab, str, data_len);\n\t\t\t}\n\t\t\taudit_log_end(ab);\n\t\t}\n\t\tbreak;\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\t\tif (data_len < sizeof(struct audit_rule_data))\n\t\t\treturn -EINVAL;\n\t\tif (audit_enabled == AUDIT_LOCKED) {\n\t\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\t\taudit_log_format(ab, \" op=%s audit_enabled=%d res=0\",\n\t\t\t\t\t msg_type == AUDIT_ADD_RULE ?\n\t\t\t\t\t\t\"add_rule\" : \"remove_rule\",\n\t\t\t\t\t audit_enabled);\n\t\t\taudit_log_end(ab);\n\t\t\treturn -EPERM;\n\t\t}\n\t\terr = audit_rule_change(msg_type, seq, data, data_len);\n\t\tbreak;\n\tcase AUDIT_LIST_RULES:\n\t\terr = audit_list_rules_send(skb, seq);\n\t\tbreak;\n\tcase AUDIT_TRIM:\n\t\taudit_trim_trees();\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=trim res=1\");\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_MAKE_EQUIV: {\n\t\tvoid *bufp = data;\n\t\tu32 sizes[2];\n\t\tsize_t msglen = data_len;\n\t\tchar *old, *new;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < 2 * sizeof(u32))\n\t\t\tbreak;\n\t\tmemcpy(sizes, bufp, 2 * sizeof(u32));\n\t\tbufp += 2 * sizeof(u32);\n\t\tmsglen -= 2 * sizeof(u32);\n\t\told = audit_unpack_string(&bufp, &msglen, sizes[0]);\n\t\tif (IS_ERR(old)) {\n\t\t\terr = PTR_ERR(old);\n\t\t\tbreak;\n\t\t}\n\t\tnew = audit_unpack_string(&bufp, &msglen, sizes[1]);\n\t\tif (IS_ERR(new)) {\n\t\t\terr = PTR_ERR(new);\n\t\t\tkfree(old);\n\t\t\tbreak;\n\t\t}\n\t\t/* OK, here comes... */\n\t\terr = audit_tag_tree(old, new);\n\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=make_equiv old=\");\n\t\taudit_log_untrustedstring(ab, old);\n\t\taudit_log_format(ab, \" new=\");\n\t\taudit_log_untrustedstring(ab, new);\n\t\taudit_log_format(ab, \" res=%d\", !err);\n\t\taudit_log_end(ab);\n\t\tkfree(old);\n\t\tkfree(new);\n\t\tbreak;\n\t}\n\tcase AUDIT_SIGNAL_INFO:\n\t\tlen = 0;\n\t\tif (audit_sig_sid) {\n\t\t\terr = security_secid_to_secctx(audit_sig_sid, &ctx, &len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsig_data = kmalloc(struct_size(sig_data, ctx, len), GFP_KERNEL);\n\t\tif (!sig_data) {\n\t\t\tif (audit_sig_sid)\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);\n\t\tsig_data->pid = audit_sig_pid;\n\t\tif (audit_sig_sid) {\n\t\t\tmemcpy(sig_data->ctx, ctx, len);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t\taudit_send_reply(skb, seq, AUDIT_SIGNAL_INFO, 0, 0,\n\t\t\t\t sig_data, struct_size(sig_data, ctx, len));\n\t\tkfree(sig_data);\n\t\tbreak;\n\tcase AUDIT_TTY_GET: {\n\t\tstruct audit_tty_status s;\n\t\tunsigned int t;\n\n\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\ts.enabled = t & AUDIT_TTY_ENABLE;\n\t\ts.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_send_reply(skb, seq, AUDIT_TTY_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_TTY_SET: {\n\t\tstruct audit_tty_status s, old;\n\t\tstruct audit_buffer\t*ab;\n\t\tunsigned int t;\n\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), data_len));\n\t\t/* check if new data is valid */\n\t\tif ((s.enabled != 0 && s.enabled != 1) ||\n\t\t    (s.log_passwd != 0 && s.log_passwd != 1))\n\t\t\terr = -EINVAL;\n\n\t\tif (err)\n\t\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\telse {\n\t\t\tt = s.enabled | (-s.log_passwd & AUDIT_TTY_LOG_PASSWD);\n\t\t\tt = xchg(&current->signal->audit_tty, t);\n\t\t}\n\t\told.enabled = t & AUDIT_TTY_ENABLE;\n\t\told.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=tty_set old-enabled=%d new-enabled=%d\"\n\t\t\t\t \" old-log_passwd=%d new-log_passwd=%d res=%d\",\n\t\t\t\t old.enabled, s.enabled, old.log_passwd,\n\t\t\t\t s.log_passwd, !err);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err < 0 ? err : 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BACKLOG_WAIT_TIME (60 * HZ)"
          ],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;",
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static kuid_t\t\taudit_sig_uid = INVALID_UID;",
            "static pid_t\t\taudit_sig_pid = -1;",
            "static u32\t\taudit_sig_sid;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BACKLOG_WAIT_TIME (60 * HZ)\n\nu32\t\taudit_enabled = AUDIT_OFF;\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic kuid_t\t\taudit_sig_uid = INVALID_UID;\nstatic pid_t\t\taudit_sig_pid = -1;\nstatic u32\t\taudit_sig_sid;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nstatic int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tu32\t\t\tseq;\n\tvoid\t\t\t*data;\n\tint\t\t\tdata_len;\n\tint\t\t\terr;\n\tstruct audit_buffer\t*ab;\n\tu16\t\t\tmsg_type = nlh->nlmsg_type;\n\tstruct audit_sig_info   *sig_data;\n\tchar\t\t\t*ctx = NULL;\n\tu32\t\t\tlen;\n\n\terr = audit_netlink_ok(skb, msg_type);\n\tif (err)\n\t\treturn err;\n\n\tseq  = nlh->nlmsg_seq;\n\tdata = nlmsg_data(nlh);\n\tdata_len = nlmsg_len(nlh);\n\n\tswitch (msg_type) {\n\tcase AUDIT_GET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\ts.enabled\t\t   = audit_enabled;\n\t\ts.failure\t\t   = audit_failure;\n\t\t/* NOTE: use pid_vnr() so the PID is relative to the current\n\t\t *       namespace */\n\t\ts.pid\t\t\t   = auditd_pid_vnr();\n\t\ts.rate_limit\t\t   = audit_rate_limit;\n\t\ts.backlog_limit\t\t   = audit_backlog_limit;\n\t\ts.lost\t\t\t   = atomic_read(&audit_lost);\n\t\ts.backlog\t\t   = skb_queue_len(&audit_queue);\n\t\ts.feature_bitmap\t   = AUDIT_FEATURE_BITMAP_ALL;\n\t\ts.backlog_wait_time\t   = audit_backlog_wait_time;\n\t\ts.backlog_wait_time_actual = atomic_read(&audit_backlog_wait_time_actual);\n\t\taudit_send_reply(skb, seq, AUDIT_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_SET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), data_len));\n\t\tif (s.mask & AUDIT_STATUS_ENABLED) {\n\t\t\terr = audit_set_enabled(s.enabled);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_FAILURE) {\n\t\t\terr = audit_set_failure(s.failure);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_PID) {\n\t\t\t/* NOTE: we are using the vnr PID functions below\n\t\t\t *       because the s.pid value is relative to the\n\t\t\t *       namespace of the caller; at present this\n\t\t\t *       doesn't matter much since you can really only\n\t\t\t *       run auditd from the initial pid namespace, but\n\t\t\t *       something to keep in mind if this changes */\n\t\t\tpid_t new_pid = s.pid;\n\t\t\tpid_t auditd_pid;\n\t\t\tstruct pid *req_pid = task_tgid(current);\n\n\t\t\t/* Sanity check - PID values must match. Setting\n\t\t\t * pid to 0 is how auditd ends auditing. */\n\t\t\tif (new_pid && (new_pid != pid_vnr(req_pid)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* test the auditd connection */\n\t\t\taudit_replace(req_pid);\n\n\t\t\tauditd_pid = auditd_pid_vnr();\n\t\t\tif (auditd_pid) {\n\t\t\t\t/* replacing a healthy auditd is not allowed */\n\t\t\t\tif (new_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\t/* only current auditd can unregister itself */\n\t\t\t\tif (pid_vnr(req_pid) != auditd_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (new_pid) {\n\t\t\t\t/* register a new auditd connection */\n\t\t\t\terr = auditd_set(req_pid,\n\t\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t\t sock_net(NETLINK_CB(skb).sk));\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid,\n\t\t\t\t\t\t\t\terr ? 0 : 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* try to process any backlog */\n\t\t\t\twake_up_interruptible(&kauditd_wait);\n\t\t\t} else {\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid, 1);\n\n\t\t\t\t/* unregister the auditd connection */\n\t\t\t\tauditd_reset(NULL);\n\t\t\t}\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_RATE_LIMIT) {\n\t\t\terr = audit_set_rate_limit(s.rate_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_LIMIT) {\n\t\t\terr = audit_set_backlog_limit(s.backlog_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_WAIT_TIME) {\n\t\t\tif (sizeof(s) > (size_t)nlh->nlmsg_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (s.backlog_wait_time > 10*AUDIT_BACKLOG_WAIT_TIME)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = audit_set_backlog_wait_time(s.backlog_wait_time);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_LOST) {\n\t\t\tu32 lost = atomic_xchg(&audit_lost, 0);\n\n\t\t\taudit_log_config_change(\"lost\", 0, lost, 1);\n\t\t\treturn lost;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_BACKLOG_WAIT_TIME_ACTUAL) {\n\t\t\tu32 actual = atomic_xchg(&audit_backlog_wait_time_actual, 0);\n\n\t\t\taudit_log_config_change(\"backlog_wait_time_actual\", 0, actual, 1);\n\t\t\treturn actual;\n\t\t}\n\t\tbreak;\n\t}\n\tcase AUDIT_GET_FEATURE:\n\t\terr = audit_get_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_SET_FEATURE:\n\t\tif (data_len < sizeof(struct audit_features))\n\t\t\treturn -EINVAL;\n\t\terr = audit_set_feature(data);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!audit_enabled && msg_type != AUDIT_USER_AVC)\n\t\t\treturn 0;\n\t\t/* exit early if there isn't at least one character to print */\n\t\tif (data_len < 2)\n\t\t\treturn -EINVAL;\n\n\t\terr = audit_filter(msg_type, AUDIT_FILTER_USER);\n\t\tif (err == 1) { /* match or error */\n\t\t\tchar *str = data;\n\n\t\t\terr = 0;\n\t\t\tif (msg_type == AUDIT_USER_TTY) {\n\t\t\t\terr = tty_audit_push();\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\taudit_log_user_recv_msg(&ab, msg_type);\n\t\t\tif (msg_type != AUDIT_USER_TTY) {\n\t\t\t\t/* ensure NULL termination */\n\t\t\t\tstr[data_len - 1] = '\\0';\n\t\t\t\taudit_log_format(ab, \" msg='%.*s'\",\n\t\t\t\t\t\t AUDIT_MESSAGE_TEXT_MAX,\n\t\t\t\t\t\t str);\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" data=\");\n\t\t\t\tif (data_len > 0 && str[data_len - 1] == '\\0')\n\t\t\t\t\tdata_len--;\n\t\t\t\taudit_log_n_untrustedstring(ab, str, data_len);\n\t\t\t}\n\t\t\taudit_log_end(ab);\n\t\t}\n\t\tbreak;\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\t\tif (data_len < sizeof(struct audit_rule_data))\n\t\t\treturn -EINVAL;\n\t\tif (audit_enabled == AUDIT_LOCKED) {\n\t\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\t\taudit_log_format(ab, \" op=%s audit_enabled=%d res=0\",\n\t\t\t\t\t msg_type == AUDIT_ADD_RULE ?\n\t\t\t\t\t\t\"add_rule\" : \"remove_rule\",\n\t\t\t\t\t audit_enabled);\n\t\t\taudit_log_end(ab);\n\t\t\treturn -EPERM;\n\t\t}\n\t\terr = audit_rule_change(msg_type, seq, data, data_len);\n\t\tbreak;\n\tcase AUDIT_LIST_RULES:\n\t\terr = audit_list_rules_send(skb, seq);\n\t\tbreak;\n\tcase AUDIT_TRIM:\n\t\taudit_trim_trees();\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=trim res=1\");\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_MAKE_EQUIV: {\n\t\tvoid *bufp = data;\n\t\tu32 sizes[2];\n\t\tsize_t msglen = data_len;\n\t\tchar *old, *new;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < 2 * sizeof(u32))\n\t\t\tbreak;\n\t\tmemcpy(sizes, bufp, 2 * sizeof(u32));\n\t\tbufp += 2 * sizeof(u32);\n\t\tmsglen -= 2 * sizeof(u32);\n\t\told = audit_unpack_string(&bufp, &msglen, sizes[0]);\n\t\tif (IS_ERR(old)) {\n\t\t\terr = PTR_ERR(old);\n\t\t\tbreak;\n\t\t}\n\t\tnew = audit_unpack_string(&bufp, &msglen, sizes[1]);\n\t\tif (IS_ERR(new)) {\n\t\t\terr = PTR_ERR(new);\n\t\t\tkfree(old);\n\t\t\tbreak;\n\t\t}\n\t\t/* OK, here comes... */\n\t\terr = audit_tag_tree(old, new);\n\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=make_equiv old=\");\n\t\taudit_log_untrustedstring(ab, old);\n\t\taudit_log_format(ab, \" new=\");\n\t\taudit_log_untrustedstring(ab, new);\n\t\taudit_log_format(ab, \" res=%d\", !err);\n\t\taudit_log_end(ab);\n\t\tkfree(old);\n\t\tkfree(new);\n\t\tbreak;\n\t}\n\tcase AUDIT_SIGNAL_INFO:\n\t\tlen = 0;\n\t\tif (audit_sig_sid) {\n\t\t\terr = security_secid_to_secctx(audit_sig_sid, &ctx, &len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsig_data = kmalloc(struct_size(sig_data, ctx, len), GFP_KERNEL);\n\t\tif (!sig_data) {\n\t\t\tif (audit_sig_sid)\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);\n\t\tsig_data->pid = audit_sig_pid;\n\t\tif (audit_sig_sid) {\n\t\t\tmemcpy(sig_data->ctx, ctx, len);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t\taudit_send_reply(skb, seq, AUDIT_SIGNAL_INFO, 0, 0,\n\t\t\t\t sig_data, struct_size(sig_data, ctx, len));\n\t\tkfree(sig_data);\n\t\tbreak;\n\tcase AUDIT_TTY_GET: {\n\t\tstruct audit_tty_status s;\n\t\tunsigned int t;\n\n\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\ts.enabled = t & AUDIT_TTY_ENABLE;\n\t\ts.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_send_reply(skb, seq, AUDIT_TTY_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_TTY_SET: {\n\t\tstruct audit_tty_status s, old;\n\t\tstruct audit_buffer\t*ab;\n\t\tunsigned int t;\n\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), data_len));\n\t\t/* check if new data is valid */\n\t\tif ((s.enabled != 0 && s.enabled != 1) ||\n\t\t    (s.log_passwd != 0 && s.log_passwd != 1))\n\t\t\terr = -EINVAL;\n\n\t\tif (err)\n\t\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\telse {\n\t\t\tt = s.enabled | (-s.log_passwd & AUDIT_TTY_LOG_PASSWD);\n\t\t\tt = xchg(&current->signal->audit_tty, t);\n\t\t}\n\t\told.enabled = t & AUDIT_TTY_ENABLE;\n\t\told.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=tty_set old-enabled=%d new-enabled=%d\"\n\t\t\t\t \" old-log_passwd=%d new-log_passwd=%d res=%d\",\n\t\t\t\t old.enabled, s.enabled, old.log_passwd,\n\t\t\t\t s.log_passwd, !err);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err < 0 ? err : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_ok",
          "args": [
            "nlh",
            "len"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ctl_lock",
          "args": [],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "234-238",
          "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "skb"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\n\nstatic void audit_receive(struct sk_buff  *skb)\n{\n\tstruct nlmsghdr *nlh;\n\t/*\n\t * len MUST be signed for nlmsg_next to be able to dec it below 0\n\t * if the nlmsg_len was not aligned\n\t */\n\tint len;\n\tint err;\n\n\tnlh = nlmsg_hdr(skb);\n\tlen = skb->len;\n\n\taudit_ctl_lock();\n\twhile (nlmsg_ok(nlh, len)) {\n\t\terr = audit_receive_msg(skb, nlh);\n\t\t/* if err or if this message says it wants a response */\n\t\tif (err || (nlh->nlmsg_flags & NLM_F_ACK))\n\t\t\tnetlink_ack(skb, nlh, err, NULL);\n\n\t\tnlh = nlmsg_next(nlh, &len);\n\t}\n\taudit_ctl_unlock();\n\n\t/* can't block with the ctrl lock, so penalize the sender now */\n\tif (audit_backlog_limit &&\n\t    (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t/* wake kauditd to try and flush the queue */\n\t\twake_up_interruptible(&kauditd_wait);\n\n\t\tadd_wait_queue_exclusive(&audit_backlog_wait, &wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(audit_backlog_wait_time);\n\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t}\n}"
  },
  {
    "function_name": "audit_receive_msg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1182-1511",
    "snippet": "static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tu32\t\t\tseq;\n\tvoid\t\t\t*data;\n\tint\t\t\tdata_len;\n\tint\t\t\terr;\n\tstruct audit_buffer\t*ab;\n\tu16\t\t\tmsg_type = nlh->nlmsg_type;\n\tstruct audit_sig_info   *sig_data;\n\tchar\t\t\t*ctx = NULL;\n\tu32\t\t\tlen;\n\n\terr = audit_netlink_ok(skb, msg_type);\n\tif (err)\n\t\treturn err;\n\n\tseq  = nlh->nlmsg_seq;\n\tdata = nlmsg_data(nlh);\n\tdata_len = nlmsg_len(nlh);\n\n\tswitch (msg_type) {\n\tcase AUDIT_GET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\ts.enabled\t\t   = audit_enabled;\n\t\ts.failure\t\t   = audit_failure;\n\t\t/* NOTE: use pid_vnr() so the PID is relative to the current\n\t\t *       namespace */\n\t\ts.pid\t\t\t   = auditd_pid_vnr();\n\t\ts.rate_limit\t\t   = audit_rate_limit;\n\t\ts.backlog_limit\t\t   = audit_backlog_limit;\n\t\ts.lost\t\t\t   = atomic_read(&audit_lost);\n\t\ts.backlog\t\t   = skb_queue_len(&audit_queue);\n\t\ts.feature_bitmap\t   = AUDIT_FEATURE_BITMAP_ALL;\n\t\ts.backlog_wait_time\t   = audit_backlog_wait_time;\n\t\ts.backlog_wait_time_actual = atomic_read(&audit_backlog_wait_time_actual);\n\t\taudit_send_reply(skb, seq, AUDIT_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_SET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), data_len));\n\t\tif (s.mask & AUDIT_STATUS_ENABLED) {\n\t\t\terr = audit_set_enabled(s.enabled);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_FAILURE) {\n\t\t\terr = audit_set_failure(s.failure);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_PID) {\n\t\t\t/* NOTE: we are using the vnr PID functions below\n\t\t\t *       because the s.pid value is relative to the\n\t\t\t *       namespace of the caller; at present this\n\t\t\t *       doesn't matter much since you can really only\n\t\t\t *       run auditd from the initial pid namespace, but\n\t\t\t *       something to keep in mind if this changes */\n\t\t\tpid_t new_pid = s.pid;\n\t\t\tpid_t auditd_pid;\n\t\t\tstruct pid *req_pid = task_tgid(current);\n\n\t\t\t/* Sanity check - PID values must match. Setting\n\t\t\t * pid to 0 is how auditd ends auditing. */\n\t\t\tif (new_pid && (new_pid != pid_vnr(req_pid)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* test the auditd connection */\n\t\t\taudit_replace(req_pid);\n\n\t\t\tauditd_pid = auditd_pid_vnr();\n\t\t\tif (auditd_pid) {\n\t\t\t\t/* replacing a healthy auditd is not allowed */\n\t\t\t\tif (new_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\t/* only current auditd can unregister itself */\n\t\t\t\tif (pid_vnr(req_pid) != auditd_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (new_pid) {\n\t\t\t\t/* register a new auditd connection */\n\t\t\t\terr = auditd_set(req_pid,\n\t\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t\t sock_net(NETLINK_CB(skb).sk));\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid,\n\t\t\t\t\t\t\t\terr ? 0 : 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* try to process any backlog */\n\t\t\t\twake_up_interruptible(&kauditd_wait);\n\t\t\t} else {\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid, 1);\n\n\t\t\t\t/* unregister the auditd connection */\n\t\t\t\tauditd_reset(NULL);\n\t\t\t}\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_RATE_LIMIT) {\n\t\t\terr = audit_set_rate_limit(s.rate_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_LIMIT) {\n\t\t\terr = audit_set_backlog_limit(s.backlog_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_WAIT_TIME) {\n\t\t\tif (sizeof(s) > (size_t)nlh->nlmsg_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (s.backlog_wait_time > 10*AUDIT_BACKLOG_WAIT_TIME)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = audit_set_backlog_wait_time(s.backlog_wait_time);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_LOST) {\n\t\t\tu32 lost = atomic_xchg(&audit_lost, 0);\n\n\t\t\taudit_log_config_change(\"lost\", 0, lost, 1);\n\t\t\treturn lost;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_BACKLOG_WAIT_TIME_ACTUAL) {\n\t\t\tu32 actual = atomic_xchg(&audit_backlog_wait_time_actual, 0);\n\n\t\t\taudit_log_config_change(\"backlog_wait_time_actual\", 0, actual, 1);\n\t\t\treturn actual;\n\t\t}\n\t\tbreak;\n\t}\n\tcase AUDIT_GET_FEATURE:\n\t\terr = audit_get_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_SET_FEATURE:\n\t\tif (data_len < sizeof(struct audit_features))\n\t\t\treturn -EINVAL;\n\t\terr = audit_set_feature(data);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!audit_enabled && msg_type != AUDIT_USER_AVC)\n\t\t\treturn 0;\n\t\t/* exit early if there isn't at least one character to print */\n\t\tif (data_len < 2)\n\t\t\treturn -EINVAL;\n\n\t\terr = audit_filter(msg_type, AUDIT_FILTER_USER);\n\t\tif (err == 1) { /* match or error */\n\t\t\tchar *str = data;\n\n\t\t\terr = 0;\n\t\t\tif (msg_type == AUDIT_USER_TTY) {\n\t\t\t\terr = tty_audit_push();\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\taudit_log_user_recv_msg(&ab, msg_type);\n\t\t\tif (msg_type != AUDIT_USER_TTY) {\n\t\t\t\t/* ensure NULL termination */\n\t\t\t\tstr[data_len - 1] = '\\0';\n\t\t\t\taudit_log_format(ab, \" msg='%.*s'\",\n\t\t\t\t\t\t AUDIT_MESSAGE_TEXT_MAX,\n\t\t\t\t\t\t str);\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" data=\");\n\t\t\t\tif (data_len > 0 && str[data_len - 1] == '\\0')\n\t\t\t\t\tdata_len--;\n\t\t\t\taudit_log_n_untrustedstring(ab, str, data_len);\n\t\t\t}\n\t\t\taudit_log_end(ab);\n\t\t}\n\t\tbreak;\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\t\tif (data_len < sizeof(struct audit_rule_data))\n\t\t\treturn -EINVAL;\n\t\tif (audit_enabled == AUDIT_LOCKED) {\n\t\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\t\taudit_log_format(ab, \" op=%s audit_enabled=%d res=0\",\n\t\t\t\t\t msg_type == AUDIT_ADD_RULE ?\n\t\t\t\t\t\t\"add_rule\" : \"remove_rule\",\n\t\t\t\t\t audit_enabled);\n\t\t\taudit_log_end(ab);\n\t\t\treturn -EPERM;\n\t\t}\n\t\terr = audit_rule_change(msg_type, seq, data, data_len);\n\t\tbreak;\n\tcase AUDIT_LIST_RULES:\n\t\terr = audit_list_rules_send(skb, seq);\n\t\tbreak;\n\tcase AUDIT_TRIM:\n\t\taudit_trim_trees();\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=trim res=1\");\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_MAKE_EQUIV: {\n\t\tvoid *bufp = data;\n\t\tu32 sizes[2];\n\t\tsize_t msglen = data_len;\n\t\tchar *old, *new;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < 2 * sizeof(u32))\n\t\t\tbreak;\n\t\tmemcpy(sizes, bufp, 2 * sizeof(u32));\n\t\tbufp += 2 * sizeof(u32);\n\t\tmsglen -= 2 * sizeof(u32);\n\t\told = audit_unpack_string(&bufp, &msglen, sizes[0]);\n\t\tif (IS_ERR(old)) {\n\t\t\terr = PTR_ERR(old);\n\t\t\tbreak;\n\t\t}\n\t\tnew = audit_unpack_string(&bufp, &msglen, sizes[1]);\n\t\tif (IS_ERR(new)) {\n\t\t\terr = PTR_ERR(new);\n\t\t\tkfree(old);\n\t\t\tbreak;\n\t\t}\n\t\t/* OK, here comes... */\n\t\terr = audit_tag_tree(old, new);\n\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=make_equiv old=\");\n\t\taudit_log_untrustedstring(ab, old);\n\t\taudit_log_format(ab, \" new=\");\n\t\taudit_log_untrustedstring(ab, new);\n\t\taudit_log_format(ab, \" res=%d\", !err);\n\t\taudit_log_end(ab);\n\t\tkfree(old);\n\t\tkfree(new);\n\t\tbreak;\n\t}\n\tcase AUDIT_SIGNAL_INFO:\n\t\tlen = 0;\n\t\tif (audit_sig_sid) {\n\t\t\terr = security_secid_to_secctx(audit_sig_sid, &ctx, &len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsig_data = kmalloc(struct_size(sig_data, ctx, len), GFP_KERNEL);\n\t\tif (!sig_data) {\n\t\t\tif (audit_sig_sid)\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);\n\t\tsig_data->pid = audit_sig_pid;\n\t\tif (audit_sig_sid) {\n\t\t\tmemcpy(sig_data->ctx, ctx, len);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t\taudit_send_reply(skb, seq, AUDIT_SIGNAL_INFO, 0, 0,\n\t\t\t\t sig_data, struct_size(sig_data, ctx, len));\n\t\tkfree(sig_data);\n\t\tbreak;\n\tcase AUDIT_TTY_GET: {\n\t\tstruct audit_tty_status s;\n\t\tunsigned int t;\n\n\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\ts.enabled = t & AUDIT_TTY_ENABLE;\n\t\ts.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_send_reply(skb, seq, AUDIT_TTY_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_TTY_SET: {\n\t\tstruct audit_tty_status s, old;\n\t\tstruct audit_buffer\t*ab;\n\t\tunsigned int t;\n\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), data_len));\n\t\t/* check if new data is valid */\n\t\tif ((s.enabled != 0 && s.enabled != 1) ||\n\t\t    (s.log_passwd != 0 && s.log_passwd != 1))\n\t\t\terr = -EINVAL;\n\n\t\tif (err)\n\t\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\telse {\n\t\t\tt = s.enabled | (-s.log_passwd & AUDIT_TTY_LOG_PASSWD);\n\t\t\tt = xchg(&current->signal->audit_tty, t);\n\t\t}\n\t\told.enabled = t & AUDIT_TTY_ENABLE;\n\t\told.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=tty_set old-enabled=%d new-enabled=%d\"\n\t\t\t\t \" old-log_passwd=%d new-log_passwd=%d res=%d\",\n\t\t\t\t old.enabled, s.enabled, old.log_passwd,\n\t\t\t\t s.log_passwd, !err);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err < 0 ? err : 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_BACKLOG_WAIT_TIME (60 * HZ)"
    ],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;",
      "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
      "static u32\taudit_rate_limit;",
      "static u32\taudit_backlog_limit = 64;",
      "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
      "static kuid_t\t\taudit_sig_uid = INVALID_UID;",
      "static pid_t\t\taudit_sig_pid = -1;",
      "static u32\t\taudit_sig_sid;",
      "static atomic_t\taudit_lost = ATOMIC_INIT(0);",
      "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
      "static struct sk_buff_head audit_queue;",
      "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" op=tty_set old-enabled=%d new-enabled=%d\"\n\t\t\t\t \" old-log_passwd=%d new-log_passwd=%d res=%d\"",
            "old.enabled",
            "s.enabled",
            "old.log_passwd",
            "s.log_passwd",
            "!err"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_common_recv_msg",
          "args": [
            "audit_context()",
            "&ab",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_common_recv_msg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1054-1071",
          "snippet": "static void audit_log_common_recv_msg(struct audit_context *context,\n\t\t\t\t\tstruct audit_buffer **ab, u16 msg_type)\n{\n\tuid_t uid = from_kuid(&init_user_ns, current_uid());\n\tpid_t pid = task_tgid_nr(current);\n\n\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {\n\t\t*ab = NULL;\n\t\treturn;\n\t}\n\n\t*ab = audit_log_start(context, GFP_KERNEL, msg_type);\n\tif (unlikely(!*ab))\n\t\treturn;\n\taudit_log_format(*ab, \"pid=%d uid=%u \", pid, uid);\n\taudit_log_session_info(*ab);\n\taudit_log_task_context(*ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic void audit_log_common_recv_msg(struct audit_context *context,\n\t\t\t\t\tstruct audit_buffer **ab, u16 msg_type)\n{\n\tuid_t uid = from_kuid(&init_user_ns, current_uid());\n\tpid_t pid = task_tgid_nr(current);\n\n\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {\n\t\t*ab = NULL;\n\t\treturn;\n\t}\n\n\t*ab = audit_log_start(context, GFP_KERNEL, msg_type);\n\tif (unlikely(!*ab))\n\t\treturn;\n\taudit_log_format(*ab, \"pid=%d uid=%u \", pid, uid);\n\taudit_log_session_info(*ab);\n\taudit_log_task_context(*ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&current->signal->audit_tty",
            "t"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "current->signal->audit_tty"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&s",
            "data",
            "min_t(size_t, sizeof(s), data_len)"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "sizeof(s)",
            "data_len"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&s",
            "0",
            "sizeof(s)"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_send_reply",
          "args": [
            "skb",
            "seq",
            "AUDIT_TTY_GET",
            "0",
            "0",
            "&s",
            "sizeof(s)"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "audit_send_reply",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "968-992",
          "snippet": "static void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply;\n\n\treply = kzalloc(sizeof(*reply), GFP_KERNEL);\n\tif (!reply)\n\t\treturn;\n\n\treply->skb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!reply->skb)\n\t\tgoto err;\n\treply->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\treply->portid = NETLINK_CB(request_skb).portid;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (IS_ERR(tsk))\n\t\tgoto err;\n\n\treturn;\n\nerr:\n\taudit_free_reply(reply);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply;\n\n\treply = kzalloc(sizeof(*reply), GFP_KERNEL);\n\tif (!reply)\n\t\treturn;\n\n\treply->skb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!reply->skb)\n\t\tgoto err;\n\treply->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\treply->portid = NETLINK_CB(request_skb).portid;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (IS_ERR(tsk))\n\t\tgoto err;\n\n\treturn;\n\nerr:\n\taudit_free_reply(reply);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "current->signal->audit_tty"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sig_data"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "sig_data",
            "ctx",
            "len"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "audit_sig_uid"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "struct_size(sig_data, ctx, len)",
            "GFP_KERNEL"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "sig_data",
            "ctx",
            "len"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_secid_to_secctx",
          "args": [
            "audit_sig_sid",
            "&ctx",
            "&len"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "new"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_tag_tree",
          "args": [
            "old",
            "new"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tag_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "870-960",
          "snippet": "int audit_tag_tree(char *old, char *new)\n{\n\tstruct list_head cursor, barrier;\n\tint failed = 0;\n\tstruct path path1, path2;\n\tstruct vfsmount *tagged;\n\tint err;\n\n\terr = kern_path(new, 0, &path2);\n\tif (err)\n\t\treturn err;\n\ttagged = collect_mounts(&path2);\n\tpath_put(&path2);\n\tif (IS_ERR(tagged))\n\t\treturn PTR_ERR(tagged);\n\n\terr = kern_path(old, 0, &path1);\n\tif (err) {\n\t\tdrop_collected_mounts(tagged);\n\t\treturn err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&barrier, &tree_list);\n\tlist_add(&cursor, &barrier);\n\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tint good_one = 0;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path2);\n\t\tif (!err) {\n\t\t\tgood_one = path_is_under(&path1, &path2);\n\t\t\tpath_put(&path2);\n\t\t}\n\n\t\tif (!good_one) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfailed = iterate_mounts(tag_mount, tree, tagged);\n\t\tif (failed) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tspin_lock(&hash_lock);\n\t\tif (!tree->goner) {\n\t\t\tlist_move(&tree->list, &tree_list);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\tput_tree(tree);\n\t}\n\n\twhile (barrier.prev != &tree_list) {\n\t\tstruct audit_tree *tree;\n\n\t\ttree = container_of(barrier.prev, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&tree->list, &barrier);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tif (!failed) {\n\t\t\tstruct audit_node *node;\n\t\t\tspin_lock(&hash_lock);\n\t\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t\tspin_unlock(&hash_lock);\n\t\t} else {\n\t\t\ttrim_marked(tree);\n\t\t}\n\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&barrier);\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n\tpath_put(&path1);\n\tdrop_collected_mounts(tagged);\n\treturn failed;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(tree_list);",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nint audit_tag_tree(char *old, char *new)\n{\n\tstruct list_head cursor, barrier;\n\tint failed = 0;\n\tstruct path path1, path2;\n\tstruct vfsmount *tagged;\n\tint err;\n\n\terr = kern_path(new, 0, &path2);\n\tif (err)\n\t\treturn err;\n\ttagged = collect_mounts(&path2);\n\tpath_put(&path2);\n\tif (IS_ERR(tagged))\n\t\treturn PTR_ERR(tagged);\n\n\terr = kern_path(old, 0, &path1);\n\tif (err) {\n\t\tdrop_collected_mounts(tagged);\n\t\treturn err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&barrier, &tree_list);\n\tlist_add(&cursor, &barrier);\n\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tint good_one = 0;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path2);\n\t\tif (!err) {\n\t\t\tgood_one = path_is_under(&path1, &path2);\n\t\t\tpath_put(&path2);\n\t\t}\n\n\t\tif (!good_one) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfailed = iterate_mounts(tag_mount, tree, tagged);\n\t\tif (failed) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tspin_lock(&hash_lock);\n\t\tif (!tree->goner) {\n\t\t\tlist_move(&tree->list, &tree_list);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\tput_tree(tree);\n\t}\n\n\twhile (barrier.prev != &tree_list) {\n\t\tstruct audit_tree *tree;\n\n\t\ttree = container_of(barrier.prev, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&tree->list, &barrier);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tif (!failed) {\n\t\t\tstruct audit_node *node;\n\t\t\tspin_lock(&hash_lock);\n\t\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t\tspin_unlock(&hash_lock);\n\t\t} else {\n\t\t\ttrim_marked(tree);\n\t\t}\n\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&barrier);\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n\tpath_put(&path1);\n\tdrop_collected_mounts(tagged);\n\treturn failed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_unpack_string",
          "args": [
            "&bufp",
            "&msglen",
            "sizes[1]"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "audit_unpack_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "127-150",
          "snippet": "char *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_trim_trees",
          "args": [],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "audit_trim_trees",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "677-723",
          "snippet": "void audit_trim_trees(void)\n{\n\tstruct list_head cursor;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&cursor, &tree_list);\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tstruct path path;\n\t\tstruct vfsmount *root_mnt;\n\t\tstruct audit_node *node;\n\t\tint err;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path);\n\t\tif (err)\n\t\t\tgoto skip_it;\n\n\t\troot_mnt = collect_mounts(&path);\n\t\tpath_put(&path);\n\t\tif (IS_ERR(root_mnt))\n\t\t\tgoto skip_it;\n\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list) {\n\t\t\tstruct audit_chunk *chunk = find_chunk(node);\n\t\t\t/* this could be NULL if the watch is dying else where... */\n\t\t\tnode->index |= 1U<<31;\n\t\t\tif (iterate_mounts(compare_root,\n\t\t\t\t\t   (void *)(chunk->key),\n\t\t\t\t\t   root_mnt))\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\ttrim_marked(tree);\n\t\tdrop_collected_mounts(root_mnt);\nskip_it:\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(tree_list);",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nvoid audit_trim_trees(void)\n{\n\tstruct list_head cursor;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&cursor, &tree_list);\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tstruct path path;\n\t\tstruct vfsmount *root_mnt;\n\t\tstruct audit_node *node;\n\t\tint err;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path);\n\t\tif (err)\n\t\t\tgoto skip_it;\n\n\t\troot_mnt = collect_mounts(&path);\n\t\tpath_put(&path);\n\t\tif (IS_ERR(root_mnt))\n\t\t\tgoto skip_it;\n\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list) {\n\t\t\tstruct audit_chunk *chunk = find_chunk(node);\n\t\t\t/* this could be NULL if the watch is dying else where... */\n\t\t\tnode->index |= 1U<<31;\n\t\t\tif (iterate_mounts(compare_root,\n\t\t\t\t\t   (void *)(chunk->key),\n\t\t\t\t\t   root_mnt))\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\ttrim_marked(tree);\n\t\tdrop_collected_mounts(root_mnt);\nskip_it:\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_list_rules_send",
          "args": [
            "skb",
            "seq"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "audit_list_rules_send",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1171-1202",
          "snippet": "int audit_list_rules_send(struct sk_buff *request_skb, int seq)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_netlink_list *dest;\n\n\t/* We can't just spew out the rules here because we might fill\n\t * the available socket buffer space and deadlock waiting for\n\t * auditctl to read from it... which isn't ever going to\n\t * happen if we're actually running in the context of auditctl\n\t * trying to _send_ the stuff */\n\n\tdest = kmalloc(sizeof(*dest), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\tdest->portid = NETLINK_CB(request_skb).portid;\n\tskb_queue_head_init(&dest->q);\n\n\tmutex_lock(&audit_filter_mutex);\n\taudit_list_rules(seq, &dest->q);\n\tmutex_unlock(&audit_filter_mutex);\n\n\ttsk = kthread_run(audit_send_list_thread, dest, \"audit_send_list\");\n\tif (IS_ERR(tsk)) {\n\t\tskb_queue_purge(&dest->q);\n\t\tput_net(dest->net);\n\t\tkfree(dest);\n\t\treturn PTR_ERR(tsk);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_list_rules_send(struct sk_buff *request_skb, int seq)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_netlink_list *dest;\n\n\t/* We can't just spew out the rules here because we might fill\n\t * the available socket buffer space and deadlock waiting for\n\t * auditctl to read from it... which isn't ever going to\n\t * happen if we're actually running in the context of auditctl\n\t * trying to _send_ the stuff */\n\n\tdest = kmalloc(sizeof(*dest), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\tdest->portid = NETLINK_CB(request_skb).portid;\n\tskb_queue_head_init(&dest->q);\n\n\tmutex_lock(&audit_filter_mutex);\n\taudit_list_rules(seq, &dest->q);\n\tmutex_unlock(&audit_filter_mutex);\n\n\ttsk = kthread_run(audit_send_list_thread, dest, \"audit_send_list\");\n\tif (IS_ERR(tsk)) {\n\t\tskb_queue_purge(&dest->q);\n\t\tput_net(dest->net);\n\t\tkfree(dest);\n\t\treturn PTR_ERR(tsk);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_rule_change",
          "args": [
            "msg_type",
            "seq",
            "data",
            "data_len"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "audit_rule_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1132-1164",
          "snippet": "int audit_rule_change(int type, int seq, void *data, size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\n\tswitch (type) {\n\tcase AUDIT_ADD_RULE:\n\t\tentry = audit_data_to_entry(data, datasz);\n\t\tif (IS_ERR(entry))\n\t\t\treturn PTR_ERR(entry);\n\t\terr = audit_add_rule(entry);\n\t\taudit_log_rule_change(\"add_rule\", &entry->rule, !err);\n\t\tbreak;\n\tcase AUDIT_DEL_RULE:\n\t\tentry = audit_data_to_entry(data, datasz);\n\t\tif (IS_ERR(entry))\n\t\t\treturn PTR_ERR(entry);\n\t\terr = audit_del_rule(entry);\n\t\taudit_log_rule_change(\"remove_rule\", &entry->rule, !err);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (err || type == AUDIT_DEL_RULE) {\n\t\tif (entry->rule.exe)\n\t\t\taudit_remove_mark(entry->rule.exe);\n\t\taudit_free_rule(entry);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_rule_change(int type, int seq, void *data, size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\n\tswitch (type) {\n\tcase AUDIT_ADD_RULE:\n\t\tentry = audit_data_to_entry(data, datasz);\n\t\tif (IS_ERR(entry))\n\t\t\treturn PTR_ERR(entry);\n\t\terr = audit_add_rule(entry);\n\t\taudit_log_rule_change(\"add_rule\", &entry->rule, !err);\n\t\tbreak;\n\tcase AUDIT_DEL_RULE:\n\t\tentry = audit_data_to_entry(data, datasz);\n\t\tif (IS_ERR(entry))\n\t\t\treturn PTR_ERR(entry);\n\t\terr = audit_del_rule(entry);\n\t\taudit_log_rule_change(\"remove_rule\", &entry->rule, !err);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (err || type == AUDIT_DEL_RULE) {\n\t\tif (entry->rule.exe)\n\t\t\taudit_remove_mark(entry->rule.exe);\n\t\taudit_free_rule(entry);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_n_untrustedstring",
          "args": [
            "ab",
            "str",
            "data_len"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2080-2087",
          "snippet": "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_user_recv_msg",
          "args": [
            "&ab",
            "msg_type"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_user_recv_msg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1073-1077",
          "snippet": "static inline void audit_log_user_recv_msg(struct audit_buffer **ab,\n\t\t\t\t\t   u16 msg_type)\n{\n\taudit_log_common_recv_msg(NULL, ab, msg_type);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline void audit_log_user_recv_msg(struct audit_buffer **ab,\n\t\t\t\t\t   u16 msg_type)\n{\n\taudit_log_common_recv_msg(NULL, ab, msg_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tty_audit_push",
          "args": [],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_filter",
          "args": [
            "msg_type",
            "AUDIT_FILTER_USER"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1329-1398",
          "snippet": "int audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t   f->type, f->op, f->lsm_rule);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nint audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t   f->type, f->op, f->lsm_rule);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_feature",
          "args": [
            "data"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_feature",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1114-1168",
          "snippet": "static int audit_set_feature(struct audit_features *uaf)\n{\n\tint i;\n\n\tBUILD_BUG_ON(AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names));\n\n\t/* if there is ever a version 2 we should handle that here */\n\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\t\told_lock = af.lock & feature;\n\n\t\t/* are we changing a locked feature? */\n\t\tif (old_lock && (new_feature != old_feature)) {\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 0);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\t/* nothing invalid, do the changes */\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\told_lock = af.lock & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\n\t\tif (new_feature != old_feature)\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 1);\n\n\t\tif (new_feature)\n\t\t\taf.features |= feature;\n\t\telse\n\t\t\taf.features &= ~feature;\n\t\taf.lock |= new_lock;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};",
            "static char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\nstatic char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};\n\nstatic int audit_set_feature(struct audit_features *uaf)\n{\n\tint i;\n\n\tBUILD_BUG_ON(AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names));\n\n\t/* if there is ever a version 2 we should handle that here */\n\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\t\told_lock = af.lock & feature;\n\n\t\t/* are we changing a locked feature? */\n\t\tif (old_lock && (new_feature != old_feature)) {\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 0);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\t/* nothing invalid, do the changes */\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\told_lock = af.lock & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\n\t\tif (new_feature != old_feature)\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 1);\n\n\t\tif (new_feature)\n\t\t\taf.features |= feature;\n\t\telse\n\t\t\taf.features &= ~feature;\n\t\taf.lock |= new_lock;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_feature",
          "args": [
            "skb"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_feature",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1085-1094",
          "snippet": "static int audit_get_feature(struct sk_buff *skb)\n{\n\tu32 seq;\n\n\tseq = nlmsg_hdr(skb)->nlmsg_seq;\n\n\taudit_send_reply(skb, seq, AUDIT_GET_FEATURE, 0, 0, &af, sizeof(af));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\n\nstatic int audit_get_feature(struct sk_buff *skb)\n{\n\tu32 seq;\n\n\tseq = nlmsg_hdr(skb)->nlmsg_seq;\n\n\taudit_send_reply(skb, seq, AUDIT_GET_FEATURE, 0, 0, &af, sizeof(af));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_config_change",
          "args": [
            "\"backlog_wait_time_actual\"",
            "0",
            "actual",
            "1"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_config_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "386-403",
          "snippet": "static int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"op=set %s=%u old=%u \", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"op=set %s=%u old=%u \", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&audit_backlog_wait_time_actual",
            "0"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&audit_lost",
            "0"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_set_backlog_wait_time",
          "args": [
            "s.backlog_wait_time"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_backlog_wait_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "441-445",
          "snippet": "static int audit_set_backlog_wait_time(u32 timeout)\n{\n\treturn audit_do_config_change(\"audit_backlog_wait_time\",\n\t\t\t\t      &audit_backlog_wait_time, timeout);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\n\nstatic int audit_set_backlog_wait_time(u32 timeout)\n{\n\treturn audit_do_config_change(\"audit_backlog_wait_time\",\n\t\t\t\t      &audit_backlog_wait_time, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_backlog_limit",
          "args": [
            "s.backlog_limit"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_backlog_limit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "436-439",
          "snippet": "static int audit_set_backlog_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_backlog_limit\", &audit_backlog_limit, limit);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_backlog_limit = 64;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_backlog_limit = 64;\n\nstatic int audit_set_backlog_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_backlog_limit\", &audit_backlog_limit, limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_rate_limit",
          "args": [
            "s.rate_limit"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_rate_limit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "431-434",
          "snippet": "static int audit_set_rate_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_rate_limit\", &audit_rate_limit, limit);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_rate_limit;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_rate_limit;\n\nstatic int audit_set_rate_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_rate_limit\", &audit_rate_limit, limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditd_reset",
          "args": [
            "NULL"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "619-644",
          "snippet": "static void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;",
            "static DEFINE_SPINLOCK(auditd_conn_lock);",
            "static struct sk_buff_head audit_retry_queue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\nstatic struct sk_buff_head audit_retry_queue;\n\nstatic void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&kauditd_wait"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auditd_set",
          "args": [
            "req_pid",
            "NETLINK_CB(skb).portid",
            "sock_net(NETLINK_CB(skb).sk)"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "498-523",
          "snippet": "static int auditd_set(struct pid *pid, u32 portid, struct net *net)\n{\n\tunsigned long flags;\n\tstruct auditd_connection *ac_old, *ac_new;\n\n\tif (!pid || !net)\n\t\treturn -EINVAL;\n\n\tac_new = kzalloc(sizeof(*ac_new), GFP_KERNEL);\n\tif (!ac_new)\n\t\treturn -ENOMEM;\n\tac_new->pid = get_pid(pid);\n\tac_new->portid = portid;\n\tac_new->net = get_net(net);\n\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\trcu_assign_pointer(auditd_conn, ac_new);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;",
            "static DEFINE_SPINLOCK(auditd_conn_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\n\nstatic int auditd_set(struct pid *pid, u32 portid, struct net *net)\n{\n\tunsigned long flags;\n\tstruct auditd_connection *ac_old, *ac_new;\n\n\tif (!pid || !net)\n\t\treturn -EINVAL;\n\n\tac_new = kzalloc(sizeof(*ac_new), GFP_KERNEL);\n\tif (!ac_new)\n\t\treturn -ENOMEM;\n\tac_new->pid = get_pid(pid);\n\tac_new->portid = portid;\n\tac_new->net = get_net(net);\n\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\trcu_assign_pointer(auditd_conn, ac_new);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_net",
          "args": [
            "NETLINK_CB(skb).sk"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "skb"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "skb"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "req_pid"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "pid_vnr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "486-489",
          "snippet": "pid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditd_pid_vnr",
          "args": [],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_pid_vnr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "267-281",
          "snippet": "static pid_t auditd_pid_vnr(void)\n{\n\tpid_t pid;\n\tconst struct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac || !ac->pid)\n\t\tpid = 0;\n\telse\n\t\tpid = pid_vnr(ac->pid);\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\n\nstatic pid_t auditd_pid_vnr(void)\n{\n\tpid_t pid;\n\tconst struct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac || !ac->pid)\n\t\tpid = 0;\n\telse\n\t\tpid = pid_vnr(ac->pid);\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_replace",
          "args": [
            "req_pid"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "audit_replace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1170-1180",
          "snippet": "static int audit_replace(struct pid *pid)\n{\n\tpid_t pvnr;\n\tstruct sk_buff *skb;\n\n\tpvnr = pid_vnr(pid);\n\tskb = audit_make_reply(0, AUDIT_REPLACE, 0, 0, &pvnr, sizeof(pvnr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treturn auditd_send_unicast_skb(skb);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_replace(struct pid *pid)\n{\n\tpid_t pvnr;\n\tstruct sk_buff *skb;\n\n\tpvnr = pid_vnr(pid);\n\tskb = audit_make_reply(0, AUDIT_REPLACE, 0, 0, &pvnr, sizeof(pvnr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treturn auditd_send_unicast_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_set_failure",
          "args": [
            "s.failure"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_failure",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "460-468",
          "snippet": "static int audit_set_failure(u32 state)\n{\n\tif (state != AUDIT_FAIL_SILENT\n\t    && state != AUDIT_FAIL_PRINTK\n\t    && state != AUDIT_FAIL_PANIC)\n\t\treturn -EINVAL;\n\n\treturn audit_do_config_change(\"audit_failure\", &audit_failure, state);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nstatic int audit_set_failure(u32 state)\n{\n\tif (state != AUDIT_FAIL_SILENT\n\t    && state != AUDIT_FAIL_PRINTK\n\t    && state != AUDIT_FAIL_PANIC)\n\t\treturn -EINVAL;\n\n\treturn audit_do_config_change(\"audit_failure\", &audit_failure, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_enabled",
          "args": [
            "s.enabled"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "447-458",
          "snippet": "static int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;",
            "bool\t\taudit_ever_enabled = !!AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\nbool\t\taudit_ever_enabled = !!AUDIT_OFF;\n\nstatic int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "sizeof(s)",
            "data_len"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&s",
            "0",
            "sizeof(s)"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&audit_backlog_wait_time_actual"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_len",
          "args": [
            "&audit_queue"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&audit_lost"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&s",
            "0",
            "sizeof(s)"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_len",
          "args": [
            "nlh"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_data",
          "args": [
            "nlh"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_netlink_ok",
          "args": [
            "skb",
            "msg_type"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "audit_netlink_ok",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "998-1052",
          "snippet": "static int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)\n{\n\tint err = 0;\n\n\t/* Only support initial user namespace for now. */\n\t/*\n\t * We return ECONNREFUSED because it tricks userspace into thinking\n\t * that audit was not configured into the kernel.  Lots of users\n\t * configure their PAM stack (because that's what the distro does)\n\t * to reject login if unable to send messages to audit.  If we return\n\t * ECONNREFUSED the PAM stack thinks the kernel does not have audit\n\t * configured in and will let login proceed.  If we return EPERM\n\t * userspace will reject all logins.  This should be removed when we\n\t * support non init namespaces!!\n\t */\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -ECONNREFUSED;\n\n\tswitch (msg_type) {\n\tcase AUDIT_LIST:\n\tcase AUDIT_ADD:\n\tcase AUDIT_DEL:\n\t\treturn -EOPNOTSUPP;\n\tcase AUDIT_GET:\n\tcase AUDIT_SET:\n\tcase AUDIT_GET_FEATURE:\n\tcase AUDIT_SET_FEATURE:\n\tcase AUDIT_LIST_RULES:\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\tcase AUDIT_SIGNAL_INFO:\n\tcase AUDIT_TTY_GET:\n\tcase AUDIT_TTY_SET:\n\tcase AUDIT_TRIM:\n\tcase AUDIT_MAKE_EQUIV:\n\t\t/* Only support auditd and auditctl in initial pid namespace\n\t\t * for now. */\n\t\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\t\treturn -EPERM;\n\n\t\tif (!netlink_capable(skb, CAP_AUDIT_CONTROL))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!netlink_capable(skb, CAP_AUDIT_WRITE))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tdefault:  /* bad msg */\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)\n{\n\tint err = 0;\n\n\t/* Only support initial user namespace for now. */\n\t/*\n\t * We return ECONNREFUSED because it tricks userspace into thinking\n\t * that audit was not configured into the kernel.  Lots of users\n\t * configure their PAM stack (because that's what the distro does)\n\t * to reject login if unable to send messages to audit.  If we return\n\t * ECONNREFUSED the PAM stack thinks the kernel does not have audit\n\t * configured in and will let login proceed.  If we return EPERM\n\t * userspace will reject all logins.  This should be removed when we\n\t * support non init namespaces!!\n\t */\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -ECONNREFUSED;\n\n\tswitch (msg_type) {\n\tcase AUDIT_LIST:\n\tcase AUDIT_ADD:\n\tcase AUDIT_DEL:\n\t\treturn -EOPNOTSUPP;\n\tcase AUDIT_GET:\n\tcase AUDIT_SET:\n\tcase AUDIT_GET_FEATURE:\n\tcase AUDIT_SET_FEATURE:\n\tcase AUDIT_LIST_RULES:\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\tcase AUDIT_SIGNAL_INFO:\n\tcase AUDIT_TTY_GET:\n\tcase AUDIT_TTY_SET:\n\tcase AUDIT_TRIM:\n\tcase AUDIT_MAKE_EQUIV:\n\t\t/* Only support auditd and auditctl in initial pid namespace\n\t\t * for now. */\n\t\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\t\treturn -EPERM;\n\n\t\tif (!netlink_capable(skb, CAP_AUDIT_CONTROL))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!netlink_capable(skb, CAP_AUDIT_WRITE))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tdefault:  /* bad msg */\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BACKLOG_WAIT_TIME (60 * HZ)\n\nu32\t\taudit_enabled = AUDIT_OFF;\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic kuid_t\t\taudit_sig_uid = INVALID_UID;\nstatic pid_t\t\taudit_sig_pid = -1;\nstatic u32\t\taudit_sig_sid;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nstatic int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tu32\t\t\tseq;\n\tvoid\t\t\t*data;\n\tint\t\t\tdata_len;\n\tint\t\t\terr;\n\tstruct audit_buffer\t*ab;\n\tu16\t\t\tmsg_type = nlh->nlmsg_type;\n\tstruct audit_sig_info   *sig_data;\n\tchar\t\t\t*ctx = NULL;\n\tu32\t\t\tlen;\n\n\terr = audit_netlink_ok(skb, msg_type);\n\tif (err)\n\t\treturn err;\n\n\tseq  = nlh->nlmsg_seq;\n\tdata = nlmsg_data(nlh);\n\tdata_len = nlmsg_len(nlh);\n\n\tswitch (msg_type) {\n\tcase AUDIT_GET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\ts.enabled\t\t   = audit_enabled;\n\t\ts.failure\t\t   = audit_failure;\n\t\t/* NOTE: use pid_vnr() so the PID is relative to the current\n\t\t *       namespace */\n\t\ts.pid\t\t\t   = auditd_pid_vnr();\n\t\ts.rate_limit\t\t   = audit_rate_limit;\n\t\ts.backlog_limit\t\t   = audit_backlog_limit;\n\t\ts.lost\t\t\t   = atomic_read(&audit_lost);\n\t\ts.backlog\t\t   = skb_queue_len(&audit_queue);\n\t\ts.feature_bitmap\t   = AUDIT_FEATURE_BITMAP_ALL;\n\t\ts.backlog_wait_time\t   = audit_backlog_wait_time;\n\t\ts.backlog_wait_time_actual = atomic_read(&audit_backlog_wait_time_actual);\n\t\taudit_send_reply(skb, seq, AUDIT_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_SET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), data_len));\n\t\tif (s.mask & AUDIT_STATUS_ENABLED) {\n\t\t\terr = audit_set_enabled(s.enabled);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_FAILURE) {\n\t\t\terr = audit_set_failure(s.failure);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_PID) {\n\t\t\t/* NOTE: we are using the vnr PID functions below\n\t\t\t *       because the s.pid value is relative to the\n\t\t\t *       namespace of the caller; at present this\n\t\t\t *       doesn't matter much since you can really only\n\t\t\t *       run auditd from the initial pid namespace, but\n\t\t\t *       something to keep in mind if this changes */\n\t\t\tpid_t new_pid = s.pid;\n\t\t\tpid_t auditd_pid;\n\t\t\tstruct pid *req_pid = task_tgid(current);\n\n\t\t\t/* Sanity check - PID values must match. Setting\n\t\t\t * pid to 0 is how auditd ends auditing. */\n\t\t\tif (new_pid && (new_pid != pid_vnr(req_pid)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* test the auditd connection */\n\t\t\taudit_replace(req_pid);\n\n\t\t\tauditd_pid = auditd_pid_vnr();\n\t\t\tif (auditd_pid) {\n\t\t\t\t/* replacing a healthy auditd is not allowed */\n\t\t\t\tif (new_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\t/* only current auditd can unregister itself */\n\t\t\t\tif (pid_vnr(req_pid) != auditd_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (new_pid) {\n\t\t\t\t/* register a new auditd connection */\n\t\t\t\terr = auditd_set(req_pid,\n\t\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t\t sock_net(NETLINK_CB(skb).sk));\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid,\n\t\t\t\t\t\t\t\terr ? 0 : 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* try to process any backlog */\n\t\t\t\twake_up_interruptible(&kauditd_wait);\n\t\t\t} else {\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid, 1);\n\n\t\t\t\t/* unregister the auditd connection */\n\t\t\t\tauditd_reset(NULL);\n\t\t\t}\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_RATE_LIMIT) {\n\t\t\terr = audit_set_rate_limit(s.rate_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_LIMIT) {\n\t\t\terr = audit_set_backlog_limit(s.backlog_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_WAIT_TIME) {\n\t\t\tif (sizeof(s) > (size_t)nlh->nlmsg_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (s.backlog_wait_time > 10*AUDIT_BACKLOG_WAIT_TIME)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = audit_set_backlog_wait_time(s.backlog_wait_time);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_LOST) {\n\t\t\tu32 lost = atomic_xchg(&audit_lost, 0);\n\n\t\t\taudit_log_config_change(\"lost\", 0, lost, 1);\n\t\t\treturn lost;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_BACKLOG_WAIT_TIME_ACTUAL) {\n\t\t\tu32 actual = atomic_xchg(&audit_backlog_wait_time_actual, 0);\n\n\t\t\taudit_log_config_change(\"backlog_wait_time_actual\", 0, actual, 1);\n\t\t\treturn actual;\n\t\t}\n\t\tbreak;\n\t}\n\tcase AUDIT_GET_FEATURE:\n\t\terr = audit_get_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_SET_FEATURE:\n\t\tif (data_len < sizeof(struct audit_features))\n\t\t\treturn -EINVAL;\n\t\terr = audit_set_feature(data);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!audit_enabled && msg_type != AUDIT_USER_AVC)\n\t\t\treturn 0;\n\t\t/* exit early if there isn't at least one character to print */\n\t\tif (data_len < 2)\n\t\t\treturn -EINVAL;\n\n\t\terr = audit_filter(msg_type, AUDIT_FILTER_USER);\n\t\tif (err == 1) { /* match or error */\n\t\t\tchar *str = data;\n\n\t\t\terr = 0;\n\t\t\tif (msg_type == AUDIT_USER_TTY) {\n\t\t\t\terr = tty_audit_push();\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\taudit_log_user_recv_msg(&ab, msg_type);\n\t\t\tif (msg_type != AUDIT_USER_TTY) {\n\t\t\t\t/* ensure NULL termination */\n\t\t\t\tstr[data_len - 1] = '\\0';\n\t\t\t\taudit_log_format(ab, \" msg='%.*s'\",\n\t\t\t\t\t\t AUDIT_MESSAGE_TEXT_MAX,\n\t\t\t\t\t\t str);\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" data=\");\n\t\t\t\tif (data_len > 0 && str[data_len - 1] == '\\0')\n\t\t\t\t\tdata_len--;\n\t\t\t\taudit_log_n_untrustedstring(ab, str, data_len);\n\t\t\t}\n\t\t\taudit_log_end(ab);\n\t\t}\n\t\tbreak;\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\t\tif (data_len < sizeof(struct audit_rule_data))\n\t\t\treturn -EINVAL;\n\t\tif (audit_enabled == AUDIT_LOCKED) {\n\t\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\t\taudit_log_format(ab, \" op=%s audit_enabled=%d res=0\",\n\t\t\t\t\t msg_type == AUDIT_ADD_RULE ?\n\t\t\t\t\t\t\"add_rule\" : \"remove_rule\",\n\t\t\t\t\t audit_enabled);\n\t\t\taudit_log_end(ab);\n\t\t\treturn -EPERM;\n\t\t}\n\t\terr = audit_rule_change(msg_type, seq, data, data_len);\n\t\tbreak;\n\tcase AUDIT_LIST_RULES:\n\t\terr = audit_list_rules_send(skb, seq);\n\t\tbreak;\n\tcase AUDIT_TRIM:\n\t\taudit_trim_trees();\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=trim res=1\");\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_MAKE_EQUIV: {\n\t\tvoid *bufp = data;\n\t\tu32 sizes[2];\n\t\tsize_t msglen = data_len;\n\t\tchar *old, *new;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < 2 * sizeof(u32))\n\t\t\tbreak;\n\t\tmemcpy(sizes, bufp, 2 * sizeof(u32));\n\t\tbufp += 2 * sizeof(u32);\n\t\tmsglen -= 2 * sizeof(u32);\n\t\told = audit_unpack_string(&bufp, &msglen, sizes[0]);\n\t\tif (IS_ERR(old)) {\n\t\t\terr = PTR_ERR(old);\n\t\t\tbreak;\n\t\t}\n\t\tnew = audit_unpack_string(&bufp, &msglen, sizes[1]);\n\t\tif (IS_ERR(new)) {\n\t\t\terr = PTR_ERR(new);\n\t\t\tkfree(old);\n\t\t\tbreak;\n\t\t}\n\t\t/* OK, here comes... */\n\t\terr = audit_tag_tree(old, new);\n\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=make_equiv old=\");\n\t\taudit_log_untrustedstring(ab, old);\n\t\taudit_log_format(ab, \" new=\");\n\t\taudit_log_untrustedstring(ab, new);\n\t\taudit_log_format(ab, \" res=%d\", !err);\n\t\taudit_log_end(ab);\n\t\tkfree(old);\n\t\tkfree(new);\n\t\tbreak;\n\t}\n\tcase AUDIT_SIGNAL_INFO:\n\t\tlen = 0;\n\t\tif (audit_sig_sid) {\n\t\t\terr = security_secid_to_secctx(audit_sig_sid, &ctx, &len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsig_data = kmalloc(struct_size(sig_data, ctx, len), GFP_KERNEL);\n\t\tif (!sig_data) {\n\t\t\tif (audit_sig_sid)\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);\n\t\tsig_data->pid = audit_sig_pid;\n\t\tif (audit_sig_sid) {\n\t\t\tmemcpy(sig_data->ctx, ctx, len);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t\taudit_send_reply(skb, seq, AUDIT_SIGNAL_INFO, 0, 0,\n\t\t\t\t sig_data, struct_size(sig_data, ctx, len));\n\t\tkfree(sig_data);\n\t\tbreak;\n\tcase AUDIT_TTY_GET: {\n\t\tstruct audit_tty_status s;\n\t\tunsigned int t;\n\n\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\ts.enabled = t & AUDIT_TTY_ENABLE;\n\t\ts.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_send_reply(skb, seq, AUDIT_TTY_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_TTY_SET: {\n\t\tstruct audit_tty_status s, old;\n\t\tstruct audit_buffer\t*ab;\n\t\tunsigned int t;\n\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), data_len));\n\t\t/* check if new data is valid */\n\t\tif ((s.enabled != 0 && s.enabled != 1) ||\n\t\t    (s.log_passwd != 0 && s.log_passwd != 1))\n\t\t\terr = -EINVAL;\n\n\t\tif (err)\n\t\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\telse {\n\t\t\tt = s.enabled | (-s.log_passwd & AUDIT_TTY_LOG_PASSWD);\n\t\t\tt = xchg(&current->signal->audit_tty, t);\n\t\t}\n\t\told.enabled = t & AUDIT_TTY_ENABLE;\n\t\told.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=tty_set old-enabled=%d new-enabled=%d\"\n\t\t\t\t \" old-log_passwd=%d new-log_passwd=%d res=%d\",\n\t\t\t\t old.enabled, s.enabled, old.log_passwd,\n\t\t\t\t s.log_passwd, !err);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err < 0 ? err : 0;\n}"
  },
  {
    "function_name": "audit_replace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1170-1180",
    "snippet": "static int audit_replace(struct pid *pid)\n{\n\tpid_t pvnr;\n\tstruct sk_buff *skb;\n\n\tpvnr = pid_vnr(pid);\n\tskb = audit_make_reply(0, AUDIT_REPLACE, 0, 0, &pvnr, sizeof(pvnr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treturn auditd_send_unicast_skb(skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "auditd_send_unicast_skb",
          "args": [
            "skb"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_send_unicast_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "657-696",
          "snippet": "static int auditd_send_unicast_skb(struct sk_buff *skb)\n{\n\tint rc;\n\tu32 portid;\n\tstruct net *net;\n\tstruct sock *sk;\n\tstruct auditd_connection *ac;\n\n\t/* NOTE: we can't call netlink_unicast while in the RCU section so\n\t *       take a reference to the network namespace and grab local\n\t *       copies of the namespace, the sock, and the portid; the\n\t *       namespace and sock aren't going to go away while we hold a\n\t *       reference and if the portid does become invalid after the RCU\n\t *       section netlink_unicast() should safely return an error */\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\trc = -ECONNREFUSED;\n\t\tgoto err;\n\t}\n\tnet = get_net(ac->net);\n\tsk = audit_get_sk(net);\n\tportid = ac->portid;\n\trcu_read_unlock();\n\n\trc = netlink_unicast(sk, skb, portid, 0);\n\tput_net(net);\n\tif (rc < 0)\n\t\tgoto err;\n\n\treturn rc;\n\nerr:\n\tif (ac && rc == -ECONNREFUSED)\n\t\tauditd_reset(ac);\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\n\nstatic int auditd_send_unicast_skb(struct sk_buff *skb)\n{\n\tint rc;\n\tu32 portid;\n\tstruct net *net;\n\tstruct sock *sk;\n\tstruct auditd_connection *ac;\n\n\t/* NOTE: we can't call netlink_unicast while in the RCU section so\n\t *       take a reference to the network namespace and grab local\n\t *       copies of the namespace, the sock, and the portid; the\n\t *       namespace and sock aren't going to go away while we hold a\n\t *       reference and if the portid does become invalid after the RCU\n\t *       section netlink_unicast() should safely return an error */\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\trc = -ECONNREFUSED;\n\t\tgoto err;\n\t}\n\tnet = get_net(ac->net);\n\tsk = audit_get_sk(net);\n\tportid = ac->portid;\n\trcu_read_unlock();\n\n\trc = netlink_unicast(sk, skb, portid, 0);\n\tput_net(net);\n\tif (rc < 0)\n\t\tgoto err;\n\n\treturn rc;\n\nerr:\n\tif (ac && rc == -ECONNREFUSED)\n\t\tauditd_reset(ac);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_make_reply",
          "args": [
            "0",
            "AUDIT_REPLACE",
            "0",
            "0",
            "&pvnr",
            "sizeof(pvnr)"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "audit_make_reply",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "905-928",
          "snippet": "struct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "pid"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "pid_vnr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "486-489",
          "snippet": "pid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_replace(struct pid *pid)\n{\n\tpid_t pvnr;\n\tstruct sk_buff *skb;\n\n\tpvnr = pid_vnr(pid);\n\tskb = audit_make_reply(0, AUDIT_REPLACE, 0, 0, &pvnr, sizeof(pvnr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treturn auditd_send_unicast_skb(skb);\n}"
  },
  {
    "function_name": "audit_set_feature",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1114-1168",
    "snippet": "static int audit_set_feature(struct audit_features *uaf)\n{\n\tint i;\n\n\tBUILD_BUG_ON(AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names));\n\n\t/* if there is ever a version 2 we should handle that here */\n\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\t\told_lock = af.lock & feature;\n\n\t\t/* are we changing a locked feature? */\n\t\tif (old_lock && (new_feature != old_feature)) {\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 0);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\t/* nothing invalid, do the changes */\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\told_lock = af.lock & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\n\t\tif (new_feature != old_feature)\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 1);\n\n\t\tif (new_feature)\n\t\t\taf.features |= feature;\n\t\telse\n\t\t\taf.features &= ~feature;\n\t\taf.lock |= new_lock;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};",
      "static char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_feature_change",
          "args": [
            "i",
            "old_feature",
            "new_feature",
            "old_lock",
            "new_lock",
            "1"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_feature_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1096-1112",
          "snippet": "static void audit_log_feature_change(int which, u32 old_feature, u32 new_feature,\n\t\t\t\t     u32 old_lock, u32 new_lock, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_FEATURE_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_task_info(ab);\n\taudit_log_format(ab, \" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\",\n\t\t\t audit_feature_names[which], !!old_feature, !!new_feature,\n\t\t\t !!old_lock, !!new_lock, res);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;",
            "static char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\nstatic char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};\n\nstatic void audit_log_feature_change(int which, u32 old_feature, u32 new_feature,\n\t\t\t\t     u32 old_lock, u32 new_lock, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_FEATURE_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_task_info(ab);\n\taudit_log_format(ab, \" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\",\n\t\t\t audit_feature_names[which], !!old_feature, !!new_feature,\n\t\t\t !!old_lock, !!new_lock, res);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIT_FEATURE_TO_MASK",
          "args": [
            "i"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_FEATURE_TO_MASK",
          "args": [
            "i"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "audit_feature_names"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\nstatic char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};\n\nstatic int audit_set_feature(struct audit_features *uaf)\n{\n\tint i;\n\n\tBUILD_BUG_ON(AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names));\n\n\t/* if there is ever a version 2 we should handle that here */\n\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\t\told_lock = af.lock & feature;\n\n\t\t/* are we changing a locked feature? */\n\t\tif (old_lock && (new_feature != old_feature)) {\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 0);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\t/* nothing invalid, do the changes */\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\told_lock = af.lock & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\n\t\tif (new_feature != old_feature)\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 1);\n\n\t\tif (new_feature)\n\t\t\taf.features |= feature;\n\t\telse\n\t\t\taf.features &= ~feature;\n\t\taf.lock |= new_lock;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_log_feature_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1096-1112",
    "snippet": "static void audit_log_feature_change(int which, u32 old_feature, u32 new_feature,\n\t\t\t\t     u32 old_lock, u32 new_lock, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_FEATURE_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_task_info(ab);\n\taudit_log_format(ab, \" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\",\n\t\t\t audit_feature_names[which], !!old_feature, !!new_feature,\n\t\t\t !!old_lock, !!new_lock, res);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;",
      "static char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\"",
            "audit_feature_names[which]",
            "!!old_feature",
            "!!new_feature",
            "!!old_lock",
            "!!new_lock",
            "res"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_info",
          "args": [
            "ab"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2207-2240",
          "snippet": "void audit_log_task_info(struct audit_buffer *ab)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(current->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(current),\n\t\t\t task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n\taudit_log_task_context(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_task_info(struct audit_buffer *ab)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(current->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(current),\n\t\t\t task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n\taudit_log_task_context(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_FEATURE_CHANGE"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\nstatic char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};\n\nstatic void audit_log_feature_change(int which, u32 old_feature, u32 new_feature,\n\t\t\t\t     u32 old_lock, u32 new_lock, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_FEATURE_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_task_info(ab);\n\taudit_log_format(ab, \" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\",\n\t\t\t audit_feature_names[which], !!old_feature, !!new_feature,\n\t\t\t !!old_lock, !!new_lock, res);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_get_feature",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1085-1094",
    "snippet": "static int audit_get_feature(struct sk_buff *skb)\n{\n\tu32 seq;\n\n\tseq = nlmsg_hdr(skb)->nlmsg_seq;\n\n\taudit_send_reply(skb, seq, AUDIT_GET_FEATURE, 0, 0, &af, sizeof(af));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_send_reply",
          "args": [
            "skb",
            "seq",
            "AUDIT_GET_FEATURE",
            "0",
            "0",
            "&af",
            "sizeof(af)"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "audit_send_reply",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "968-992",
          "snippet": "static void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply;\n\n\treply = kzalloc(sizeof(*reply), GFP_KERNEL);\n\tif (!reply)\n\t\treturn;\n\n\treply->skb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!reply->skb)\n\t\tgoto err;\n\treply->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\treply->portid = NETLINK_CB(request_skb).portid;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (IS_ERR(tsk))\n\t\tgoto err;\n\n\treturn;\n\nerr:\n\taudit_free_reply(reply);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply;\n\n\treply = kzalloc(sizeof(*reply), GFP_KERNEL);\n\tif (!reply)\n\t\treturn;\n\n\treply->skb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!reply->skb)\n\t\tgoto err;\n\treply->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\treply->portid = NETLINK_CB(request_skb).portid;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (IS_ERR(tsk))\n\t\tgoto err;\n\n\treturn;\n\nerr:\n\taudit_free_reply(reply);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "skb"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\n\nstatic int audit_get_feature(struct sk_buff *skb)\n{\n\tu32 seq;\n\n\tseq = nlmsg_hdr(skb)->nlmsg_seq;\n\n\taudit_send_reply(skb, seq, AUDIT_GET_FEATURE, 0, 0, &af, sizeof(af));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_audit_feature_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1079-1082",
    "snippet": "int is_audit_feature_set(int i)\n{\n\treturn af.features & AUDIT_FEATURE_TO_MASK(i);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUDIT_FEATURE_TO_MASK",
          "args": [
            "i"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\n\nint is_audit_feature_set(int i)\n{\n\treturn af.features & AUDIT_FEATURE_TO_MASK(i);\n}"
  },
  {
    "function_name": "audit_log_user_recv_msg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1073-1077",
    "snippet": "static inline void audit_log_user_recv_msg(struct audit_buffer **ab,\n\t\t\t\t\t   u16 msg_type)\n{\n\taudit_log_common_recv_msg(NULL, ab, msg_type);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_common_recv_msg",
          "args": [
            "NULL",
            "ab",
            "msg_type"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_common_recv_msg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1054-1071",
          "snippet": "static void audit_log_common_recv_msg(struct audit_context *context,\n\t\t\t\t\tstruct audit_buffer **ab, u16 msg_type)\n{\n\tuid_t uid = from_kuid(&init_user_ns, current_uid());\n\tpid_t pid = task_tgid_nr(current);\n\n\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {\n\t\t*ab = NULL;\n\t\treturn;\n\t}\n\n\t*ab = audit_log_start(context, GFP_KERNEL, msg_type);\n\tif (unlikely(!*ab))\n\t\treturn;\n\taudit_log_format(*ab, \"pid=%d uid=%u \", pid, uid);\n\taudit_log_session_info(*ab);\n\taudit_log_task_context(*ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic void audit_log_common_recv_msg(struct audit_context *context,\n\t\t\t\t\tstruct audit_buffer **ab, u16 msg_type)\n{\n\tuid_t uid = from_kuid(&init_user_ns, current_uid());\n\tpid_t pid = task_tgid_nr(current);\n\n\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {\n\t\t*ab = NULL;\n\t\treturn;\n\t}\n\n\t*ab = audit_log_start(context, GFP_KERNEL, msg_type);\n\tif (unlikely(!*ab))\n\t\treturn;\n\taudit_log_format(*ab, \"pid=%d uid=%u \", pid, uid);\n\taudit_log_session_info(*ab);\n\taudit_log_task_context(*ab);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline void audit_log_user_recv_msg(struct audit_buffer **ab,\n\t\t\t\t\t   u16 msg_type)\n{\n\taudit_log_common_recv_msg(NULL, ab, msg_type);\n}"
  },
  {
    "function_name": "audit_log_common_recv_msg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "1054-1071",
    "snippet": "static void audit_log_common_recv_msg(struct audit_context *context,\n\t\t\t\t\tstruct audit_buffer **ab, u16 msg_type)\n{\n\tuid_t uid = from_kuid(&init_user_ns, current_uid());\n\tpid_t pid = task_tgid_nr(current);\n\n\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {\n\t\t*ab = NULL;\n\t\treturn;\n\t}\n\n\t*ab = audit_log_start(context, GFP_KERNEL, msg_type);\n\tif (unlikely(!*ab))\n\t\treturn;\n\taudit_log_format(*ab, \"pid=%d uid=%u \", pid, uid);\n\taudit_log_session_info(*ab);\n\taudit_log_task_context(*ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "*ab"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2143-2168",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_session_info",
          "args": [
            "*ab"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_session_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2126-2132",
          "snippet": "void audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "*ab",
            "\"pid=%d uid=%u \"",
            "pid",
            "uid"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!*ab"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "msg_type"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_uid()"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic void audit_log_common_recv_msg(struct audit_context *context,\n\t\t\t\t\tstruct audit_buffer **ab, u16 msg_type)\n{\n\tuid_t uid = from_kuid(&init_user_ns, current_uid());\n\tpid_t pid = task_tgid_nr(current);\n\n\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {\n\t\t*ab = NULL;\n\t\treturn;\n\t}\n\n\t*ab = audit_log_start(context, GFP_KERNEL, msg_type);\n\tif (unlikely(!*ab))\n\t\treturn;\n\taudit_log_format(*ab, \"pid=%d uid=%u \", pid, uid);\n\taudit_log_session_info(*ab);\n\taudit_log_task_context(*ab);\n}"
  },
  {
    "function_name": "audit_netlink_ok",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "998-1052",
    "snippet": "static int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)\n{\n\tint err = 0;\n\n\t/* Only support initial user namespace for now. */\n\t/*\n\t * We return ECONNREFUSED because it tricks userspace into thinking\n\t * that audit was not configured into the kernel.  Lots of users\n\t * configure their PAM stack (because that's what the distro does)\n\t * to reject login if unable to send messages to audit.  If we return\n\t * ECONNREFUSED the PAM stack thinks the kernel does not have audit\n\t * configured in and will let login proceed.  If we return EPERM\n\t * userspace will reject all logins.  This should be removed when we\n\t * support non init namespaces!!\n\t */\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -ECONNREFUSED;\n\n\tswitch (msg_type) {\n\tcase AUDIT_LIST:\n\tcase AUDIT_ADD:\n\tcase AUDIT_DEL:\n\t\treturn -EOPNOTSUPP;\n\tcase AUDIT_GET:\n\tcase AUDIT_SET:\n\tcase AUDIT_GET_FEATURE:\n\tcase AUDIT_SET_FEATURE:\n\tcase AUDIT_LIST_RULES:\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\tcase AUDIT_SIGNAL_INFO:\n\tcase AUDIT_TTY_GET:\n\tcase AUDIT_TTY_SET:\n\tcase AUDIT_TRIM:\n\tcase AUDIT_MAKE_EQUIV:\n\t\t/* Only support auditd and auditctl in initial pid namespace\n\t\t * for now. */\n\t\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\t\treturn -EPERM;\n\n\t\tif (!netlink_capable(skb, CAP_AUDIT_CONTROL))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!netlink_capable(skb, CAP_AUDIT_WRITE))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tdefault:  /* bad msg */\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlink_capable",
          "args": [
            "skb",
            "CAP_AUDIT_WRITE"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_capable",
          "args": [
            "skb",
            "CAP_AUDIT_CONTROL"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)\n{\n\tint err = 0;\n\n\t/* Only support initial user namespace for now. */\n\t/*\n\t * We return ECONNREFUSED because it tricks userspace into thinking\n\t * that audit was not configured into the kernel.  Lots of users\n\t * configure their PAM stack (because that's what the distro does)\n\t * to reject login if unable to send messages to audit.  If we return\n\t * ECONNREFUSED the PAM stack thinks the kernel does not have audit\n\t * configured in and will let login proceed.  If we return EPERM\n\t * userspace will reject all logins.  This should be removed when we\n\t * support non init namespaces!!\n\t */\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -ECONNREFUSED;\n\n\tswitch (msg_type) {\n\tcase AUDIT_LIST:\n\tcase AUDIT_ADD:\n\tcase AUDIT_DEL:\n\t\treturn -EOPNOTSUPP;\n\tcase AUDIT_GET:\n\tcase AUDIT_SET:\n\tcase AUDIT_GET_FEATURE:\n\tcase AUDIT_SET_FEATURE:\n\tcase AUDIT_LIST_RULES:\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\tcase AUDIT_SIGNAL_INFO:\n\tcase AUDIT_TTY_GET:\n\tcase AUDIT_TTY_SET:\n\tcase AUDIT_TRIM:\n\tcase AUDIT_MAKE_EQUIV:\n\t\t/* Only support auditd and auditctl in initial pid namespace\n\t\t * for now. */\n\t\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\t\treturn -EPERM;\n\n\t\tif (!netlink_capable(skb, CAP_AUDIT_CONTROL))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!netlink_capable(skb, CAP_AUDIT_WRITE))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tdefault:  /* bad msg */\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "audit_send_reply",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "968-992",
    "snippet": "static void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply;\n\n\treply = kzalloc(sizeof(*reply), GFP_KERNEL);\n\tif (!reply)\n\t\treturn;\n\n\treply->skb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!reply->skb)\n\t\tgoto err;\n\treply->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\treply->portid = NETLINK_CB(request_skb).portid;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (IS_ERR(tsk))\n\t\tgoto err;\n\n\treturn;\n\nerr:\n\taudit_free_reply(reply);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_free_reply",
          "args": [
            "reply"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_reply",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "930-939",
          "snippet": "static void audit_free_reply(struct audit_reply *reply)\n{\n\tif (!reply)\n\t\treturn;\n\n\tkfree_skb(reply->skb);\n\tif (reply->net)\n\t\tput_net(reply->net);\n\tkfree(reply);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_free_reply(struct audit_reply *reply)\n{\n\tif (!reply)\n\t\treturn;\n\n\tkfree_skb(reply->skb);\n\tif (reply->net)\n\t\tput_net(reply->net);\n\tkfree(reply);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tsk"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "audit_send_reply_thread",
            "reply",
            "\"audit_send_reply\""
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "request_skb"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "sock_net(NETLINK_CB(request_skb).sk)"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_net",
          "args": [
            "NETLINK_CB(request_skb).sk"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "request_skb"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_make_reply",
          "args": [
            "seq",
            "type",
            "done",
            "multi",
            "payload",
            "size"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "audit_make_reply",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "905-928",
          "snippet": "struct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*reply)",
            "GFP_KERNEL"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply;\n\n\treply = kzalloc(sizeof(*reply), GFP_KERNEL);\n\tif (!reply)\n\t\treturn;\n\n\treply->skb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!reply->skb)\n\t\tgoto err;\n\treply->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\treply->portid = NETLINK_CB(request_skb).portid;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (IS_ERR(tsk))\n\t\tgoto err;\n\n\treturn;\n\nerr:\n\taudit_free_reply(reply);\n}"
  },
  {
    "function_name": "audit_send_reply_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "941-954",
    "snippet": "static int audit_send_reply_thread(void *arg)\n{\n\tstruct audit_reply *reply = (struct audit_reply *)arg;\n\n\taudit_ctl_lock();\n\taudit_ctl_unlock();\n\n\t/* Ignore failure. It'll only happen if the sender goes away,\n\t   because our timeout is set to infinite. */\n\tnetlink_unicast(audit_get_sk(reply->net), reply->skb, reply->portid, 0);\n\treply->skb = NULL;\n\taudit_free_reply(reply);\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_free_reply",
          "args": [
            "reply"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_reply",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "930-939",
          "snippet": "static void audit_free_reply(struct audit_reply *reply)\n{\n\tif (!reply)\n\t\treturn;\n\n\tkfree_skb(reply->skb);\n\tif (reply->net)\n\t\tput_net(reply->net);\n\tkfree(reply);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_free_reply(struct audit_reply *reply)\n{\n\tif (!reply)\n\t\treturn;\n\n\tkfree_skb(reply->skb);\n\tif (reply->net)\n\t\tput_net(reply->net);\n\tkfree(reply);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_unicast",
          "args": [
            "audit_get_sk(reply->net)",
            "reply->skb",
            "reply->portid",
            "0"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sk",
          "args": [
            "reply->net"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_sk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "291-300",
          "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int audit_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ctl_unlock",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "243-247",
          "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ctl_lock",
          "args": [],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "234-238",
          "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_send_reply_thread(void *arg)\n{\n\tstruct audit_reply *reply = (struct audit_reply *)arg;\n\n\taudit_ctl_lock();\n\taudit_ctl_unlock();\n\n\t/* Ignore failure. It'll only happen if the sender goes away,\n\t   because our timeout is set to infinite. */\n\tnetlink_unicast(audit_get_sk(reply->net), reply->skb, reply->portid, 0);\n\treply->skb = NULL;\n\taudit_free_reply(reply);\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_free_reply",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "930-939",
    "snippet": "static void audit_free_reply(struct audit_reply *reply)\n{\n\tif (!reply)\n\t\treturn;\n\n\tkfree_skb(reply->skb);\n\tif (reply->net)\n\t\tput_net(reply->net);\n\tkfree(reply);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "reply"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "reply->net"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "reply->skb"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_free_reply(struct audit_reply *reply)\n{\n\tif (!reply)\n\t\treturn;\n\n\tkfree_skb(reply->skb);\n\tif (reply->net)\n\t\tput_net(reply->net);\n\tkfree(reply);\n}"
  },
  {
    "function_name": "audit_make_reply",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "905-928",
    "snippet": "struct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "skb"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "payload",
            "size"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_data",
          "args": [
            "nlh"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_put",
          "args": [
            "skb",
            "0",
            "seq",
            "t",
            "size",
            "flags"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_new",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}"
  },
  {
    "function_name": "audit_send_list_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "886-903",
    "snippet": "int audit_send_list_thread(void *_dest)\n{\n\tstruct audit_netlink_list *dest = _dest;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = audit_get_sk(dest->net);\n\n\t/* wait for parent to finish and send an ACK */\n\taudit_ctl_lock();\n\taudit_ctl_unlock();\n\n\twhile ((skb = __skb_dequeue(&dest->q)) != NULL)\n\t\tnetlink_unicast(sk, skb, dest->portid, 0);\n\n\tput_net(dest->net);\n\tkfree(dest);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dest"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "dest->net"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_unicast",
          "args": [
            "sk",
            "skb",
            "dest->portid",
            "0"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__skb_dequeue",
          "args": [
            "&dest->q"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ctl_unlock",
          "args": [],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "243-247",
          "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ctl_lock",
          "args": [],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "234-238",
          "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sk",
          "args": [
            "dest->net"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_sk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "291-300",
          "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int audit_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_send_list_thread(void *_dest)\n{\n\tstruct audit_netlink_list *dest = _dest;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = audit_get_sk(dest->net);\n\n\t/* wait for parent to finish and send an ACK */\n\taudit_ctl_lock();\n\taudit_ctl_unlock();\n\n\twhile ((skb = __skb_dequeue(&dest->q)) != NULL)\n\t\tnetlink_unicast(sk, skb, dest->portid, 0);\n\n\tput_net(dest->net);\n\tkfree(dest);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kauditd_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "809-884",
    "snippet": "static int kauditd_thread(void *dummy)\n{\n\tint rc;\n\tu32 portid = 0;\n\tstruct net *net = NULL;\n\tstruct sock *sk = NULL;\n\tstruct auditd_connection *ac;\n\n#define UNICAST_RETRIES 5\n\n\tset_freezable();\n\twhile (!kthread_should_stop()) {\n\t\t/* NOTE: see the lock comments in auditd_send_unicast_skb() */\n\t\trcu_read_lock();\n\t\tac = rcu_dereference(auditd_conn);\n\t\tif (!ac) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto main_queue;\n\t\t}\n\t\tnet = get_net(ac->net);\n\t\tsk = audit_get_sk(net);\n\t\tportid = ac->portid;\n\t\trcu_read_unlock();\n\n\t\t/* attempt to flush the hold queue */\n\t\trc = kauditd_send_queue(sk, portid,\n\t\t\t\t\t&audit_hold_queue, UNICAST_RETRIES,\n\t\t\t\t\tNULL, kauditd_rehold_skb);\n\t\tif (rc < 0) {\n\t\t\tsk = NULL;\n\t\t\tauditd_reset(ac);\n\t\t\tgoto main_queue;\n\t\t}\n\n\t\t/* attempt to flush the retry queue */\n\t\trc = kauditd_send_queue(sk, portid,\n\t\t\t\t\t&audit_retry_queue, UNICAST_RETRIES,\n\t\t\t\t\tNULL, kauditd_hold_skb);\n\t\tif (rc < 0) {\n\t\t\tsk = NULL;\n\t\t\tauditd_reset(ac);\n\t\t\tgoto main_queue;\n\t\t}\n\nmain_queue:\n\t\t/* process the main queue - do the multicast send and attempt\n\t\t * unicast, dump failed record sends to the retry queue; if\n\t\t * sk == NULL due to previous failures we will just do the\n\t\t * multicast send and move the record to the hold queue */\n\t\trc = kauditd_send_queue(sk, portid, &audit_queue, 1,\n\t\t\t\t\tkauditd_send_multicast_skb,\n\t\t\t\t\t(sk ?\n\t\t\t\t\t kauditd_retry_skb : kauditd_hold_skb));\n\t\tif (ac && rc < 0)\n\t\t\tauditd_reset(ac);\n\t\tsk = NULL;\n\n\t\t/* drop our netns reference, no auditd sends past this line */\n\t\tif (net) {\n\t\t\tput_net(net);\n\t\t\tnet = NULL;\n\t\t}\n\n\t\t/* we have processed all the queues so wake everyone */\n\t\twake_up(&audit_backlog_wait);\n\n\t\t/* NOTE: we want to wake up if there is anything on the queue,\n\t\t *       regardless of if an auditd is connected, as we need to\n\t\t *       do the multicast send and rotate records from the\n\t\t *       main queue to the retry/hold queues */\n\t\twait_event_freezable(kauditd_wait,\n\t\t\t\t     (skb_queue_len(&audit_queue) ? 1 : 0));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define UNICAST_RETRIES 5"
    ],
    "globals_used": [
      "static struct auditd_connection __rcu *auditd_conn;",
      "static struct sk_buff_head audit_queue;",
      "static struct sk_buff_head audit_retry_queue;",
      "static struct sk_buff_head audit_hold_queue;",
      "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
      "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event_freezable",
          "args": [
            "kauditd_wait",
            "(skb_queue_len(&audit_queue) ? 1 : 0)"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_len",
          "args": [
            "&audit_queue"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&audit_backlog_wait"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "net"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auditd_reset",
          "args": [
            "ac"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "619-644",
          "snippet": "static void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;",
            "static DEFINE_SPINLOCK(auditd_conn_lock);",
            "static struct sk_buff_head audit_retry_queue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\nstatic struct sk_buff_head audit_retry_queue;\n\nstatic void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kauditd_send_queue",
          "args": [
            "sk",
            "portid",
            "&audit_queue",
            "1",
            "kauditd_send_multicast_skb",
            "(sk ?\n\t\t\t\t\t kauditd_retry_skb : kauditd_hold_skb)"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_send_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "713-763",
          "snippet": "static int kauditd_send_queue(struct sock *sk, u32 portid,\n\t\t\t      struct sk_buff_head *queue,\n\t\t\t      unsigned int retry_limit,\n\t\t\t      void (*skb_hook)(struct sk_buff *skb),\n\t\t\t      void (*err_hook)(struct sk_buff *skb))\n{\n\tint rc = 0;\n\tstruct sk_buff *skb;\n\tunsigned int failed = 0;\n\n\t/* NOTE: kauditd_thread takes care of all our locking, we just use\n\t *       the netlink info passed to us (e.g. sk and portid) */\n\n\twhile ((skb = skb_dequeue(queue))) {\n\t\t/* call the skb_hook for each skb we touch */\n\t\tif (skb_hook)\n\t\t\t(*skb_hook)(skb);\n\n\t\t/* can we send to anyone via unicast? */\n\t\tif (!sk) {\n\t\t\tif (err_hook)\n\t\t\t\t(*err_hook)(skb);\n\t\t\tcontinue;\n\t\t}\n\nretry:\n\t\t/* grab an extra skb reference in case of error */\n\t\tskb_get(skb);\n\t\trc = netlink_unicast(sk, skb, portid, 0);\n\t\tif (rc < 0) {\n\t\t\t/* send failed - try a few times unless fatal error */\n\t\t\tif (++failed >= retry_limit ||\n\t\t\t    rc == -ECONNREFUSED || rc == -EPERM) {\n\t\t\t\tsk = NULL;\n\t\t\t\tif (err_hook)\n\t\t\t\t\t(*err_hook)(skb);\n\t\t\t\tif (rc == -EAGAIN)\n\t\t\t\t\trc = 0;\n\t\t\t\t/* continue to drain the queue */\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tgoto retry;\n\t\t} else {\n\t\t\t/* skb sent - drop the extra reference and continue */\n\t\t\tconsume_skb(skb);\n\t\t\tfailed = 0;\n\t\t}\n\t}\n\n\treturn (rc >= 0 ? 0 : rc);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int kauditd_send_queue(struct sock *sk, u32 portid,\n\t\t\t      struct sk_buff_head *queue,\n\t\t\t      unsigned int retry_limit,\n\t\t\t      void (*skb_hook)(struct sk_buff *skb),\n\t\t\t      void (*err_hook)(struct sk_buff *skb))\n{\n\tint rc = 0;\n\tstruct sk_buff *skb;\n\tunsigned int failed = 0;\n\n\t/* NOTE: kauditd_thread takes care of all our locking, we just use\n\t *       the netlink info passed to us (e.g. sk and portid) */\n\n\twhile ((skb = skb_dequeue(queue))) {\n\t\t/* call the skb_hook for each skb we touch */\n\t\tif (skb_hook)\n\t\t\t(*skb_hook)(skb);\n\n\t\t/* can we send to anyone via unicast? */\n\t\tif (!sk) {\n\t\t\tif (err_hook)\n\t\t\t\t(*err_hook)(skb);\n\t\t\tcontinue;\n\t\t}\n\nretry:\n\t\t/* grab an extra skb reference in case of error */\n\t\tskb_get(skb);\n\t\trc = netlink_unicast(sk, skb, portid, 0);\n\t\tif (rc < 0) {\n\t\t\t/* send failed - try a few times unless fatal error */\n\t\t\tif (++failed >= retry_limit ||\n\t\t\t    rc == -ECONNREFUSED || rc == -EPERM) {\n\t\t\t\tsk = NULL;\n\t\t\t\tif (err_hook)\n\t\t\t\t\t(*err_hook)(skb);\n\t\t\t\tif (rc == -EAGAIN)\n\t\t\t\t\trc = 0;\n\t\t\t\t/* continue to drain the queue */\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tgoto retry;\n\t\t} else {\n\t\t\t/* skb sent - drop the extra reference and continue */\n\t\t\tconsume_skb(skb);\n\t\t\tfailed = 0;\n\t\t}\n\t}\n\n\treturn (rc >= 0 ? 0 : rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sk",
          "args": [
            "net"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_sk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "291-300",
          "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int audit_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "ac->net"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "auditd_conn"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "set_freezable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "161-175",
          "snippet": "bool set_freezable(void)\n{\n\tmight_sleep();\n\n\t/*\n\t * Modify flags while holding freezer_lock.  This ensures the\n\t * freezer notices that we aren't frozen yet or the freezing\n\t * condition is visible to try_to_freeze() below.\n\t */\n\tspin_lock_irq(&freezer_lock);\n\tcurrent->flags &= ~PF_NOFREEZE;\n\tspin_unlock_irq(&freezer_lock);\n\n\treturn try_to_freeze();\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(freezer_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nbool set_freezable(void)\n{\n\tmight_sleep();\n\n\t/*\n\t * Modify flags while holding freezer_lock.  This ensures the\n\t * freezer notices that we aren't frozen yet or the freezing\n\t * condition is visible to try_to_freeze() below.\n\t */\n\tspin_lock_irq(&freezer_lock);\n\tcurrent->flags &= ~PF_NOFREEZE;\n\tspin_unlock_irq(&freezer_lock);\n\n\treturn try_to_freeze();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define UNICAST_RETRIES 5\n\nstatic struct auditd_connection __rcu *auditd_conn;\nstatic struct sk_buff_head audit_queue;\nstatic struct sk_buff_head audit_retry_queue;\nstatic struct sk_buff_head audit_hold_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\n\nstatic int kauditd_thread(void *dummy)\n{\n\tint rc;\n\tu32 portid = 0;\n\tstruct net *net = NULL;\n\tstruct sock *sk = NULL;\n\tstruct auditd_connection *ac;\n\n#define UNICAST_RETRIES 5\n\n\tset_freezable();\n\twhile (!kthread_should_stop()) {\n\t\t/* NOTE: see the lock comments in auditd_send_unicast_skb() */\n\t\trcu_read_lock();\n\t\tac = rcu_dereference(auditd_conn);\n\t\tif (!ac) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto main_queue;\n\t\t}\n\t\tnet = get_net(ac->net);\n\t\tsk = audit_get_sk(net);\n\t\tportid = ac->portid;\n\t\trcu_read_unlock();\n\n\t\t/* attempt to flush the hold queue */\n\t\trc = kauditd_send_queue(sk, portid,\n\t\t\t\t\t&audit_hold_queue, UNICAST_RETRIES,\n\t\t\t\t\tNULL, kauditd_rehold_skb);\n\t\tif (rc < 0) {\n\t\t\tsk = NULL;\n\t\t\tauditd_reset(ac);\n\t\t\tgoto main_queue;\n\t\t}\n\n\t\t/* attempt to flush the retry queue */\n\t\trc = kauditd_send_queue(sk, portid,\n\t\t\t\t\t&audit_retry_queue, UNICAST_RETRIES,\n\t\t\t\t\tNULL, kauditd_hold_skb);\n\t\tif (rc < 0) {\n\t\t\tsk = NULL;\n\t\t\tauditd_reset(ac);\n\t\t\tgoto main_queue;\n\t\t}\n\nmain_queue:\n\t\t/* process the main queue - do the multicast send and attempt\n\t\t * unicast, dump failed record sends to the retry queue; if\n\t\t * sk == NULL due to previous failures we will just do the\n\t\t * multicast send and move the record to the hold queue */\n\t\trc = kauditd_send_queue(sk, portid, &audit_queue, 1,\n\t\t\t\t\tkauditd_send_multicast_skb,\n\t\t\t\t\t(sk ?\n\t\t\t\t\t kauditd_retry_skb : kauditd_hold_skb));\n\t\tif (ac && rc < 0)\n\t\t\tauditd_reset(ac);\n\t\tsk = NULL;\n\n\t\t/* drop our netns reference, no auditd sends past this line */\n\t\tif (net) {\n\t\t\tput_net(net);\n\t\t\tnet = NULL;\n\t\t}\n\n\t\t/* we have processed all the queues so wake everyone */\n\t\twake_up(&audit_backlog_wait);\n\n\t\t/* NOTE: we want to wake up if there is anything on the queue,\n\t\t *       regardless of if an auditd is connected, as we need to\n\t\t *       do the multicast send and rotate records from the\n\t\t *       main queue to the retry/hold queues */\n\t\twait_event_freezable(kauditd_wait,\n\t\t\t\t     (skb_queue_len(&audit_queue) ? 1 : 0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kauditd_send_multicast_skb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "774-803",
    "snippet": "static void kauditd_send_multicast_skb(struct sk_buff *skb)\n{\n\tstruct sk_buff *copy;\n\tstruct sock *sock = audit_get_sk(&init_net);\n\tstruct nlmsghdr *nlh;\n\n\t/* NOTE: we are not taking an additional reference for init_net since\n\t *       we don't have to worry about it going away */\n\n\tif (!netlink_has_listeners(sock, AUDIT_NLGRP_READLOG))\n\t\treturn;\n\n\t/*\n\t * The seemingly wasteful skb_copy() rather than bumping the refcount\n\t * using skb_get() is necessary because non-standard mods are made to\n\t * the skb by the original kaudit unicast socket send routine.  The\n\t * existing auditd daemon assumes this breakage.  Fixing this would\n\t * require co-ordinating a change in the established protocol between\n\t * the kaudit kernel subsystem and the auditd userspace code.  There is\n\t * no reason for new multicast clients to continue with this\n\t * non-compliance.\n\t */\n\tcopy = skb_copy(skb, GFP_KERNEL);\n\tif (!copy)\n\t\treturn;\n\tnlh = nlmsg_hdr(copy);\n\tnlh->nlmsg_len = skb->len;\n\n\tnlmsg_multicast(sock, copy, 0, AUDIT_NLGRP_READLOG, GFP_KERNEL);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_multicast",
          "args": [
            "sock",
            "copy",
            "0",
            "AUDIT_NLGRP_READLOG",
            "GFP_KERNEL"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "copy"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_copy",
          "args": [
            "skb",
            "GFP_KERNEL"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_has_listeners",
          "args": [
            "sock",
            "AUDIT_NLGRP_READLOG"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sk",
          "args": [
            "&init_net"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_sk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "291-300",
          "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int audit_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_send_multicast_skb(struct sk_buff *skb)\n{\n\tstruct sk_buff *copy;\n\tstruct sock *sock = audit_get_sk(&init_net);\n\tstruct nlmsghdr *nlh;\n\n\t/* NOTE: we are not taking an additional reference for init_net since\n\t *       we don't have to worry about it going away */\n\n\tif (!netlink_has_listeners(sock, AUDIT_NLGRP_READLOG))\n\t\treturn;\n\n\t/*\n\t * The seemingly wasteful skb_copy() rather than bumping the refcount\n\t * using skb_get() is necessary because non-standard mods are made to\n\t * the skb by the original kaudit unicast socket send routine.  The\n\t * existing auditd daemon assumes this breakage.  Fixing this would\n\t * require co-ordinating a change in the established protocol between\n\t * the kaudit kernel subsystem and the auditd userspace code.  There is\n\t * no reason for new multicast clients to continue with this\n\t * non-compliance.\n\t */\n\tcopy = skb_copy(skb, GFP_KERNEL);\n\tif (!copy)\n\t\treturn;\n\tnlh = nlmsg_hdr(copy);\n\tnlh->nlmsg_len = skb->len;\n\n\tnlmsg_multicast(sock, copy, 0, AUDIT_NLGRP_READLOG, GFP_KERNEL);\n}"
  },
  {
    "function_name": "kauditd_send_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "713-763",
    "snippet": "static int kauditd_send_queue(struct sock *sk, u32 portid,\n\t\t\t      struct sk_buff_head *queue,\n\t\t\t      unsigned int retry_limit,\n\t\t\t      void (*skb_hook)(struct sk_buff *skb),\n\t\t\t      void (*err_hook)(struct sk_buff *skb))\n{\n\tint rc = 0;\n\tstruct sk_buff *skb;\n\tunsigned int failed = 0;\n\n\t/* NOTE: kauditd_thread takes care of all our locking, we just use\n\t *       the netlink info passed to us (e.g. sk and portid) */\n\n\twhile ((skb = skb_dequeue(queue))) {\n\t\t/* call the skb_hook for each skb we touch */\n\t\tif (skb_hook)\n\t\t\t(*skb_hook)(skb);\n\n\t\t/* can we send to anyone via unicast? */\n\t\tif (!sk) {\n\t\t\tif (err_hook)\n\t\t\t\t(*err_hook)(skb);\n\t\t\tcontinue;\n\t\t}\n\nretry:\n\t\t/* grab an extra skb reference in case of error */\n\t\tskb_get(skb);\n\t\trc = netlink_unicast(sk, skb, portid, 0);\n\t\tif (rc < 0) {\n\t\t\t/* send failed - try a few times unless fatal error */\n\t\t\tif (++failed >= retry_limit ||\n\t\t\t    rc == -ECONNREFUSED || rc == -EPERM) {\n\t\t\t\tsk = NULL;\n\t\t\t\tif (err_hook)\n\t\t\t\t\t(*err_hook)(skb);\n\t\t\t\tif (rc == -EAGAIN)\n\t\t\t\t\trc = 0;\n\t\t\t\t/* continue to drain the queue */\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tgoto retry;\n\t\t} else {\n\t\t\t/* skb sent - drop the extra reference and continue */\n\t\t\tconsume_skb(skb);\n\t\t\tfailed = 0;\n\t\t}\n\t}\n\n\treturn (rc >= 0 ? 0 : rc);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "consume_skb",
          "args": [
            "skb"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "skb"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_unicast",
          "args": [
            "sk",
            "skb",
            "portid",
            "0"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_get",
          "args": [
            "skb"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "skb"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "skb"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_dequeue",
          "args": [
            "queue"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int kauditd_send_queue(struct sock *sk, u32 portid,\n\t\t\t      struct sk_buff_head *queue,\n\t\t\t      unsigned int retry_limit,\n\t\t\t      void (*skb_hook)(struct sk_buff *skb),\n\t\t\t      void (*err_hook)(struct sk_buff *skb))\n{\n\tint rc = 0;\n\tstruct sk_buff *skb;\n\tunsigned int failed = 0;\n\n\t/* NOTE: kauditd_thread takes care of all our locking, we just use\n\t *       the netlink info passed to us (e.g. sk and portid) */\n\n\twhile ((skb = skb_dequeue(queue))) {\n\t\t/* call the skb_hook for each skb we touch */\n\t\tif (skb_hook)\n\t\t\t(*skb_hook)(skb);\n\n\t\t/* can we send to anyone via unicast? */\n\t\tif (!sk) {\n\t\t\tif (err_hook)\n\t\t\t\t(*err_hook)(skb);\n\t\t\tcontinue;\n\t\t}\n\nretry:\n\t\t/* grab an extra skb reference in case of error */\n\t\tskb_get(skb);\n\t\trc = netlink_unicast(sk, skb, portid, 0);\n\t\tif (rc < 0) {\n\t\t\t/* send failed - try a few times unless fatal error */\n\t\t\tif (++failed >= retry_limit ||\n\t\t\t    rc == -ECONNREFUSED || rc == -EPERM) {\n\t\t\t\tsk = NULL;\n\t\t\t\tif (err_hook)\n\t\t\t\t\t(*err_hook)(skb);\n\t\t\t\tif (rc == -EAGAIN)\n\t\t\t\t\trc = 0;\n\t\t\t\t/* continue to drain the queue */\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tgoto retry;\n\t\t} else {\n\t\t\t/* skb sent - drop the extra reference and continue */\n\t\t\tconsume_skb(skb);\n\t\t\tfailed = 0;\n\t\t}\n\t}\n\n\treturn (rc >= 0 ? 0 : rc);\n}"
  },
  {
    "function_name": "auditd_send_unicast_skb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "657-696",
    "snippet": "static int auditd_send_unicast_skb(struct sk_buff *skb)\n{\n\tint rc;\n\tu32 portid;\n\tstruct net *net;\n\tstruct sock *sk;\n\tstruct auditd_connection *ac;\n\n\t/* NOTE: we can't call netlink_unicast while in the RCU section so\n\t *       take a reference to the network namespace and grab local\n\t *       copies of the namespace, the sock, and the portid; the\n\t *       namespace and sock aren't going to go away while we hold a\n\t *       reference and if the portid does become invalid after the RCU\n\t *       section netlink_unicast() should safely return an error */\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\trc = -ECONNREFUSED;\n\t\tgoto err;\n\t}\n\tnet = get_net(ac->net);\n\tsk = audit_get_sk(net);\n\tportid = ac->portid;\n\trcu_read_unlock();\n\n\trc = netlink_unicast(sk, skb, portid, 0);\n\tput_net(net);\n\tif (rc < 0)\n\t\tgoto err;\n\n\treturn rc;\n\nerr:\n\tif (ac && rc == -ECONNREFUSED)\n\t\tauditd_reset(ac);\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct auditd_connection __rcu *auditd_conn;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "auditd_reset",
          "args": [
            "ac"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "619-644",
          "snippet": "static void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;",
            "static DEFINE_SPINLOCK(auditd_conn_lock);",
            "static struct sk_buff_head audit_retry_queue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\nstatic struct sk_buff_head audit_retry_queue;\n\nstatic void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "net"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_unicast",
          "args": [
            "sk",
            "skb",
            "portid",
            "0"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sk",
          "args": [
            "net"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_sk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "291-300",
          "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int audit_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "ac->net"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "skb"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "auditd_conn"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\n\nstatic int auditd_send_unicast_skb(struct sk_buff *skb)\n{\n\tint rc;\n\tu32 portid;\n\tstruct net *net;\n\tstruct sock *sk;\n\tstruct auditd_connection *ac;\n\n\t/* NOTE: we can't call netlink_unicast while in the RCU section so\n\t *       take a reference to the network namespace and grab local\n\t *       copies of the namespace, the sock, and the portid; the\n\t *       namespace and sock aren't going to go away while we hold a\n\t *       reference and if the portid does become invalid after the RCU\n\t *       section netlink_unicast() should safely return an error */\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\trc = -ECONNREFUSED;\n\t\tgoto err;\n\t}\n\tnet = get_net(ac->net);\n\tsk = audit_get_sk(net);\n\tportid = ac->portid;\n\trcu_read_unlock();\n\n\trc = netlink_unicast(sk, skb, portid, 0);\n\tput_net(net);\n\tif (rc < 0)\n\t\tgoto err;\n\n\treturn rc;\n\nerr:\n\tif (ac && rc == -ECONNREFUSED)\n\t\tauditd_reset(ac);\n\treturn rc;\n}"
  },
  {
    "function_name": "auditd_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "619-644",
    "snippet": "static void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct auditd_connection __rcu *auditd_conn;",
      "static DEFINE_SPINLOCK(auditd_conn_lock);",
      "static struct sk_buff_head audit_retry_queue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kauditd_hold_skb",
          "args": [
            "skb"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_hold_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "567-589",
          "snippet": "static void kauditd_hold_skb(struct sk_buff *skb)\n{\n\t/* at this point it is uncertain if we will ever send this to auditd so\n\t * try to send the message via printk before we go any further */\n\tkauditd_printk_skb(skb);\n\n\t/* can we just silently drop the message? */\n\tif (!audit_default) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* if we have room, queue the message */\n\tif (!audit_backlog_limit ||\n\t    skb_queue_len(&audit_hold_queue) < audit_backlog_limit) {\n\t\tskb_queue_tail(&audit_hold_queue, skb);\n\t\treturn;\n\t}\n\n\t/* we have no other options - drop the message */\n\taudit_log_lost(\"kauditd hold queue overflow\");\n\tkfree_skb(skb);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_default = AUDIT_OFF;",
            "static u32\taudit_backlog_limit = 64;",
            "static struct sk_buff_head audit_hold_queue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_default = AUDIT_OFF;\nstatic u32\taudit_backlog_limit = 64;\nstatic struct sk_buff_head audit_hold_queue;\n\nstatic void kauditd_hold_skb(struct sk_buff *skb)\n{\n\t/* at this point it is uncertain if we will ever send this to auditd so\n\t * try to send the message via printk before we go any further */\n\tkauditd_printk_skb(skb);\n\n\t/* can we just silently drop the message? */\n\tif (!audit_default) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* if we have room, queue the message */\n\tif (!audit_backlog_limit ||\n\t    skb_queue_len(&audit_hold_queue) < audit_backlog_limit) {\n\t\tskb_queue_tail(&audit_hold_queue, skb);\n\t\treturn;\n\t}\n\n\t/* we have no other options - drop the message */\n\taudit_log_lost(\"kauditd hold queue overflow\");\n\tkfree_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_dequeue",
          "args": [
            "&audit_retry_queue"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&ac_old->rcu",
            "auditd_conn_free"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&auditd_conn_lock",
            "flags"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "auditd_conn",
            "NULL"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "auditd_conn",
            "lockdep_is_held(&auditd_conn_lock)"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&auditd_conn_lock"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&auditd_conn_lock",
            "flags"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\nstatic struct sk_buff_head audit_retry_queue;\n\nstatic void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}"
  },
  {
    "function_name": "kauditd_retry_skb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "600-606",
    "snippet": "static void kauditd_retry_skb(struct sk_buff *skb)\n{\n\t/* NOTE: because records should only live in the retry queue for a\n\t * short period of time, before either being sent or moved to the hold\n\t * queue, we don't currently enforce a limit on this queue */\n\tskb_queue_tail(&audit_retry_queue, skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sk_buff_head audit_retry_queue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "&audit_retry_queue",
            "skb"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_retry_queue;\n\nstatic void kauditd_retry_skb(struct sk_buff *skb)\n{\n\t/* NOTE: because records should only live in the retry queue for a\n\t * short period of time, before either being sent or moved to the hold\n\t * queue, we don't currently enforce a limit on this queue */\n\tskb_queue_tail(&audit_retry_queue, skb);\n}"
  },
  {
    "function_name": "kauditd_hold_skb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "567-589",
    "snippet": "static void kauditd_hold_skb(struct sk_buff *skb)\n{\n\t/* at this point it is uncertain if we will ever send this to auditd so\n\t * try to send the message via printk before we go any further */\n\tkauditd_printk_skb(skb);\n\n\t/* can we just silently drop the message? */\n\tif (!audit_default) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* if we have room, queue the message */\n\tif (!audit_backlog_limit ||\n\t    skb_queue_len(&audit_hold_queue) < audit_backlog_limit) {\n\t\tskb_queue_tail(&audit_hold_queue, skb);\n\t\treturn;\n\t}\n\n\t/* we have no other options - drop the message */\n\taudit_log_lost(\"kauditd hold queue overflow\");\n\tkfree_skb(skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_default = AUDIT_OFF;",
      "static u32\taudit_backlog_limit = 64;",
      "static struct sk_buff_head audit_hold_queue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "skb"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"kauditd hold queue overflow\""
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "354-384",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "&audit_hold_queue",
            "skb"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_len",
          "args": [
            "&audit_hold_queue"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "skb"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kauditd_printk_skb",
          "args": [
            "skb"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_default = AUDIT_OFF;\nstatic u32\taudit_backlog_limit = 64;\nstatic struct sk_buff_head audit_hold_queue;\n\nstatic void kauditd_hold_skb(struct sk_buff *skb)\n{\n\t/* at this point it is uncertain if we will ever send this to auditd so\n\t * try to send the message via printk before we go any further */\n\tkauditd_printk_skb(skb);\n\n\t/* can we just silently drop the message? */\n\tif (!audit_default) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* if we have room, queue the message */\n\tif (!audit_backlog_limit ||\n\t    skb_queue_len(&audit_hold_queue) < audit_backlog_limit) {\n\t\tskb_queue_tail(&audit_hold_queue, skb);\n\t\treturn;\n\t}\n\n\t/* we have no other options - drop the message */\n\taudit_log_lost(\"kauditd hold queue overflow\");\n\tkfree_skb(skb);\n}"
  },
  {
    "function_name": "kauditd_rehold_skb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "549-553",
    "snippet": "static void kauditd_rehold_skb(struct sk_buff *skb)\n{\n\t/* put the record back in the queue at the same place */\n\tskb_queue_head(&audit_hold_queue, skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sk_buff_head audit_hold_queue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_queue_head",
          "args": [
            "&audit_hold_queue",
            "skb"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_hold_queue;\n\nstatic void kauditd_rehold_skb(struct sk_buff *skb)\n{\n\t/* put the record back in the queue at the same place */\n\tskb_queue_head(&audit_hold_queue, skb);\n}"
  },
  {
    "function_name": "kauditd_printk_skb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "532-539",
    "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"type=%d %s\\n\"",
            "nlh->nlmsg_type",
            "data"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_data",
          "args": [
            "nlh"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "skb"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
  },
  {
    "function_name": "auditd_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "498-523",
    "snippet": "static int auditd_set(struct pid *pid, u32 portid, struct net *net)\n{\n\tunsigned long flags;\n\tstruct auditd_connection *ac_old, *ac_new;\n\n\tif (!pid || !net)\n\t\treturn -EINVAL;\n\n\tac_new = kzalloc(sizeof(*ac_new), GFP_KERNEL);\n\tif (!ac_new)\n\t\treturn -ENOMEM;\n\tac_new->pid = get_pid(pid);\n\tac_new->portid = portid;\n\tac_new->net = get_net(net);\n\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\trcu_assign_pointer(auditd_conn, ac_new);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct auditd_connection __rcu *auditd_conn;",
      "static DEFINE_SPINLOCK(auditd_conn_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&ac_old->rcu",
            "auditd_conn_free"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&auditd_conn_lock",
            "flags"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "auditd_conn",
            "ac_new"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "auditd_conn",
            "lockdep_is_held(&auditd_conn_lock)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&auditd_conn_lock"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&auditd_conn_lock",
            "flags"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "net"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "pid"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "460-469",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ac_new)",
            "GFP_KERNEL"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\n\nstatic int auditd_set(struct pid *pid, u32 portid, struct net *net)\n{\n\tunsigned long flags;\n\tstruct auditd_connection *ac_old, *ac_new;\n\n\tif (!pid || !net)\n\t\treturn -EINVAL;\n\n\tac_new = kzalloc(sizeof(*ac_new), GFP_KERNEL);\n\tif (!ac_new)\n\t\treturn -ENOMEM;\n\tac_new->pid = get_pid(pid);\n\tac_new->portid = portid;\n\tac_new->net = get_net(net);\n\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\trcu_assign_pointer(auditd_conn, ac_new);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "auditd_conn_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "478-486",
    "snippet": "static void auditd_conn_free(struct rcu_head *rcu)\n{\n\tstruct auditd_connection *ac;\n\n\tac = container_of(rcu, struct auditd_connection, rcu);\n\tput_pid(ac->pid);\n\tput_net(ac->net);\n\tkfree(ac);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ac"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "ac->net"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "ac->pid"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "120-124",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structauditd_connection",
            "rcu"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void auditd_conn_free(struct rcu_head *rcu)\n{\n\tstruct auditd_connection *ac;\n\n\tac = container_of(rcu, struct auditd_connection, rcu);\n\tput_pid(ac->pid);\n\tput_net(ac->net);\n\tkfree(ac);\n}"
  },
  {
    "function_name": "audit_set_failure",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "460-468",
    "snippet": "static int audit_set_failure(u32 state)\n{\n\tif (state != AUDIT_FAIL_SILENT\n\t    && state != AUDIT_FAIL_PRINTK\n\t    && state != AUDIT_FAIL_PANIC)\n\t\treturn -EINVAL;\n\n\treturn audit_do_config_change(\"audit_failure\", &audit_failure, state);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_do_config_change",
          "args": [
            "\"audit_failure\"",
            "&audit_failure",
            "state"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "audit_do_config_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "405-429",
          "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nstatic int audit_set_failure(u32 state)\n{\n\tif (state != AUDIT_FAIL_SILENT\n\t    && state != AUDIT_FAIL_PRINTK\n\t    && state != AUDIT_FAIL_PANIC)\n\t\treturn -EINVAL;\n\n\treturn audit_do_config_change(\"audit_failure\", &audit_failure, state);\n}"
  },
  {
    "function_name": "audit_set_enabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "447-458",
    "snippet": "static int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;",
      "bool\t\taudit_ever_enabled = !!AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_do_config_change",
          "args": [
            "\"audit_enabled\"",
            "&audit_enabled",
            "state"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "audit_do_config_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "405-429",
          "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\nbool\t\taudit_ever_enabled = !!AUDIT_OFF;\n\nstatic int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "audit_set_backlog_wait_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "441-445",
    "snippet": "static int audit_set_backlog_wait_time(u32 timeout)\n{\n\treturn audit_do_config_change(\"audit_backlog_wait_time\",\n\t\t\t\t      &audit_backlog_wait_time, timeout);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_do_config_change",
          "args": [
            "\"audit_backlog_wait_time\"",
            "&audit_backlog_wait_time",
            "timeout"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "audit_do_config_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "405-429",
          "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\n\nstatic int audit_set_backlog_wait_time(u32 timeout)\n{\n\treturn audit_do_config_change(\"audit_backlog_wait_time\",\n\t\t\t\t      &audit_backlog_wait_time, timeout);\n}"
  },
  {
    "function_name": "audit_set_backlog_limit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "436-439",
    "snippet": "static int audit_set_backlog_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_backlog_limit\", &audit_backlog_limit, limit);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_backlog_limit = 64;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_do_config_change",
          "args": [
            "\"audit_backlog_limit\"",
            "&audit_backlog_limit",
            "limit"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "audit_do_config_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "405-429",
          "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_backlog_limit = 64;\n\nstatic int audit_set_backlog_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_backlog_limit\", &audit_backlog_limit, limit);\n}"
  },
  {
    "function_name": "audit_set_rate_limit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "431-434",
    "snippet": "static int audit_set_rate_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_rate_limit\", &audit_rate_limit, limit);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_rate_limit;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_do_config_change",
          "args": [
            "\"audit_rate_limit\"",
            "&audit_rate_limit",
            "limit"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "audit_do_config_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "405-429",
          "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_rate_limit;\n\nstatic int audit_set_rate_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_rate_limit\", &audit_rate_limit, limit);\n}"
  },
  {
    "function_name": "audit_do_config_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "405-429",
    "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_config_change",
          "args": [
            "function_name",
            "new",
            "old",
            "allow_changes"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_config_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "386-403",
          "snippet": "static int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"op=set %s=%u old=%u \", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"op=set %s=%u old=%u \", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
  },
  {
    "function_name": "audit_log_config_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "386-403",
    "snippet": "static int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"op=set %s=%u old=%u \", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" res=%d\"",
            "allow_changes"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2143-2168",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_session_info",
          "args": [
            "ab"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_session_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2126-2132",
          "snippet": "void audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"op=set %s=%u old=%u \", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}"
  },
  {
    "function_name": "audit_log_lost",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "354-384",
    "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
      "static u32\taudit_rate_limit;",
      "static u32\taudit_backlog_limit = 64;",
      "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "message"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "302-315",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\"",
            "atomic_read(&audit_lost)",
            "audit_rate_limit",
            "audit_backlog_limit"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&audit_lost"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&audit_lost"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
  },
  {
    "function_name": "audit_rate_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "317-344",
    "snippet": "static inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_rate_limit;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_rate_limit;\n\nstatic inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "audit_panic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "302-315",
    "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"audit: %s\\n\"",
            "message"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "179-361",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s\\n\"",
            "message"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "audit_get_sk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "291-300",
    "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int audit_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "audit_net_id"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
  },
  {
    "function_name": "auditd_pid_vnr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "267-281",
    "snippet": "static pid_t auditd_pid_vnr(void)\n{\n\tpid_t pid;\n\tconst struct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac || !ac->pid)\n\t\tpid = 0;\n\telse\n\t\tpid = pid_vnr(ac->pid);\n\trcu_read_unlock();\n\n\treturn pid;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct auditd_connection __rcu *auditd_conn;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "ac->pid"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "pid_vnr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "486-489",
          "snippet": "pid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "auditd_conn"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\n\nstatic pid_t auditd_pid_vnr(void)\n{\n\tpid_t pid;\n\tconst struct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac || !ac->pid)\n\t\tpid = 0;\n\telse\n\t\tpid = pid_vnr(ac->pid);\n\trcu_read_unlock();\n\n\treturn pid;\n}"
  },
  {
    "function_name": "audit_ctl_owner_current",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "256-259",
    "snippet": "static bool audit_ctl_owner_current(void)\n{\n\treturn (current == audit_cmd_mutex.owner);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstatic bool audit_ctl_owner_current(void)\n{\n\treturn (current == audit_cmd_mutex.owner);\n}"
  },
  {
    "function_name": "audit_ctl_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "243-247",
    "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_cmd_mutex.lock"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
  },
  {
    "function_name": "audit_ctl_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "234-238",
    "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_cmd_mutex.lock"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
  },
  {
    "function_name": "auditd_test_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
    "lines": "218-229",
    "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct auditd_connection __rcu *auditd_conn;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "task"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "auditd_conn"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
  }
]