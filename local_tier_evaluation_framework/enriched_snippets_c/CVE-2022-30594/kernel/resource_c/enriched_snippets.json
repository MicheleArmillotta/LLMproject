[
  {
    "function_name": "iomem_init_inode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1909-1937",
    "snippet": "static int __init iomem_init_inode(void)\n{\n\tstatic struct vfsmount *iomem_vfs_mount;\n\tstatic int iomem_fs_cnt;\n\tstruct inode *inode;\n\tint rc;\n\n\trc = simple_pin_fs(&iomem_fs_type, &iomem_vfs_mount, &iomem_fs_cnt);\n\tif (rc < 0) {\n\t\tpr_err(\"Cannot mount iomem pseudo filesystem: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tinode = alloc_anon_inode(iomem_vfs_mount->mnt_sb);\n\tif (IS_ERR(inode)) {\n\t\trc = PTR_ERR(inode);\n\t\tpr_err(\"Cannot allocate inode for iomem: %d\\n\", rc);\n\t\tsimple_release_fs(&iomem_vfs_mount, &iomem_fs_cnt);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Publish iomem revocation inode initialized.\n\t * Pairs with smp_load_acquire() in revoke_iomem().\n\t */\n\tsmp_store_release(&iomem_inode, inode);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *iomem_inode;",
      "static struct file_system_type iomem_fs_type = {\n\t.name\t\t= \"iomem\",\n\t.owner\t\t= THIS_MODULE,\n\t.init_fs_context = iomem_fs_init_fs_context,\n\t.kill_sb\t= kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&iomem_inode",
            "inode"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&iomem_vfs_mount",
            "&iomem_fs_cnt"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot allocate inode for iomem: %d\\n\"",
            "rc"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_anon_inode",
          "args": [
            "iomem_vfs_mount->mnt_sb"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot mount iomem pseudo filesystem: %d\\n\"",
            "rc"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_pin_fs",
          "args": [
            "&iomem_fs_type",
            "&iomem_vfs_mount",
            "&iomem_fs_cnt"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct inode *iomem_inode;\nstatic struct file_system_type iomem_fs_type = {\n\t.name\t\t= \"iomem\",\n\t.owner\t\t= THIS_MODULE,\n\t.init_fs_context = iomem_fs_init_fs_context,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic int __init iomem_init_inode(void)\n{\n\tstatic struct vfsmount *iomem_vfs_mount;\n\tstatic int iomem_fs_cnt;\n\tstruct inode *inode;\n\tint rc;\n\n\trc = simple_pin_fs(&iomem_fs_type, &iomem_vfs_mount, &iomem_fs_cnt);\n\tif (rc < 0) {\n\t\tpr_err(\"Cannot mount iomem pseudo filesystem: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tinode = alloc_anon_inode(iomem_vfs_mount->mnt_sb);\n\tif (IS_ERR(inode)) {\n\t\trc = PTR_ERR(inode);\n\t\tpr_err(\"Cannot allocate inode for iomem: %d\\n\", rc);\n\t\tsimple_release_fs(&iomem_vfs_mount, &iomem_fs_cnt);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Publish iomem revocation inode initialized.\n\t * Pairs with smp_load_acquire() in revoke_iomem().\n\t */\n\tsmp_store_release(&iomem_inode, inode);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iomem_fs_init_fs_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1897-1900",
    "snippet": "static int iomem_fs_init_fs_context(struct fs_context *fc)\n{\n\treturn init_pseudo(fc, DEVMEM_MAGIC) ? 0 : -ENOMEM;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_pseudo",
          "args": [
            "fc",
            "DEVMEM_MAGIC"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int iomem_fs_init_fs_context(struct fs_context *fc)\n{\n\treturn init_pseudo(fc, DEVMEM_MAGIC) ? 0 : -ENOMEM;\n}"
  },
  {
    "function_name": "strict_iomem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1888-1895",
    "snippet": "static int __init strict_iomem(char *str)\n{\n\tif (strstr(str, \"relaxed\"))\n\t\tstrict_iomem_checks = 0;\n\tif (strstr(str, \"strict\"))\n\t\tstrict_iomem_checks = 1;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"strict\""
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"relaxed\""
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __init strict_iomem(char *str)\n{\n\tif (strstr(str, \"relaxed\"))\n\t\tstrict_iomem_checks = 0;\n\tif (strstr(str, \"strict\"))\n\t\tstrict_iomem_checks = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "request_free_mem_region",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1879-1883",
    "snippet": "struct resource *request_free_mem_region(struct resource *base,\n\t\tunsigned long size, const char *name)\n{\n\treturn __request_free_mem_region(NULL, base, size, name);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__request_free_mem_region",
          "args": [
            "NULL",
            "base",
            "size",
            "name"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "__request_free_mem_region",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "1802-1859",
          "snippet": "static struct resource *__request_free_mem_region(struct device *dev,\n\t\tstruct resource *base, unsigned long size, const char *name)\n{\n\tresource_size_t end, addr;\n\tstruct resource *res;\n\tstruct region_devres *dr = NULL;\n\n\tsize = ALIGN(size, 1UL << PA_SECTION_SHIFT);\n\tend = min_t(unsigned long, base->end, (1UL << MAX_PHYSMEM_BITS) - 1);\n\taddr = end - size + 1UL;\n\n\tres = alloc_resource(GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (dev) {\n\t\tdr = devres_alloc(devm_region_release,\n\t\t\t\tsizeof(struct region_devres), GFP_KERNEL);\n\t\tif (!dr) {\n\t\t\tfree_resource(res);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\twrite_lock(&resource_lock);\n\tfor (; addr > size && addr >= base->start; addr -= size) {\n\t\tif (__region_intersects(addr, size, 0, IORES_DESC_NONE) !=\n\t\t\t\tREGION_DISJOINT)\n\t\t\tcontinue;\n\n\t\tif (__request_region_locked(res, &iomem_resource, addr, size,\n\t\t\t\t\t\tname, 0))\n\t\t\tbreak;\n\n\t\tif (dev) {\n\t\t\tdr->parent = &iomem_resource;\n\t\t\tdr->start = addr;\n\t\t\tdr->n = size;\n\t\t\tdevres_add(dev, dr);\n\t\t}\n\n\t\tres->desc = IORES_DESC_DEVICE_PRIVATE_MEMORY;\n\t\twrite_unlock(&resource_lock);\n\n\t\t/*\n\t\t * A driver is claiming this region so revoke any mappings.\n\t\t */\n\t\trevoke_iomem(res);\n\t\treturn res;\n\t}\n\twrite_unlock(&resource_lock);\n\n\tfree_resource(res);\n\tif (dr)\n\t\tdevres_free(dr);\n\n\treturn ERR_PTR(-ERANGE);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic struct resource *__request_free_mem_region(struct device *dev,\n\t\tstruct resource *base, unsigned long size, const char *name)\n{\n\tresource_size_t end, addr;\n\tstruct resource *res;\n\tstruct region_devres *dr = NULL;\n\n\tsize = ALIGN(size, 1UL << PA_SECTION_SHIFT);\n\tend = min_t(unsigned long, base->end, (1UL << MAX_PHYSMEM_BITS) - 1);\n\taddr = end - size + 1UL;\n\n\tres = alloc_resource(GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (dev) {\n\t\tdr = devres_alloc(devm_region_release,\n\t\t\t\tsizeof(struct region_devres), GFP_KERNEL);\n\t\tif (!dr) {\n\t\t\tfree_resource(res);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\twrite_lock(&resource_lock);\n\tfor (; addr > size && addr >= base->start; addr -= size) {\n\t\tif (__region_intersects(addr, size, 0, IORES_DESC_NONE) !=\n\t\t\t\tREGION_DISJOINT)\n\t\t\tcontinue;\n\n\t\tif (__request_region_locked(res, &iomem_resource, addr, size,\n\t\t\t\t\t\tname, 0))\n\t\t\tbreak;\n\n\t\tif (dev) {\n\t\t\tdr->parent = &iomem_resource;\n\t\t\tdr->start = addr;\n\t\t\tdr->n = size;\n\t\t\tdevres_add(dev, dr);\n\t\t}\n\n\t\tres->desc = IORES_DESC_DEVICE_PRIVATE_MEMORY;\n\t\twrite_unlock(&resource_lock);\n\n\t\t/*\n\t\t * A driver is claiming this region so revoke any mappings.\n\t\t */\n\t\trevoke_iomem(res);\n\t\treturn res;\n\t}\n\twrite_unlock(&resource_lock);\n\n\tfree_resource(res);\n\tif (dr)\n\t\tdevres_free(dr);\n\n\treturn ERR_PTR(-ERANGE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource *request_free_mem_region(struct resource *base,\n\t\tunsigned long size, const char *name)\n{\n\treturn __request_free_mem_region(NULL, base, size, name);\n}"
  },
  {
    "function_name": "devm_request_free_mem_region",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1872-1876",
    "snippet": "struct resource *devm_request_free_mem_region(struct device *dev,\n\t\tstruct resource *base, unsigned long size)\n{\n\treturn __request_free_mem_region(dev, base, size, dev_name(dev));\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__request_free_mem_region",
          "args": [
            "dev",
            "base",
            "size",
            "dev_name(dev)"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "__request_free_mem_region",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "1802-1859",
          "snippet": "static struct resource *__request_free_mem_region(struct device *dev,\n\t\tstruct resource *base, unsigned long size, const char *name)\n{\n\tresource_size_t end, addr;\n\tstruct resource *res;\n\tstruct region_devres *dr = NULL;\n\n\tsize = ALIGN(size, 1UL << PA_SECTION_SHIFT);\n\tend = min_t(unsigned long, base->end, (1UL << MAX_PHYSMEM_BITS) - 1);\n\taddr = end - size + 1UL;\n\n\tres = alloc_resource(GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (dev) {\n\t\tdr = devres_alloc(devm_region_release,\n\t\t\t\tsizeof(struct region_devres), GFP_KERNEL);\n\t\tif (!dr) {\n\t\t\tfree_resource(res);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\twrite_lock(&resource_lock);\n\tfor (; addr > size && addr >= base->start; addr -= size) {\n\t\tif (__region_intersects(addr, size, 0, IORES_DESC_NONE) !=\n\t\t\t\tREGION_DISJOINT)\n\t\t\tcontinue;\n\n\t\tif (__request_region_locked(res, &iomem_resource, addr, size,\n\t\t\t\t\t\tname, 0))\n\t\t\tbreak;\n\n\t\tif (dev) {\n\t\t\tdr->parent = &iomem_resource;\n\t\t\tdr->start = addr;\n\t\t\tdr->n = size;\n\t\t\tdevres_add(dev, dr);\n\t\t}\n\n\t\tres->desc = IORES_DESC_DEVICE_PRIVATE_MEMORY;\n\t\twrite_unlock(&resource_lock);\n\n\t\t/*\n\t\t * A driver is claiming this region so revoke any mappings.\n\t\t */\n\t\trevoke_iomem(res);\n\t\treturn res;\n\t}\n\twrite_unlock(&resource_lock);\n\n\tfree_resource(res);\n\tif (dr)\n\t\tdevres_free(dr);\n\n\treturn ERR_PTR(-ERANGE);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic struct resource *__request_free_mem_region(struct device *dev,\n\t\tstruct resource *base, unsigned long size, const char *name)\n{\n\tresource_size_t end, addr;\n\tstruct resource *res;\n\tstruct region_devres *dr = NULL;\n\n\tsize = ALIGN(size, 1UL << PA_SECTION_SHIFT);\n\tend = min_t(unsigned long, base->end, (1UL << MAX_PHYSMEM_BITS) - 1);\n\taddr = end - size + 1UL;\n\n\tres = alloc_resource(GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (dev) {\n\t\tdr = devres_alloc(devm_region_release,\n\t\t\t\tsizeof(struct region_devres), GFP_KERNEL);\n\t\tif (!dr) {\n\t\t\tfree_resource(res);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\twrite_lock(&resource_lock);\n\tfor (; addr > size && addr >= base->start; addr -= size) {\n\t\tif (__region_intersects(addr, size, 0, IORES_DESC_NONE) !=\n\t\t\t\tREGION_DISJOINT)\n\t\t\tcontinue;\n\n\t\tif (__request_region_locked(res, &iomem_resource, addr, size,\n\t\t\t\t\t\tname, 0))\n\t\t\tbreak;\n\n\t\tif (dev) {\n\t\t\tdr->parent = &iomem_resource;\n\t\t\tdr->start = addr;\n\t\t\tdr->n = size;\n\t\t\tdevres_add(dev, dr);\n\t\t}\n\n\t\tres->desc = IORES_DESC_DEVICE_PRIVATE_MEMORY;\n\t\twrite_unlock(&resource_lock);\n\n\t\t/*\n\t\t * A driver is claiming this region so revoke any mappings.\n\t\t */\n\t\trevoke_iomem(res);\n\t\treturn res;\n\t}\n\twrite_unlock(&resource_lock);\n\n\tfree_resource(res);\n\tif (dr)\n\t\tdevres_free(dr);\n\n\treturn ERR_PTR(-ERANGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource *devm_request_free_mem_region(struct device *dev,\n\t\tstruct resource *base, unsigned long size)\n{\n\treturn __request_free_mem_region(dev, base, size, dev_name(dev));\n}"
  },
  {
    "function_name": "__request_free_mem_region",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1802-1859",
    "snippet": "static struct resource *__request_free_mem_region(struct device *dev,\n\t\tstruct resource *base, unsigned long size, const char *name)\n{\n\tresource_size_t end, addr;\n\tstruct resource *res;\n\tstruct region_devres *dr = NULL;\n\n\tsize = ALIGN(size, 1UL << PA_SECTION_SHIFT);\n\tend = min_t(unsigned long, base->end, (1UL << MAX_PHYSMEM_BITS) - 1);\n\taddr = end - size + 1UL;\n\n\tres = alloc_resource(GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (dev) {\n\t\tdr = devres_alloc(devm_region_release,\n\t\t\t\tsizeof(struct region_devres), GFP_KERNEL);\n\t\tif (!dr) {\n\t\t\tfree_resource(res);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\twrite_lock(&resource_lock);\n\tfor (; addr > size && addr >= base->start; addr -= size) {\n\t\tif (__region_intersects(addr, size, 0, IORES_DESC_NONE) !=\n\t\t\t\tREGION_DISJOINT)\n\t\t\tcontinue;\n\n\t\tif (__request_region_locked(res, &iomem_resource, addr, size,\n\t\t\t\t\t\tname, 0))\n\t\t\tbreak;\n\n\t\tif (dev) {\n\t\t\tdr->parent = &iomem_resource;\n\t\t\tdr->start = addr;\n\t\t\tdr->n = size;\n\t\t\tdevres_add(dev, dr);\n\t\t}\n\n\t\tres->desc = IORES_DESC_DEVICE_PRIVATE_MEMORY;\n\t\twrite_unlock(&resource_lock);\n\n\t\t/*\n\t\t * A driver is claiming this region so revoke any mappings.\n\t\t */\n\t\trevoke_iomem(res);\n\t\treturn res;\n\t}\n\twrite_unlock(&resource_lock);\n\n\tfree_resource(res);\n\tif (dr)\n\t\tdevres_free(dr);\n\n\treturn ERR_PTR(-ERANGE);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ERANGE"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "dr"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_resource",
          "args": [
            "res"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "free_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "161-174",
          "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "revoke_iomem",
          "args": [
            "res"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "revoke_iomem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "1161-1161",
          "snippet": "static void revoke_iomem(struct resource *res) {}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void revoke_iomem(struct resource *res) {}"
        }
      },
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "dr"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__request_region_locked",
          "args": [
            "res",
            "&iomem_resource",
            "addr",
            "size",
            "name",
            "0"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "__request_region_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "1175-1224",
          "snippet": "static int __request_region_locked(struct resource *res, struct resource *parent,\n\t\t\t\t   resource_size_t start, resource_size_t n,\n\t\t\t\t   const char *name, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = start + n - 1;\n\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tres->flags = resource_type(parent) | resource_ext_type(parent);\n\t\tres->flags |= IORESOURCE_BUSY | flags;\n\t\tres->desc = parent->desc;\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\t/*\n\t\t * mm/hmm.c reserves physical addresses which then\n\t\t * become unavailable to other users.  Conflicts are\n\t\t * not expected.  Warn to aid debugging if encountered.\n\t\t */\n\t\tif (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {\n\t\t\tpr_warn(\"Unaddressable device %s %pR conflicts with %pR\",\n\t\t\t\tconflict->name, conflict, res);\n\t\t}\n\t\tif (conflict != parent) {\n\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {\n\t\t\t\tparent = conflict;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {\n\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_lock(&resource_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Uhhuh, that didn't work out.. */\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nstatic int __request_region_locked(struct resource *res, struct resource *parent,\n\t\t\t\t   resource_size_t start, resource_size_t n,\n\t\t\t\t   const char *name, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = start + n - 1;\n\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tres->flags = resource_type(parent) | resource_ext_type(parent);\n\t\tres->flags |= IORESOURCE_BUSY | flags;\n\t\tres->desc = parent->desc;\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\t/*\n\t\t * mm/hmm.c reserves physical addresses which then\n\t\t * become unavailable to other users.  Conflicts are\n\t\t * not expected.  Warn to aid debugging if encountered.\n\t\t */\n\t\tif (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {\n\t\t\tpr_warn(\"Unaddressable device %s %pR conflicts with %pR\",\n\t\t\t\tconflict->name, conflict, res);\n\t\t}\n\t\tif (conflict != parent) {\n\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {\n\t\t\t\tparent = conflict;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {\n\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_lock(&resource_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Uhhuh, that didn't work out.. */\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__region_intersects",
          "args": [
            "addr",
            "size",
            "0",
            "IORES_DESC_NONE"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "__region_intersects",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "517-543",
          "snippet": "static int __region_intersects(resource_size_t start, size_t size,\n\t\t\tunsigned long flags, unsigned long desc)\n{\n\tstruct resource res;\n\tint type = 0; int other = 0;\n\tstruct resource *p;\n\n\tres.start = start;\n\tres.end = start + size - 1;\n\n\tfor (p = iomem_resource.child; p ; p = p->sibling) {\n\t\tbool is_type = (((p->flags & flags) == flags) &&\n\t\t\t\t((desc == IORES_DESC_NONE) ||\n\t\t\t\t (desc == p->desc)));\n\n\t\tif (resource_overlaps(p, &res))\n\t\t\tis_type ? type++ : other++;\n\t}\n\n\tif (type == 0)\n\t\treturn REGION_DISJOINT;\n\n\tif (other == 0)\n\t\treturn REGION_INTERSECTS;\n\n\treturn REGION_MIXED;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\n\nstatic int __region_intersects(resource_size_t start, size_t size,\n\t\t\tunsigned long flags, unsigned long desc)\n{\n\tstruct resource res;\n\tint type = 0; int other = 0;\n\tstruct resource *p;\n\n\tres.start = start;\n\tres.end = start + size - 1;\n\n\tfor (p = iomem_resource.child; p ; p = p->sibling) {\n\t\tbool is_type = (((p->flags & flags) == flags) &&\n\t\t\t\t((desc == IORES_DESC_NONE) ||\n\t\t\t\t (desc == p->desc)));\n\n\t\tif (resource_overlaps(p, &res))\n\t\t\tis_type ? type++ : other++;\n\t}\n\n\tif (type == 0)\n\t\treturn REGION_DISJOINT;\n\n\tif (other == 0)\n\t\treturn REGION_INTERSECTS;\n\n\treturn REGION_MIXED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "devm_region_release",
            "sizeof(struct region_devres)",
            "GFP_KERNEL"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_resource",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "176-193",
          "snippet": "static struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "base->end",
            "(1UL << MAX_PHYSMEM_BITS) - 1"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "1UL << PA_SECTION_SHIFT"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic struct resource *__request_free_mem_region(struct device *dev,\n\t\tstruct resource *base, unsigned long size, const char *name)\n{\n\tresource_size_t end, addr;\n\tstruct resource *res;\n\tstruct region_devres *dr = NULL;\n\n\tsize = ALIGN(size, 1UL << PA_SECTION_SHIFT);\n\tend = min_t(unsigned long, base->end, (1UL << MAX_PHYSMEM_BITS) - 1);\n\taddr = end - size + 1UL;\n\n\tres = alloc_resource(GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (dev) {\n\t\tdr = devres_alloc(devm_region_release,\n\t\t\t\tsizeof(struct region_devres), GFP_KERNEL);\n\t\tif (!dr) {\n\t\t\tfree_resource(res);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\twrite_lock(&resource_lock);\n\tfor (; addr > size && addr >= base->start; addr -= size) {\n\t\tif (__region_intersects(addr, size, 0, IORES_DESC_NONE) !=\n\t\t\t\tREGION_DISJOINT)\n\t\t\tcontinue;\n\n\t\tif (__request_region_locked(res, &iomem_resource, addr, size,\n\t\t\t\t\t\tname, 0))\n\t\t\tbreak;\n\n\t\tif (dev) {\n\t\t\tdr->parent = &iomem_resource;\n\t\t\tdr->start = addr;\n\t\t\tdr->n = size;\n\t\t\tdevres_add(dev, dr);\n\t\t}\n\n\t\tres->desc = IORES_DESC_DEVICE_PRIVATE_MEMORY;\n\t\twrite_unlock(&resource_lock);\n\n\t\t/*\n\t\t * A driver is claiming this region so revoke any mappings.\n\t\t */\n\t\trevoke_iomem(res);\n\t\treturn res;\n\t}\n\twrite_unlock(&resource_lock);\n\n\tfree_resource(res);\n\tif (dr)\n\t\tdevres_free(dr);\n\n\treturn ERR_PTR(-ERANGE);\n}"
  },
  {
    "function_name": "resource_list_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1792-1798",
    "snippet": "void resource_list_free(struct list_head *head)\n{\n\tstruct resource_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, head, node)\n\t\tresource_list_destroy_entry(entry);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_list_destroy_entry",
          "args": [
            "entry"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "entry",
            "tmp",
            "head",
            "node"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nvoid resource_list_free(struct list_head *head)\n{\n\tstruct resource_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, head, node)\n\t\tresource_list_destroy_entry(entry);\n}"
  },
  {
    "function_name": "resource_list_create_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1777-1789",
    "snippet": "struct resource_entry *resource_list_create_entry(struct resource *res,\n\t\t\t\t\t\t  size_t extra_size)\n{\n\tstruct resource_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry) + extra_size, GFP_KERNEL);\n\tif (entry) {\n\t\tINIT_LIST_HEAD(&entry->node);\n\t\tentry->res = res ? res : &entry->__res;\n\t}\n\n\treturn entry;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->node"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*entry) + extra_size",
            "GFP_KERNEL"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource_entry *resource_list_create_entry(struct resource *res,\n\t\t\t\t\t\t  size_t extra_size)\n{\n\tstruct resource_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry) + extra_size, GFP_KERNEL);\n\tif (entry) {\n\t\tINIT_LIST_HEAD(&entry->node);\n\t\tentry->res = res ? res : &entry->__res;\n\t}\n\n\treturn entry;\n}"
  },
  {
    "function_name": "iomem_is_exclusive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1727-1775",
    "snippet": "bool iomem_is_exclusive(u64 addr)\n{\n\tconst unsigned int exclusive_system_ram = IORESOURCE_SYSTEM_RAM |\n\t\t\t\t\t\t  IORESOURCE_EXCLUSIVE;\n\tbool skip_children = false, err = false;\n\tint size = PAGE_SIZE;\n\tstruct resource *p;\n\n\taddr = addr & PAGE_MASK;\n\n\tread_lock(&resource_lock);\n\tfor_each_resource(&iomem_resource, p, skip_children) {\n\t\tif (p->start >= addr + size)\n\t\t\tbreak;\n\t\tif (p->end < addr) {\n\t\t\tskip_children = true;\n\t\t\tcontinue;\n\t\t}\n\t\tskip_children = false;\n\n\t\t/*\n\t\t * IORESOURCE_SYSTEM_RAM resources are exclusive if\n\t\t * IORESOURCE_EXCLUSIVE is set, even if they\n\t\t * are not busy and even if \"iomem=relaxed\" is set. The\n\t\t * responsible driver dynamically adds/removes system RAM within\n\t\t * such an area and uncontrolled access is dangerous.\n\t\t */\n\t\tif ((p->flags & exclusive_system_ram) == exclusive_system_ram) {\n\t\t\terr = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * A resource is exclusive if IORESOURCE_EXCLUSIVE is set\n\t\t * or CONFIG_IO_STRICT_DEVMEM is enabled and the\n\t\t * resource is busy.\n\t\t */\n\t\tif (!strict_iomem_checks || !(p->flags & IORESOURCE_BUSY))\n\t\t\tcontinue;\n\t\tif (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)\n\t\t\t\t|| p->flags & IORESOURCE_EXCLUSIVE) {\n\t\t\terr = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IO_STRICT_DEVMEM"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_resource",
          "args": [
            "&iomem_resource",
            "p",
            "skip_children"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nbool iomem_is_exclusive(u64 addr)\n{\n\tconst unsigned int exclusive_system_ram = IORESOURCE_SYSTEM_RAM |\n\t\t\t\t\t\t  IORESOURCE_EXCLUSIVE;\n\tbool skip_children = false, err = false;\n\tint size = PAGE_SIZE;\n\tstruct resource *p;\n\n\taddr = addr & PAGE_MASK;\n\n\tread_lock(&resource_lock);\n\tfor_each_resource(&iomem_resource, p, skip_children) {\n\t\tif (p->start >= addr + size)\n\t\t\tbreak;\n\t\tif (p->end < addr) {\n\t\t\tskip_children = true;\n\t\t\tcontinue;\n\t\t}\n\t\tskip_children = false;\n\n\t\t/*\n\t\t * IORESOURCE_SYSTEM_RAM resources are exclusive if\n\t\t * IORESOURCE_EXCLUSIVE is set, even if they\n\t\t * are not busy and even if \"iomem=relaxed\" is set. The\n\t\t * responsible driver dynamically adds/removes system RAM within\n\t\t * such an area and uncontrolled access is dangerous.\n\t\t */\n\t\tif ((p->flags & exclusive_system_ram) == exclusive_system_ram) {\n\t\t\terr = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * A resource is exclusive if IORESOURCE_EXCLUSIVE is set\n\t\t * or CONFIG_IO_STRICT_DEVMEM is enabled and the\n\t\t * resource is busy.\n\t\t */\n\t\tif (!strict_iomem_checks || !(p->flags & IORESOURCE_BUSY))\n\t\t\tcontinue;\n\t\tif (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)\n\t\t\t\t|| p->flags & IORESOURCE_EXCLUSIVE) {\n\t\t\terr = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "iomem_map_sanity_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1675-1713",
    "snippet": "int iomem_map_sanity_check(resource_size_t addr, unsigned long size)\n{\n\tstruct resource *p = &iomem_resource;\n\tint err = 0;\n\tloff_t l;\n\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {\n\t\t/*\n\t\t * We can probably skip the resources without\n\t\t * IORESOURCE_IO attribute?\n\t\t */\n\t\tif (p->start >= addr + size)\n\t\t\tcontinue;\n\t\tif (p->end < addr)\n\t\t\tcontinue;\n\t\tif (PFN_DOWN(p->start) <= PFN_DOWN(addr) &&\n\t\t    PFN_DOWN(p->end) >= PFN_DOWN(addr + size - 1))\n\t\t\tcontinue;\n\t\t/*\n\t\t * if a resource is \"BUSY\", it's not a hardware resource\n\t\t * but a driver mapping of such a resource; we don't want\n\t\t * to warn for those; some drivers legitimately map only\n\t\t * partial hardware resources. (example: vesafb)\n\t\t */\n\t\tif (p->flags & IORESOURCE_BUSY)\n\t\t\tcontinue;\n\n\t\tprintk(KERN_WARNING \"resource sanity check: requesting [mem %#010llx-%#010llx], which spans more than %s %pR\\n\",\n\t\t       (unsigned long long)addr,\n\t\t       (unsigned long long)(addr + size - 1),\n\t\t       p->name, p);\n\t\terr = -1;\n\t\tbreak;\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"resource sanity check: requesting [mem %#010llx-%#010llx], which spans more than %s %pR\\n\"",
            "(unsigned long long)addr",
            "(unsigned long long)(addr + size - 1)",
            "p->name",
            "p"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "addr + size - 1"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "p->end"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "addr"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "p->start"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_next",
          "args": [
            "NULL",
            "p",
            "&l"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "r_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "88-93",
          "snippet": "static void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nint iomem_map_sanity_check(resource_size_t addr, unsigned long size)\n{\n\tstruct resource *p = &iomem_resource;\n\tint err = 0;\n\tloff_t l;\n\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {\n\t\t/*\n\t\t * We can probably skip the resources without\n\t\t * IORESOURCE_IO attribute?\n\t\t */\n\t\tif (p->start >= addr + size)\n\t\t\tcontinue;\n\t\tif (p->end < addr)\n\t\t\tcontinue;\n\t\tif (PFN_DOWN(p->start) <= PFN_DOWN(addr) &&\n\t\t    PFN_DOWN(p->end) >= PFN_DOWN(addr + size - 1))\n\t\t\tcontinue;\n\t\t/*\n\t\t * if a resource is \"BUSY\", it's not a hardware resource\n\t\t * but a driver mapping of such a resource; we don't want\n\t\t * to warn for those; some drivers legitimately map only\n\t\t * partial hardware resources. (example: vesafb)\n\t\t */\n\t\tif (p->flags & IORESOURCE_BUSY)\n\t\t\tcontinue;\n\n\t\tprintk(KERN_WARNING \"resource sanity check: requesting [mem %#010llx-%#010llx], which spans more than %s %pR\\n\",\n\t\t       (unsigned long long)addr,\n\t\t       (unsigned long long)(addr + size - 1),\n\t\t       p->name, p);\n\t\terr = -1;\n\t\tbreak;\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "reserve_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1629-1668",
    "snippet": "static int __init reserve_setup(char *str)\n{\n\tstatic int reserved;\n\tstatic struct resource reserve[MAXRESERVE];\n\n\tfor (;;) {\n\t\tunsigned int io_start, io_num;\n\t\tint x = reserved;\n\t\tstruct resource *parent;\n\n\t\tif (get_option(&str, &io_start) != 2)\n\t\t\tbreak;\n\t\tif (get_option(&str, &io_num) == 0)\n\t\t\tbreak;\n\t\tif (x < MAXRESERVE) {\n\t\t\tstruct resource *res = reserve + x;\n\n\t\t\t/*\n\t\t\t * If the region starts below 0x10000, we assume it's\n\t\t\t * I/O port space; otherwise assume it's memory.\n\t\t\t */\n\t\t\tif (io_start < 0x10000) {\n\t\t\t\tres->flags = IORESOURCE_IO;\n\t\t\t\tparent = &ioport_resource;\n\t\t\t} else {\n\t\t\t\tres->flags = IORESOURCE_MEM;\n\t\t\t\tparent = &iomem_resource;\n\t\t\t}\n\t\t\tres->name = \"reserved\";\n\t\t\tres->start = io_start;\n\t\t\tres->end = io_start + io_num - 1;\n\t\t\tres->flags |= IORESOURCE_BUSY;\n\t\t\tres->desc = IORES_DESC_NONE;\n\t\t\tres->child = NULL;\n\t\t\tif (request_resource(parent, res) == 0)\n\t\t\t\treserved = x+1;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define MAXRESERVE 4"
    ],
    "globals_used": [
      "struct resource ioport_resource = {\n\t.name\t= \"PCI IO\",\n\t.start\t= 0,\n\t.end\t= IO_SPACE_LIMIT,\n\t.flags\t= IORESOURCE_IO,\n};",
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "request_resource",
          "args": [
            "parent",
            "res"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "request_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "307-313",
          "snippet": "int request_resource(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = request_resource_conflict(root, new);\n\treturn conflict ? -EBUSY : 0;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint request_resource(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = request_resource_conflict(root, new);\n\treturn conflict ? -EBUSY : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&io_num"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&io_start"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\n#define MAXRESERVE 4\n\nstruct resource ioport_resource = {\n\t.name\t= \"PCI IO\",\n\t.start\t= 0,\n\t.end\t= IO_SPACE_LIMIT,\n\t.flags\t= IORESOURCE_IO,\n};\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\n\nstatic int __init reserve_setup(char *str)\n{\n\tstatic int reserved;\n\tstatic struct resource reserve[MAXRESERVE];\n\n\tfor (;;) {\n\t\tunsigned int io_start, io_num;\n\t\tint x = reserved;\n\t\tstruct resource *parent;\n\n\t\tif (get_option(&str, &io_start) != 2)\n\t\t\tbreak;\n\t\tif (get_option(&str, &io_num) == 0)\n\t\t\tbreak;\n\t\tif (x < MAXRESERVE) {\n\t\t\tstruct resource *res = reserve + x;\n\n\t\t\t/*\n\t\t\t * If the region starts below 0x10000, we assume it's\n\t\t\t * I/O port space; otherwise assume it's memory.\n\t\t\t */\n\t\t\tif (io_start < 0x10000) {\n\t\t\t\tres->flags = IORESOURCE_IO;\n\t\t\t\tparent = &ioport_resource;\n\t\t\t} else {\n\t\t\t\tres->flags = IORESOURCE_MEM;\n\t\t\t\tparent = &iomem_resource;\n\t\t\t}\n\t\t\tres->name = \"reserved\";\n\t\t\tres->start = io_start;\n\t\t\tres->end = io_start + io_num - 1;\n\t\t\tres->flags |= IORESOURCE_BUSY;\n\t\t\tres->desc = IORES_DESC_NONE;\n\t\t\tres->child = NULL;\n\t\t\tif (request_resource(parent, res) == 0)\n\t\t\t\treserved = x+1;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "__devm_release_region",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1614-1622",
    "snippet": "void __devm_release_region(struct device *dev, struct resource *parent,\n\t\t\t   resource_size_t start, resource_size_t n)\n{\n\tstruct region_devres match_data = { parent, start, n };\n\n\t__release_region(parent, start, n);\n\tWARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,\n\t\t\t       &match_data));\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "devres_destroy(dev, devm_region_release, devm_region_match,\n\t\t\t       &match_data)"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_destroy",
          "args": [
            "dev",
            "devm_region_release",
            "devm_region_match",
            "&match_data"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__release_region",
          "args": [
            "parent",
            "start",
            "n"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "__release_region",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "1268-1306",
          "snippet": "void __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nvoid __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nvoid __devm_release_region(struct device *dev, struct resource *parent,\n\t\t\t   resource_size_t start, resource_size_t n)\n{\n\tstruct region_devres match_data = { parent, start, n };\n\n\t__release_region(parent, start, n);\n\tWARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,\n\t\t\t       &match_data));\n}"
  },
  {
    "function_name": "__devm_request_region",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1588-1611",
    "snippet": "struct resource *\n__devm_request_region(struct device *dev, struct resource *parent,\n\t\t      resource_size_t start, resource_size_t n, const char *name)\n{\n\tstruct region_devres *dr = NULL;\n\tstruct resource *res;\n\n\tdr = devres_alloc(devm_region_release, sizeof(struct region_devres),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn NULL;\n\n\tdr->parent = parent;\n\tdr->start = start;\n\tdr->n = n;\n\n\tres = __request_region(parent, start, n, name, 0);\n\tif (res)\n\t\tdevres_add(dev, dr);\n\telse\n\t\tdevres_free(dr);\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "dr"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "dr"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__request_region",
          "args": [
            "parent",
            "start",
            "n",
            "name",
            "0"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "__request_region",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "1234-1257",
          "snippet": "struct resource *__request_region(struct resource *parent,\n\t\t\t\t  resource_size_t start, resource_size_t n,\n\t\t\t\t  const char *name, int flags)\n{\n\tstruct resource *res = alloc_resource(GFP_KERNEL);\n\tint ret;\n\n\tif (!res)\n\t\treturn NULL;\n\n\twrite_lock(&resource_lock);\n\tret = __request_region_locked(res, parent, start, n, name, flags);\n\twrite_unlock(&resource_lock);\n\n\tif (ret) {\n\t\tfree_resource(res);\n\t\treturn NULL;\n\t}\n\n\tif (parent == &iomem_resource)\n\t\trevoke_iomem(res);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *__request_region(struct resource *parent,\n\t\t\t\t  resource_size_t start, resource_size_t n,\n\t\t\t\t  const char *name, int flags)\n{\n\tstruct resource *res = alloc_resource(GFP_KERNEL);\n\tint ret;\n\n\tif (!res)\n\t\treturn NULL;\n\n\twrite_lock(&resource_lock);\n\tret = __request_region_locked(res, parent, start, n, name, flags);\n\twrite_unlock(&resource_lock);\n\n\tif (ret) {\n\t\tfree_resource(res);\n\t\treturn NULL;\n\t}\n\n\tif (parent == &iomem_resource)\n\t\trevoke_iomem(res);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "devm_region_release",
            "sizeof(struct region_devres)",
            "GFP_KERNEL"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource *\n__devm_request_region(struct device *dev, struct resource *parent,\n\t\t      resource_size_t start, resource_size_t n, const char *name)\n{\n\tstruct region_devres *dr = NULL;\n\tstruct resource *res;\n\n\tdr = devres_alloc(devm_region_release, sizeof(struct region_devres),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn NULL;\n\n\tdr->parent = parent;\n\tdr->start = start;\n\tdr->n = n;\n\n\tres = __request_region(parent, start, n, name, 0);\n\tif (res)\n\t\tdevres_add(dev, dr);\n\telse\n\t\tdevres_free(dr);\n\n\treturn res;\n}"
  },
  {
    "function_name": "devm_region_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1580-1586",
    "snippet": "static int devm_region_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct region_devres *this = res, *match = match_data;\n\n\treturn this->parent == match->parent &&\n\t\tthis->start == match->start && this->n == match->n;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int devm_region_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct region_devres *this = res, *match = match_data;\n\n\treturn this->parent == match->parent &&\n\t\tthis->start == match->start && this->n == match->n;\n}"
  },
  {
    "function_name": "devm_region_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1573-1578",
    "snippet": "static void devm_region_release(struct device *dev, void *res)\n{\n\tstruct region_devres *this = res;\n\n\t__release_region(this->parent, this->start, this->n);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__release_region",
          "args": [
            "this->parent",
            "this->start",
            "this->n"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "__release_region",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "1268-1306",
          "snippet": "void __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nvoid __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void devm_region_release(struct device *dev, void *res)\n{\n\tstruct region_devres *this = res;\n\n\t__release_region(this->parent, this->start, this->n);\n}"
  },
  {
    "function_name": "devm_release_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1560-1564",
    "snippet": "void devm_release_resource(struct device *dev, struct resource *new)\n{\n\tWARN_ON(devres_release(dev, devm_resource_release, devm_resource_match,\n\t\t\t       new));\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "devres_release(dev, devm_resource_release, devm_resource_match,\n\t\t\t       new)"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_release",
          "args": [
            "dev",
            "devm_resource_release",
            "devm_resource_match",
            "new"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nvoid devm_release_resource(struct device *dev, struct resource *new)\n{\n\tWARN_ON(devres_release(dev, devm_resource_release, devm_resource_match,\n\t\t\t       new));\n}"
  },
  {
    "function_name": "devm_resource_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1546-1551",
    "snippet": "static int devm_resource_match(struct device *dev, void *res, void *data)\n{\n\tstruct resource **ptr = res;\n\n\treturn *ptr == data;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int devm_resource_match(struct device *dev, void *res, void *data)\n{\n\tstruct resource **ptr = res;\n\n\treturn *ptr == data;\n}"
  },
  {
    "function_name": "devm_request_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1522-1543",
    "snippet": "int devm_request_resource(struct device *dev, struct resource *root,\n\t\t\t  struct resource *new)\n{\n\tstruct resource *conflict, **ptr;\n\n\tptr = devres_alloc(devm_resource_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\t*ptr = new;\n\n\tconflict = request_resource_conflict(root, new);\n\tif (conflict) {\n\t\tdev_err(dev, \"resource collision: %pR conflicts with %s %pR\\n\",\n\t\t\tnew, conflict->name, conflict);\n\t\tdevres_free(ptr);\n\t\treturn -EBUSY;\n\t}\n\n\tdevres_add(dev, ptr);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "ptr"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "ptr"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"resource collision: %pR conflicts with %s %pR\\n\"",
            "new",
            "conflict->name",
            "conflict"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_resource_conflict",
          "args": [
            "root",
            "new"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "request_resource_conflict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "290-298",
          "snippet": "struct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "devm_resource_release",
            "sizeof(*ptr)",
            "GFP_KERNEL"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint devm_request_resource(struct device *dev, struct resource *root,\n\t\t\t  struct resource *new)\n{\n\tstruct resource *conflict, **ptr;\n\n\tptr = devres_alloc(devm_resource_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\t*ptr = new;\n\n\tconflict = request_resource_conflict(root, new);\n\tif (conflict) {\n\t\tdev_err(dev, \"resource collision: %pR conflicts with %s %pR\\n\",\n\t\t\tnew, conflict->name, conflict);\n\t\tdevres_free(ptr);\n\t\treturn -EBUSY;\n\t}\n\n\tdevres_add(dev, ptr);\n\treturn 0;\n}"
  },
  {
    "function_name": "devm_resource_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1497-1502",
    "snippet": "static void devm_resource_release(struct device *dev, void *ptr)\n{\n\tstruct resource **r = ptr;\n\n\trelease_resource(*r);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_resource",
          "args": [
            "*r"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "release_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "321-329",
          "snippet": "int release_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, true);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint release_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, true);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void devm_resource_release(struct device *dev, void *ptr)\n{\n\tstruct resource **r = ptr;\n\n\trelease_resource(*r);\n}"
  },
  {
    "function_name": "merge_system_ram_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1462-1491",
    "snippet": "void merge_system_ram_resource(struct resource *res)\n{\n\tconst unsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\tstruct resource *cur;\n\n\tif (WARN_ON_ONCE((res->flags & flags) != flags))\n\t\treturn;\n\n\twrite_lock(&resource_lock);\n\tres->flags |= IORESOURCE_SYSRAM_MERGEABLE;\n\n\t/* Try to merge with next item in the list. */\n\tcur = res->sibling;\n\tif (cur && system_ram_resources_mergeable(res, cur)) {\n\t\tres->end = cur->end;\n\t\tres->sibling = cur->sibling;\n\t\tfree_resource(cur);\n\t}\n\n\t/* Try to merge with previous item in the list. */\n\tcur = res->parent->child;\n\twhile (cur && cur->sibling != res)\n\t\tcur = cur->sibling;\n\tif (cur && system_ram_resources_mergeable(cur, res)) {\n\t\tcur->end = res->end;\n\t\tcur->sibling = res->sibling;\n\t\tfree_resource(res);\n\t}\n\twrite_unlock(&resource_lock);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_resource",
          "args": [
            "res"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "free_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "161-174",
          "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "system_ram_resources_mergeable",
          "args": [
            "cur",
            "res"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "system_ram_resources_mergeable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "1435-1442",
          "snippet": "static bool system_ram_resources_mergeable(struct resource *r1,\n\t\t\t\t\t   struct resource *r2)\n{\n\t/* We assume either r1 or r2 is IORESOURCE_SYSRAM_MERGEABLE. */\n\treturn r1->flags == r2->flags && r1->end + 1 == r2->start &&\n\t       r1->name == r2->name && r1->desc == r2->desc &&\n\t       !r1->child && !r2->child;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic bool system_ram_resources_mergeable(struct resource *r1,\n\t\t\t\t\t   struct resource *r2)\n{\n\t/* We assume either r1 or r2 is IORESOURCE_SYSRAM_MERGEABLE. */\n\treturn r1->flags == r2->flags && r1->end + 1 == r2->start &&\n\t       r1->name == r2->name && r1->desc == r2->desc &&\n\t       !r1->child && !r2->child;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(res->flags & flags) != flags"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nvoid merge_system_ram_resource(struct resource *res)\n{\n\tconst unsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\tstruct resource *cur;\n\n\tif (WARN_ON_ONCE((res->flags & flags) != flags))\n\t\treturn;\n\n\twrite_lock(&resource_lock);\n\tres->flags |= IORESOURCE_SYSRAM_MERGEABLE;\n\n\t/* Try to merge with next item in the list. */\n\tcur = res->sibling;\n\tif (cur && system_ram_resources_mergeable(res, cur)) {\n\t\tres->end = cur->end;\n\t\tres->sibling = cur->sibling;\n\t\tfree_resource(cur);\n\t}\n\n\t/* Try to merge with previous item in the list. */\n\tcur = res->parent->child;\n\twhile (cur && cur->sibling != res)\n\t\tcur = cur->sibling;\n\tif (cur && system_ram_resources_mergeable(cur, res)) {\n\t\tcur->end = res->end;\n\t\tcur->sibling = res->sibling;\n\t\tfree_resource(res);\n\t}\n\twrite_unlock(&resource_lock);\n}"
  },
  {
    "function_name": "system_ram_resources_mergeable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1435-1442",
    "snippet": "static bool system_ram_resources_mergeable(struct resource *r1,\n\t\t\t\t\t   struct resource *r2)\n{\n\t/* We assume either r1 or r2 is IORESOURCE_SYSRAM_MERGEABLE. */\n\treturn r1->flags == r2->flags && r1->end + 1 == r2->start &&\n\t       r1->name == r2->name && r1->desc == r2->desc &&\n\t       !r1->child && !r2->child;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic bool system_ram_resources_mergeable(struct resource *r1,\n\t\t\t\t\t   struct resource *r2)\n{\n\t/* We assume either r1 or r2 is IORESOURCE_SYSRAM_MERGEABLE. */\n\treturn r1->flags == r2->flags && r1->end + 1 == r2->start &&\n\t       r1->name == r2->name && r1->desc == r2->desc &&\n\t       !r1->child && !r2->child;\n}"
  },
  {
    "function_name": "release_mem_region_adjustable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1329-1431",
    "snippet": "void release_mem_region_adjustable(resource_size_t start, resource_size_t size)\n{\n\tstruct resource *parent = &iomem_resource;\n\tstruct resource *new_res = NULL;\n\tbool alloc_nofail = false;\n\tstruct resource **p;\n\tstruct resource *res;\n\tresource_size_t end;\n\n\tend = start + size - 1;\n\tif (WARN_ON_ONCE((start < parent->start) || (end > parent->end)))\n\t\treturn;\n\n\t/*\n\t * We free up quite a lot of memory on memory hotunplug (esp., memap),\n\t * just before releasing the region. This is highly unlikely to\n\t * fail - let's play save and make it never fail as the caller cannot\n\t * perform any error handling (e.g., trying to re-add memory will fail\n\t * similarly).\n\t */\nretry:\n\tnew_res = alloc_resource(GFP_KERNEL | (alloc_nofail ? __GFP_NOFAIL : 0));\n\n\tp = &parent->child;\n\twrite_lock(&resource_lock);\n\n\twhile ((res = *p)) {\n\t\tif (res->start >= end)\n\t\t\tbreak;\n\n\t\t/* look for the next resource if it does not fit into */\n\t\tif (res->start > start || res->end < end) {\n\t\t\tp = &res->sibling;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * All memory regions added from memory-hotplug path have the\n\t\t * flag IORESOURCE_SYSTEM_RAM. If the resource does not have\n\t\t * this flag, we know that we are dealing with a resource coming\n\t\t * from HMM/devm. HMM/devm use another mechanism to add/release\n\t\t * a resource. This goes via devm_request_mem_region and\n\t\t * devm_release_mem_region.\n\t\t * HMM/devm take care to release their resources when they want,\n\t\t * so if we are dealing with them, let us just back off here.\n\t\t */\n\t\tif (!(res->flags & IORESOURCE_SYSRAM)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(res->flags & IORESOURCE_MEM))\n\t\t\tbreak;\n\n\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\tp = &res->child;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* found the target resource; let's adjust accordingly */\n\t\tif (res->start == start && res->end == end) {\n\t\t\t/* free the whole entry */\n\t\t\t*p = res->sibling;\n\t\t\tfree_resource(res);\n\t\t} else if (res->start == start && res->end != end) {\n\t\t\t/* adjust the start */\n\t\t\tWARN_ON_ONCE(__adjust_resource(res, end + 1,\n\t\t\t\t\t\t       res->end - end));\n\t\t} else if (res->start != start && res->end == end) {\n\t\t\t/* adjust the end */\n\t\t\tWARN_ON_ONCE(__adjust_resource(res, res->start,\n\t\t\t\t\t\t       start - res->start));\n\t\t} else {\n\t\t\t/* split into two entries - we need a new resource */\n\t\t\tif (!new_res) {\n\t\t\t\tnew_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!new_res) {\n\t\t\t\t\talloc_nofail = true;\n\t\t\t\t\twrite_unlock(&resource_lock);\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnew_res->name = res->name;\n\t\t\tnew_res->start = end + 1;\n\t\t\tnew_res->end = res->end;\n\t\t\tnew_res->flags = res->flags;\n\t\t\tnew_res->desc = res->desc;\n\t\t\tnew_res->parent = res->parent;\n\t\t\tnew_res->sibling = res->sibling;\n\t\t\tnew_res->child = NULL;\n\n\t\t\tif (WARN_ON_ONCE(__adjust_resource(res, res->start,\n\t\t\t\t\t\t\t   start - res->start)))\n\t\t\t\tbreak;\n\t\t\tres->sibling = new_res;\n\t\t\tnew_res = NULL;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\twrite_unlock(&resource_lock);\n\tfree_resource(new_res);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_resource",
          "args": [
            "new_res"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "free_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "161-174",
          "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "__adjust_resource(res, res->start,\n\t\t\t\t\t\t\t   start - res->start)"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__adjust_resource",
          "args": [
            "res",
            "res->start",
            "start - res->start"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "__adjust_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "946-981",
          "snippet": "static int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_resource",
          "args": [
            "GFP_ATOMIC"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "176-193",
          "snippet": "static struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "__adjust_resource(res, res->start,\n\t\t\t\t\t\t       start - res->start)"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "__adjust_resource(res, end + 1,\n\t\t\t\t\t\t       res->end - end)"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(start < parent->start) || (end > parent->end)"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nvoid release_mem_region_adjustable(resource_size_t start, resource_size_t size)\n{\n\tstruct resource *parent = &iomem_resource;\n\tstruct resource *new_res = NULL;\n\tbool alloc_nofail = false;\n\tstruct resource **p;\n\tstruct resource *res;\n\tresource_size_t end;\n\n\tend = start + size - 1;\n\tif (WARN_ON_ONCE((start < parent->start) || (end > parent->end)))\n\t\treturn;\n\n\t/*\n\t * We free up quite a lot of memory on memory hotunplug (esp., memap),\n\t * just before releasing the region. This is highly unlikely to\n\t * fail - let's play save and make it never fail as the caller cannot\n\t * perform any error handling (e.g., trying to re-add memory will fail\n\t * similarly).\n\t */\nretry:\n\tnew_res = alloc_resource(GFP_KERNEL | (alloc_nofail ? __GFP_NOFAIL : 0));\n\n\tp = &parent->child;\n\twrite_lock(&resource_lock);\n\n\twhile ((res = *p)) {\n\t\tif (res->start >= end)\n\t\t\tbreak;\n\n\t\t/* look for the next resource if it does not fit into */\n\t\tif (res->start > start || res->end < end) {\n\t\t\tp = &res->sibling;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * All memory regions added from memory-hotplug path have the\n\t\t * flag IORESOURCE_SYSTEM_RAM. If the resource does not have\n\t\t * this flag, we know that we are dealing with a resource coming\n\t\t * from HMM/devm. HMM/devm use another mechanism to add/release\n\t\t * a resource. This goes via devm_request_mem_region and\n\t\t * devm_release_mem_region.\n\t\t * HMM/devm take care to release their resources when they want,\n\t\t * so if we are dealing with them, let us just back off here.\n\t\t */\n\t\tif (!(res->flags & IORESOURCE_SYSRAM)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(res->flags & IORESOURCE_MEM))\n\t\t\tbreak;\n\n\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\tp = &res->child;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* found the target resource; let's adjust accordingly */\n\t\tif (res->start == start && res->end == end) {\n\t\t\t/* free the whole entry */\n\t\t\t*p = res->sibling;\n\t\t\tfree_resource(res);\n\t\t} else if (res->start == start && res->end != end) {\n\t\t\t/* adjust the start */\n\t\t\tWARN_ON_ONCE(__adjust_resource(res, end + 1,\n\t\t\t\t\t\t       res->end - end));\n\t\t} else if (res->start != start && res->end == end) {\n\t\t\t/* adjust the end */\n\t\t\tWARN_ON_ONCE(__adjust_resource(res, res->start,\n\t\t\t\t\t\t       start - res->start));\n\t\t} else {\n\t\t\t/* split into two entries - we need a new resource */\n\t\t\tif (!new_res) {\n\t\t\t\tnew_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!new_res) {\n\t\t\t\t\talloc_nofail = true;\n\t\t\t\t\twrite_unlock(&resource_lock);\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnew_res->name = res->name;\n\t\t\tnew_res->start = end + 1;\n\t\t\tnew_res->end = res->end;\n\t\t\tnew_res->flags = res->flags;\n\t\t\tnew_res->desc = res->desc;\n\t\t\tnew_res->parent = res->parent;\n\t\t\tnew_res->sibling = res->sibling;\n\t\t\tnew_res->child = NULL;\n\n\t\t\tif (WARN_ON_ONCE(__adjust_resource(res, res->start,\n\t\t\t\t\t\t\t   start - res->start)))\n\t\t\t\tbreak;\n\t\t\tres->sibling = new_res;\n\t\t\tnew_res = NULL;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\twrite_unlock(&resource_lock);\n\tfree_resource(new_res);\n}"
  },
  {
    "function_name": "__release_region",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1268-1306",
    "snippet": "void __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\"",
            "(unsigned long long)start",
            "(unsigned long long)end"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_resource",
          "args": [
            "res"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "free_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "161-174",
          "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&muxed_resource_wait"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nvoid __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}"
  },
  {
    "function_name": "__request_region",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1234-1257",
    "snippet": "struct resource *__request_region(struct resource *parent,\n\t\t\t\t  resource_size_t start, resource_size_t n,\n\t\t\t\t  const char *name, int flags)\n{\n\tstruct resource *res = alloc_resource(GFP_KERNEL);\n\tint ret;\n\n\tif (!res)\n\t\treturn NULL;\n\n\twrite_lock(&resource_lock);\n\tret = __request_region_locked(res, parent, start, n, name, flags);\n\twrite_unlock(&resource_lock);\n\n\tif (ret) {\n\t\tfree_resource(res);\n\t\treturn NULL;\n\t}\n\n\tif (parent == &iomem_resource)\n\t\trevoke_iomem(res);\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "revoke_iomem",
          "args": [
            "res"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "revoke_iomem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "1161-1161",
          "snippet": "static void revoke_iomem(struct resource *res) {}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void revoke_iomem(struct resource *res) {}"
        }
      },
      {
        "call_info": {
          "callee": "free_resource",
          "args": [
            "res"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "free_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "161-174",
          "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__request_region_locked",
          "args": [
            "res",
            "parent",
            "start",
            "n",
            "name",
            "flags"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "__request_region_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "1175-1224",
          "snippet": "static int __request_region_locked(struct resource *res, struct resource *parent,\n\t\t\t\t   resource_size_t start, resource_size_t n,\n\t\t\t\t   const char *name, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = start + n - 1;\n\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tres->flags = resource_type(parent) | resource_ext_type(parent);\n\t\tres->flags |= IORESOURCE_BUSY | flags;\n\t\tres->desc = parent->desc;\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\t/*\n\t\t * mm/hmm.c reserves physical addresses which then\n\t\t * become unavailable to other users.  Conflicts are\n\t\t * not expected.  Warn to aid debugging if encountered.\n\t\t */\n\t\tif (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {\n\t\t\tpr_warn(\"Unaddressable device %s %pR conflicts with %pR\",\n\t\t\t\tconflict->name, conflict, res);\n\t\t}\n\t\tif (conflict != parent) {\n\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {\n\t\t\t\tparent = conflict;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {\n\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_lock(&resource_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Uhhuh, that didn't work out.. */\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nstatic int __request_region_locked(struct resource *res, struct resource *parent,\n\t\t\t\t   resource_size_t start, resource_size_t n,\n\t\t\t\t   const char *name, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = start + n - 1;\n\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tres->flags = resource_type(parent) | resource_ext_type(parent);\n\t\tres->flags |= IORESOURCE_BUSY | flags;\n\t\tres->desc = parent->desc;\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\t/*\n\t\t * mm/hmm.c reserves physical addresses which then\n\t\t * become unavailable to other users.  Conflicts are\n\t\t * not expected.  Warn to aid debugging if encountered.\n\t\t */\n\t\tif (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {\n\t\t\tpr_warn(\"Unaddressable device %s %pR conflicts with %pR\",\n\t\t\t\tconflict->name, conflict, res);\n\t\t}\n\t\tif (conflict != parent) {\n\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {\n\t\t\t\tparent = conflict;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {\n\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_lock(&resource_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Uhhuh, that didn't work out.. */\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_resource",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "176-193",
          "snippet": "static struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *__request_region(struct resource *parent,\n\t\t\t\t  resource_size_t start, resource_size_t n,\n\t\t\t\t  const char *name, int flags)\n{\n\tstruct resource *res = alloc_resource(GFP_KERNEL);\n\tint ret;\n\n\tif (!res)\n\t\treturn NULL;\n\n\twrite_lock(&resource_lock);\n\tret = __request_region_locked(res, parent, start, n, name, flags);\n\twrite_unlock(&resource_lock);\n\n\tif (ret) {\n\t\tfree_resource(res);\n\t\treturn NULL;\n\t}\n\n\tif (parent == &iomem_resource)\n\t\trevoke_iomem(res);\n\n\treturn res;\n}"
  },
  {
    "function_name": "__request_region_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1175-1224",
    "snippet": "static int __request_region_locked(struct resource *res, struct resource *parent,\n\t\t\t\t   resource_size_t start, resource_size_t n,\n\t\t\t\t   const char *name, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = start + n - 1;\n\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tres->flags = resource_type(parent) | resource_ext_type(parent);\n\t\tres->flags |= IORESOURCE_BUSY | flags;\n\t\tres->desc = parent->desc;\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\t/*\n\t\t * mm/hmm.c reserves physical addresses which then\n\t\t * become unavailable to other users.  Conflicts are\n\t\t * not expected.  Warn to aid debugging if encountered.\n\t\t */\n\t\tif (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {\n\t\t\tpr_warn(\"Unaddressable device %s %pR conflicts with %pR\",\n\t\t\t\tconflict->name, conflict, res);\n\t\t}\n\t\tif (conflict != parent) {\n\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {\n\t\t\t\tparent = conflict;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {\n\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_lock(&resource_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Uhhuh, that didn't work out.. */\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&muxed_resource_wait",
            "&wait"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "remove_wait_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "51-58",
          "snippet": "void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&muxed_resource_wait",
            "&wait"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "add_wait_queue_priority",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "40-48",
          "snippet": "void add_wait_queue_priority(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE | WQ_FLAG_PRIORITY;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid add_wait_queue_priority(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE | WQ_FLAG_PRIORITY;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unaddressable device %s %pR conflicts with %pR\"",
            "conflict->name",
            "conflict",
            "res"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "parent",
            "res"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "196-222",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_ext_type",
          "args": [
            "parent"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_type",
          "args": [
            "parent"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nstatic int __request_region_locked(struct resource *res, struct resource *parent,\n\t\t\t\t   resource_size_t start, resource_size_t n,\n\t\t\t\t   const char *name, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = start + n - 1;\n\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tres->flags = resource_type(parent) | resource_ext_type(parent);\n\t\tres->flags |= IORESOURCE_BUSY | flags;\n\t\tres->desc = parent->desc;\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\t/*\n\t\t * mm/hmm.c reserves physical addresses which then\n\t\t * become unavailable to other users.  Conflicts are\n\t\t * not expected.  Warn to aid debugging if encountered.\n\t\t */\n\t\tif (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {\n\t\t\tpr_warn(\"Unaddressable device %s %pR conflicts with %pR\",\n\t\t\t\tconflict->name, conflict, res);\n\t\t}\n\t\tif (conflict != parent) {\n\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {\n\t\t\t\tparent = conflict;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {\n\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_lock(&resource_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Uhhuh, that didn't work out.. */\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iomem_get_mapping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1164-1173",
    "snippet": "struct address_space *iomem_get_mapping(void)\n{\n\t/*\n\t * This function is only called from file open paths, hence guaranteed\n\t * that fs_initcalls have completed and no need to check for NULL. But\n\t * since revoke_iomem can be called before the initcall we still need\n\t * the barrier to appease checkers.\n\t */\n\treturn smp_load_acquire(&iomem_inode)->i_mapping;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *iomem_inode;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&iomem_inode"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct inode *iomem_inode;\n\nstruct address_space *iomem_get_mapping(void)\n{\n\t/*\n\t * This function is only called from file open paths, hence guaranteed\n\t * that fs_initcalls have completed and no need to check for NULL. But\n\t * since revoke_iomem can be called before the initcall we still need\n\t * the barrier to appease checkers.\n\t */\n\treturn smp_load_acquire(&iomem_inode)->i_mapping;\n}"
  },
  {
    "function_name": "revoke_iomem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1161-1161",
    "snippet": "static void revoke_iomem(struct resource *res) {}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void revoke_iomem(struct resource *res) {}"
  },
  {
    "function_name": "revoke_iomem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1129-1159",
    "snippet": "static void revoke_iomem(struct resource *res)\n{\n\t/* pairs with smp_store_release() in iomem_init_inode() */\n\tstruct inode *inode = smp_load_acquire(&iomem_inode);\n\n\t/*\n\t * Check that the initialization has completed. Losing the race\n\t * is ok because it means drivers are claiming resources before\n\t * the fs_initcall level of init and prevent iomem_get_mapping users\n\t * from establishing mappings.\n\t */\n\tif (!inode)\n\t\treturn;\n\n\t/*\n\t * The expectation is that the driver has successfully marked\n\t * the resource busy by this point, so devmem_is_allowed()\n\t * should start returning false, however for performance this\n\t * does not iterate the entire resource range.\n\t */\n\tif (devmem_is_allowed(PHYS_PFN(res->start)) &&\n\t    devmem_is_allowed(PHYS_PFN(res->end))) {\n\t\t/*\n\t\t * *cringe* iomem=relaxed says \"go ahead, what's the\n\t\t * worst that can happen?\"\n\t\t */\n\t\treturn;\n\t}\n\n\tunmap_mapping_range(inode->i_mapping, res->start, resource_size(res), 1);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *iomem_inode;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_mapping_range",
          "args": [
            "inode->i_mapping",
            "res->start",
            "resource_size(res)",
            "1"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "res"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devmem_is_allowed",
          "args": [
            "PHYS_PFN(res->end)"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "res->end"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devmem_is_allowed",
          "args": [
            "PHYS_PFN(res->start)"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "res->start"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&iomem_inode"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct inode *iomem_inode;\n\nstatic void revoke_iomem(struct resource *res)\n{\n\t/* pairs with smp_store_release() in iomem_init_inode() */\n\tstruct inode *inode = smp_load_acquire(&iomem_inode);\n\n\t/*\n\t * Check that the initialization has completed. Losing the race\n\t * is ok because it means drivers are claiming resources before\n\t * the fs_initcall level of init and prevent iomem_get_mapping users\n\t * from establishing mappings.\n\t */\n\tif (!inode)\n\t\treturn;\n\n\t/*\n\t * The expectation is that the driver has successfully marked\n\t * the resource busy by this point, so devmem_is_allowed()\n\t * should start returning false, however for performance this\n\t * does not iterate the entire resource range.\n\t */\n\tif (devmem_is_allowed(PHYS_PFN(res->start)) &&\n\t    devmem_is_allowed(PHYS_PFN(res->end))) {\n\t\t/*\n\t\t * *cringe* iomem=relaxed says \"go ahead, what's the\n\t\t * worst that can happen?\"\n\t\t */\n\t\treturn;\n\t}\n\n\tunmap_mapping_range(inode->i_mapping, res->start, resource_size(res), 1);\n}"
  },
  {
    "function_name": "resource_alignment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1101-1111",
    "snippet": "resource_size_t resource_alignment(struct resource *res)\n{\n\tswitch (res->flags & (IORESOURCE_SIZEALIGN | IORESOURCE_STARTALIGN)) {\n\tcase IORESOURCE_SIZEALIGN:\n\t\treturn resource_size(res);\n\tcase IORESOURCE_STARTALIGN:\n\t\treturn res->start;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "res"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nresource_size_t resource_alignment(struct resource *res)\n{\n\tswitch (res->flags & (IORESOURCE_SIZEALIGN | IORESOURCE_STARTALIGN)) {\n\tcase IORESOURCE_SIZEALIGN:\n\t\treturn resource_size(res);\n\tcase IORESOURCE_STARTALIGN:\n\t\treturn res->start;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "reserve_region_with_split",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1066-1093",
    "snippet": "void __init\nreserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t  resource_size_t end, const char *name)\n{\n\tint abort = 0;\n\n\twrite_lock(&resource_lock);\n\tif (root->start > start || root->end < end) {\n\t\tpr_err(\"requested range [0x%llx-0x%llx] not in root %pr\\n\",\n\t\t       (unsigned long long)start, (unsigned long long)end,\n\t\t       root);\n\t\tif (start > root->end || end < root->start)\n\t\t\tabort = 1;\n\t\telse {\n\t\t\tif (end > root->end)\n\t\t\t\tend = root->end;\n\t\t\tif (start < root->start)\n\t\t\t\tstart = root->start;\n\t\t\tpr_err(\"fixing request to [0x%llx-0x%llx]\\n\",\n\t\t\t       (unsigned long long)start,\n\t\t\t       (unsigned long long)end);\n\t\t}\n\t\tdump_stack();\n\t}\n\tif (!abort)\n\t\t__reserve_region_with_split(root, start, end, name);\n\twrite_unlock(&resource_lock);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reserve_region_with_split",
          "args": [
            "root",
            "start",
            "end",
            "name"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "__reserve_region_with_split",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "1005-1064",
          "snippet": "static void __init\n__reserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t    resource_size_t end, const char *name)\n{\n\tstruct resource *parent = root;\n\tstruct resource *conflict;\n\tstruct resource *res = alloc_resource(GFP_ATOMIC);\n\tstruct resource *next_res = NULL;\n\tint type = resource_type(root);\n\n\tif (!res)\n\t\treturn;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = end;\n\tres->flags = type | IORESOURCE_BUSY;\n\tres->desc = IORES_DESC_NONE;\n\n\twhile (1) {\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict) {\n\t\t\tif (!next_res)\n\t\t\t\tbreak;\n\t\t\tres = next_res;\n\t\t\tnext_res = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* conflict covered whole area */\n\t\tif (conflict->start <= res->start &&\n\t\t\t\tconflict->end >= res->end) {\n\t\t\tfree_resource(res);\n\t\t\tWARN_ON(next_res);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* failed, split and try again */\n\t\tif (conflict->start > res->start) {\n\t\t\tend = res->end;\n\t\t\tres->end = conflict->start - 1;\n\t\t\tif (conflict->end < end) {\n\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!next_res) {\n\t\t\t\t\tfree_resource(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext_res->name = name;\n\t\t\t\tnext_res->start = conflict->end + 1;\n\t\t\t\tnext_res->end = end;\n\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;\n\t\t\t\tnext_res->desc = IORES_DESC_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tres->start = conflict->end + 1;\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __init\n__reserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t    resource_size_t end, const char *name)\n{\n\tstruct resource *parent = root;\n\tstruct resource *conflict;\n\tstruct resource *res = alloc_resource(GFP_ATOMIC);\n\tstruct resource *next_res = NULL;\n\tint type = resource_type(root);\n\n\tif (!res)\n\t\treturn;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = end;\n\tres->flags = type | IORESOURCE_BUSY;\n\tres->desc = IORES_DESC_NONE;\n\n\twhile (1) {\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict) {\n\t\t\tif (!next_res)\n\t\t\t\tbreak;\n\t\t\tres = next_res;\n\t\t\tnext_res = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* conflict covered whole area */\n\t\tif (conflict->start <= res->start &&\n\t\t\t\tconflict->end >= res->end) {\n\t\t\tfree_resource(res);\n\t\t\tWARN_ON(next_res);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* failed, split and try again */\n\t\tif (conflict->start > res->start) {\n\t\t\tend = res->end;\n\t\t\tres->end = conflict->start - 1;\n\t\t\tif (conflict->end < end) {\n\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!next_res) {\n\t\t\t\t\tfree_resource(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext_res->name = name;\n\t\t\t\tnext_res->start = conflict->end + 1;\n\t\t\t\tnext_res->end = end;\n\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;\n\t\t\t\tnext_res->desc = IORES_DESC_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tres->start = conflict->end + 1;\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"fixing request to [0x%llx-0x%llx]\\n\"",
            "(unsigned long long)start",
            "(unsigned long long)end"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"requested range [0x%llx-0x%llx] not in root %pr\\n\"",
            "(unsigned long long)start",
            "(unsigned long long)end",
            "root"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nvoid __init\nreserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t  resource_size_t end, const char *name)\n{\n\tint abort = 0;\n\n\twrite_lock(&resource_lock);\n\tif (root->start > start || root->end < end) {\n\t\tpr_err(\"requested range [0x%llx-0x%llx] not in root %pr\\n\",\n\t\t       (unsigned long long)start, (unsigned long long)end,\n\t\t       root);\n\t\tif (start > root->end || end < root->start)\n\t\t\tabort = 1;\n\t\telse {\n\t\t\tif (end > root->end)\n\t\t\t\tend = root->end;\n\t\t\tif (start < root->start)\n\t\t\t\tstart = root->start;\n\t\t\tpr_err(\"fixing request to [0x%llx-0x%llx]\\n\",\n\t\t\t       (unsigned long long)start,\n\t\t\t       (unsigned long long)end);\n\t\t}\n\t\tdump_stack();\n\t}\n\tif (!abort)\n\t\t__reserve_region_with_split(root, start, end, name);\n\twrite_unlock(&resource_lock);\n}"
  },
  {
    "function_name": "__reserve_region_with_split",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "1005-1064",
    "snippet": "static void __init\n__reserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t    resource_size_t end, const char *name)\n{\n\tstruct resource *parent = root;\n\tstruct resource *conflict;\n\tstruct resource *res = alloc_resource(GFP_ATOMIC);\n\tstruct resource *next_res = NULL;\n\tint type = resource_type(root);\n\n\tif (!res)\n\t\treturn;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = end;\n\tres->flags = type | IORESOURCE_BUSY;\n\tres->desc = IORES_DESC_NONE;\n\n\twhile (1) {\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict) {\n\t\t\tif (!next_res)\n\t\t\t\tbreak;\n\t\t\tres = next_res;\n\t\t\tnext_res = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* conflict covered whole area */\n\t\tif (conflict->start <= res->start &&\n\t\t\t\tconflict->end >= res->end) {\n\t\t\tfree_resource(res);\n\t\t\tWARN_ON(next_res);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* failed, split and try again */\n\t\tif (conflict->start > res->start) {\n\t\t\tend = res->end;\n\t\t\tres->end = conflict->start - 1;\n\t\t\tif (conflict->end < end) {\n\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!next_res) {\n\t\t\t\t\tfree_resource(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext_res->name = name;\n\t\t\t\tnext_res->start = conflict->end + 1;\n\t\t\t\tnext_res->end = end;\n\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;\n\t\t\t\tnext_res->desc = IORES_DESC_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tres->start = conflict->end + 1;\n\t\t}\n\t}\n\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_resource",
          "args": [
            "res"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "free_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "161-174",
          "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_resource",
          "args": [
            "GFP_ATOMIC"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "176-193",
          "snippet": "static struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "next_res"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "parent",
            "res"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "196-222",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_type",
          "args": [
            "root"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __init\n__reserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t    resource_size_t end, const char *name)\n{\n\tstruct resource *parent = root;\n\tstruct resource *conflict;\n\tstruct resource *res = alloc_resource(GFP_ATOMIC);\n\tstruct resource *next_res = NULL;\n\tint type = resource_type(root);\n\n\tif (!res)\n\t\treturn;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = end;\n\tres->flags = type | IORESOURCE_BUSY;\n\tres->desc = IORES_DESC_NONE;\n\n\twhile (1) {\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict) {\n\t\t\tif (!next_res)\n\t\t\t\tbreak;\n\t\t\tres = next_res;\n\t\t\tnext_res = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* conflict covered whole area */\n\t\tif (conflict->start <= res->start &&\n\t\t\t\tconflict->end >= res->end) {\n\t\t\tfree_resource(res);\n\t\t\tWARN_ON(next_res);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* failed, split and try again */\n\t\tif (conflict->start > res->start) {\n\t\t\tend = res->end;\n\t\t\tres->end = conflict->start - 1;\n\t\t\tif (conflict->end < end) {\n\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!next_res) {\n\t\t\t\t\tfree_resource(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext_res->name = name;\n\t\t\t\tnext_res->start = conflict->end + 1;\n\t\t\t\tnext_res->end = end;\n\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;\n\t\t\t\tnext_res->desc = IORES_DESC_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tres->start = conflict->end + 1;\n\t\t}\n\t}\n\n}"
  },
  {
    "function_name": "adjust_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "993-1002",
    "snippet": "int adjust_resource(struct resource *res, resource_size_t start,\n\t\t    resource_size_t size)\n{\n\tint result;\n\n\twrite_lock(&resource_lock);\n\tresult = __adjust_resource(res, start, size);\n\twrite_unlock(&resource_lock);\n\treturn result;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__adjust_resource",
          "args": [
            "res",
            "start",
            "size"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "__adjust_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "946-981",
          "snippet": "static int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint adjust_resource(struct resource *res, resource_size_t start,\n\t\t    resource_size_t size)\n{\n\tint result;\n\n\twrite_lock(&resource_lock);\n\tresult = __adjust_resource(res, start, size);\n\twrite_unlock(&resource_lock);\n\treturn result;\n}"
  },
  {
    "function_name": "__adjust_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "946-981",
    "snippet": "static int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}"
  },
  {
    "function_name": "remove_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "935-943",
    "snippet": "int remove_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, false);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_resource",
          "args": [
            "old",
            "false"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "__release_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "224-251",
          "snippet": "static int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint remove_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, false);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}"
  },
  {
    "function_name": "insert_resource_expand_to_fit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "894-918",
    "snippet": "void insert_resource_expand_to_fit(struct resource *root, struct resource *new)\n{\n\tif (new->parent)\n\t\treturn;\n\n\twrite_lock(&resource_lock);\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tconflict = __insert_resource(root, new);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\tif (conflict == root)\n\t\t\tbreak;\n\n\t\t/* Ok, expand resource to cover the conflict, then try again .. */\n\t\tif (conflict->start < new->start)\n\t\t\tnew->start = conflict->start;\n\t\tif (conflict->end > new->end)\n\t\t\tnew->end = conflict->end;\n\n\t\tprintk(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);\n\t}\n\twrite_unlock(&resource_lock);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Expanded resource %s due to conflict with %s\\n\"",
            "new->name",
            "conflict->name"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__insert_resource",
          "args": [
            "root",
            "new"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "792-839",
          "snippet": "static struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nvoid insert_resource_expand_to_fit(struct resource *root, struct resource *new)\n{\n\tif (new->parent)\n\t\treturn;\n\n\twrite_lock(&resource_lock);\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tconflict = __insert_resource(root, new);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\tif (conflict == root)\n\t\t\tbreak;\n\n\t\t/* Ok, expand resource to cover the conflict, then try again .. */\n\t\tif (conflict->start < new->start)\n\t\t\tnew->start = conflict->start;\n\t\tif (conflict->end > new->end)\n\t\t\tnew->end = conflict->end;\n\n\t\tprintk(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);\n\t}\n\twrite_unlock(&resource_lock);\n}"
  },
  {
    "function_name": "insert_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "877-883",
    "snippet": "int insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = insert_resource_conflict(parent, new);\n\treturn conflict ? -EBUSY : 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_resource_conflict",
          "args": [
            "parent",
            "new"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "insert_resource_conflict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "857-865",
          "snippet": "struct resource *insert_resource_conflict(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __insert_resource(parent, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *insert_resource_conflict(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __insert_resource(parent, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = insert_resource_conflict(parent, new);\n\treturn conflict ? -EBUSY : 0;\n}"
  },
  {
    "function_name": "insert_resource_conflict",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "857-865",
    "snippet": "struct resource *insert_resource_conflict(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __insert_resource(parent, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__insert_resource",
          "args": [
            "parent",
            "new"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "792-839",
          "snippet": "static struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *insert_resource_conflict(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __insert_resource(parent, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}"
  },
  {
    "function_name": "__insert_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "792-839",
    "snippet": "static struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "first == new"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "parent",
            "new"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "196-222",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "lookup_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "774-786",
    "snippet": "struct resource *lookup_resource(struct resource *root, resource_size_t start)\n{\n\tstruct resource *res;\n\n\tread_lock(&resource_lock);\n\tfor (res = root->child; res; res = res->sibling) {\n\t\tif (res->start == start)\n\t\t\tbreak;\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *lookup_resource(struct resource *root, resource_size_t start)\n{\n\tstruct resource *res;\n\n\tread_lock(&resource_lock);\n\tfor (res = root->child; res; res = res->sibling) {\n\t\tif (res->start == start)\n\t\t\tbreak;\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn res;\n}"
  },
  {
    "function_name": "allocate_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "730-763",
    "snippet": "int allocate_resource(struct resource *root, struct resource *new,\n\t\t      resource_size_t size, resource_size_t min,\n\t\t      resource_size_t max, resource_size_t align,\n\t\t      resource_size_t (*alignf)(void *,\n\t\t\t\t\t\tconst struct resource *,\n\t\t\t\t\t\tresource_size_t,\n\t\t\t\t\t\tresource_size_t),\n\t\t      void *alignf_data)\n{\n\tint err;\n\tstruct resource_constraint constraint;\n\n\tif (!alignf)\n\t\talignf = simple_align_resource;\n\n\tconstraint.min = min;\n\tconstraint.max = max;\n\tconstraint.align = align;\n\tconstraint.alignf = alignf;\n\tconstraint.alignf_data = alignf_data;\n\n\tif ( new->parent ) {\n\t\t/* resource is already allocated, try reallocating with\n\t\t   the new constraints */\n\t\treturn reallocate_resource(root, new, size, &constraint);\n\t}\n\n\twrite_lock(&resource_lock);\n\terr = find_resource(root, new, size, &constraint);\n\tif (err >= 0 && __request_resource(root, new))\n\t\terr = -EBUSY;\n\twrite_unlock(&resource_lock);\n\treturn err;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "root",
            "new"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "196-222",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_resource",
          "args": [
            "root",
            "new",
            "size",
            "&constraint"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "find_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "662-667",
          "snippet": "static int find_resource(struct resource *root, struct resource *new,\n\t\t\tresource_size_t size,\n\t\t\tstruct resource_constraint  *constraint)\n{\n\treturn  __find_resource(root, NULL, new, size, constraint);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int find_resource(struct resource *root, struct resource *new,\n\t\t\tresource_size_t size,\n\t\t\tstruct resource_constraint  *constraint)\n{\n\treturn  __find_resource(root, NULL, new, size, constraint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reallocate_resource",
          "args": [
            "root",
            "new",
            "size",
            "&constraint"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "reallocate_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "679-715",
          "snippet": "static int reallocate_resource(struct resource *root, struct resource *old,\n\t\t\t       resource_size_t newsize,\n\t\t\t       struct resource_constraint *constraint)\n{\n\tint err=0;\n\tstruct resource new = *old;\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\n\tif ((err = __find_resource(root, old, &new, newsize, constraint)))\n\t\tgoto out;\n\n\tif (resource_contains(&new, old)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t\tgoto out;\n\t}\n\n\tif (old->child) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (resource_contains(old, &new)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t} else {\n\t\t__release_resource(old, true);\n\t\t*old = new;\n\t\tconflict = __request_resource(root, old);\n\t\tBUG_ON(conflict);\n\t}\nout:\n\twrite_unlock(&resource_lock);\n\treturn err;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic int reallocate_resource(struct resource *root, struct resource *old,\n\t\t\t       resource_size_t newsize,\n\t\t\t       struct resource_constraint *constraint)\n{\n\tint err=0;\n\tstruct resource new = *old;\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\n\tif ((err = __find_resource(root, old, &new, newsize, constraint)))\n\t\tgoto out;\n\n\tif (resource_contains(&new, old)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t\tgoto out;\n\t}\n\n\tif (old->child) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (resource_contains(old, &new)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t} else {\n\t\t__release_resource(old, true);\n\t\t*old = new;\n\t\tconflict = __request_resource(root, old);\n\t\tBUG_ON(conflict);\n\t}\nout:\n\twrite_unlock(&resource_lock);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint allocate_resource(struct resource *root, struct resource *new,\n\t\t      resource_size_t size, resource_size_t min,\n\t\t      resource_size_t max, resource_size_t align,\n\t\t      resource_size_t (*alignf)(void *,\n\t\t\t\t\t\tconst struct resource *,\n\t\t\t\t\t\tresource_size_t,\n\t\t\t\t\t\tresource_size_t),\n\t\t      void *alignf_data)\n{\n\tint err;\n\tstruct resource_constraint constraint;\n\n\tif (!alignf)\n\t\talignf = simple_align_resource;\n\n\tconstraint.min = min;\n\tconstraint.max = max;\n\tconstraint.align = align;\n\tconstraint.alignf = alignf;\n\tconstraint.alignf_data = alignf_data;\n\n\tif ( new->parent ) {\n\t\t/* resource is already allocated, try reallocating with\n\t\t   the new constraints */\n\t\treturn reallocate_resource(root, new, size, &constraint);\n\t}\n\n\twrite_lock(&resource_lock);\n\terr = find_resource(root, new, size, &constraint);\n\tif (err >= 0 && __request_resource(root, new))\n\t\terr = -EBUSY;\n\twrite_unlock(&resource_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "reallocate_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "679-715",
    "snippet": "static int reallocate_resource(struct resource *root, struct resource *old,\n\t\t\t       resource_size_t newsize,\n\t\t\t       struct resource_constraint *constraint)\n{\n\tint err=0;\n\tstruct resource new = *old;\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\n\tif ((err = __find_resource(root, old, &new, newsize, constraint)))\n\t\tgoto out;\n\n\tif (resource_contains(&new, old)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t\tgoto out;\n\t}\n\n\tif (old->child) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (resource_contains(old, &new)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t} else {\n\t\t__release_resource(old, true);\n\t\t*old = new;\n\t\tconflict = __request_resource(root, old);\n\t\tBUG_ON(conflict);\n\t}\nout:\n\twrite_unlock(&resource_lock);\n\treturn err;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "conflict"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "root",
            "old"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "196-222",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_resource",
          "args": [
            "old",
            "true"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "__release_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "224-251",
          "snippet": "static int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_contains",
          "args": [
            "old",
            "&new"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_contains",
          "args": [
            "&new",
            "old"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_resource",
          "args": [
            "root",
            "old",
            "&new",
            "newsize",
            "constraint"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "__find_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "603-657",
          "snippet": "static int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic int reallocate_resource(struct resource *root, struct resource *old,\n\t\t\t       resource_size_t newsize,\n\t\t\t       struct resource_constraint *constraint)\n{\n\tint err=0;\n\tstruct resource new = *old;\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\n\tif ((err = __find_resource(root, old, &new, newsize, constraint)))\n\t\tgoto out;\n\n\tif (resource_contains(&new, old)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t\tgoto out;\n\t}\n\n\tif (old->child) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (resource_contains(old, &new)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t} else {\n\t\t__release_resource(old, true);\n\t\t*old = new;\n\t\tconflict = __request_resource(root, old);\n\t\tBUG_ON(conflict);\n\t}\nout:\n\twrite_unlock(&resource_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "find_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "662-667",
    "snippet": "static int find_resource(struct resource *root, struct resource *new,\n\t\t\tresource_size_t size,\n\t\t\tstruct resource_constraint  *constraint)\n{\n\treturn  __find_resource(root, NULL, new, size, constraint);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__find_resource",
          "args": [
            "root",
            "NULL",
            "new",
            "size",
            "constraint"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "__find_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "603-657",
          "snippet": "static int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int find_resource(struct resource *root, struct resource *new,\n\t\t\tresource_size_t size,\n\t\t\tstruct resource_constraint  *constraint)\n{\n\treturn  __find_resource(root, NULL, new, size, constraint);\n}"
  },
  {
    "function_name": "__find_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "603-657",
    "snippet": "static int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_contains",
          "args": [
            "&avail",
            "&alloc"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "constraint->alignf",
          "args": [
            "constraint->alignf_data",
            "&avail",
            "size",
            "constraint->align"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "tmp.start",
            "constraint->align"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_remove_reservations",
          "args": [
            "&tmp"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "arch_remove_reservations",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "578-580",
          "snippet": "void __weak arch_remove_reservations(struct resource *avail)\n{\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nvoid __weak arch_remove_reservations(struct resource *avail)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_clip",
          "args": [
            "&tmp",
            "constraint->min",
            "constraint->max"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "resource_clip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "590-597",
          "snippet": "static void resource_clip(struct resource *res, resource_size_t min,\n\t\t\t  resource_size_t max)\n{\n\tif (res->start < min)\n\t\tres->start = min;\n\tif (res->end > max)\n\t\tres->end = max;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void resource_clip(struct resource *res, resource_size_t min,\n\t\t\t  resource_size_t max)\n{\n\tif (res->start < min)\n\t\tres->start = min;\n\tif (res->end > max)\n\t\tres->end = max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}"
  },
  {
    "function_name": "resource_clip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "590-597",
    "snippet": "static void resource_clip(struct resource *res, resource_size_t min,\n\t\t\t  resource_size_t max)\n{\n\tif (res->start < min)\n\t\tres->start = min;\n\tif (res->end > max)\n\t\tres->end = max;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void resource_clip(struct resource *res, resource_size_t min,\n\t\t\t  resource_size_t max)\n{\n\tif (res->start < min)\n\t\tres->start = min;\n\tif (res->end > max)\n\t\tres->end = max;\n}"
  },
  {
    "function_name": "simple_align_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "582-588",
    "snippet": "static resource_size_t simple_align_resource(void *data,\n\t\t\t\t\t     const struct resource *avail,\n\t\t\t\t\t     resource_size_t size,\n\t\t\t\t\t     resource_size_t align)\n{\n\treturn avail->start;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic resource_size_t simple_align_resource(void *data,\n\t\t\t\t\t     const struct resource *avail,\n\t\t\t\t\t     resource_size_t size,\n\t\t\t\t\t     resource_size_t align)\n{\n\treturn avail->start;\n}"
  },
  {
    "function_name": "arch_remove_reservations",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "578-580",
    "snippet": "void __weak arch_remove_reservations(struct resource *avail)\n{\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nvoid __weak arch_remove_reservations(struct resource *avail)\n{\n}"
  },
  {
    "function_name": "region_intersects",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "565-575",
    "snippet": "int region_intersects(resource_size_t start, size_t size, unsigned long flags,\n\t\t      unsigned long desc)\n{\n\tint ret;\n\n\tread_lock(&resource_lock);\n\tret = __region_intersects(start, size, flags, desc);\n\tread_unlock(&resource_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__region_intersects",
          "args": [
            "start",
            "size",
            "flags",
            "desc"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "__region_intersects",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "517-543",
          "snippet": "static int __region_intersects(resource_size_t start, size_t size,\n\t\t\tunsigned long flags, unsigned long desc)\n{\n\tstruct resource res;\n\tint type = 0; int other = 0;\n\tstruct resource *p;\n\n\tres.start = start;\n\tres.end = start + size - 1;\n\n\tfor (p = iomem_resource.child; p ; p = p->sibling) {\n\t\tbool is_type = (((p->flags & flags) == flags) &&\n\t\t\t\t((desc == IORES_DESC_NONE) ||\n\t\t\t\t (desc == p->desc)));\n\n\t\tif (resource_overlaps(p, &res))\n\t\t\tis_type ? type++ : other++;\n\t}\n\n\tif (type == 0)\n\t\treturn REGION_DISJOINT;\n\n\tif (other == 0)\n\t\treturn REGION_INTERSECTS;\n\n\treturn REGION_MIXED;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\n\nstatic int __region_intersects(resource_size_t start, size_t size,\n\t\t\tunsigned long flags, unsigned long desc)\n{\n\tstruct resource res;\n\tint type = 0; int other = 0;\n\tstruct resource *p;\n\n\tres.start = start;\n\tres.end = start + size - 1;\n\n\tfor (p = iomem_resource.child; p ; p = p->sibling) {\n\t\tbool is_type = (((p->flags & flags) == flags) &&\n\t\t\t\t((desc == IORES_DESC_NONE) ||\n\t\t\t\t (desc == p->desc)));\n\n\t\tif (resource_overlaps(p, &res))\n\t\t\tis_type ? type++ : other++;\n\t}\n\n\tif (type == 0)\n\t\treturn REGION_DISJOINT;\n\n\tif (other == 0)\n\t\treturn REGION_INTERSECTS;\n\n\treturn REGION_MIXED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint region_intersects(resource_size_t start, size_t size, unsigned long flags,\n\t\t      unsigned long desc)\n{\n\tint ret;\n\n\tread_lock(&resource_lock);\n\tret = __region_intersects(start, size, flags, desc);\n\tread_unlock(&resource_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__region_intersects",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "517-543",
    "snippet": "static int __region_intersects(resource_size_t start, size_t size,\n\t\t\tunsigned long flags, unsigned long desc)\n{\n\tstruct resource res;\n\tint type = 0; int other = 0;\n\tstruct resource *p;\n\n\tres.start = start;\n\tres.end = start + size - 1;\n\n\tfor (p = iomem_resource.child; p ; p = p->sibling) {\n\t\tbool is_type = (((p->flags & flags) == flags) &&\n\t\t\t\t((desc == IORES_DESC_NONE) ||\n\t\t\t\t (desc == p->desc)));\n\n\t\tif (resource_overlaps(p, &res))\n\t\t\tis_type ? type++ : other++;\n\t}\n\n\tif (type == 0)\n\t\treturn REGION_DISJOINT;\n\n\tif (other == 0)\n\t\treturn REGION_INTERSECTS;\n\n\treturn REGION_MIXED;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_overlaps",
          "args": [
            "p",
            "&res"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\n\nstatic int __region_intersects(resource_size_t start, size_t size,\n\t\t\tunsigned long flags, unsigned long desc)\n{\n\tstruct resource res;\n\tint type = 0; int other = 0;\n\tstruct resource *p;\n\n\tres.start = start;\n\tres.end = start + size - 1;\n\n\tfor (p = iomem_resource.child; p ; p = p->sibling) {\n\t\tbool is_type = (((p->flags & flags) == flags) &&\n\t\t\t\t((desc == IORES_DESC_NONE) ||\n\t\t\t\t (desc == p->desc)));\n\n\t\tif (resource_overlaps(p, &res))\n\t\t\tis_type ? type++ : other++;\n\t}\n\n\tif (type == 0)\n\t\treturn REGION_DISJOINT;\n\n\tif (other == 0)\n\t\treturn REGION_INTERSECTS;\n\n\treturn REGION_MIXED;\n}"
  },
  {
    "function_name": "page_is_ram",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "511-514",
    "snippet": "int __weak page_is_ram(unsigned long pfn)\n{\n\treturn walk_system_ram_range(pfn, 1, NULL, __is_ram) == 1;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_system_ram_range",
          "args": [
            "pfn",
            "1",
            "NULL",
            "__is_ram"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "walk_system_ram_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "477-500",
          "snippet": "int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))\n{\n\tresource_size_t start, end;\n\tunsigned long flags;\n\tstruct resource res;\n\tunsigned long pfn, end_pfn;\n\tint ret = -EINVAL;\n\n\tstart = (u64) start_pfn << PAGE_SHIFT;\n\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;\n\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE, &res)) {\n\t\tpfn = PFN_UP(res.start);\n\t\tend_pfn = PFN_DOWN(res.end + 1);\n\t\tif (end_pfn > pfn)\n\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart = res.end + 1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))\n{\n\tresource_size_t start, end;\n\tunsigned long flags;\n\tstruct resource res;\n\tunsigned long pfn, end_pfn;\n\tint ret = -EINVAL;\n\n\tstart = (u64) start_pfn << PAGE_SHIFT;\n\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;\n\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE, &res)) {\n\t\tpfn = PFN_UP(res.start);\n\t\tend_pfn = PFN_DOWN(res.end + 1);\n\t\tif (end_pfn > pfn)\n\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart = res.end + 1;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint __weak page_is_ram(unsigned long pfn)\n{\n\treturn walk_system_ram_range(pfn, 1, NULL, __is_ram) == 1;\n}"
  },
  {
    "function_name": "__is_ram",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "502-505",
    "snippet": "static int __is_ram(unsigned long pfn, unsigned long nr_pages, void *arg)\n{\n\treturn 1;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __is_ram(unsigned long pfn, unsigned long nr_pages, void *arg)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "walk_system_ram_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "477-500",
    "snippet": "int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))\n{\n\tresource_size_t start, end;\n\tunsigned long flags;\n\tstruct resource res;\n\tunsigned long pfn, end_pfn;\n\tint ret = -EINVAL;\n\n\tstart = (u64) start_pfn << PAGE_SHIFT;\n\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;\n\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE, &res)) {\n\t\tpfn = PFN_UP(res.start);\n\t\tend_pfn = PFN_DOWN(res.end + 1);\n\t\tif (end_pfn > pfn)\n\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart = res.end + 1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "pfn",
            "end_pfn - pfn",
            "arg"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "res.end + 1"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "res.start"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_iomem_res",
          "args": [
            "start",
            "end",
            "flags",
            "IORES_DESC_NONE",
            "&res"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_iomem_res",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "350-397",
          "snippet": "static int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p)) {\n\t\t/* If we passed the resource we are looking for, stop */\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip until we find a range that matches what we look for */\n\t\tif (p->end < start)\n\t\t\tcontinue;\n\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\n\t\t/* Found a match, break */\n\t\tbreak;\n\t}\n\n\tif (p) {\n\t\t/* copy data */\n\t\t*res = (struct resource) {\n\t\t\t.start = max(start, p->start),\n\t\t\t.end = min(end, p->end),\n\t\t\t.flags = p->flags,\n\t\t\t.desc = p->desc,\n\t\t\t.parent = p->parent,\n\t\t};\n\t}\n\n\tread_unlock(&resource_lock);\n\treturn p ? 0 : -ENODEV;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p)) {\n\t\t/* If we passed the resource we are looking for, stop */\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip until we find a range that matches what we look for */\n\t\tif (p->end < start)\n\t\t\tcontinue;\n\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\n\t\t/* Found a match, break */\n\t\tbreak;\n\t}\n\n\tif (p) {\n\t\t/* copy data */\n\t\t*res = (struct resource) {\n\t\t\t.start = max(start, p->start),\n\t\t\t.end = min(end, p->end),\n\t\t\t.flags = p->flags,\n\t\t\t.desc = p->desc,\n\t\t\t.parent = p->parent,\n\t\t};\n\t}\n\n\tread_unlock(&resource_lock);\n\treturn p ? 0 : -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "start_pfn + nr_pages"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))\n{\n\tresource_size_t start, end;\n\tunsigned long flags;\n\tstruct resource res;\n\tunsigned long pfn, end_pfn;\n\tint ret = -EINVAL;\n\n\tstart = (u64) start_pfn << PAGE_SHIFT;\n\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;\n\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE, &res)) {\n\t\tpfn = PFN_UP(res.start);\n\t\tend_pfn = PFN_DOWN(res.end + 1);\n\t\tif (end_pfn > pfn)\n\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart = res.end + 1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "walk_mem_res",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "463-470",
    "snippet": "int walk_mem_res(u64 start, u64 end, void *arg,\n\t\t int (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, arg,\n\t\t\t\t     func);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__walk_iomem_res_desc",
          "args": [
            "start",
            "end",
            "flags",
            "IORES_DESC_NONE",
            "arg",
            "func"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "__walk_iomem_res_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "399-417",
          "snippet": "static int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -EINVAL;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -EINVAL;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_mem_res(u64 start, u64 end, void *arg,\n\t\t int (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, arg,\n\t\t\t\t     func);\n}"
  },
  {
    "function_name": "walk_system_ram_res",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "450-457",
    "snippet": "int walk_system_ram_res(u64 start, u64 end, void *arg,\n\t\t\tint (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, arg,\n\t\t\t\t     func);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__walk_iomem_res_desc",
          "args": [
            "start",
            "end",
            "flags",
            "IORES_DESC_NONE",
            "arg",
            "func"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "__walk_iomem_res_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "399-417",
          "snippet": "static int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -EINVAL;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -EINVAL;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_system_ram_res(u64 start, u64 end, void *arg,\n\t\t\tint (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, arg,\n\t\t\t\t     func);\n}"
  },
  {
    "function_name": "walk_iomem_res_desc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "436-440",
    "snippet": "int walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start,\n\t\tu64 end, void *arg, int (*func)(struct resource *, void *))\n{\n\treturn __walk_iomem_res_desc(start, end, flags, desc, arg, func);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__walk_iomem_res_desc",
          "args": [
            "start",
            "end",
            "flags",
            "desc",
            "arg",
            "func"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "__walk_iomem_res_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "399-417",
          "snippet": "static int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -EINVAL;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -EINVAL;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start,\n\t\tu64 end, void *arg, int (*func)(struct resource *, void *))\n{\n\treturn __walk_iomem_res_desc(start, end, flags, desc, arg, func);\n}"
  },
  {
    "function_name": "__walk_iomem_res_desc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "399-417",
    "snippet": "static int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -EINVAL;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "&res",
            "arg"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_iomem_res",
          "args": [
            "start",
            "end",
            "flags",
            "desc",
            "&res"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_iomem_res",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "350-397",
          "snippet": "static int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p)) {\n\t\t/* If we passed the resource we are looking for, stop */\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip until we find a range that matches what we look for */\n\t\tif (p->end < start)\n\t\t\tcontinue;\n\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\n\t\t/* Found a match, break */\n\t\tbreak;\n\t}\n\n\tif (p) {\n\t\t/* copy data */\n\t\t*res = (struct resource) {\n\t\t\t.start = max(start, p->start),\n\t\t\t.end = min(end, p->end),\n\t\t\t.flags = p->flags,\n\t\t\t.desc = p->desc,\n\t\t\t.parent = p->parent,\n\t\t};\n\t}\n\n\tread_unlock(&resource_lock);\n\treturn p ? 0 : -ENODEV;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p)) {\n\t\t/* If we passed the resource we are looking for, stop */\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip until we find a range that matches what we look for */\n\t\tif (p->end < start)\n\t\t\tcontinue;\n\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\n\t\t/* Found a match, break */\n\t\tbreak;\n\t}\n\n\tif (p) {\n\t\t/* copy data */\n\t\t*res = (struct resource) {\n\t\t\t.start = max(start, p->start),\n\t\t\t.end = min(end, p->end),\n\t\t\t.flags = p->flags,\n\t\t\t.desc = p->desc,\n\t\t\t.parent = p->parent,\n\t\t};\n\t}\n\n\tread_unlock(&resource_lock);\n\treturn p ? 0 : -ENODEV;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -EINVAL;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_next_iomem_res",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "350-397",
    "snippet": "static int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p)) {\n\t\t/* If we passed the resource we are looking for, stop */\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip until we find a range that matches what we look for */\n\t\tif (p->end < start)\n\t\t\tcontinue;\n\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\n\t\t/* Found a match, break */\n\t\tbreak;\n\t}\n\n\tif (p) {\n\t\t/* copy data */\n\t\t*res = (struct resource) {\n\t\t\t.start = max(start, p->start),\n\t\t\t.end = min(end, p->end),\n\t\t\t.flags = p->flags,\n\t\t\t.desc = p->desc,\n\t\t\t.parent = p->parent,\n\t\t};\n\t}\n\n\tread_unlock(&resource_lock);\n\treturn p ? 0 : -ENODEV;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "p->end"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start",
            "p->start"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_resource",
          "args": [
            "p"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "next_resource_skip_children",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "76-81",
          "snippet": "static struct resource *next_resource_skip_children(struct resource *p)\n{\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *next_resource_skip_children(struct resource *p)\n{\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p)) {\n\t\t/* If we passed the resource we are looking for, stop */\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip until we find a range that matches what we look for */\n\t\tif (p->end < start)\n\t\t\tcontinue;\n\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\n\t\t/* Found a match, break */\n\t\tbreak;\n\t}\n\n\tif (p) {\n\t\t/* copy data */\n\t\t*res = (struct resource) {\n\t\t\t.start = max(start, p->start),\n\t\t\t.end = min(end, p->end),\n\t\t\t.flags = p->flags,\n\t\t\t.desc = p->desc,\n\t\t\t.parent = p->parent,\n\t\t};\n\t}\n\n\tread_unlock(&resource_lock);\n\treturn p ? 0 : -ENODEV;\n}"
  },
  {
    "function_name": "release_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "321-329",
    "snippet": "int release_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, true);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_resource",
          "args": [
            "old",
            "true"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "__release_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "224-251",
          "snippet": "static int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint release_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, true);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}"
  },
  {
    "function_name": "request_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "307-313",
    "snippet": "int request_resource(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = request_resource_conflict(root, new);\n\treturn conflict ? -EBUSY : 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "request_resource_conflict",
          "args": [
            "root",
            "new"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "request_resource_conflict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "290-298",
          "snippet": "struct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint request_resource(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = request_resource_conflict(root, new);\n\treturn conflict ? -EBUSY : 0;\n}"
  },
  {
    "function_name": "request_resource_conflict",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "290-298",
    "snippet": "struct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "root",
            "new"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "196-222",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}"
  },
  {
    "function_name": "release_child_resources",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "276-281",
    "snippet": "void release_child_resources(struct resource *r)\n{\n\twrite_lock(&resource_lock);\n\t__release_child_resources(r);\n\twrite_unlock(&resource_lock);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_child_resources",
          "args": [
            "r"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "__release_child_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "253-274",
          "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nvoid release_child_resources(struct resource *r)\n{\n\twrite_lock(&resource_lock);\n\t__release_child_resources(r);\n\twrite_unlock(&resource_lock);\n}"
  },
  {
    "function_name": "__release_child_resources",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "253-274",
    "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "tmp"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"release child resource %pR\\n\"",
            "tmp"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_child_resources",
          "args": [
            "tmp"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "__release_child_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "253-274",
          "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}"
  },
  {
    "function_name": "__release_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "224-251",
    "snippet": "static int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "__request_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "196-222",
    "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
  },
  {
    "function_name": "alloc_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "176-193",
    "snippet": "static struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct resource *bootmem_resource_free;",
      "static DEFINE_SPINLOCK(bootmem_resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct resource)",
            "flags"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "res",
            "0",
            "sizeof(struct resource)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bootmem_resource_lock"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bootmem_resource_lock"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}"
  },
  {
    "function_name": "free_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "161-174",
    "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct resource *bootmem_resource_free;",
      "static DEFINE_SPINLOCK(bootmem_resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "res"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bootmem_resource_lock"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bootmem_resource_lock"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "virt_to_head_page(res)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "res"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
  },
  {
    "function_name": "ioresources_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "150-156",
    "snippet": "static int __init ioresources_init(void)\n{\n\tproc_create_seq_data(\"ioports\", 0, NULL, &resource_op,\n\t\t\t&ioport_resource);\n\tproc_create_seq_data(\"iomem\", 0, NULL, &resource_op, &iomem_resource);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource ioport_resource = {\n\t.name\t= \"PCI IO\",\n\t.start\t= 0,\n\t.end\t= IO_SPACE_LIMIT,\n\t.flags\t= IORESOURCE_IO,\n};",
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_seq_data",
          "args": [
            "\"iomem\"",
            "0",
            "NULL",
            "&resource_op",
            "&iomem_resource"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_seq_data",
          "args": [
            "\"ioports\"",
            "0",
            "NULL",
            "&resource_op",
            "&ioport_resource"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource ioport_resource = {\n\t.name\t= \"PCI IO\",\n\t.start\t= 0,\n\t.end\t= IO_SPACE_LIMIT,\n\t.flags\t= IORESOURCE_IO,\n};\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\n\nstatic int __init ioresources_init(void)\n{\n\tproc_create_seq_data(\"ioports\", 0, NULL, &resource_op,\n\t\t\t&ioport_resource);\n\tproc_create_seq_data(\"iomem\", 0, NULL, &resource_op, &iomem_resource);\n\treturn 0;\n}"
  },
  {
    "function_name": "r_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "116-141",
    "snippet": "static int r_show(struct seq_file *m, void *v)\n{\n\tstruct resource *root = pde_data(file_inode(m->file));\n\tstruct resource *r = v, *p;\n\tunsigned long long start, end;\n\tint width = root->end < 0x10000 ? 4 : 8;\n\tint depth;\n\n\tfor (depth = 0, p = r; depth < MAX_IORES_LEVEL; depth++, p = p->parent)\n\t\tif (p->parent == root)\n\t\t\tbreak;\n\n\tif (file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN)) {\n\t\tstart = r->start;\n\t\tend = r->end;\n\t} else {\n\t\tstart = end = 0;\n\t}\n\n\tseq_printf(m, \"%*s%0*llx-%0*llx : %s\\n\",\n\t\t\tdepth * 2, \"\",\n\t\t\twidth, start,\n\t\t\twidth, end,\n\t\t\tr->name ? r->name : \"<BAD>\");\n\treturn 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*s%0*llx-%0*llx : %s\\n\"",
            "depth * 2",
            "\"\"",
            "width",
            "start",
            "width",
            "end",
            "r->name ? r->name : \"<BAD>\""
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_ns_capable",
          "args": [
            "m->file",
            "&init_user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "file_ns_capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "466-477",
          "snippet": "bool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pde_data",
          "args": [
            "file_inode(m->file)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "m->file"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int r_show(struct seq_file *m, void *v)\n{\n\tstruct resource *root = pde_data(file_inode(m->file));\n\tstruct resource *r = v, *p;\n\tunsigned long long start, end;\n\tint width = root->end < 0x10000 ? 4 : 8;\n\tint depth;\n\n\tfor (depth = 0, p = r; depth < MAX_IORES_LEVEL; depth++, p = p->parent)\n\t\tif (p->parent == root)\n\t\t\tbreak;\n\n\tif (file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN)) {\n\t\tstart = r->start;\n\t\tend = r->end;\n\t} else {\n\t\tstart = end = 0;\n\t}\n\n\tseq_printf(m, \"%*s%0*llx-%0*llx : %s\\n\",\n\t\t\tdepth * 2, \"\",\n\t\t\twidth, start,\n\t\t\twidth, end,\n\t\t\tr->name ? r->name : \"<BAD>\");\n\treturn 0;\n}"
  },
  {
    "function_name": "r_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "110-114",
    "snippet": "static void r_stop(struct seq_file *m, void *v)\n\t__releases(resource_lock)\n{\n\tread_unlock(&resource_lock);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "resource_lock"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic void r_stop(struct seq_file *m, void *v)\n\t__releases(resource_lock)\n{\n\tread_unlock(&resource_lock);\n}"
  },
  {
    "function_name": "r_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "99-108",
    "snippet": "static void *r_start(struct seq_file *m, loff_t *pos)\n\t__acquires(resource_lock)\n{\n\tstruct resource *p = pde_data(file_inode(m->file));\n\tloff_t l = 0;\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p && l < *pos; p = r_next(m, p, &l))\n\t\t;\n\treturn p;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "r_next",
          "args": [
            "m",
            "p",
            "&l"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "r_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "88-93",
          "snippet": "static void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pde_data",
          "args": [
            "file_inode(m->file)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "m->file"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "resource_lock"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic void *r_start(struct seq_file *m, loff_t *pos)\n\t__acquires(resource_lock)\n{\n\tstruct resource *p = pde_data(file_inode(m->file));\n\tloff_t l = 0;\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p && l < *pos; p = r_next(m, p, &l))\n\t\t;\n\treturn p;\n}"
  },
  {
    "function_name": "r_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "88-93",
    "snippet": "static void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_resource",
          "args": [
            "p"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "next_resource_skip_children",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "76-81",
          "snippet": "static struct resource *next_resource_skip_children(struct resource *p)\n{\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *next_resource_skip_children(struct resource *p)\n{\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p);\n}"
  },
  {
    "function_name": "next_resource_skip_children",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "76-81",
    "snippet": "static struct resource *next_resource_skip_children(struct resource *p)\n{\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *next_resource_skip_children(struct resource *p)\n{\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}"
  },
  {
    "function_name": "next_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
    "lines": "67-74",
    "snippet": "static struct resource *next_resource(struct resource *p)\n{\n\tif (p->child)\n\t\treturn p->child;\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <uapi/linux/magic.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/pseudo_fs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *next_resource(struct resource *p)\n{\n\tif (p->child)\n\t\treturn p->child;\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}"
  }
]